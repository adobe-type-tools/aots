<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<!--____________________________________________________________________________

	Copyright 2000-2016 Adobe Systems Incorporated. All Rights Reserved.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use these files except in compliance with the License.
	You may obtain a copy of the License at

	 http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
  ___________________________________________________________________________-->

<article xmlns:web='http://aots.adobe.com/2001/web'
         xmlns=''
         web:area='opentype_spec'
         web:index='yes'>
  <title>Annotated CFF Specification</title>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Introduction</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>This document describes the specification of a font format
        that is suitable for compactly representing one or more Type 1
        or CID-keyed fonts. Unlike previous Type 1 and CID-keyed font
        formats, CFF allows multiple fonts to be stored together in a
        unit called a <emphasis>FontSet</emphasis>. Principal space
        savings are a result of using a compact binary representation
        for most of the information, sharing of common data between
        fonts, and defaulting frequently occurring data.</para>

      <para>The CFF format is designed to be used in conjunction with
          Type 2 charstrings for the character description procedures
          (see Adobe Technical Note #5177: &#x201c;The Type 2
          Charstring Format&#x201d;).</para>

      <para>The design supports the embedding of PostScript&#xae;
          language code which permits additional flexibility and
          extensibility of the format when used in printer
          environments (see Appendix E).</para>
    </section>

    <!--______________________________________________________________________-->
    <section>
      <title>Annotation</title>

      <para>It may be nice at this point to introduce the remaining
      sections so that readers can find their way. In addition, I
      would suggest a reordering of the sections to minimize forward
      references:
      <itemizedlist>
	<listitem>
	  <para>sections 3, 4 and 5, which describe the basic plumbing
	    of data types, DICT and INDEX structures.</para>
	</listitem>
	<listitem>
	  <para>section 2, which gives the overall organization</para>
	</listitem>
	<listitem>
	  <para>sections 6 (Header), 10 (String INDEX) and 16 (Global
	  Subrs INDEX), which describe the top level pieces
	  shared by all fonts in the fontset</para>
	</listitem>
	<listitem>
	  <para>sections 7 (Name INDEX) and 8 (Top DICT INDEX), which
	  describe the top level arrays that collect the fonts in the
	  fontset.</para>
	</listitem>
	<listitem>
	  <para>sections 9 (name-keyed fonts), 17 (synthetic fonts)
	  and 19 (CID-keyed fonts) which describe the three kinds of
	  fonts in a fontset</para>
	</listitem>
	<listitem>
	  <para>the remaining sections, which describe auxilliary data
	  structures used to represent the fonts in the fontset.</para>
	</listitem>
      </itemizedlist>
      Section 15 should be replicated within sections 9 and 19,
	with the appropriate specialization.</para>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Data Layout</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>Conceptually the binary data is organized as a number of
        separate data structures. The overall layout within the
        binary data is shown Table 1. Since some of these data
        structures are reached via offsets the ordering could be
        changed, although the first five occupy fixed
        locations.</para>

      <table>
        <title>CFF Data Layout</title>

        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>Entry</entry>
              <entry>Comments</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Header</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>Name INDEX</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>Top DICT INDEX</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>String INDEX</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>Global Subr INDEX</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>Encodings</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>Charsets</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>FDSelect</entry>
              <entry>CIDFonts only</entry>
            </row>
            <row>
              <entry>CharStrings INDEX</entry>
              <entry>per-font</entry>
            </row>
            <row>
              <entry>Font DICT INDEX</entry>
              <entry>per-font, CIDFonts only</entry>
            </row>
            <row>
              <entry>Private DICT</entry>
              <entry>per-font</entry>
            </row>
            <row>
              <entry>Local Subr INDEX</entry>
              <entry>per-font or per-Private DICT for CIDFonts</entry>
            </row>
            <row>
              <entry>Copyright and Trademark Notices</entry>
              <entry>&#x2013;</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Appendix D shows an annotated example of a CFF
        font.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>The last element, "Copyright and Trademark Notices", is
        not documented anywhere. The change log shows that the March
        16, 2000 version removed an entire section on the subject. We
        assume that the authors forgot to remove it from this table as
        well, and we will ignore it.</para>

      <para>There is a gap in the specification. Sections 3&#x2013;5
        describe infrastructure, sections 6, 7, 8, 10 and 16 describe
        the five global elements and the remaining sections describe
        other structures pointed by these five elements. This section
        could provide a better bridge between the parts, along these
        lines:</para>

      <blockquote>
        <para>A CFF structure starts with five components: the Header,
          the Name INDEX, the Top DICT INDEX, the String INDEX and the
          Global Subr INDEX. Those five elements must be present in
          that order, without gaps between them.</para>

        <para>The Header, String INDEX and Global Subr INDEX contain
          data shared by all the fonts in the FontSet, and are
          described in sections 6, 10 and 16.</para>

        <para>The Name INDEX and Top DICT INDEX are parallal arrays
          that contain one element per font in the FontSet. A font in
          the fontset can be identified by its position in those
          arrays. The Top DICT of a font can point (via offsets) to
          additional data strucutures needed to represent that font.
          Those data structures are stored in the CFF structure
          following the Global Subr INDEX, in any order. The Name
          INDEX and Top DICT INDEX are described in sections 7 and
          8.</para>

        <para>There are three kinds of fonts in a CFF FontSet:
            <itemizedlist>
            <listitem>
              <para>Name-keyed fonts, where each glyph has a name, the
                font specifies an encoding, and all the glyphs share
                the same rendering properties.</para>
            </listitem>
            <listitem>
              <para>Synthetic fonts, which are modifications (within
                well defined limits) of another name-keyed font in the
                fontset; typically, these are used to represent
                obliqued or expanded variations of their base
                font.</para>
            </listitem>
            <listitem>
              <para>CID-keyed fonts, where the glyphs are part of a
                well-know CID collection (such as the Adobe-Japan-1-5
                collection) and thus not named nor encoded (but each
                glyph is attached to a CID), and each glyph can have
                its own rendering parameters (more typically, glyphs
                are organized in group that share the same rendering
                parameters).</para>
            </listitem>
          </itemizedlist></para>

        <para>The kind of a font is determined by the contents of Top
          DICT. If it contains a ROS operator, then this operator must
          be the first one, and the font is a CID-keyed font. If it
          contains a SyntheticBase operator, then this operator must
          be the first one, and the font is a Synthetic font.
          Otherwise, the font is a name-keyed font.</para>

        <para>For each font kind, there are requirements on the
          content of the Top DICT and on the content of the structures
          pointed by those Top DICTs. These are described in sections
          9, 17 and 19.</para>
      </blockquote>

      <para>Section 9 would be renamed "Name-keyed Fonts" and describe
        specifically those fonts. It and section 18 would be made more
        similar to section 17: a description of the valid operators in
        the top DICT and the structures they point to. This would help
        immensely for CID-keyed fonts, where the sets of legal
        operators in the Top, Font and Private DICTs are somewhat
        unclear.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Let's start with the class that represents a CFF
        FontSet, aptly named <varname>CFFFontSet</varname>:</para>

<code-fragment package='com.adobe.aots.opentype' class='CFFFontSet'>
  <code-title>CFFFontSet class</code-title>
  package com.adobe.aots.opentype;

  import java.util.Map;
  import java.util.List;
  import java.util.Stack;
  import java.util.Iterator;

  import org.w3c.dom.Element;
  import org.w3c.dom.NodeList;
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.AttributesImpl;

  import com.adobe.aots.util.ContentHandlerPlus;

  public class CFFFontSet {
    <code-include linkend='cfffontset.constants'/>
    <code-include linkend='cfffontset.members'/>
    <code-include linkend='cfffontset.innerclasses'/>
    <code-include linkend='cfffontset.methods'/>
  }
</code-fragment>

      <para>Following our observations in the annotations, we conclude
        that an important concept in CFF is that of a font, more so
        than that of a Top DICT. Furthermore, there are different
        kinds of fonts. This leads us to a set of classes, one for
        each font kind. We will introduce a common interface,
        <varname>CFFFont</varname>, that all these classes must
        implement. A <varname>CFFFont</varname> represents one
        combined entry in the Name INDEX and Top DICT INDEX, as well
        as the structures pointed by that Top DICT.</para>

      <para>The other data contained in <varname>CFFFontSet</varname>
        is the header data, the global subroutines, and the String
        INDEX. In our internal representation, all the references to
        strings in the String INDEX are replaced by the strings
        themselves. This will simplify our manipulations of the
        internal structure.</para>

      <para>Altogether, we have the following internal
        representation:</para>

<code-fragment id='cfffontset.members'>
  <code-title>Internal representation of a CFFFontSet</code-title>
  protected CFFHeader header;
  protected CFFCharStrings globalSubrs;
  protected CFFFont[] fonts;
</code-fragment>


      <para>A useful operation is to get the number of fonts in the
        font set:</para>

<code-fragment id='cfffontset.methods'>
  public int size () {
    return fonts.length;
  }
</code-fragment>

      <para>Not surprisingly, a number of operations on the
        <varname>CFFFontSet</varname> are just the dispatching to
        the approriate <varname>CFFFont</varname>. We may as well
        take care of these right now.</para>

      <para>This one gets the name of a glyph given
        it's glyph ID. For CID-keyed font, this name is of the form
        "CIDx" where x is the hexadecimal representation (using '0'
        &#x2013; '9' and 'a' &#x2013; 'z') of the CID of the
        glyph.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to return the name of a glyph, given its gid</code-title>
  public String getGlyphName (int f, int gid) {
    return fonts [f].getGlyphName (gid);
  }
</code-fragment>

      <para>The inverse operation:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to return the gid of a glyph, given its name</code-title>
  public int getGlyphID (int f, String name) {
    return fonts [f].getGlyphID (name);
  }
</code-fragment>

      <para>This one fills a StringBuilder with the outline of a
      glyph, in PDF syntax:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to get the outline of 'gid', in PDF syntax</code-title>
  public void getGlyphOutline (int f, int gid, StringBuilder sb) {
    fonts [f].getGlyphOutline (gid, sb);
  }
</code-fragment>

      <para>This one fills a StringBuilder with the lines and curves of a
      glyph:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to get the lines and curves of 'gid'</code-title>
  public void getGlyphLinesAndCurves (int f, int gid, StringBuilder sb) {
    fonts [f].getGlyphLinesAndCurves (gid, sb);
  }
</code-fragment>

      <para>This one computes the bounding box of a glyph; but first,
      let's have a bounding box object</para>

<code-fragment package='com.adobe.aots.opentype' class='BoundingBox'>
  <code-title>BoundingBox class</code-title>
package com.adobe.aots.opentype;

public class BoundingBox {
  public double xmin;
  public double ymin;
  public double xmax;
  public double ymax;

  public BoundingBox ()
  {
    this.xmin = Double.POSITIVE_INFINITY;
    this.ymin = Double.POSITIVE_INFINITY;

    this.xmax = Double.NEGATIVE_INFINITY;
    this.ymax = Double.NEGATIVE_INFINITY;
  }

  public void include (double x, double y) {
    if (x &lt; xmin) {
      xmin = x; }
    if (xmax &lt; x) {
      xmax = x; }
    if (y &lt; ymin) {
     ymin = y; }
    if (ymax &lt; y) {
      ymax = y; }
  }
}
</code-fragment>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to return the bounding box of a glyph, given its gid</code-title>
  public BoundingBox getGlyphBoundingBox (int f, int gid) {
    return fonts [f].getGlyphBoundingBox (gid);
  }
</code-fragment>

      <para>This one gets the name of a font:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to return the name of a font</code-title>
  public String getName (int f) {
    return fonts [f].getName ();
  }
</code-fragment>

      <para>This one tells us if a font is name keyed:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to determine if a font is name keyed</code-title>
  public boolean isNameKeyed (int f) {
    return fonts [f] instanceof CFFNameKeyedFont;
  }
</code-fragment>

      <para>Here is a method that transforms the CFFFontSet to CID
	format; more precisely, given one of the fonts in the
	CFFFontSet, that font is transformed to be CID-keyed, keeping
	the CharStrings indices constant. The ROS is set to
	Adobe-Identity-0, the CID to GID mapping is set to the
	identity. Other fonts in the CFFFontSet are unchanged.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to convert a CFFFont to CID</code-title>
  public void toCID (int f) {
    fonts [f] = fonts [f].toCID ();
  }
</code-fragment>

      <para>It's now time to introduce our
        <varname>CFFFont</varname> interface:</para>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>CFFFont interface</code-title>
  public interface CFFFont {
    <code-include linkend='cfffont.methods'/>
  }
</code-fragment>

      <para>The <varname>getName</varname> method returns the name of
        the font:</para>

<code-fragment id='cfffont.methods'>
  <code-title>getName method</code-title>
  public String getName ();
</code-fragment>

      <para>These two methods convert to and from the XML
	representation:</para>

<code-fragment id='cfffont.methods'>
  <code-title>XML methods</code-title>
  public void toXML (ContentHandlerPlus ch, Type2Font2XML t2Processor)
    throws org.xml.sax.SAXException;

  public void fromXML (Element e)
      throws InvalidFontException;
</code-fragment>

      <para>When we load the binary representation of a
        <varname>CFFFont</varname>, we need to parse its Top DICT
        first, so that we can determine its kind and construct the
        corresponding object. Thus, our <varname>fromBinary</varname>
        method is given the already digested name (out of the Name
        INDEX) and parsed Top DICT:</para>

<code-fragment id='cfffont.methods'>
  <code-title>fromBinary method</code-title>
  public void fromBinary (byte[] data,
                          String name,
                          Map&lt;String, Operator> topDict,
                          String[] stringINDEX)
    throws InvalidFontException;
</code-fragment>

      <para>Creating the binary representation of a
      <varname>CFFFont</varname> is a three step process. First, we
      need to fill the String INDEX, using the
      <varname>collectStrings</varname> method. Next, we create the
      Top DICT, using the <varname>topDictToBinary</varname>
      method. Finally, we can create the other chunks (such as the
      private dictionnary) using the <varname>restToBinary</varname>
      method.</para>

<code-fragment id='cfffont.methods'>
  <code-title>toBinary methods</code-title>
  public void collectStrings (List&lt;String> strings);

  public void topDictToBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException;
  public void restToBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException;
</code-fragment>

      <para>We also need a few methods to support the
        <varname>CFFFontSet</varname> methods:</para>

<code-fragment id='cfffont.methods'>
  <code-title>Methods to find glyph names and IDs</code-title>
  public String getGlyphName (int gid);

  public void getGlyphOutline (int gid, StringBuilder sb);
  public void getGlyphLinesAndCurves (int gid, StringBuilder sb);

  public BoundingBox getGlyphBoundingBox (int gid);

  public int getGlyphID (String glyphname);

  public CFFFont toCID ();
</code-fragment>
      </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

      <para>Here is our method to convert from the binary
        representation to our internal representation.</para>

      <para>Because we want to resolve the references to strings in
	the String INDEX to the strings themselves, we need to parse
	that first. But to find its place in the structure, we need to
	skip over the Name and Top DICT INDEXes.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>CFFFontSet.fromBinary method</code-title>
  public int fromBinary (java.io.InputStream in, int length)
      throws java.io.IOException, InvalidFontException {

    byte[] data = new byte [length];
    int result = in.read (data);

    fromBinary (data);
    return result;
  }

  public void fromBinary (byte [] data)
      throws InvalidFontException {
    int offset = 0;

    // find the offsets of the fixed pieces
    header = new CFFHeader ();
    int namesOffset = header.fromBinary (data, offset);
    int topDictsOffset = skipINDEX (data, namesOffset);
    int stringsOffset = skipINDEX (data, topDictsOffset);
    int globalSubrsOffset = skipINDEX (data, stringsOffset);

    // finish parsing the top level elements
    String[] names = namesFromBinary (data, namesOffset);
    String[] strings = stringsFromBinary (data, stringsOffset);
    Map[] topDicts = dictsFromBinary (data, topDictsOffset, strings);
    globalSubrs = new CFFCharStrings ();
    offset = globalSubrs.fromBinary (data, globalSubrsOffset);

    // create the CFFFonts
    fonts = new CFFFont [names.length];
    for (int i = 0; i &lt; names.length; i++) {
      if (topDicts [i].get ("SyntheticBase") != null) {
        fonts [i] = new CFFSyntheticFont (); }
      else if (topDicts[i].get ("ROS") != null) {
        fonts [i] = new CFFCIDKeyedFont (); }
      else {
        fonts [i] = new CFFNameKeyedFont (); }
      fonts [i].fromBinary (data, names [i],
                            (Map&lt;String, Operator>) (topDicts [i]), strings); }
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>Generating the binary representation follows the steps
	outlined earlier:</para>

<code-fragment id='cfffontset.methods'>
  public byte[] toBinary () {

  try {
    ByteBuffer bb = new ByteBuffer ();

    // collect all the strings
    List&lt;String> strings = new java.util.ArrayList&lt;String> (70*1000);
    for (int i = 0; i &lt; predefinedCFFStrings.length; i++) {
      strings.add (predefinedCFFStrings [i]); }
    for (int i = 0; i &lt; fonts.length; i++) {
      fonts [i].collectStrings (strings); }

    // Header
    header.toBinary (bb);

    { // Name INDEX
      IndexCursor indexCursor = startIndex (bb, fonts.length);
      for (int i = 0; i &lt; fonts.length; i++) {
        String name = fonts [i].getName ();
        for (int j = 0; j &lt; name.length (); j++) {
          bb.addCard8 (name.charAt (j)); }
        indexCursor = elementEntered (bb, indexCursor); }}

    { // Top Dict INDEX
      IndexCursor indexCursor = startIndex (bb, fonts.length);
      for (int i = 0; i &lt; fonts.length; i++) {
        fonts [i].topDictToBinary (bb, strings);
        indexCursor = elementEntered (bb, indexCursor); }}

    { // String INDEX
      int nbActualStrings = strings.size () - predefinedCFFStrings.length;
      IndexCursor indexCursor = startIndex (bb, nbActualStrings);
      for (int i = predefinedCFFStrings.length; i &lt; strings.size (); i++) {
        String s = strings.get (i);
        for (int j = 0; j &lt; s.length (); j++) {
          bb.addCard8 (s.charAt (j)); }
        indexCursor = elementEntered (bb, indexCursor); }}

    // Global Subroutines
    globalSubrs.toBinary (bb);

    // Remaining structures
    for (int i = 0; i &lt; fonts.length; i++) {
      fonts [i].restToBinary (bb, strings); }

    return bb.toArray (); }

  catch (Exception e) {
    System.out.println ("Exception: " + e.getMessage ());
    e.printStackTrace ();
    return null; }
  }
</code-fragment>
      </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

      <para>Our XML representation follows basically the same steps
        as our implementation, but it goes a bit further; we do not
        explicitly represent the Strings INDEX, as explained in
        section 10; the header data is represented as attributes as
        explained in section 6.</para>

<code-fragment file='cfffontset.rnc' method='text'>
  <code-title>CFFFontSet DTD</code-title>

##_____________________________________________________________________________
##
##  Copyright 2000-2016 Adobe Systems Incorporated. All Rights Reserved.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use these files except in compliance with the License.
##  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##_____________________________________________________________________________

start =
  element fontSet { fontSet }

fontSet =
  header,

  ( element name-keyed-font { name-keyed-font }?
  &amp; element cid-keyed-font { cid-keyed-font }?
  &amp; element synthetic-font { synthetic-font }? ),

  element globalSubrs { globalSubrs }?

<code-include linkend='schema'/>

</code-fragment>
      </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
      <title>Compiler</title>

      <para>Pretty straightforward:</para>

<code-fragment id='cfffontset.methods'>
  public void fromXML (Element cfffontset)
      throws InvalidFontException {
    header = new CFFHeader ();
    header.fromXML (cfffontset);

    globalSubrs = new CFFCharStrings ();

    NodeList nl = cfffontset.getChildNodes ();

    if (cfffontset.getElementsByTagName ("globalSubrs").getLength () == 0) {
      fonts = new CFFFont [nl.getLength ()]; }
    else {
      fonts = new CFFFont [nl.getLength () - 1]; }

    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element e = (Element) nl.item (i);

      if ("name-keyed-font".equals (e.getTagName ())) {
        fonts [i] = new CFFNameKeyedFont ();
        fonts [i].fromXML (e); }

      else if ("cid-keyed-font".equals (e.getTagName ())) {
        fonts [i] = new CFFCIDKeyedFont ();
        fonts [i].fromXML (e); }

      else if ("synthetic-font".equals (e.getTagName ())) {
        fonts [i] = new CFFSyntheticFont ();
        fonts [i].fromXML (e); }

      else { // must be globalSubrs
        globalSubrs.fromXML (e); }}
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

      <para>Pretty straightforward:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>toXML method</code-title>
  public void toXML (com.adobe.aots.util.ContentHandlerPlus ch)
      throws org.xml.sax.SAXException {

    Attributes at = header.toXML ();
    ch.startElement ("fontSet", at); {

      Type2Font2XML t2Processor = new Type2Font2XML ();
      if (globalSubrs != null) {
        globalSubrs.initSbs (); }

      for (int i = 0; i &lt; fonts.length; i++) {
        fonts [i].toXML (ch, t2Processor); }

      if (globalSubrs != null) {
        globalSubrs.toXML (ch, "globalSubrs"); }

      ch.endElement ("fontSet"); }
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Data Types</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>This section describes data representation and types used
        by the format.</para>

      <para>All multi-byte numeric data and offset fields are stored
        in big-endian byte order (high byte low offset) and do not
        honor any alignment restrictions. This leads to a format that
        is free from padding bytes.</para>

      <para>Data objects are often specified by byte offsets that are
        relative to some reference point within the CFF data. These
        offsets are 1 to 4 bytes in length. This document uses the
        convention of enclosing the reference point in parentheses and
        uses a reference point of (0) to indicate an offset relative
        to the start of the CFF data and (self) to indicate an offset
        relative to the data structure containing the offset.</para>

      <table>
        <title>CFF Data Types</title>
        <tgroup>
          <colspec colwidth='4pc'/>
          <colspec colwidth='4pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Range</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>0-255</entry>
              <entry>1-byte unsigned number</entry>
            </row>
            <row>
              <entry>Card16</entry>
              <entry>0&#x2013;65535</entry>
              <entry>2-byte unsigned number</entry>
            </row>
            <row>
              <entry>Offset</entry>
              <entry>varies</entry>
              <entry>1, 2, 3, or 4 byte offset (specified by OffSize
                field)</entry>
            </row>
            <row>
              <entry>OffSize</entry>
              <entry>1&#x2013;4</entry>
              <entry>1-byte unsigned number specifies the size of an
                Offset field or fields</entry>
            </row>
            <row>
              <entry>SID</entry>
              <entry>0&#x2013;64999</entry>
              <entry>2-byte string identifier</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>This document describes data structures by listing field
        types, names, and descriptions. Data structures may be given a
        type name and subsequently described. Arrays of objects are
        indicated by the usual square bracket convention enclosing the
        array length.</para>

      <para>The majority of CFF data is contained by either of two
        data structures called DICT and INDEX which are described in
        subsequent sections.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>To help the creation of binary versions, here is a
        <varname>ByteBuffer</varname>, which is a growable byte
        sequence.  Typically, we add bytes at the end of the
          sequence, but from time to time, we need to come back and
          update pointers (using a sequence
          <varname>length</varname>, <varname>skip</varname>, other
          computation, <varname>fixOffset</varname>):</para>

<code-fragment package='com.adobe.aots.opentype' class='ByteBuffer'>
  <code-title>ByteBuffer class</code-title>
  package com.adobe.aots.opentype;

  public class ByteBuffer {
    private int used;
    private byte[] bytes;

    public ByteBuffer (int initialSize) {
      this.used = 0;
      this.bytes = new byte [initialSize];
    }

    public ByteBuffer () {
      this (102400);
    }

    public int length () {
      return used;
    }

    private void ensure (int n) {
      if (bytes.length - used &lt;= n) {
        int inc = 0;
        while (inc &lt; n) {
          inc += 102400; }
        byte[] temp = new byte [bytes.length + inc];
        System.arraycopy (bytes, 0, temp, 0, used);
        bytes = temp; }
    }

    public void skip (int n) {
      ensure (n);
      used += n;
    }

    public void addCard32 (int n) {
      ensure (4);
      bytes [used++] = (byte)((n >> 24) &amp; 0xff);
      bytes [used++] = (byte)((n >> 16) &amp; 0xff);
      bytes [used++] = (byte)((n >>  8) &amp; 0xff);
      bytes [used++] = (byte)((n      ) &amp; 0xff);
    }

    public void addCard24 (int n) {
      ensure (3);
      bytes [used++] = (byte)((n >> 16) &amp; 0xff);
      bytes [used++] = (byte)((n >>  8) &amp; 0xff);
      bytes [used++] = (byte)((n      ) &amp; 0xff);
    }

    public void addCard16 (int n) {
      ensure (2);
      bytes [used++] = (byte)((n >> 8) &amp; 0xff);
      bytes [used++] = (byte)((n     ) &amp; 0xff);
    }

    public void addCard8 (int n) {
      ensure (1);
      bytes [used++] = (byte)((n     ) &amp; 0xff);
    }

    public void addOffset (int n) {
      addCard32 (n);
    }

    public void addOffSize (int n) {
       addCard8 (n);
    }

    public void fixOffset (int pos, int n) {
      bytes [pos++] = (byte)((n >> 24) &amp; 0xff);
      bytes [pos++] = (byte)((n >> 16) &amp; 0xff);
      bytes [pos++] = (byte)((n >>  8) &amp; 0xff);
      bytes [pos++] = (byte)((n      ) &amp; 0xff);
    }

    public void addBytes (byte[] b) {
      ensure (b.length);
      System.arraycopy (b, 0, bytes, used, b.length);
      used += b.length;
    }

    public byte[] toArray () {
      byte[] b = new byte [used];
      System.arraycopy (bytes, 0, b, 0, used);
      return b;
    }
  }
</code-fragment>

      <para>Conversely, here are some methods to pull the bits and
        pieces.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Methods to take apart a binary representation</code-title>
  protected int getCard8 (byte[] data, int offset) {
    int x = data [offset];
    if (x &lt; 0) {
      x += 256; }
    return x;
  }

  protected int getCard16 (byte[] data, int offset) {
    int b1 = ((int)(getCard8 (data, offset    ))) &lt;&lt;  8;
    int b2 = ((int)(getCard8 (data, offset + 1)));
    return (b1 | b2);
  }

  protected int getCard24 (byte[] data, int offset) {
    int b1 = ((int)(getCard8 (data, offset    ))) &lt;&lt; 16;
    int b2 = ((int)(getCard8 (data, offset + 1))) &lt;&lt;  8;
    int b3 = ((int)(getCard8 (data, offset + 2)));
    return (b1 | b2 | b3);
  }

  protected int getCard32 (byte[] data, int offset) {
    long b1 = ((long)(getCard8 (data, offset    ))) &lt;&lt; 24;
    long b2 = ((long)(getCard8 (data, offset + 1))) &lt;&lt; 16;
    long b3 = ((long)(getCard8 (data, offset + 2))) &lt;&lt;  8;
    long b4 = ((long)(getCard8 (data, offset + 3)));

    long o = (b1 | b2 | b3 | b4);

    if (o > Integer.MAX_VALUE) {
      System.out.println ("Offset too big!"); }
    return (int) o;
  }


  protected int getOffSize (byte[] data, int offset) {
    return getCard8 (data, offset);
  }

  protected int getOffset (byte[] data, int offset, int offSize) {
    switch (offSize) {
      case 1: {
        return getCard8 (data, offset); }
      case 2: {
        return getCard16 (data, offset); }
      case 3: {
        return getCard24 (data, offset); }
      default: {
        return getCard32 (data, offset); }}
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>DICT Data</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

    <para>Font dictionary data comprising key-value pairs is
      represented in a compact tokenized format that is similar to
      that used to represent Type 1 charstrings. Dictionary keys are
      encoded as 1- or 2-byte operators and dictionary values are
      encoded as variable-size numeric operands that represent
      either integer or real values. An operator is preceded by the
      operand(s) that specify its value. A DICT is simply a sequence
      of operand(s)/operator bytes concatenated together.</para>

    <para>A number of integer operand types of varying sizes are
      defined and are encoded as shown in Table 3 (first byte of
      operand is b0, second is b1, and so on).</para>

    <table>
      <title>Operand Encoding</title>
      <tgroup>
          <colspec colwidth='4pc'/>
          <colspec colwidth='6pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='12pc'/>
        <thead>
          <row>
            <entry>Size</entry>
            <entry>b0 range</entry>
            <entry>Value range</entry>
            <entry>Value calculation</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>1</entry>
            <entry>32 &#x2013; 246</entry>
            <entry>-107 &#x2013; +107</entry>
            <entry>b0-139</entry>
          </row>
          <row>
            <entry>2</entry>
            <entry>247 &#x2013; 250</entry>
            <entry>+108 &#x2013; +1131</entry>
            <entry>(b0-247)*256+b1+108</entry>
          </row>
          <row>
            <entry>2</entry>
            <entry>251 &#x2013; 254</entry>
            <entry>-1131 &#x2013; -108</entry>
            <entry>(b0-251)*256-b1-108</entry>
          </row>
          <row>
            <entry>3</entry>
            <entry>28</entry>
            <entry>-32768 &#x2013; +32767</entry>
            <entry>b1&lt;&lt;8 | b2</entry>
          </row>
          <row>
            <entry>5</entry>
            <entry>29 </entry>
            <entry>-(2^31) &#x2013; +(2^31-1)</entry>
            <entry>b1&lt;&lt;24 | b2&lt;&lt;16 | b3&lt;&lt;8 | b4</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Note 1: The 1- , 2-, and 3- byte integer formats are
      identical to those used by Type 2 charstrings.</para>

    <para>Examples of the integer formats are shown in Table
      4.</para>

    <table>
      <title>Integer Format Examples</title>
      <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
        <thead>
          <row>
            <entry>Value</entry>
            <entry>Encoding</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>0</entry>
            <entry>8b</entry>
          </row>
          <row>
            <entry>100</entry>
            <entry>ef</entry>
          </row>
          <row>
            <entry>-100</entry>
            <entry>27</entry>
          </row>
          <row>
            <entry>1000</entry>
            <entry>fa 7c</entry>
          </row>
          <row>
            <entry>-1000</entry>
            <entry>fe 7c</entry>
          </row>
          <row>
            <entry>10000</entry>
            <entry>1c 27 10</entry>
          </row>
          <row>
            <entry>-10000</entry>
            <entry>1c d8 f0</entry>
          </row>
          <row>
            <entry>100000</entry>
            <entry>1d 00 01 86 a0</entry>
          </row>
          <row>
            <entry>-100000</entry>
            <entry>1d ff fe 79 60</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>A real number operand is provided in addition to integer
      operands. This operand begins with a byte value of 30 followed
      by a variable-length sequence of bytes. Each byte is composed
      of two 4-bit nibbles as defined in Table 5. The first nibble
      of a pair is stored in the most significant 4 bits of a byte
      and the second nibble of a pair is stored in the least
      significant 4 bits of a byte.</para>

    <table>
      <title>Nibble Definitions</title>
      <tgroup>
        <colspec colwidth='8pc'/>
        <colspec colwidth='8pc'/>
        <thead>
          <row>
            <entry>Nibble</entry>
            <entry>Represents</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>0&#x2013;9</entry>
            <entry>0&#x2013;9</entry>
          </row>
          <row>
            <entry>a</entry>
            <entry>. (decimal point)</entry>
          </row>
          <row>
            <entry>b</entry>
            <entry>E</entry>
          </row>
          <row>
            <entry>c</entry>
            <entry>E-</entry>
          </row>
          <row>
            <entry>d</entry>
            <entry>&lt;reserved></entry>
          </row>
          <row>
            <entry>e</entry>
            <entry>- (minus)</entry>
          </row>
          <row>
            <entry>f</entry>
            <entry>end of number</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>A real number is terminated by one (or two) 0xf nibbles so
      that it is always padded to a full byte. Thus, the value
      -2.25 is encoded by the byte sequence (1e e2 a2 5f) and the
      value 0.140541E-3 by the sequence (1e 0a 14 05 41 c3
      ff).</para>

    <para>Operators and operands may be distinguished by inspection
      of their first byte: 0&#x2013;21 specify operators and 28, 29, 30,
      and 32&#x2013;254 specify operands (numbers). Byte values
      22&#x2013;27, 31, and 255 are reserved. An operator may be
      preceded by up to a maximum of 48 operands.</para>

    <para>An operator may have one or more operands of the types
      shown in Table 6.</para>

    <table>
      <title>Operand Types</title>
      <tgroup>
        <colspec colwidth='8pc'/>
        <colspec colwidth='22pc'/>
        <thead>
          <row>
            <entry>Type</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>number</entry>
            <entry>Integer or real number</entry>
          </row>
          <row>
            <entry>boolean</entry>
            <entry>Integer type with the values 0 (false) and 1 (true)</entry>
          </row>
          <row>
            <entry>SID</entry>
            <entry>String id (see section 10)</entry>
          </row>
          <row>
            <entry>array</entry>
            <entry>One or more numbers</entry>
          </row>
          <row>
            <entry>delta</entry>
            <entry>A number or a delta-encoded array of numbers (see
              below)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The length of array or delta types is determined by
      counting the operands preceding the operator. The second and
      subsequent numbers in a delta are encoded as the difference
      between successive values. For example, an array a0, a1, ...,
      an would be encoded as: a0 (a1-a0) (a2-a1) ...,
      (an-a(n-1)).</para>

    <para>Two-byte operators have an initial escape byte of 12.
      Further compaction of dictionary data is achieved by
      establishing default values for various DICT keys. For those
      keys that have a default value the absence of the
      corresponding operator in a DICT implies a key should take its
      default value.</para>

    <para>(A list of DICT operators for the Top and Private DICTs
      may be found in sections 9 and 15, respectively.)</para>

    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>The specification states that a font dictionary is a set
        of key-value pairs. It is unclear whether the same key can
        appear multiple times, with or without the same
        value. We assume it cannot, base on Type1 history.</para>

      <para>Note 1 mentions that the 1, 2 and 3 byte integer
        formats are identical to those of Type2. It could be
        completed by observing that there is no equivalent of the 4
        byte 16.16 numbers of Type 2 and that Type 2 has no
        equivalent of the 4 byte integers of CFF.</para>

      <para>The SID type in dictionnaries is actually different from
        the SID type defined in section 3. In a dictionnary, the
        integer that is to be interpreted as a SID is stored just like
        any other integer, using a variable length encodig, not as a
        two byte unsigned integer.</para>

      <para>Overall, the grammar for real numbers (that is, the valid
        sequences of nibbles) is not specified. For example, nothing
        rules out the sequence "EE", although it is doubtful that it
        is valid. While a tool can steer away from generating such
        sequences and/or reject fonts that contain it, there are a
        number of cases that are more difficult to sort out. For
        example, should there be a digit before the decimal point?
        Is the sequence "E" followed by "-" illegal or is it
        equivalent to "E-"?</para>

      <para>The arithmetic on numbers (both integers and real numbers)
        is not defined. This makes the delta operand type difficult to
        use.</para>

      <para>Each operator accepts a specific list of operands, which
        does not depend on the particular dictionnary in which the
        operator occurs. This list of operands, or at least their
        number, names, types and default values, really belong to the syntax of
        dictionaries, that is to this section. We recommend that the
        content of appendix H be incorporated in this section, and
        that for each operator, the number, names and types of the
        operators be specified. The meaning of an operator, and
        whether it can be present in a given dictionnary should be
        left to sections describing the invididual dictionaries. If
        that recommendation is followed, then the last sentence
        should be removed. Otherwise, is should be changed to: "A
        list of the DICT operators can be found in Appendix H. The
        Top, Private and Synthetic dictionaries are described in
        sections 9, 15 and 17."</para>

      <para>Many operands are given the "number" type. In many cases,
        it seems that this is too generous. For example, all the
        operands that represent offsets should probably limited to be
        integers.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>We represent the combination of an operator and its
	operands in a <varname>Operator</varname> object.</para>

      <para>The
	<varname>fromBinary</varname> method is given the current
	operand stack, as well as the map from SIDs to Strings (so
	that the former can be replaced by the later).</para>

      <para>The <varname>collectStrings</varname> method is invoked at
	the beginning of the generation of the binary representation,
	to collect all the Strings that need to be entered in the
	String INDEX.</para>

      <para>The <varname>toBinary</varname> method generates the
        binary byte sequence for the operands and the operator.</para>

      <para>The <varname>toXML</varname> and
	<varname>fromXML</varname> methods are used to create and
	parse the XML representation of CFF structures.</para>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>Operator class</code-title>
  public class Operator implements Cloneable {
    public boolean oneByte;
    public int     code;
    public String  name;

    public Operator (boolean oneByte, int code, String name) {
      this.oneByte = oneByte;
      this.code = code;
      this.name = name;
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {}

    public void collectStrings (List&lt;String> strings) {}

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      if (! oneByte) {
        bb.addCard8 (12); }
      bb.addCard8 (code);
    }

    public void toXML (ContentHandlerPlus ch)
      throws SAXException {}

    public void fromXML (Element e) {}

    public Object clone () {
      try {
        return super.clone (); }
      catch (CloneNotSupportedException e) {
        return null; }
    }
  }
</code-fragment>

      <para>We have one subclass for each combination of operand
      types.</para>


<code-fragment id='cfffontset.innerclasses'>
  <code-title>StringOp class</code-title>
  public class StringOp extends Operator {
    String value;

    public StringOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 1) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o = s.pop ();
      if (! (o instanceof Integer)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
      this.value = strings [((Integer)o).intValue ()];
    }

    public void collectStrings (List&lt;String> strings) {
      if (strings.indexOf (value) == -1) {
        strings.add (value); }
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      intToBinary (bb, strings.indexOf (value));
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", value);
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      value = e.getAttribute ("v");
    }
  }
</code-fragment>

      <para>For offsets, note that the <varname>toBinary</varname>
	method always generates a four-byte integer, with the value 0,
	which is later updated via the <varname>fixOffset</varname>
	method.</para>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>OffsetOp class</code-title>
  public class OffsetOp extends Operator {
    int location;

    public OffsetOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 1) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o = s.pop ();
      if (! (o instanceof Integer)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
      this.location = ((Integer)o).intValue ();
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      bb.addCard8 (29);
      location = bb.length ();
      bb.addCard32 (0);
      super.toBinary (bb, strings);
    }

    public void fixOffset (ByteBuffer bb, int actual) {
      bb.fixOffset (location, actual);
    }

    public void toXML (ContentHandlerPlus ch)
      throws SAXException {}

    public void fromXML (Element e) {}
  }
</code-fragment>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>BboxOp class</code-title>
  public class BBoxOp   extends Operator {
    public Object xmin, ymin, xmax, ymax;

    public BBoxOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 4) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      ymax = s.pop ();
      xmax = s.pop ();
      ymin = s.pop ();
      xmin = s.pop ();
      if (   ! (xmin instanceof Integer || xmin instanceof String)
          || ! (ymin instanceof Integer || ymin instanceof String)
          || ! (xmax instanceof Integer || xmax instanceof String)
          || ! (ymax instanceof Integer || ymax instanceof String)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      numberToBinary (bb, xmin);
      numberToBinary (bb, ymin);
      numberToBinary (bb, xmax);
      numberToBinary (bb, ymax);
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "xmin", "xmin", "CDATA", xmin.toString ());
      at.addAttribute ("", "ymin", "ymin", "CDATA", ymin.toString ());
      at.addAttribute ("", "xmax", "xmax", "CDATA", xmax.toString ());
      at.addAttribute ("", "ymax", "ymax", "CDATA", ymax.toString ());
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      //TODO: reduce to Integer if possible
      xmin = e.getAttribute ("xmin");
      ymin = e.getAttribute ("ymin");
      xmax = e.getAttribute ("xmax");
      ymax = e.getAttribute ("ymax");
    }
  }
</code-fragment>



<code-fragment id='cfffontset.innerclasses'>
  <code-title>MatrixOp class</code-title>
  public class MatrixOp   extends Operator {
    public Object a, b, c, d, e, f;

    public MatrixOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 6) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      f = s.pop ();
      e = s.pop ();
      d = s.pop ();
      c = s.pop ();
      b = s.pop ();
      a = s.pop ();
      if (   ! (a instanceof Integer || a instanceof String)
          || ! (b instanceof Integer || b instanceof String)
          || ! (c instanceof Integer || c instanceof String)
          || ! (d instanceof Integer || d instanceof String)
          || ! (e instanceof Integer || e instanceof String)
          || ! (f instanceof Integer || f instanceof String)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      numberToBinary (bb, a);
      numberToBinary (bb, b);
      numberToBinary (bb, c);
      numberToBinary (bb, d);
      numberToBinary (bb, e);
      numberToBinary (bb, f);
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "a", "a", "CDATA", a.toString ());
      at.addAttribute ("", "b", "b", "CDATA", b.toString ());
      at.addAttribute ("", "c", "c", "CDATA", c.toString ());
      at.addAttribute ("", "d", "d", "CDATA", d.toString ());
      at.addAttribute ("", "e", "e", "CDATA", e.toString ());
      at.addAttribute ("", "f", "f", "CDATA", f.toString ());
      ch.element (name, at);
    }

    public void fromXML (Element el) {
      //TODO: reduce to Integer if possible
      a = el.getAttribute ("a");
      b = el.getAttribute ("b");
      c = el.getAttribute ("c");
      d = el.getAttribute ("d");
      e = el.getAttribute ("e");
      f = el.getAttribute ("f");
    }
  }
</code-fragment>


<code-fragment id='cfffontset.innerclasses'>
  <code-title>NumberOp class</code-title>
  public class NumberOp extends Operator {
    public Object value;

    public NumberOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 1) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o = s.pop ();
      if (! (o instanceof Integer || o instanceof String)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
      this.value = o;
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      numberToBinary (bb, value);
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", value.toString ());
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      value = e.getAttribute ("v");
    }
  }
</code-fragment>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>ArrayOp class</code-title>
  public class ArrayOp  extends Operator {
    public Object[] values;

    public ArrayOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      values = s.toArray ();
      for (int i = 0; i &lt; values.length; i++) {
        if (! (values [i] instanceof Integer || values [i] instanceof String)) {
          throw new InvalidFontException ("Wrong operand type for '"
                                          + name + "'"); }}
      s.clear ();
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      for (int i = 0; i &lt; values.length; i++) {
        numberToBinary (bb, values [i]); }
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      String s = "";
      if (values.length != 0) {
        s = "" + values [0];
        for (int i = 1; i &lt; values.length; i++) {
          s += " " + values [i]; }}
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", s);
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      String s = e.getAttribute ("v");
      int i;
      int len = s.length ();
      int count = 0;

      i = 0;
      while (i &lt; len) {
        while (i &lt; len &amp;&amp; s.charAt (i) == ' ') {
          i++; }
        if (i == len) {
          break; }
        while (i &lt; len &amp;&amp; s.charAt (i) != ' ') {
          i++; }
        count++; }

      values = new Object [count];

      i = 0;
      count = 0;
      while (i &lt; len) {
        while (i &lt; len &amp;&amp; s.charAt (i) == ' ') {
          i++; }
        if (i == len) {
          break; }
        int start = i;
        while (i &lt; len &amp;&amp; s.charAt (i) != ' ') {
          i++; }
        values [count] = s.substring (start, i);
        count++; }
    }
  }
</code-fragment>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>DeltaOp class</code-title>
  public class DeltaOp  extends ArrayOp {
    public DeltaOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }
  }

  public class BooleanOp extends IntegerOp {

    public BooleanOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 1) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o = s.pop ();
      if (! (o instanceof Integer)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
      value = ((Integer)o).intValue ();
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", (value != 0) ? "true" : "false");
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      value = "true".equals (e.getAttribute ("v")) ? 1 : 0;
    }
  }
</code-fragment>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>ROSOp class</code-title>
  public class ROSOp     extends Operator {
    public String registry;
    public String ordering;
    public Object supplement;

    public ROSOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 3) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o3 = s.pop ();
      Object o2 = s.pop ();
      Object o1 = s.pop ();

      if (   ! (o1 instanceof Integer)
          || ! (o2 instanceof Integer)
          || ! (o3 instanceof Integer || o3 instanceof String)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }

      this.supplement = o3;
      this.ordering = strings [((Integer)o2).intValue ()];
      this.registry = strings [((Integer)o1).intValue ()];
    }

    public void collectStrings (List&lt;String> strings) {
      if (strings.indexOf (registry) == -1) {
        strings.add (registry); }
      if (strings.indexOf (ordering) == -1) {
        strings.add (ordering); }
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      intToBinary (bb, strings.indexOf (registry));
      intToBinary (bb, strings.indexOf (ordering));
      numberToBinary (bb, supplement);
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "registry", "registry", "CDATA", registry);
      at.addAttribute ("", "ordering", "ordering", "CDATA", ordering);
      at.addAttribute ("", "supplement", "supplement", "CDATA", "" + supplement);
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      registry = e.getAttribute ("registry");
      ordering = e.getAttribute ("ordering");
      supplement = e.getAttribute ("supplement");
    }
  }
</code-fragment>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>IntegerOp class</code-title>
  public class IntegerOp extends Operator {
    public int value;

    public IntegerOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 1) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o = s.pop ();
      if (! (o instanceof Integer)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
      this.value = ((Integer)o).intValue ();
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      intToBinary (bb, value);
      super.toBinary (bb, strings);
    }

    public void toXML (ContentHandlerPlus ch)
        throws SAXException {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + value);
      ch.element (name, at);
    }

    public void fromXML (Element e) {
      value = Integer.decode (e.getAttribute ("v")).intValue ();
    }
  }
</code-fragment>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>PrivateOp class</code-title>
  public class PrivateOp extends Operator {
    public int size;
    public int offset;

    public int sizeLocation;
    public int offsetLocation;

    public PrivateOp (boolean oneByte, int code, String name) {
      super (oneByte, code, name);
    }

    public void fromBinary (Stack s, String[] strings)
        throws InvalidFontException {
      if (s.size () != 2) {
        throw new InvalidFontException ("Wrong # of operands for '"
                                        + name + "'"); }
      Object o2 = s.pop ();
      Object o1 = s.pop ();
      if (! (o1 instanceof Integer) || ! (o2 instanceof Integer)) {
        throw new InvalidFontException ("Wrong operand type for '"
                                        + name + "'"); }
      this.size = ((Integer)o1).intValue ();
      this.offset = ((Integer)o2).intValue ();
    }

    public void toBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
      bb.addCard8 (29);
      sizeLocation = bb.length ();
      bb.addCard32 (0);
      bb.addCard8 (29);
      offsetLocation = bb.length ();
      bb.addCard32 (0);
      super.toBinary (bb, strings);
    }

    public void fixOffset (ByteBuffer bb, int actual) {
      bb.fixOffset (offsetLocation, actual);
    }
    public void fixSize (ByteBuffer bb, int actual) {
      bb.fixOffset (sizeLocation, actual);
    }
  }
</code-fragment>

      <para>Finally, here is the full list of operators, from which we
      will clone when we construct a dictionary:</para>

<code-fragment id='cfffontset.members'>
  <code-title>Operator templates</code-title>
  private Operator [] operators =
      {new StringOp      (true,   0, "version"),
       new StringOp      (true,   1, "Notice"),
       new StringOp      (true,   2, "FullName"),
       new StringOp      (true,   3, "FamilyName"),
       new StringOp      (true,   4, "Weight"),
       new BBoxOp        (true,   5, "FontBBox"),
       new ArrayOp       (true,   6, "BlueValues"),
       new ArrayOp       (true,   7, "OtherBlues"),
       new ArrayOp       (true,   8, "FamilyBlues"),
       new ArrayOp       (true,   9, "FamilyOtherBlues"),
       new NumberOp      (true,  10, "StdHW"),
       new NumberOp      (true,  11, "StdVW"),
       new NumberOp      (true,  13, "UniqueID"),
       new ArrayOp       (true,  14, "XUID"),
       new IntegerOp     (true,  15, "charset"),
       new IntegerOp     (true,  16, "Encoding"),
       new IntegerOp     (true,  17, "CharStrings"),
       new PrivateOp     (true,  18, "Private"),
       new IntegerOp     (true,  19, "Subrs"),
       new NumberOp      (true,  20, "defaultWidthX"),
       new NumberOp      (true,  21, "nominalWidthX"),

       new StringOp      (false,  0, "Copyright"),
       new BooleanOp     (false,  1, "isFixedPitch"),
       new NumberOp      (false,  2, "ItalicAngle"),
       new NumberOp      (false,  3, "UnderlinePosition"),
       new NumberOp      (false,  4, "UnderlineThickness"),
       new NumberOp      (false,  5, "PainType"),
       new NumberOp      (false,  6, "CharstringType"),
       new MatrixOp      (false,  7, "FontMatrix"),
       new NumberOp      (false,  8, "StrokeWidth"),
       new NumberOp      (false,  9, "BlueScale"),
       new NumberOp      (false, 10, "BlueShift"),
       new NumberOp      (false, 11, "BlueFuzz"),
       new ArrayOp       (false, 12, "StemSnapH"),
       new ArrayOp       (false, 13, "StemSnapV"),
       new BooleanOp     (false, 14, "ForceBold"),
       new NumberOp      (false, 17, "LanguageGroup"),
       new NumberOp      (false, 18, "ExpansionFactor"),
       new NumberOp      (false, 19, "initialRandomSeed"),
       new NumberOp      (false, 20, "SyntheticBase"),
       new StringOp      (false, 21, "PostScript"),
       new StringOp      (false, 22, "BaseFontName"),
       new ArrayOp       (false, 23, "BaseFontBlend"),
       new ROSOp         (false, 30, "ROS"),
       new NumberOp      (false, 31, "CIDFontVersion"),
       new NumberOp      (false, 32, "CIDFontRevision"),
       new NumberOp      (false, 33, "CIDFontType"),
       new NumberOp      (false, 34, "CIDCount"),
       new NumberOp      (false, 35, "UIDBase"),
       new IntegerOp     (false, 36, "FDArray"),
       new IntegerOp     (false, 37, "FDSelect"),
       new StringOp      (false, 38, "FontName")};
</code-fragment>

      <para>We represent a DICT as a
        <varname>Map</varname> from operator names to Operator.</para>

      <para>The choice of a <varname>String</varname> for real
        numbers is to avoid introducing errors when round-tripping
        from the binary format to our internal representation, yet
        have something that does not depend on the CFF
        format.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

      <para>First, a couple of methods to manipulate 16 and 32 bit
	signed integers:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Methods to take apart a binary representation</code-title>
  protected int getInt16 (byte[] data, int offset) {
    int b1 = data [offset] &lt;&lt; 8;
    int b2 = getCard8 (data, offset+1);
    return (b1 | b2);
  }

  protected int getInt32 (byte[] data, int offset) {
    int b1 = data [offset]   &lt;&lt; 24;
    int b2 = getCard8 (data, offset+1) &lt;&lt; 16;
    int b3 = getCard8 (data, offset+2) &lt;&lt;  8;
    int b4 = getCard8 (data, offset+3);
    return (b1 | b2 | b3 | b4);
  }
</code-fragment>

      <para>Parsing a dictionnary from an existing font file
        involves pushing the operands on a stack, and entering in
        the map the content of that stack when an operator is found.
        Note that we need to know the size of the DICT, since it is
        not possible to discover it from the dictionnary
        itself.</para>

      <para>If <varname>m</varname> is not null, the key/value pairs
        will be added to that map; otherwise, they are added to a
        newly created map. In both cases, the map is returned.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Load a DICT from binary</code-title>
  public Map&lt;String, Operator> dictFromBinary (Map&lt;String, Operator> m,
                             byte[] data, int offset, int size,
                             String[] strings)
      throws InvalidFontException {

    if (m == null) {
      m = new java.util.HashMap&lt;String, Operator> (); }

    Stack&lt;Object> s = new Stack&lt;Object> ();
    int limit = offset + size;

    while (offset &lt; limit) {
      int b0 = getCard8 (data, offset);
      offset++;
      <code-include linkend='cfffontset.dictFromBinary.integer'/>
      <code-include linkend='cfffontset.dictFromBinary.realnumber'/>
      <code-include linkend='cfffontset.dictFromBinary.operator'/>

      throw new InvalidFontException ("CFF/Dict operand = " + b0); }

    if (s.size () != 0) {
      throw new InvalidFontException ("CFF/Dict stack not empty"); }

    return m;
  }
</code-fragment>

      <para>Here is the parsing of integer operands.</para>

<code-fragment id='cfffontset.dictFromBinary.integer'>
  <code-title>Parse an integer at 'offset'; if ok, advance 'offset' and continue</code-title>
  if (b0 == 28) {
    s.push (new Integer (getInt16 (data, offset)));
    offset += 2;
    continue; }

  if (b0 == 29) {
    s.push (new Integer (getInt32 (data, offset)));
    offset += 4;
    continue; }

  if (32 &lt;= b0 &amp;&amp; b0 &lt;= 246) {
    s.push (new Integer (b0 - 139));
    continue; }

  if (247 &lt;= b0 &amp;&amp; b0 &lt;= 250) {
    int b1 = getCard8 (data, offset);
    offset++;
    s.push (new Integer ((b0 - 247) * 256 + b1 + 108));
    continue; }

  if (251 &lt;= b0 &amp;&amp; b0 &lt;= 254) {
    int b1 = getCard8 (data, offset);
    offset++;
    s.push (new Integer (-(b0 - 251)*256 - b1 - 108));
    continue; }
</code-fragment>

      <para>Here is the parsing of real number operands.</para>

<code-fragment id='cfffontset.dictFromBinary.realnumber'>
  <code-title>Parse a real number at 'offset'; if ok, advance 'offset' and continue</code-title>
  if (b0 == 30) {
    String val = "";
    String[] values = {"0", "1", "2", "3", "4", "5", "6", "7",
                       "8", "9", ".", "E", "E-", "", "-"};
    boolean done = false;

    while (! done) {
      int b = getCard8 (data, offset);
      offset++;
      if (b == 0xff) {
        done = true; }
      else if ((b &amp; 0xf) == 0xf) {
        val += values [b >> 4];
        done = true; }
      else {
        val += values [b >> 4] + values [b &amp; 0xf]; }}

    s.push (val);
    continue; }
</code-fragment>


      <para>And finally, the parsing of operators</para>

<code-fragment id='cfffontset.dictFromBinary.operator'>
  <code-title>Parse an operator at 'offset'; if ok, advance 'offset' and continue</code-title>
  boolean oneByte = true;
  boolean done = false;
  if (b0 == 12) {
    b0 = getCard8 (data, offset);
    offset++;
    oneByte = false; }

  for (int i = 0; i &lt; operators.length; i++) {
    if (   operators [i].oneByte == oneByte
        &amp;&amp; operators [i].code == b0) {
      Operator operator = (Operator) operators [i].clone ();
      operator.fromBinary (s, strings);
      m.put (operator.name, operator);
      done = true;
      break; }}

  if (done) {
    continue; }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>Remember that we need to collect the strings that appear
      in all structures. Here is the handling of dictionnaries:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to collect strings</code-title>
  public void collectStringsInDict (List&lt;String> strings, Map&lt;String, Operator> dict) {
    for (Iterator it = dict.values ().iterator (); it.hasNext (); ) {
      ((Operator) it.next ()).collectStrings (strings); }
  }
</code-fragment>

      <para>Here are a few methods to output numbers:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Method to serialize an integer</code-title>
  private void intToBinary (ByteBuffer bb, int n) {
    if (-107 &lt;= n &amp;&amp; n &lt;= 107) {
      bb.addCard8 (n + 139); }

    else if (108 &lt;= n &amp;&amp; n &lt;= 1131) {
      bb.addCard8 ((n - 108) / 256 + 247);
      bb.addCard8 ((n - 108) % 256); }

    else if (-1131 &lt;= n &amp;&amp; n &lt;= -108) {
      bb.addCard8 ((-108 - n) / 256 + 251);
      bb.addCard8 ((-108 - n) % 256); }

    else if (-32768 &lt;= n &amp;&amp; n &lt;= 32767) {
      bb.addCard8 (28);
      bb.addCard16 (n); }

    else {
      bb.addCard8 (29);
      bb.addCard32 (n); }
  }

  private void floatToBinary (ByteBuffer bb, String val)
       throws InvalidFontException {
    bb.addCard8 (30);
    byte b = 0;
    boolean topNibble = true;
    for (int i = 0; i &lt; val.length (); i++) {
      char c = val.charAt (i);
      switch (c) {
        case '0': b |= (0x0 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '1': b |= (0x1 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '2': b |= (0x2 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '3': b |= (0x3 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '4': b |= (0x4 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '5': b |= (0x5 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '6': b |= (0x6 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '7': b |= (0x7 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '8': b |= (0x8 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '9': b |= (0x9 &lt;&lt; (topNibble ? 4 : 0)); break;
        case '.': b |= (0xa &lt;&lt; (topNibble ? 4 : 0)); break;
        case 'E': b |= (0xb &lt;&lt; (topNibble ? 4 : 0)); break;
        case '-': b |= (0xe &lt;&lt; (topNibble ? 4 : 0)); break;
        default: {
          throw new InvalidFontException ("CFF: invalid float number"); }}
      if (! topNibble) {
        bb.addCard8 (b);
        b = 0; }
      topNibble = ! topNibble; }
    if (topNibble) {
      bb.addCard8 (0xff); }
    else {
      bb.addCard8 (b | 0xf); }
  }

  public void numberToBinary (ByteBuffer bb, Object o)
        throws InvalidFontException {
    if (o instanceof String) {
      String s = (String) o;
      if (s.indexOf ('.') == -1) {
        intToBinary (bb, Integer.parseInt (s)); }
      else {
        floatToBinary (bb, s); }}
    else {
      intToBinary (bb, ((Integer)o).intValue ()); }
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

<code-fragment id='schema'>
   version =                    attribute v { text }
   Notice =			attribute v { text }
   Copyright =			attribute v { text }
   FullName =			attribute v { text }
   FamilyName =			attribute v { text }
   Weight =			attribute v { text }
   isFixedPitch =		attribute v { text }
   ItalicAngle =		attribute v { text }
   UnderlinePosition =		attribute v { text }
   UnderlineThickness =		attribute v { text }
   PaintType =			attribute v { text }
   CharstringType =		attribute v { text }

   FontMatrix  =
       attribute a { text },
       attribute b { text },
       attribute c { text },
       attribute d { text },
       attribute e { text },
       attribute f { text }

   UniqueID =	                attribute v { text }

   FontBBox =
       attribute xmin { text },
       attribute xmax { text },
       attribute ymin { text },
       attribute ymax { text }

   StrokeWidth =		attribute v { text }
   XUID =			attribute v { text }
   PostScript =			attribute v { text }
   BaseFontName =		attribute v { text }
   BaseFontBlend =		attribute v { text }
   BlueValues =			attribute v { text }
   OtherBlues =			attribute v { text }
   FamilyBlues =		attribute v { text }
   FamilyOtherBlues =		attribute v { text }
   BlueScale =			attribute v { text }
   BlueShift =			attribute v { text }
   BlueFuzz =			attribute v { text }
   StdHW =			attribute v { text }
   StdVW =			attribute v { text }
   StemSnapH =			attribute v { text }
   StemSnapV =			attribute v { text }
   ForceBold =			attribute v { text }
   LanguageGroup =		attribute v { text }
   ExpansionFactor =		attribute v { text }
   initialRandomSeed =		attribute v { text }
   defaultWidthX =		attribute v { text }
   nominalWidthX =		attribute v { text }

   ROS =
     attribute registry { text },
     attribute ordering { text },
     attribute supplement { text }

   CIDFontVersion =		attribute v { text }
   CIDFontRevision =	        attribute v { text }
   CIDFontType =		attribute v { text }
   CIDCount =			attribute v { text }
   UIDBase =			attribute v { text }

   SyntheticBase =              attribute v { text }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

      <para>We explicitly control the order in which the elements appear in the
	XML:</para>

<code-fragment id='cfffontset.methods'>
  public void dictToXML (ContentHandlerPlus ch, Map&lt;String, Operator> dict)
      throws org.xml.sax.SAXException {

    String[] keys = {"ROS", "CIDFontVersion", "CIDFontRevision",
                     "CIDFontType", "CIDCount", "UIDBase",

                     "version", "Notice", "Copyright", "FullName",
                     "FamilyName", "Weight", "isFixedPitch", "ItalicAngle",
                     "UnderlinePosition", "UnderlineThickness",
                     "PaintType", "CharstringType", "FontMatrix",
                     "UniqueID", "FontBBox", "StrokeWidth", "XUID",
                     "PostScript", "BaseFontName", "BaseFontBlend",

                     "BlueValues", "OtherBlues", "FamilyBlues",
                     "FamilyOtherBlues", "BlueScale", "BlueShift",
                     "BlueFuzz", "StdHW", "StdVW", "StemSnapH",
                     "StemSnapV", "ForceBold", "LanguageGroup",
                     "ExpansionFactor", "initialRandomSeed",
                     "defaultWidthX", "nominalWidthX"};

    for (int i = 0; i &lt; keys.length; i++) {
      Operator op = (Operator) dict.get (keys [i]);
      if (op != null) {
         op.toXML (ch); }}
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>INDEX Data</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>An INDEX is an array of variable-sized objects. It
        comprises a <emphasis>header</emphasis>, an <emphasis>offset
          array</emphasis>, and <emphasis>object data</emphasis>.
        The offset array specifies offsets within the object data.
        An object is retrieved by indexing the offset array and
        fetching the object at the specified offset. The object's
        length can be determined by subtracting its offset from the
        next offset in the offset array. An additional offset is
        added at the end of the offset array so the length of the
        last object may be determined. The INDEX format is shown in
        Table 7.</para>

      <table>
        <title>INDEX Format</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card16</entry>
              <entry>count</entry>
              <entry>Number of objects stored in INDEX</entry>
            </row>
            <row>
              <entry>OffSize</entry>
              <entry>offSize</entry>
              <entry>Offset array element size</entry>
            </row>
            <row>
              <entry>Offset</entry>
              <entry>offset [count+1]</entry>
              <entry>Offset array (from byte preceding object
                data)</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>data [&lt;varies>]</entry>
              <entry>Object data</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Offsets in the offset array are relative to the byte
        that precedes the object data. Therefore the first element
        of the offset array is always 1. (This ensures that every
        object has a corresponding offset which is always nonzero
        and permits the efficient implementation of dynamic object
        loading.)</para>

      <para>An empty INDEX is represented by a count field with a 0
        value and no additional fields. Thus, the total size of an
        empty INDEX is 2 bytes.</para>

      <para>Note 2 An INDEX may be skipped by jumping to the offset
        specified by the last element of the offset array.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>We do not represent an INDEX by itself.</para>

    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

      <para>Our first method figures out the offset of the byte
        following an INDEX:</para>

<code-fragment id='cfffontset.methods'>
  <code-title>skipINDEX method</code-title>
  private int skipINDEX (byte[] data, int offset)
      throws InvalidFontException {

    try {
      int count = getCard16 (data, offset);
      offset += 2;

      if (count == 0) {
        return offset; }

      int indexOffSize = getCard8 (data, offset);
      offset += 1;

      offset += count * indexOffSize;

      return offset + indexOffSize - 1
              + getOffset (data, offset, indexOffSize); }

    catch (ArrayIndexOutOfBoundsException e) {
      throw new InvalidFontException ("not enough data for CFF INDEX ("
                                      + offset + ")"); }
  }
</code-fragment>

      <para>Our second method parses an INDEX and returns the
        offsets, relative to the beginning of the data buffer. In
        case the INDEX contains no elements, the resulting array has
        a single element. In all cases, the last element contains
        the index in <varname>data</varname> of the first byte
        following the whole INDEX structure. </para>

      <para>We also verify the consistency of the INDEX itself: the
        first offset must be 1, and the successive offsets must not
        decrease.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>getINDEXOffsets method</code-title>
protected int[] getINDEXOffsets (byte[] data, int offset)
    throws InvalidFontException {

  try {
    int count = getCard16 (data, offset);
    offset += 2;

    int[] offsets = new int [count + 1];

    if (count != 0) {
      int indexOffSize = getCard8 (data, offset);
      offset += 1;

      for (int i = 0; i &lt;= count; i++) {
        offsets [i] = getOffset (data, offset, indexOffSize);
        offset += indexOffSize; }}

    else {
      offsets [0] = 1; }

    // check that the offsets are plausible
    if (offsets [0] != 1) {
      throw new InvalidFontException ("offset[0] != 1 in CFF INDEX"); }

    for (int i = 1; i &lt;= count; i++) {
      if (offsets [i] &lt; offsets [i-1]) {
        throw new InvalidFontException ("offsets not increasing in CFF INDEX"); }}

    // make the offsets relative to the beginning of the CFF table
    for (int i = 0; i &lt;= count; i++) {
      offsets [i] += offset - 1; }

    return offsets; }

   catch (ArrayIndexOutOfBoundsException e) {
     throw new InvalidFontException ("not enough data for CFF INDEX"); }
}
</code-fragment>

      <para>Here is a method to compute the minimum OffSize. Given
        the total size of the data to be assembled in an INDEX, this
        method computes the smallest offset size that can be used. If
        the data is too big, the exception InvalidFontException is
        thrown.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>findCFFOffsetSize method</code-title>
  private int findCFFOffsetSize (int datasize)
      throws InvalidFontException {

    if (datasize &lt; 0xff) {
      return 1; }
    else if (datasize &lt; 0xffff) {
      return 2; }
    else if (datasize &lt; 0xffffff) {
      return 3; }
    else if (datasize &lt; 0xffffffffL) {
      return 4; }
    else {
      throw new InvalidFontException ("data too big for INDEX ("
                                       + datasize + ")"); }
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>There is a chicken and egg problem if we try to use the
	optimal size for offsets: we need to know the size and
	position of all the pointed objects; but those in turn depend
	on the offset size. The only sure way to achieve that would be
	to try each size 1, 2, 3, 4 in turn, until a valid one is
	found. This would involve a fair amount of complication and
	buffering. Instead, we observe that most indices will either
	have a small number of entries (in which case, not much is
	saved by selecting a larger than necessary offset size), or be
	fairly large (thus requiring a large offset size). This allows
	us to always use 4 bytes offsets, considerably simplifying the
	code.</para>

      <para>Our strategy is to fill the index as elements are entered
	into it. We first call the <varname>startIndex</varname>
	method to reserve space for all the offsets; then, after each
	element is created, we call the
	<varname>elementEntered</varname> method to update the
	appropriate offset.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>INDEXToBinary</code-title>
  public class IndexCursor {
    int cursor;
    int base;
  }

  protected IndexCursor startIndex (ByteBuffer bb, int n) {
    if (n == 0) {
      bb.addCard16 (0);
      return null; }

    bb.addCard16 (n);
    bb.addCard8 (4);

    bb.addOffset (1);

    IndexCursor cursor = new IndexCursor ();
    cursor.cursor = bb.length ();

    for (int i = 0; i &lt; n; i++) {
      bb.addOffset (1); }

    cursor.base = bb.length () - 1;
    return cursor;
  }

  private IndexCursor elementEntered (ByteBuffer bb, IndexCursor cursor) {
    bb.fixOffset (cursor.cursor, bb.length () - cursor.base);
    cursor.cursor += 4;
    return cursor;
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Header</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>The binary data begins with a header having the format
        shown in Table 8.</para>

      <table>
        <title>Header Format</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>major</entry>
              <entry>Format major version (starting at 1)</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>minor</entry>
              <entry>Format minor version (starting at 0)</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>hdrSize</entry>
              <entry>Header size (bytes)</entry>
            </row>
            <row>
              <entry>OffSize</entry>
              <entry>offSize</entry>
              <entry>Absolute offset (0) size</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Implementations reading font set files must include code
        to check version numbers so that if and when the format and
        therefore the version number changes, older implementations
        will reject newer versions gracefully. If the major version
        number is understood by an implementation it can safely
        proceed with reading the font. The minor version number
        indicates extensions to the format that are undetectable by
        implementations that do not support them although they will
        be unable to take advantage of these extensions.</para>

      <para>The hdrSize field must be used when locating the Name
        INDEX. It is provided so that future versions of the format
        may introduce additional data between the offSize field and
        the Name INDEX in a manner that is compatible with older
        implementations.</para>

      <para>The offSize field specifies the size of all offsets (0)
        relative to the start of CFF data.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>It seems that the OffSize value is not used anywhere.
        All the offsets are either in INDEX structures, in which
        case the INDEX structure also provides the size of the
        offsets, or in DICT structures, in which case offsets are
        represented as DICT operands. The specification could note
        that this field was used in earlier versions, and may be
        used in future versions, but is useless in this
        version.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>CFFHeader class</code-title>
  public class CFFHeader {
    protected int major;
    protected int minor;

    <code-include linkend='cffheader.methods'/>
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

<code-fragment id='cffheader.methods'>
  <code-title>CFFHeader.fromBinary</code-title>
    public int fromBinary (byte[] data, int offset)
        throws InvalidFontException {

      major = getCard8 (data, offset);
      minor = getCard8 (data, offset + 1);
      int hdrSize = getCard8 (data, offset + 2);

      if (major != 1) {
        throw new InvalidFontException ("Unsupported major version: " + major); }

      return offset + hdrSize;
    }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

<code-fragment id='cffheader.methods'>
  <code-title>CFFHeader.toBinary</code-title>
    public void toBinary (ByteBuffer bb) {
      bb.addCard8 (major);
      bb.addCard8 (minor);
      bb.addCard8 (4);
      bb.addCard8 (4);  // offSize, not used?
    }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

<code-fragment id='schema'>
  header =
    attribute major { text },
    attribute minor { text }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
      <title>Compiler</title>

<code-fragment id='cffheader.methods'>
  <code-title>CFFHeader.fromXML</code-title>
    public void fromXML (Element e) {
      major = Integer.decode (e.getAttribute ("major")).intValue ();
      minor = Integer.decode (e.getAttribute ("minor")).intValue ();
    }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

<code-fragment id='cffheader.methods'>
  <code-title>CFFHeader.toXML</code-title>
    public Attributes toXML () {
      AttributesImpl at
         = new AttributesImpl ();
      at.addAttribute ("", "major", "major", "CDATA", "" + major);
      at.addAttribute ("", "minor", "minor", "CDATA", "" + minor);
      return at;
    }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Name INDEX</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>This contains the PostScript language names (FontName or
        CIDFontName) of all the fonts in the FontSet stored in an
        INDEX structure. The font names are sorted, thereby
        permitting a binary search to be performed when locating a
        specific font within a FontSet. The sort order is based on
        character codes treated as 8-bit unsigned integers. A given
        font name precedes another font name having the first name
        as its prefix. There must be at least one entry in this
        INDEX, i.e. the FontSet must contain at least one
        font.</para>

      <para>For compatibility with client software, such as
        PostScript interpreters and Acrobat&#xae;, font names should
        be no longer than 127 characters and should not contain any
        of the following ASCII characters: [, ], (, ), {, }, &lt;,
        >, /, %, null (NUL), space, tab, carriage return, line
        feed, form feed. It is recommended that font names be
        restricted to the printable ASCII subset, codes 33 through
        126. Adobe Type Manager&#xae; (ATM&#xae;) software imposes a
        further restriction on the font name length of 63
        characters.</para>

      <para>Note 3 For compatibility with earlier PostScript
        interpreters, see Technical Note #5088, &#x201c;Font Naming
        Issues.&#x201d;</para>

      <para>A font may be deleted from a FontSet without removing
        its data by setting the first byte of its name in the Name
        INDEX to 0 (NUL). This kind of deletion offers a simple way
        to handle font upgrades without rebuilding entire fontsets.
        Binary search software must detect deletions and restart the
        search at the previous or next name in the INDEX to ensure
        that all appropriate names are matched.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>The specification does not unambiguously impose that the
        names are made of ASCII characters, encoded using ASCII,
        although that seems to be the case.</para>

      <para>The specification does not unambiguously state if the
        names stored in the Name INDEX must be equal to some entry
        in the corresponding Top DICT.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Our internal representation of the Names will actually
        be folded away, so we do not represent it explicitly.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

<code-fragment id='cfffontset.methods'>
  <code-title>namesFromBinary</code-title>
  public String[] namesFromBinary (byte[] data, int offset)
      throws InvalidFontException {
    int[] stringOffsets = getINDEXOffsets (data, offset);
    String[] strings = new String [stringOffsets.length - 1];

    try {
      for (int i = 0; i &lt; strings.length; i++) {
        strings [i] = new String (data,
                                  stringOffsets [i],
                                  stringOffsets [i+1] - stringOffsets [i],
                                  "ASCII"); }}

    catch (java.io.UnsupportedEncodingException e) {
      System.err.println ("What? ASCII is not supported?");
      e.printStackTrace ();
      System.exit (1); }

    return strings;
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Top DICT INDEX</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>This contains the top-level DICTs of all the fonts in
        the FontSet stored in an INDEX structure. Objects contained
        within this INDEX correspond to those in the Name INDEX in
        both order and number. Each object is a DICT structure that
        corresponds to the top-level dictionary of a PostScript
        font.</para>
      <para>A font is identified by an entry in the Name INDEX and
        its data is accessed via the corresponding Top DICT.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Our internal representation of the Top DICTS will actually
        be folded away, so we do not represent them explicitly.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

      <para>Parsing the Top DICT INDEX returns an array of
        <varname>Map</varname>, each one representing a dictionary.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>Parse the Top DICT INDEX at 'offset' using 'strings'</code-title>
  private Map[] dictsFromBinary (byte[] data, int offset, String[] strings)
        throws InvalidFontException {
    int[] dictOffsets = getINDEXOffsets (data, offset);
    Map[] dicts = new Map [dictOffsets.length - 1];

    for (int i = 0; i &lt; dictOffsets.length - 1; i++) {
      dicts [i] = dictFromBinary (null,
                                  data,
                                  dictOffsets [i],
                                  dictOffsets [i+1] - dictOffsets [i],
                                  strings); }

    return dicts;
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Top DICT Data</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>The names of the Top DICT operators shown in Table 9
        are, where possible, the same as the corresponding Type 1
        dict key. Operators that have no corresponding Type 1 dict
        key are noted in the table below along with a default value,
        if any. (Several operators have been derived from FontInfo
        dict keys but have been grouped together with the Top DICT
        operators for simplicity. The keys from the FontInfo dict
        are indicated in the Default,notes column of Table
        9.)</para>

      <table>
        <title>Top DICT Operator Entries</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='3pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='12pc'/>
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Value</entry>
              <entry>Operand(s)</entry>
              <entry>Default, notes</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>version</entry>
              <entry>0</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FontInfo</entry>
            </row>
            <row>
              <entry>Notice</entry>
              <entry>1</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FontInfo</entry>
            </row>
            <row>
              <entry>Copyright</entry>
              <entry>12 0</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FontInfo</entry>
            </row>
            <row>
              <entry>FullName</entry>
              <entry>2</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FontInfo</entry>
            </row>
            <row>
              <entry>FamilyName</entry>
              <entry>3</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FontInfo</entry>
            </row>
            <row>
              <entry>Weight</entry>
              <entry>4</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FontInfo</entry>
            </row>
            <row>
              <entry>isFixedPitch</entry>
              <entry>12 1</entry>
              <entry>boolean</entry>
              <entry>0 (false), FontInfo</entry>
            </row>
            <row>
              <entry>ItalicAngle</entry>
              <entry>12 2</entry>
              <entry>number</entry>
              <entry>0, FontInfo</entry>
            </row>
            <row>
              <entry>UnderlinePosition</entry>
              <entry>12 3</entry>
              <entry>number</entry>
              <entry>&#x2013;100, FontInfo</entry>
            </row>
            <row>
              <entry>UnderlineThickness</entry>
              <entry>12 4</entry>
              <entry>number</entry>
              <entry>50, FontInfo</entry>
            </row>
            <row>
              <entry>PaintType</entry>
              <entry>12 5</entry>
              <entry>number</entry>
              <entry>0</entry>
            </row>
            <row>
              <entry>CharstringType</entry>
              <entry>12 6</entry>
              <entry>number</entry>
              <entry>2</entry>
            </row>
            <row>
              <entry>FontMatrix</entry>
              <entry>12 7</entry>
              <entry>array</entry>
              <entry>0.001 0 0 0.001 0 0</entry>
            </row>
            <row>
              <entry>UniqueID</entry>
              <entry>13</entry>
              <entry>number</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>FontBBox</entry>
              <entry>5</entry>
              <entry>array</entry>
              <entry>0 0 0 0</entry>
            </row>
            <row>
              <entry>StrokeWidth</entry>
              <entry>12 8</entry>
              <entry>number</entry>
              <entry>0</entry>
            </row>
            <row>
              <entry>XUID</entry>
              <entry>14</entry>
              <entry>array</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>charset</entry>
              <entry>15</entry>
              <entry>number</entry>
              <entry>0, charset offset (0)</entry>
            </row>
            <row>
              <entry>Encoding</entry>
              <entry>16</entry>
              <entry>number</entry>
              <entry>0, encoding offset (0)</entry>
            </row>
            <row>
              <entry>CharStrings</entry>
              <entry>17</entry>
              <entry>number</entry>
              <entry>&#x2013;, CharStrings offset (0)</entry>
            </row>
            <row>
              <entry>Private</entry>
              <entry>18</entry>
              <entry>number number</entry>
              <entry>&#x2013;, Private DICT size and offset (0)</entry>
            </row>
            <row>
              <entry>SyntheticBase</entry>
              <entry>12 20</entry>
              <entry>number</entry>
              <entry>&#x2013;, synthetic base font index</entry>
            </row>
            <row>
              <entry>PostScript</entry>
              <entry>12 21</entry>
              <entry>SID</entry>
              <entry>&#x2013;, embedded PostScript language code</entry>
            </row>
            <row>
              <entry>BaseFontName</entry>
              <entry>12 22</entry>
              <entry>SID</entry>
              <entry>&#x2013;, (added as needed by Adobe-based technology)</entry>
            </row>
            <row>
              <entry>BaseFontBlend</entry>
              <entry>12 23</entry>
              <entry>delta</entry>
              <entry>&#x2013;, (added as needed by Adobe-based technology)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The embeddedPostScript operator provides an escape
        mechanism that may be used to address extensibility or
        compatibility issues in a printer font (see Appendix
        F).</para>

      <para>The separation of dictionary data into top-level and
        Private dictionaries reflects Type 1 usage where Top DICT
        data is parsed at findfont time and used to construct a
        valid Type 1 font dictionary. The Private operator value
        specifies a size and an offset that is followed at font
        rendering time in order to construct the data structures
        associated with Private DICT data.</para>

      <para>The operators BaseFontName and BaseFontBlend are added
        to multiple master font instances embedded in PDF documents.
        BaseFontName is the FontName of the original multiple master
        font and BaseFontBlend is the User Design Vector used to
        compute the instance.</para>

      <para>CIDFonts require the additional Top DICT operators shown
        in Table 10</para>

      <table>
        <title>CIDFont Operator Extensions</title>

        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='3pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='12pc'/>
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Value</entry>
              <entry>Operand(s)</entry>
              <entry>Default, notes</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>ROS</entry>
              <entry>12 30</entry>
              <entry>SID SID number</entry>
              <entry>&#x2013;, Registry Ordering Supplement</entry>
            </row>
            <row>
              <entry>CIDFontVersion</entry>
              <entry>12 31</entry>
              <entry>number</entry>
              <entry>0</entry>
            </row>
            <row>
              <entry>CIDFontRevision</entry>
              <entry>12 32</entry>
              <entry>number</entry>
              <entry>0</entry>
            </row>
            <row>
              <entry>CIDFontType</entry>
              <entry>12 33</entry>
              <entry>number</entry>
              <entry>0</entry>
            </row>
            <row>
              <entry>CIDCount</entry>
              <entry>12 34</entry>
              <entry>number</entry>
              <entry>8720</entry>
            </row>
            <row>
              <entry>UIDBase</entry>
              <entry>12 35</entry>
              <entry>number</entry>
              <entry>&#x2013;</entry>
            </row>
            <row>
              <entry>FDArray</entry>
              <entry>12 36</entry>
              <entry>number</entry>
              <entry>&#x2013;, Font DICT (FD) INDEX offset (0)</entry>
            </row>
            <row>
              <entry>FDSelect</entry>
              <entry>12 37</entry>
              <entry>number</entry>
              <entry>&#x2013;, FDSelect offset (0)</entry>
            </row>
            <row>
              <entry>FontName</entry>
              <entry>12 38</entry>
              <entry>SID</entry>
              <entry>&#x2013;, FD FontName</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The ROS operator combines the Registry, Ordering, and
        Supplement keys together. CIDFonts are described fully in
        section 18.</para>

      <para>The Top DICT begins with the SyntheticBase and ROS
        operators for synthetic and CIDFonts, respectively. Regular
        Type 1 fonts begin with some other operator. (This permits
        the determination of the kind of font without parsing the
        entire Top DICT.)</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>Following the recommendation in section 2, this section
        should be targeted at the description of name-keyed
        fonts only. The part about CID-keyed font would be moved to
        section 18.</para>

      <para>The legal operators in the TopDict of a named-keyed font are:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='15pc'/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Required</entry>
              <entry>Default</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>version</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Notice</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Copyright</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FullName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FamilyName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Weight</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>isFixedPitch</entry>
              <entry>N</entry>
              <entry>0 (false)</entry>
              <entry></entry>
            </row>
            <row>
              <entry>ItalicAngle</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UnderlinePosition</entry>
              <entry>N</entry>
              <entry>-100</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UnderlineThickness</entry>
              <entry>N</entry>
              <entry>50</entry>
              <entry></entry>
            </row>
            <row>
              <entry>PaintType</entry>
              <entry>N</entry>
              <entry>2</entry>
              <entry></entry>
            </row>
            <row>
              <entry>CharstringType</entry>
              <entry>N</entry>
              <entry>2</entry>
              <entry></entry>
            </row>
            <row>
              <entry>FontMatrix</entry>
              <entry>N</entry>
              <entry>0.001 0 0 0.001 0 0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UniqueID</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FontBBox</entry>
              <entry>N</entry>
              <entry>0 0 0 0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>StrokeWidth</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>XUID</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>charset</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry>maps GIDs to SIDs</entry>
            </row>
            <row>
              <entry>Encoding</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>CharStrings</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Private</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry>Private must point to a DICT, but that DICT can
                be empty</entry>
            </row>
            <row>
              <entry>PostScript</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>BaseFontName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>BaseFontBlend</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>It is unclear if the FullName and FamilyName are
	required. Similarly for the Encoding.</para>


      <para>Note that some software does not seem to like UniqueID
	that are encoded as float.</para>

      <para>The legal operators in a Private DICT (pointed by Private in a
        Top DICT) are:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='15pc'/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Required</entry>
              <entry>Default</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>BlueValues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>OtherBlues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry>if present, BlueValues must be present, and
                OtherBlues must occur after BlueValues</entry>
            </row>
            <row>
              <entry>FamilyBlues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FamilyOtherBlues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry>if present, FamiliyBlues must be present, and
                FamilyOtherBlues must occur after FamilyBlues</entry>
            </row>
            <row>
              <entry>BlueScale</entry>
              <entry>N</entry>
              <entry>0.039625</entry>
              <entry></entry>
            </row>
            <row>
              <entry>BlueShift</entry>
              <entry>N</entry>
              <entry>7</entry>
              <entry></entry>
            </row>
            <row>
              <entry>BlueFuzz</entry>
              <entry>N</entry>
              <entry>1</entry>
              <entry></entry>
            </row>
            <row>
              <entry>StdHW</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>StdVW</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>StemSnapH</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>StemSnapV</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>ForceBold</entry>
              <entry>N</entry>
              <entry>0 (false)</entry>
              <entry></entry>
            </row>
            <row>
              <entry>LanguageGroup</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>ExpansionFactor</entry>
              <entry>N</entry>
              <entry>0.06</entry>
              <entry></entry>
            </row>
            <row>
              <entry>initialRandomSeed</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>Subrs</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>defaultWidthX</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>nominalWidthX</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>At this point, one could observe that the set of
        operators of the Top and Private DICT are entirely disjoint,
        and that the separation between the two is fairly arbitrary;
        it may be nice to interact with existing software, but it is
        irrelevant for the understanding of a font.</para>

      <para>Another drawback of the current form of the
        specification is that it assumes a complete knowledge of the
        Type1 model, and a fair amount of smartness on the part of
        the reader to know what to take and what to leave out from
        the "Type1 specifcation" and the "Type1 Supplement". I am
        not sure how much this should or can be remedied, but it
        would be nice to have some indication, if not a full
        specification, of the meaning and intended use of the
        operators.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Following our recommendation in section 2, here is the
        class that represents a name-keyed font:</para>

<code-fragment id='cfffontset.innerclasses'>
  public class CFFNameKeyedFont implements CFFFont {
    <code-include linkend='cffnamekeyedfont.members'/>
    <code-include linkend='cffnamekeyedfont.methods'/>
}
</code-fragment>

      <para>Here is the internal representation of name-keyed font:
        <itemizedlist>
          <listitem>
            <para><varname>name</varname> contains the font name (from the Name
	      INDEX).</para>
          </listitem>
          <listitem>
            <para><varname>dict</varname> contains the combination of
            the Top DICT and the Private DICT.</para>
          </listitem>
          <listitem>
            <para><varname>glyphNames</varname> contains the names of
	      the glyphs, extracted from the charset structure pointed
	      by the charset operator in the Top DICT.</para>
          </listitem>
          <listitem>
            <para><varname>encoding</varname> contains the mapping
	      from code points to glyph IDs, as found in the encoding
	      structure pointed by the Encoding operator in the Top
	      DICT.</para>
          </listitem>
          <listitem>
            <para><varname>charstrings</varname> contains the
	      charstrings of the glyphs, as found in the structure
	      pointed by the CharStrings operator in the Top
	      DICT.</para>
          </listitem>
          <listitem>
            <para><varname>localSubrs</varname> contains the
	      charstrings of the local subroutines, as found in the
	      structure pointed by the Subrs operator in the Private
	      DICT.</para>
          </listitem>
        </itemizedlist></para>

      <para>In <varname>dict</varname>, the entries for charset,
        Encoding, CharStrings, Private and Subrs are
        irrelevant.</para>

<code-fragment id='cffnamekeyedfont.members'>
  <code-title>CFFNameKeyedFont members</code-title>
  protected String         name;
  protected Map&lt;String, Operator>            dict;

  protected int[]          encoding;
  protected String[]       glyphNames;
  CFFCharStrings           charstrings;
  CFFCharStrings           localSubrs;
</code-fragment>

      <para>Here are the implementation of the methods that
        answer questions about the font:</para>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>Useful methods!</code-title>
  public String getName () {
    return name;
  }

  public String getGlyphName (int gid) {
    if (gid &lt; 0 || glyphNames.length &lt;= gid) {
      return "&lt;virtual>"; }
    return glyphNames [gid];
  }

  public void getGlyphOutline (int gid, StringBuilder sb) {
    Type22Pdf c = new Type22Pdf (sb, 0d, 0d);
    Type2Interpreter i = new Type2Interpreter ();
    i.decode (charstrings.charstrings [gid],
 	      localSubrs != null ? localSubrs.charstrings : null,
	      globalSubrs != null ? globalSubrs.charstrings : null,
	      c);
  }


  class X extends Type2LinesAndCurves {

    protected StringBuilder sb;

    public X (StringBuilder sb) {
      this.sb = sb;
    }

    public void line (double x1, double y1, double x2, double y2) {
      sb.append ("line from " + x1 + ", " + y1 + " to " +
	               + x2 + ", " + y2 + "\n");
    }

    public void curve (double x1, double y1, double x2, double y2,
               double x3, double y3, double x4, double y4) {

      sb.append ("curve " + x1 + "," + y1 + "  " +
	               + x2 + "," + y2 + "  "
	               + x3 + "," + y3 + "  "
	               + x4 + "," + y4 + "\n");
    }
  }

  public void getGlyphLinesAndCurves (int gid, StringBuilder sb) {
    Type2Consumer c = new X (sb);
    Type2Interpreter i = new Type2Interpreter ();
    i.decode (charstrings.charstrings [gid],
 	      localSubrs != null ? localSubrs.charstrings : null,
	      globalSubrs != null ? globalSubrs.charstrings : null,
	      c);
  }

  public BoundingBox getGlyphBoundingBox (int gid) {
    Type2BoundingBox c = new Type2BoundingBox ();
    Type2Interpreter i = new Type2Interpreter ();
    i.decode (charstrings.charstrings [gid],
 	      localSubrs != null ? localSubrs.charstrings : null,
	      globalSubrs != null ? globalSubrs.charstrings : null,
	      c);
    return c.bb;
  }

  public int getGlyphID (String glyphname) {
    for (int i = 0; i &lt; glyphNames.length; i++) {
      if (glyphname.equals (glyphNames [i])) {
        return i; }}
    return 0;
  }
</code-fragment>


      <para>Converting to a CID-keyed version is mostly
	straightforward. The main difficulty is that we need to split
	the 'dict' into two parts: remember that 'dict' represents
	both the TOPDict and the PrivateDict, while for CID-keyed
	fonts, we keep the two separate.</para>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>Method to convert to CID</code-title>
  public Operator insertOp (String name, Map&lt;String, Operator> dict) {
    for (int i = 0; i &lt; operators.length; i++) {
      if (name.equals (operators [i].name)) {
        Operator operator = (Operator) operators [i].clone ();
        dict.put (operator.name, operator);
        return operator; }}
    return null;
  }

  public CFFFont toCID () {
    CFFCIDKeyedFont result = new CFFCIDKeyedFont ();

    result.name = name;

    result.cids = new int [charstrings.numGlyphs ()];
    for (int i = 0; i &lt; result.cids.length; i++) {
      result.cids [i] = i; }

    result.fdselect = new int [1][3];
    result.fdselect [0][0] = 0;
    result.fdselect [0][1] = charstrings.numGlyphs () - 1;
    result.fdselect [0][2] = 0;

    result.charstrings = charstrings;

    result.components = new CFFCIDComponentFont [1];
    result.components [0] = new CFFCIDComponentFont ();
    result.components [0].name = "component0";

    result.components [0].localSubrs = localSubrs;


    result.dict = dict;

    { ROSOp op = (ROSOp) insertOp ("ROS", result.dict);
      op.registry = "Adobe";
      op.ordering = "Identity";
      op.supplement = new Integer (0); }

    { NumberOp op = (NumberOp) insertOp ("CIDCount", dict);
      op.value = new Integer (charstrings.numGlyphs ()); }

    result.components [0].dict = new java.util.HashMap&lt;String, Operator> ();
    String[] privateKeys = {"BlueValues", "OtherBlues", "FamilyBlues",
                          "FamilyOtherBlues", "BlueScale", "BlueShift",
                          "BlueFuzz", "StdHW", "StdVW", "StemSnapH",
                          "StemSnapV", "ForceBold", "LanguageGroup",
                          "ExpansionFactor", "initialRandomSeed",
                          "defaultWidthX", "nominalWidthX"};
    for (int i = 0; i &lt; privateKeys.length; i++) {
      Operator op = result.dict.get (privateKeys [i]);
      if (op != null) {
        result.components [0].dict.put (privateKeys [i], op);
        result.dict.remove (op); }}

    return result;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

      <para>Here is our <varname>fromBinary</varname> method, which is
        given the topDICT and further explores the data from there to
        fill our internal representation:</para>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>fromBinary method</code-title>
  public void fromBinary (byte[] data,
                          String name,
                          Map&lt;String, Operator> topDICT,
                          String[] strings)
      throws InvalidFontException {

    this.name = name;
    this.dict = topDICT;

    { IntegerOp o = (IntegerOp) dict.get ("CharStrings");
      if (o == null) {
        throw new InvalidFontException ("missing TopDICT/CharStrings"); }
      charstrings = new CFFCharStrings ();
      charstrings.fromBinary (data, o.value); }


    { int numGlyphs = charstrings.numGlyphs ();
      IntegerOp o = (IntegerOp) dict.get ("charset");
      int offset = 0;
      if (o != null) {
        offset = o.value; }
      glyphNames = nameCharsetFromBinary (data, offset, numGlyphs, strings); }

    { IntegerOp o = (IntegerOp) dict.get ("Encoding");
      int offset = 0;
      if (o != null) {
        offset = o.value; }
      encoding = encodingFromBinary (data, offset, strings); }

    { PrivateOp o = (PrivateOp) dict.get ("Private");
      if (o != null) {
        dict = dictFromBinary (dict, data, o.offset, o.size, strings);

        IntegerOp o2 = (IntegerOp) dict.get ("Subrs");
        if (o2 != null) {
          localSubrs = new CFFCharStrings ();
          localSubrs.fromBinary (data, o.offset + o2.value); }}}
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>We have a little bit of a catch-22 here, since Top DICTs
      (which are part of the first five components of a CFF FontSet)
      point to other data structures such as Private DICTs. To figure
      out the content of the Top DICTs, we need to figure out the
      position of the structures they point to, which depend on the
      size of the Top DICTs; and computing the later is about as
      complicated as computing the content of the Top DICTs!</para>

      <para>Our strategy is as follow:
        <itemizedlist>
          <listitem>
            <para>first, we compute the content of the TopDICTs, using
              dummy values for the pointers and remembering where
              those dummy values are. This gives us the size and most
              of the content of the Top DICTs.</para>
          </listitem>
          <listitem>
            <para>when it is time to output the pointed structures, we
            then know where they are, and can do back to fix the
            TopDICTs.</para>
          </listitem>
        </itemizedlist></para>

      <para>The following member only serve to remember where the
	dummy values are between the first and the second phase:</para>

<code-fragment id='cffnamekeyedfont.members'>
  <code-title>Remembering offsets locations</code-title>
  private OffsetOp charsetOp = null;
  private OffsetOp encodingOp = null;
  private OffsetOp charstringsOp = null;
  private PrivateOp privateOp = null;
</code-fragment>

      <para>There is one last wrinkle: the pointers are numbers, and
        their values could affect their sizes, in turn affecting how
        big a Top DICT is, in turn affecting the value of the
        pointers. To break that cycle, we always use the 4 byte
        representation for those numbers, so that we can compute the size of
        the Top DICT before we know the position of the pointed
        structures.</para>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>Methods to convert to binary</code-title>
  public void collectStrings (List&lt;String> strings) {

    for (int i = 0; i &lt; glyphNames.length; i++) {
      if (strings.indexOf (glyphNames [i]) == -1) {
        strings.add (glyphNames [i]); }}

    collectStringsInDict (strings, dict);
  }

  public void topDictToBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {

    String[] topKeys = {"version", "Notice", "Copyright", "FullName",
                       "FamilyName", "Weight", "isFixedPitch", "ItalicAngle",
                      "UnderlinePosition", "UnderlineThickness",
                      "PaintType", "CharstringType", "FontMatrix",
                      "FontBBox", "UniqueID", "StrokeWidth", "XUID",
                      "PostScript", "BaseFontName", "BaseFontBlend"};

    for (int i = 0; i &lt; topKeys.length; i++) {
      Operator op = (Operator) dict.get (topKeys [i]);
      if (op != null) {
         op.toBinary (bb, strings); }}

    charsetOp = null;
    { int n = isPredefinedCharset (glyphNames);
      if (n != 0) {
        if (n > 0) {
          IntegerOp op = new IntegerOp (true, 15, "charset");
          op.value = n;
          op.toBinary (bb, strings); }
        else {
          charsetOp = new OffsetOp (true, 15, "charset");
          charsetOp.toBinary (bb, strings); }}}

    encodingOp = null;
    { int n = 0;
      if (encoding != null) {
        n = isPredefinedEncoding (encoding, glyphNames); }

      if (n > 0) {
        IntegerOp op = new IntegerOp (true, 16, "Encoding");
        op.value = n;
        op.toBinary (bb, strings); }
      else if (n &lt; 0) {
        encodingOp = new OffsetOp (true, 16, "Encoding");
        encodingOp.toBinary (bb, strings); }}

    charstringsOp = new OffsetOp (true, 17, "CharStrings");
    charstringsOp.toBinary (bb, strings);

    privateOp = new PrivateOp (true, 18, "Private");
    privateOp.toBinary (bb, strings);
  }

  public void restToBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {

    if (charsetOp != null) {
      charsetOp.fixOffset (bb, bb.length ());
      charsetToBinary (bb, glyphNames, strings); }

    if (encodingOp != null) {
      encodingOp.fixOffset (bb, bb.length ());
      encodingToBinary (bb, encoding, glyphNames); }

    charstringsOp.fixOffset (bb, bb.length ());
    charstrings.toBinary (bb);

    privateOp.fixOffset (bb, bb.length ());

    int privateStart = bb.length ();

    String[] privateKeys = {"BlueValues", "OtherBlues", "FamilyBlues",
                          "FamilyOtherBlues", "BlueScale", "BlueShift",
                          "BlueFuzz", "StdHW", "StdVW", "StemSnapH",
                          "StemSnapV", "ForceBold", "LanguageGroup",
                          "ExpansionFactor", "initialRandomSeed",
                          "defaultWidthX", "nominalWidthX"};

    for (int i = 0; i &lt; privateKeys.length; i++) {
      Operator op = (Operator) dict.get (privateKeys [i]);
      if (op != null) {
        op.toBinary (bb, strings); }}

    if (localSubrs != null) {
      OffsetOp subrsOp = new OffsetOp (true, 19, "Subrs");
      subrsOp.toBinary (bb, strings);
      subrsOp.fixOffset (bb, bb.length () - privateStart); }

    privateOp.fixSize (bb, bb.length () - privateStart);

    if (localSubrs != null) {
      localSubrs.toBinary (bb); }
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

<code-fragment id='schema'>
name-keyed-font =
  attribute name { text },

  element version { version }?,
  element Notice  { Notice }?,
  element Copyright { Copyright }?,
  element FullName { FullName }?,
  element FamilyName { FamilyName }?,
  element Weight { Weight }?,
  element isFixedPitch { isFixedPitch }?,
  element ItalicAngle { ItalicAngle }?,
  element UnderlinePosition { UnderlinePosition }?,
  element UnderlineThickness { UnderlineThickness }?,
  element PaintType { PaintType }?,
  element CharstringType { CharstringType }?,
  element FontMatrix { FontMatrix }?,
  element UniqueID { UniqueID }?,
  element FontBBox { FontBBox }?,
  element StrokeWidth { StrokeWidth }?,
  element XUID { XUID }?,
  element PostScript { PostScript }?,
  element BaseFontName { BaseFontName }?,
  element BaseFontBlend { BaseFontBlend }?,

  element BlueValues { BlueValues }?,
  element OtherBlues { OtherBlues }?,
  element FamilyBlues { FamilyBlues }?,
  element FamilyOtherBlues { FamilyOtherBlues }?,
  element BlueScale { BlueScale }?,
  element BlueShift { BlueShift }?,
  element BlueFuzz { BlueFuzz }?,
  element StdHW { StdHW }?,
  element StdVW { StdVW }?,
  element StemSnapH { StemSnapH }?,
  element StemSnapV { StemSnapV }?,
  element ForceBold { ForceBold }?,
  element LanguageGroup { LanguageGroup }?,
  element ExpansionFactor { ExpansionFactor }?,
  element initialRandomSeed { initialRandomSeed }?,
  element defaultWidthX { defaultWidthX }?,
  element nominalWidthX { nominalWidthX }?,

  element encoding { encoding }?,
  element charstrings { charstrings },
  element localSubrs { localSubrs }?
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
      <title>Compiler</title>

<code-fragment id='cffnamekeyedfont.methods'>
  public void fromXML (Element nameKeyedFont)
      throws InvalidFontException {
    name = nameKeyedFont.getAttribute ("name");

    dict = new java.util.HashMap&lt;String, Operator> ();

    NodeList nl =  nameKeyedFont.getChildNodes ();
    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element e = (Element) nl.item (i);

      if ("encoding".equals (e.getTagName ())) {
        encodingFromXML (e); }
      else if ("charstrings".equals (e.getTagName ())) {
        charstrings = new CFFCharStrings ();
        glyphNames = charstrings.fromXMLNames (e); }
      else if ("localSubrs".equals (e.getTagName ())) {
        localSubrs = new CFFCharStrings ();
        localSubrs.fromXML (e); }
      else {
        for (int j = 0; j &lt; operators.length; j++) {
          if ((operators [j].name).equals (e.getTagName ())) {
            Operator operator = (Operator) operators [j].clone ();
            operator.fromXML (e);
            dict.put (operator.name, operator);
            break; }}}}
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>Method to output to XML</code-title>
  public void toXML (com.adobe.aots.util.ContentHandlerPlus ch,
                     Type2Font2XML t2Processor)
      throws org.xml.sax.SAXException {

    charstrings.initSbs ();
    if (localSubrs != null) {
      localSubrs.initSbs (); }

    for (int gid = 0; gid &lt; charstrings.numGlyphs (); gid++) {
      t2Processor.decompileCharstring (charstrings, gid,
                                       localSubrs, globalSubrs); }

    AttributesImpl at;
    at = new AttributesImpl ();
    at.addAttribute ("", "name", "name", "CDATA", "" + name);

    ch.startElement ("name-keyed-font", at); {
      dictToXML (ch, dict);
      encodingToXML (ch, encoding);
      charstrings.toXML (ch, "charstrings", glyphNames);
      if (localSubrs != null) {
        localSubrs.toXML (ch, "localSubrs"); }
      ch.endElement ("name-keyed-font"); }
  }
</code-fragment>

    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>String INDEX</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>All the strings, with the exception of the FontName and
        CIDFontName strings which appear in the Name INDEX, used by
        different fonts within the FontSet are collected together
        into an INDEX structure and are referenced by a 2-byte
        unsigned number called a string identifier or SID. Only
        unique strings are stored in the table thereby removing
        duplication across fonts. Further space saving is obtained
        by allocating commonly occurring strings to predefined SIDs.
        These strings, known as the standard strings, describe all
        the names used in the ISOAdobe and Expert character sets
        along with a few other strings common to Type 1 fonts. A
        complete list of standard strings is given in Appendix
        A.</para>

      <para>The client program will contain an array of standard
        strings with nStdStrings elements. Thus, the standard
        strings take SIDs in the range 0 to (nStdStrings-1). The
        first string in the String INDEX corresponds to the SID
        whose value is equal to nStdStrings, the first non-standard
        string, and so on. When the client needs to determine the
        string that corresponds to a particular SID it performs the
        following: test if SID is in standard range then fetch from
        internal table, otherwise, fetch string from the String
        INDEX using a value of (SID - nStdStrings) as the
        index.</para>

      <para>An SID is defined as a 2-byte unsigned number but only
        takes values in the range 0-64999, inclusive. SID values
        65000 and above are available for implementation use.</para>

      <para>A FontSet with zero non-standard strings is represented
        by an empty INDEX.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>In the first paragraph, "Only unique strings are
        stored". It is clear that this is permitted by the data
        structure, but what is less clear is wheter it is
        <emphasis>required</emphasis>. The authors of the
        specification indicated that the intent is to allow strings
        to be stored only once and shared, but not to require
        it. To reflect this, the wording could be changed to "Only
        unique strings should to be stored, to avoid duplication
        across fonts, but it is legal to have the same string occur
        multiple times in the String INDEX."</para>

      <para>The character set and encoding is unclear. This needs to
        be clarified. In this implementation, we assume that strings
        can only contain ASCII characters, using the ASCII encoding. The
        String INDEX by itself imposes no more, but use of a string
        may place more requirements (e.g. that a string used as a
        PostScript font name be limited to a strict subset of the
        ASCII set).</para>

      <para>It may be worth clarifying that there is no limit on the
        size of the data (either the size of individual strings or
        the total size of all the character storage) other than
        those imposed by the INDEX organization.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Here is a class that represents the String INDEX of a
        CFF table.</para>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>CFFStrings class</code-title>
  private class CFFStrings {
    <code-include linkend='cffstrings.members'/>
    <code-include linkend='cffstrings.methods'/>
  }
</code-fragment>

      <para>We keep the strings and sids in a pair of maps,
        string2sid and sid2string. We want to maintain of few
        invariants on those structures:

        <itemizedlist>
          <listitem>
            <para>if string2sid(s) = n for some n and s, then n is a
            key in sid2string and furthermore sid2string (string2sid
            (s)) = s.</para>
          </listitem>

          <listitem>
            <para>if sid2string(n) = s for some n and s, then s is a
            key in string2sid. However, it could be that string2sid
            (sid2string (n)) != n; this can happen if the same
            string is present under two different sids.</para>
          </listitem>

          <listitem>
            <para>the set of keys in sid2strings is
              [0..sid2strings.size() - 1]</para>
          </listitem>
          <listitem>
            <para>sid2strings.size () is less than 65,000.</para>
          </listitem>

          <listitem>
            <para>each string in the set of keys of string2sid (or
              equivalently, the set of values of string2sid)
              is made only of ASCII characters</para>
          </listitem>

          <listitem>
            <para>the sum of the number of characters of sid2string
            (n), for 0 &lt;= n &lt; sid2string.size (), must be less
            than 0xffffffff.</para>
          </listitem>

          <listitem>
            <para>sid2string (n), for n &lt;= stdStrings, is the nth
            predefined string</para>
          </listitem>
        </itemizedlist>

        These invariants ensure that the two maps represent a
        valid String INDEX. To avoid counting over and over again
        the total number of characters, we keep it in the variable
        'charCount'.</para>

<code-fragment id='cffstrings.members'>
  <code-title>CFFStrings members</code-title>
  private Map&lt;String, Integer> string2sid;
  private Map&lt;Integer, String> sid2string;
  private long charCount;
</code-fragment>

      <para>We allow only the insertion of strings, not their
        deletion. We do that through a couple of helper methods; the
        first sets the maps to the set of predefined strings, and
        the second adds a string at the first available SID. The
        critical observation for the verification of the invariants
        is that the simultaneous insertion in sid2string and
        string2sid with the sid sid2strings.size () leaves the first
        three invariants unchanged; the proof of the other
        invariants is straightforward.</para>

<code-fragment id='cffstrings.methods'>
  <code-title>Inserting a string</code-title>
  private void insertPredefinedStrings () {
    string2sid = new java.util.HashMap&lt;String, Integer> ();
    sid2string = new java.util.HashMap&lt;Integer, String> ();
    charCount = 0;

    for (int i = 0; i &lt; predefinedCFFStrings.length; i++) {
      Integer ii = new Integer (i);
      string2sid.put (predefinedCFFStrings [i], ii);
      sid2string.put (ii, predefinedCFFStrings [i]);
      charCount += predefinedCFFStrings [i].length (); }
  }


  private Integer insert (String s)
      throws InvalidFontException {
    for (int j = 0; j &lt; s.length (); j++) {
      if (0x7f &lt; s.charAt (j)) {
        throw new InvalidFontException ("non-ASCII string in CFF Strings"); }}

    if (sid2string.size () >= 65000) {
      throw new InvalidFontException ("no SID available"); }

    if (charCount + s.length () >= 0xffffffffL) {
      throw new InvalidFontException ("strings too big"); }

    Integer ii = new Integer (sid2string.size ());
    string2sid.put (s, ii);
    sid2string.put (ii, s);
    charCount += s.length ();

    return ii;
  }
</code-fragment>

      <para>There is a single constructor. The resulting CFFStrings
        contains exactly the set of predefined strings.</para>

<code-fragment id='cffstrings.methods'>
  <code-title>Constructor</code-title>
  public CFFStrings () {
    insertPredefinedStrings ();
  }
</code-fragment>

      <para>It is then possible to add the strings contained in an
        existing font, under their SID. As a result, it is possible
        that the same string be present under two or more distinct
        SIDs. The <varname>fromBinary</varname> method may be called
        at most once, immediatly after the constructor. 'data' is
        parsed starting as position 'offset'; if the bytes cannot be
        interpreted as a valid Strings INDEX, the InvalidFont
        exception is thrown.</para>


      <para>After that, it is possible to query for the string
        corresponding to a SID; if that SID is not used, null is
        returned:</para>

<code-fragment id='cffstrings.methods'>
  <code-title>getString</code-title>
  public String getString (int sid) {
    return sid2string.get (new Integer (sid));
  }
</code-fragment>

      <para>Another operation is to find the SID under which a
        string is present. If the string is present under multiple
        SIDs, one of them is returned. If the string is not present,
        it is inserted in the pool and a new unused SID is assigned
        to it; if they are no unused SIDs (i.e. if SIDs [0..64,999]
        are already used), or if the string is not valid (i.e. not
        made of ASCII characters), the exception
        InvalidFontException is thrown; otherwise, the assigned SID
        is returned.</para>

<code-fragment id='cffstrings.methods'>
  <code-title>getIndex</code-title>
  public int getIndex (String s)
      throws InvalidFontException {
   Integer sid = string2sid.get (s);

    if (sid == null) {
      sid = insert (s); }

    return sid.intValue ();
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
        <title>FromBinary</title>

        <para>There is a small catch in that code. It seems that that
          String constructor is not well specified and maybe even not
          well implemented. There is no exception for "illegal byte
          sequence for that encoding", and the result may be
          undefined. I quickly looked through the bug parade (on the
          JDC), and it seems that there are new APIs in 1.4 for code
          conversion that may be better than this one.</para>

<code-fragment id='cfffontset.methods'>
  <code-title>stringsFromBinary</code-title>
  public String[] stringsFromBinary (byte[] data, int offset)
      throws InvalidFontException {
    int[] stringOffsets = getINDEXOffsets (data, offset);
    String[] strings = new String [predefinedCFFStrings.length
                                   + stringOffsets.length - 1];

    try {
      for (int i = 0; i &lt; predefinedCFFStrings.length; i++) {
        strings [i] = predefinedCFFStrings [i]; }

      for (int i = 0; i &lt; stringOffsets.length - 1; i++) {
        strings [i + predefinedCFFStrings.length]
           = new String (data,
                         stringOffsets [i],
                         stringOffsets [i+1] - stringOffsets [i],
                         "ASCII"); }}

    catch (java.io.UnsupportedEncodingException e) {
      System.err.println ("What? ASCII is not supported?");
      e.printStackTrace ();
      System.exit (1); }

    return strings;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
        <title>ToBinary</title>

        <para>Serialization is bit messier, because we do not
        currently use any helper to build the index:</para>

<code-fragment id='cffstrings.methods.disabled'>
  <code-title>toBinary</code-title>
  public void toBinary (ByteBuffer bb)
     throws InvalidFontException {

    int stringCount = string2sid.size ();
    int storedCount = stringCount - predefinedCFFStrings.length;
    ByteBuffer[] data = new ByteBuffer [storedCount];


    for (int i = 0; i &lt; storedCount; i++) {
      data [i] = new ByteBuffer ();
      String s = sid2string.get (i + predefinedCFFStrings.length);
      for (int j = 0; j &lt; s.length (); j++) {
        data [i].addCard8 (s.charAt (j)); }}

    INDEXToBinary (bb, data);
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
        <title>XML Representation</title>

        <para>The String INDEX mechanism is really a storage
          mechanism, and there is little benefit in reflecting it an
          XML representation of a font. Instead, wherever a SID
          occurs, the XML representation will actually show the actual
          string.</para>

        <para>What we loose is fine control over the construction of
          the String INDEX. For example, the XML representation cannot
          imply a particular ordering of the strings, nor can it force
          a string to occur twice. However, it does not seem very
          useful to have that fine control, hence our decision.</para>

    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Glyph Organization</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
        <title>Specification</title>

        <para>The glyphs within a font constitute a charset and are
          accessed via an encoding. An encoding is an array of codes
          associated with some or all glyphs in a font and a charset
          is an array of "names" for all glyphs in the font. (In
          CFF these names are actually SIDs or CIDs, which must be
          unique.)</para>

        <para>In order to understand how charsets, encodings, and
          glyphs are related in CFF it is useful to think of them as 3
          "parallel" arrays that are indexed in unison. Thus, it
          is possible to name and encode the glyph at the given glyph
          index (GID) by using the GID to index the charset and
          encoding arrays, respectively. By definition the first glyph
          (GID 0) is ".notdef" and must be present in all fonts.
          Since this is always the case, it is not necessary to
          represent either the encoding (unencoded) or name (.notdef)
          for GID 0. Consequently, taking advantage of this
          optimization, the encoding and charset arrays always begin
          with GID 1.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>A font in a FontSet contains a bunch of glyphs. Glyphs can
        be identified in a number of ways.</para>

      <para>First, every glyph has a Glyph ID (GID), which is an
        integer in the range [0..numberOfGlyphs-1]. By convention, the
        glyph with GID 0 is the ".notdef" glyph, which is intended to
        be used whenever the font does not contain a glyph appropriate
        for the purpose at hand.</para>

      <para>Second, in name-keyed fonts (and by derivation, synthetic
        fonts), every glyph has a name, which is a string. Every glyph
        must have a different name. These names are stored in the
        fontset String INDEX; the charset of the font maps glyphs to
        their names, i.e. GIDs to SIDs. The name of GID 0 must be
        ".notdef". Because each glyph has a unique name, and SIDs must
        be in the range [0..64,999], this means that a name-keyed font
        can have at most 65,000 glyphs; furthermore, that limit can be
        reached only if one is willing to use all the strings in the
        FontSet (including the predefined strings). The CFF
        specification by itself does not give any meaning to the
        names; they are arbitrary; however, the context in which a CFF
        FontSet is used may impose some convention on the names,
        e.g. that the name "four" be used only for a glyph that
        represents the character "4".</para>

      <para>Third, in name-keyed fonts and synthetic fonts, an
        Encoding is a map from a subset of [0..255] to some of the
        glyphs in the font. Given the intended use of the ".notdef"
        glyph, these can be considered as total maps from [0..255], by
        adding mappings to the ".notdef" glyph. The integers 0..255
        are called character codes. A mapped glyph is said to be encoded,
        and every encoded glyph can be identified by one or more
        character codes.</para>

      <para>Fourth, in CID-keyed fonts, every glyph has a unique CID, which
        is an integer in the rage [0..0xfffe]. 0xffff is not available
        and the FDSelect structure takes advantage of that. The
        association between a glyph and its CID is via the charset of
        the font, which is in that case a map from GIDs to CIDs. CIDs
        act just like names, and the CFF specification by itself does
        not give any meaning to the CIDs; they are arbitrary; however,
        the context in which a CFF FontSet is used may impose some
        convention on the CIDs, e.g. that if the ROS of the font is
        Adobe-Japan-1.4, then the CID 0x???? be used only for a glyph
        that represents the character "?".</para>

      <para>A CFFFontSet consumer can choose any of these name spaces
        to refer to glyphs. For example, PDF documents use the code
        points (for name-keyed fonts) or CIDs (for CID-keyed
        fonts). OpenType fonts use GIDs.</para>

      <para>Using GIDs is the most straightforward, but the glyph
        references are intimately linked to the font; for example,
        building a derivative font that contains only the glyphs
        needed for a certain purpose ("subsetting" the font) usually
        changes the GIDs, as those are constrained to be
        [0..numberOfGlyphs-1]. Using the other names provides some
        level of isolation; a subsetting operation can modify the
        charset and/or Encoding of a font to take into account the GID
        renaming.</para>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Encodings</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>Encoding data is located via the offset operand to the
        Encoding operator in the Top DICT. Only one Encoding
        operator can be specified per font except for CIDFonts which
        specify no encoding. A glyph's encoding is specified by a
        1-byte code that permits values in the range 0-255.</para>

      <para>Each encoding is described by a format-type identifier
        byte followed by format-specific data. Two formats are
        currently defined as specified in Tables 11 and 12.</para>

      <table>
        <title>Format 0</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>format</entry>
              <entry>=0</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>nCodes</entry>
              <entry>Number of encoded glyphs</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>code [nCodes]</entry>
              <entry>Code array</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Each element of the code array represents the encoding
        for the corresponding glyph. This format should be used when
        the codes are in a fairly random order.</para>

      <table>
        <title>Format 1</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>format</entry>
              <entry>=1</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>nRanges</entry>
              <entry>Number of code ranges</entry>
            </row>
            <row>
              <entry>struct</entry>
              <entry>Range1 [nRanges]</entry>
              <entry>Range1 array (see Table 13)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The format of a Range1 is described in Table 13.</para>

      <table>
        <title>Range1 Format (Encoding)</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>first</entry>
              <entry>First code in range</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>nLeft</entry>
              <entry>Codes left in range (excluding first)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Each Range1 describes a group of sequential codes. For
        example, the codes 51 52 53 54 55 could be represented by
        the Range1: 51 4, and a perfectly ordered encoding of 256
        codes can be described with the Range1: 0 255.</para>

      <para>This format is particularly suited to encodings that are
        well ordered.</para>

      <para>A few fonts have multiply-encoded glyphs which are not
        supported directly by any of the above formats. This
        situation is indicated by setting the high-order bit in the
        format byte and supplementing the encoding, regardless of
        format type, as shown in Table 14.</para>

      <table>
        <title>Supplemental Encoding Data</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>nSups</entry>
              <entry>Number of supplementary mappings</entry>
            </row>
            <row>
              <entry>struct</entry>
              <entry>Supplement [nSups]</entry>
              <entry>Supplementary encoding array (see Table 15 below)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The format of a Supplement is specified in Table
        15.</para>

      <table>
        <title>Supplement Format</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>code</entry>
              <entry>Encoding</entry>
            </row>
            <row>
              <entry>SID</entry>
              <entry>glyph</entry>
              <entry>Name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Each Supplement describes a single code-to-glyph mapping
        which provides another encoding for a glyph that has already
        been mentioned in the main encoding table.</para>

      <para>Sorting glyphs by encoding and then SID for unencoded
        glyphs (remembering that .notdef must be first) typically
        yields very small font encodings. Still more optimization is
        possible by observing that many fonts adopt one of two
        common encodings. In these cases the operand to the Encoding
        operator in the Top DICT specifies a predefined encoding id,
        in place of an offset, as defined in Table 16.</para>

      <table>
        <title>Encoding ID</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>Id</entry>
              <entry>Name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>Standard Encoding</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>Expert Encoding</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>If the font uses Standard Encoding the Encoding operator
        can be omitted from the Top DICT since its default value is
        0. Details of predefined encodings can be found in Appendix
        B.</para>

      <para>It is not necessary for a font to contain all the glyphs
        specified by a predefined encoding in order to be able to
        use it. The only requirement is that every glyph in the font
        has an identical encoding to those in the predefined encoding
        (including unencoded glyphs).</para>

      <para>Two or more fonts may share the same encoding by setting
        the offset operand of the Encoding operator to the same
        value in each font.</para>

      <para>By definition, glyphs that are not specified by custom
        or predefined encodings are unencoded.</para>

      <para>Note 4 Predefined encodings may be applied to a variety
        of fonts regardless of charset whereas custom encodings may
        only be applied to fonts with specific charsets.
        Consequently, predefined encodings are specified as code to
        SID mappings and custom encodings are specified as code to
        GID mappings.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>Fundamentally, an encoding is map from [0..255] to
	glyphs. For historical reasons, it is represented backwards in
	the font, as the inverse map from glyphs to codes, with supplemental
	encoding data to take care of the cases where two codes map to
	the same glyph.</para>

      <para>In a format 0 or 1 table, it is not clear what "the
        corresponding glyph" is. The array (which is run-length
        encoded in format 1) contains the code, but what
        is the index? The SID of the glyph name, or the glyph ID? We
        assume it is the glyph ID.</para>

      <para>In any case, this restricts the encoded glyphs to those with
        IDs (or SIDs) 0 through n; it cannot be an arbitrary subset of
        the glyphs. By contrast, the supplemental encoding data can be
        used to encode an arbitrary glyph.</para>

      <para>Another aspect that is not very clear is the behavior of
        an application that converts from a code to a glyph: what
        should it do if there is no glyph with that code? Use the
        .notdef glyph? Generate some error? We assume the
        former, based on the fact that the predefined encodings are
        map the full 0-255 and extensively use .notdef.</para>

      <para>The predefined encodings in Appendix B list both an SID
        and a string for each code point. However, remember that the
        same string can be present in the Strings INDEX under two
        different SIDs. So this raises the question: which is
        normative? For example, in the Standard Encoding, which is the
        glyph at code point 36: the glyph whose name is SID 5, or a
        glyph whose name is any SID, as long as the string
        corresponding to this SID is "dollar"? We choose the later
        interpretation.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>We represent an encoding as an array of 256 glyph
        IDs. While this means a fair amount of unwinding for the
        supplemental data and the predefined encodings, it is the
        most useful form.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>encodingFromBinary</code-title>
  public int[] encodingFromBinary (byte[] data, int offset, String[] strings)
      throws InvalidFontException {

    if (offset == 0 || offset == 1) {
      int[] std;
      if (offset == 0) {
        std = standardEncoding; }
      else {
        std = expertEncoding; }

      int[] encoding = new int [std.length];

      for (int i = 0; i &lt; std.length; i++) {
        encoding [i] = getGlyphID (predefinedCFFStrings [std [i]]); }

      return encoding; }


    int[] encoding = new int [256];
    for (int i = 0; i &lt; encoding.length; i++) {
      encoding [i] = 0; }

    int format = getCard8 (data, offset);
    offset++;

    boolean supplement = false;
    if ((format &amp; 0x80) != 0) {
      supplement = true;
      format &amp;= 0x7f; }

    switch (format) {

      case 0: {
        int ncodes = getCard8 (data, offset);
        offset++;
        for (int i = 0; i &lt; ncodes; i++) {
          encoding [getCard8 (data, offset)] = i;
          offset++; }
        break; }

      case 1: {
        int currentGID = 0;
        int nRanges = getCard8 (data, offset);
        offset++;
        for (int i = 0; i &lt; nRanges; i++) {
          int currentCode = getCard8 (data, offset);
          offset++;
          int nLeft = getCard8 (data, offset);
          offset++;
          for (int j = 0; j &lt;= nLeft; j++) {
            encoding [currentCode++] = currentGID++; }}
        break; }

      default: {
        throw new InvalidFontException ("encoding: wrong format (" +
                                        + format + ")"); }}


    if (supplement) {
      int nSups = getCard8 (data, offset);
      offset++;

      for (int i = 0; i &lt; nSups; i++) {
        int code = getCard8 (data, offset);
        offset++;
        int sid = getCard16 (data, offset);
        offset += 2;
        encoding [i] = getGlyphID (strings [sid]); }}

    return encoding;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>Our first method recognizes if an encoding can be
	represented by a predefined encoding. This will be the case if
	for every code point:
	<itemizedlist>
	  <listitem>
	    <para>the glyph actually encoded there has the same name
	      as the predefined encoding</para>
	  </listitem>
	  <listitem>
	    <para>or, there is no glyph actually encoded there, and no glyph
	      has that name</para>
	  </listitem>
	</itemizedlist></para>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>Encoding to binary methods</code-title>
  private boolean checkPredefinedEncoding (int[] predefined,
                                           int[] actual, String[] glyphnames) {
    for (int i = 0; i &lt; predefined.length; i++) {
      if (predefinedCFFStrings [predefined [i]].equals (glyphnames [actual [i]])) {
        continue; }
      if (actual [i] != 0) {
        return false; }
      for (int j = 0; j &lt; glyphnames.length; j++) {
        if (glyphnames [j].equals (predefinedCFFStrings [predefined [i]])) {
          return false; }}}
    return true;
  }

  public int isPredefinedEncoding (int[] encoding, String[] glyphnames) {
    if (checkPredefinedEncoding (standardEncoding, encoding, glyphnames)) {
      return 0; }

    if (checkPredefinedEncoding (expertEncoding, encoding, glyphnames)) {
      return 1; }

    return -1;
  }

  private void encodingToBinary (ByteBuffer bb,
                                 int[] actual, String[] glyphnames) {
    //TODO
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

<code-fragment id='schema'>
  encoding =
    map*

  map = element map { attribute code { text }, attribute gid { text }}
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

<code-fragment id='cffnamekeyedfont.methods'>
  <code-title>toXML method</code-title>
  public void encodingToXML (ContentHandlerPlus ch, int[] encoding)
      throws org.xml.sax.SAXException {
    ch.startElement ("encoding"); {
      for (int i = 0; i &lt; encoding.length; i++) {
        AttributesImpl at;
        at = new AttributesImpl ();
        at.addAttribute ("", "code", "code", "CDATA", "" + i);
        at.addAttribute ("", "gid",  "gid", "CDATA", "" + encoding [i]);
        ch.element ("map", at); }
      ch.endElement ("encoding"); }
  }

  public void encodingFromXML (Element enc) {
    NodeList nl = enc.getChildNodes ();
    encoding = new int [nl.getLength ()];
    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element map = (Element) nl.item (i);
      int code = Integer.decode (map.getAttribute ("code")).intValue ();
      int gid = Integer.decode (map.getAttribute ("gid")).intValue ();
      encoding [code] = gid; }
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Charsets</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
        <title>Specification</title>

        <para>Charset data is located via the offset operand to the
          charset operator in the Top DICT. Each charset is described
          by a formattype identifier byte followed by format-specific
          data. Three formats are currently defined as shown in Tables
          17, 18, and 20.</para>

        <table>
          <title>Format 0</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Card8</entry>
                <entry>format</entry>
                <entry>=0</entry>
              </row>
              <row>
                <entry>SID</entry>
                <entry>glyph [nGlyphs-1]</entry>
                <entry>Glyph name array</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Each element of the glyph array represents the name of
          the corresponding glyph. This format should be used when the
          SIDs are in a fairly random order. The number of glyphs
          (nGlyphs) is the value of the count field in the CharStrings
          INDEX. (There is one less element in the glyph name array
          than nGlyphs because the .notdef glyph name is
          omitted.)</para>

        <table>
          <title>Format 1</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Card8</entry>
                <entry>format</entry>
                <entry>=1</entry>
              </row>
              <row>
                <entry>struct</entry>
                <entry>Range1 [&lt;varies>]</entry>
                <entry>Range1 array (see Table 19)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The Range1 format is shown in Table 19.</para>

        <table>
          <title>Range1 Format (Charset)</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>SID</entry>
                <entry>first</entry>
                <entry>First glyph in range</entry>
              </row>
              <row>
                <entry>Card8</entry>
                <entry>nLeft</entry>
                <entry>Glyphs left in range (excluding first)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Each Range1 describes a group of sequential SIDs. The
          number of ranges is not explicitly specified in the font.
          Instead, software utilizing this data simply processes
          ranges until all glyphs in the font are covered. This format
          is particularly suited to charsets that are well
          ordered.</para>

        <table>
          <title>Format 2</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Card8</entry>
                <entry>format</entry>
                <entry>=2</entry>
              </row>
              <row>
                <entry>struct</entry>
                <entry>Range2 [&lt;varies>]</entry>
                <entry>Range2 array (see Table 21)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The Range2 format is shown in Table 21.</para>

        <table>
          <title>Range2 Format</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>SID</entry>
                <entry>first</entry>
                <entry>First glyph in range</entry>
              </row>
              <row>
                <entry>Card16</entry>
                <entry>nLeft</entry>
                <entry>Glyphs left in range (excluding first)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Format 2 differs from format 1 only in the size of the
          nLeft field in each range. This format is most suitable for
          fonts with a large well-ordered charset - for example,
          for Asian CIDFonts.</para>
        <para>Careful attention to the allocation order of SIDs
          typically yields very small font charsets. Still more
          optimization is possible by observing that many fonts adopt
          one of 3 common charsets. In these cases the operand to the
          charset operator in the Top DICT specifies a predefined
          charset id, in place of an offset, as shown in Table
          22.</para>

        <table>
          <title>Charset ID</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
            <thead>
              <row>
                <entry>Id</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>ISOAdobe</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Expert</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>ExpertSubset</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>If the font has an ISOAdobe charset, the charset
          operator can be omitted from the Top DICT since its default
          value is 0. Details of predefined charsets can be found in
          Appendix C. A font may use a predefined charset if it
          exactly matches in the first nGlyphs. CID fonts must not use
          predefined charsets.</para>

        <para>Two or more fonts may share the same charset by setting
          the offset operand of the charset operator to the same value
          in each font.</para>
    </section>

    <!--______________________________________________________________________-->
    <section>
      <title>Annotation</title>

      <para>The charset structure is actually used differently in
	name-keyed fonts and in CID-keyed fonts. In name-keyed fonts,
	it is indeed a map from glyph IDs to SIDs, as described
	here. However, for CID-keyed fonts, it is a map from glyph IDs
	to CIDs; those CIDs should not be interpreted as SIDs.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
        <title>FromBinary</title>

<code-fragment id='cfffontset.methods'>
  <code-title>charsetFromBinary</code-title>
  public String[] nameCharsetFromBinary (byte[] data, int offset,
                                         int numGlyphs, String[] strings) {
    int[] c = charsetFromBinary (data, offset, numGlyphs);
    String[] result = new String [c.length];
    for (int i = 0; i &lt; c.length; i++) {
      result [i] = strings [c [i]]; }
    return result;
  }

  public int[] charsetFromBinary (byte[] data, int offset, int numGlyphs) {

    if (offset == 0) {
      return isoAdobeCharset; }

    if (offset == 1) {
      return expertCharset; }

    if (offset == 2) {
      return expertSubsetCharset; }

    int[] result = new int [numGlyphs];
    result [0] = 0;  // glyph 0 is always .notdef

    int format = getCard8 (data, offset);
    offset++;

    switch (format) {

      case 0: {
        for (int i = 1; i &lt; numGlyphs; i++) {
          result [i] = getCard16 (data, offset);
          offset += 2; }
        break; }

      case 1: {
        int currentGlyphID = 1;
        while (currentGlyphID &lt; numGlyphs) {
          int currentSID = getCard16 (data, offset);
          offset += 2;
          int nLeft = getCard8 (data, offset);
          offset ++;
          for (int i = 0; i &lt;= nLeft; i++) {
            result [currentGlyphID++] = currentSID++; }}
        break; }

      case 2: {
        int currentGlyphID = 1;
        while (currentGlyphID &lt; numGlyphs) {
          int currentSID = getCard16 (data, offset);
          offset += 2;
          int nLeft = getCard16 (data, offset);
          offset += 2;
          for (int i = 0; i &lt;= nLeft; i++) {
            result [currentGlyphID++] = currentSID++; }}
        break; }}

    return result;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
        <title>ToBinary</title>

<code-fragment id='cfffontset.methods'>
  <code-title>charsetToBinary</code-title>
  public boolean checkPredefinedCharset (int[] predefined, String[] actual) {
    if (predefined.length != actual.length) {
      return false; }

    for (int i = 0; i &lt; predefined.length; i++) {
      if (! predefinedCFFStrings [predefined[i]].equals (actual [i])) {
      return false; }}

    return true;
  }

  public int isPredefinedCharset (String[] names) {
    if (checkPredefinedCharset (isoAdobeCharset, names)) {
      return 0; }
    if (checkPredefinedCharset (expertCharset, names)) {
      return 1; }
    if (checkPredefinedCharset (expertSubsetCharset, names)) {
      return 2; }
    return -1;
  }



  public void charsetToBinary (ByteBuffer bb, String[] names,
                               List&lt;String> strings) {
    int[] sids = new int [names.length];
    for (int i = 0; i &lt; sids.length; i++) {
      sids [i] = strings.indexOf (names [i]); }

    numsetToBinary (bb, sids);
  }


  public void numsetToBinary (ByteBuffer bb, int[] ids) {
    ByteBuffer format0 = numsetToBinary0 (ids);
    ByteBuffer format1 = numsetToBinary1 (ids);
    ByteBuffer format2 = numsetToBinary2 (ids);

    if (format1.length () &lt; format0.length ()) {
      format0 = format1; }
    if (format2.length () &lt; format0.length ()) {
      format0 = format2; }

    byte[] b = format0.toArray ();
    for (int i = 0; i &lt; b.length; i++) {
      bb.addCard8 (b [i]); }
  }

  public ByteBuffer numsetToBinary0 (int[] ids) {
    ByteBuffer bb = new ByteBuffer ();
    bb.addCard8 (0);
    for (int i = 1; i &lt; ids.length; i++) {
      bb.addCard16 (ids [i]); }
    return bb;
  }

  public ByteBuffer numsetToBinary1 (int[] ids) {
    ByteBuffer bb = new ByteBuffer ();
    bb.addCard8 (1);
    int i = 1;
    while (i &lt; ids.length) {
      bb.addCard16 (ids [i]);
      i++;
      int nLeft = 0;
      while (   i &lt; ids.length
             &amp;&amp; ids [i] == ids [i-1] + 1
             &amp;&amp; nLeft &lt; 0xff) {
        i++;
        nLeft++; }
      bb.addCard8 (nLeft); }
    return bb;
  }

  public ByteBuffer numsetToBinary2 (int[] ids) {
    ByteBuffer bb = new ByteBuffer ();
    bb.addCard8 (2);
    int i = 1;
    while (i &lt; ids.length) {
      bb.addCard16 (ids [i]);
      i++;
      int nLeft = 0;
      while (   i &lt; ids.length
             &amp;&amp; ids [i] == ids [i-1] + 1
             &amp;&amp; nLeft &lt; 0xffff) {
        i++;
        nLeft++; }
      bb.addCard16 (nLeft); }
    return bb;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
        <title>XML Representation</title>

        <para>Not represented</para>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>CharStrings INDEX</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
        <title>Specification</title>

        <para>This contains the charstrings of all the glyphs in a
          font stored in an INDEX structure. Charstring objects
          contained within this INDEX are accessed by GID. The first
          charstring (GID 0) must be the .notdef glyph. The number of
          glyphs available in a font may be determined from the count
          field in the INDEX.</para>

        <para>The format of the charstring data, and therefore the
          method of interpretation, is specified by the CharstringType
          operator in the Top DICT. The CharstringType operator has a
          default value of 2 indicating the Type 2 charstring format
          which was designed in conjunction with CFF. Type 1
          charstrings are documented in the "Adobe Type 1 Font Format"
          published by Addison-Wesley. Type 2 charstrings are
          described in Adobe Technical Note #5177: "Type 2 Charstring
          Format." Other charstring types may also be supported by
          this method.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
        <title>Implementation</title>

      <para>In this implementation, we assume that all charstrings are
        Type 2. To fully understand this code, please refer to the
        Type 2 specification.</para>

      <para>We represent the charstrings of a CharStrings INDEX in the
	<varname>charstrings</varname> field:</para>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>CFFCharStrings class</code-title>
  public class CFFCharStrings {
    public byte[][] charstrings = null;

    public CFFCharStrings () {
    }

    <code-include linkend='cffcharstrings.methods'/>
  }
</code-fragment>

      <para>A useful operation is of course to figure out how many
        charstrings are present.</para>

<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.numGlyphs</code-title>
  public int numGlyphs () {
    if (charstrings != null) {
      return charstrings.length; }
    else {
      return 0; }
  }
</code-fragment>

    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
        <title>FromBinary</title>

<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.fromBinary</code-title>
  public int fromBinary (byte[] data, int offset)
      throws InvalidFontException {
    int [] charStringsOffsets = getINDEXOffsets (data, offset);
    charstrings = new byte [charStringsOffsets.length - 1][];

    for (int i = 0; i &lt; charstrings.length; i++) {
      int thisone = charStringsOffsets [i];
      int next = charStringsOffsets [i+1];
      charstrings [i] = new byte [next - thisone];
      System.arraycopy (data, thisone, charstrings[i], 0, next - thisone); }

    return charStringsOffsets [charStringsOffsets.length - 1];
  }
</code-fragment>

<!--
<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.fromBinary</code-title>
  public int fromBinary (byte[] data, int offset)
      throws InvalidFontException {
    int [] charStringsOffsets = getINDEXOffsets (data, offset);
    charstrings = new String [charStringsOffsets.length - 1];
    for (int i = 0; i &lt; charstrings.length; i++) {

      charstrings [i] = oneCharStringFromBinary (data,
                          charStringsOffsets [i],
                          charStringsOffsets [i+1]); }
    return charStringsOffsets [charStringsOffsets.length - 1];
  }

  public String oneCharStringFromBinary (byte[] data, int offset, int end) {
    StringBuilder s = new StringBuilder ();

    char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7',
                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    while (offset &lt; end) {
      int b = getCard8 (data, offset);
      offset++;

      s.append ('%');
      s.append (digits [(b >>4) &amp; 0xf]);
      s.append (digits [b       &amp; 0xf]);
      s.append (' '); }

    return s.toString ();
  }

  public String oneCharStringFromBinary2 (byte[] data, int offset, int end) {
    StringBuilder s = new StringBuilder ();

    while (offset &lt; end) {
      int b0 = getCard8 (data, offset);
      offset++;

      switch (b0) {
        case 1: s.append ("hstem"); break;
        case 3: s.append ("vstem"); break;
        case 4: s.append ("vmoveto"); break;
        case 5: s.append ("rlineto"); break;
        case 6: s.append ("hlineto"); break;
        case 7: s.append ("vlineto"); break;
        case 8: s.append ("rrcurveto"); break;
        case 10: s.append ("callsubr"); break;
        case 11: s.append ("return"); break;
        case 12: {
          int b1 = getCard8 (data, offset);
          offset++;

          switch (b1) {
            case 3: s.append ("and"); break;
            case 4: s.append ("or"); break;
            case 5: s.append ("not"); break;
            cae 9: s.append ("abs"); break;
            case 10: s.append ("add"); break;
            case 11: s.append ("sub"); break;
            case 12: s.append ("div"); break;
            case 14: s.append ("neg"); break;
            case 15: s.append ("eq"); break;
            case 18: s.append ("drop"); break;
            case 20: s.append ("put"); break;
            case 21: s.append ("get"); break;
            case 22: s.append ("ifelse"); break;
            case 23: s.append ("random"); break;
            case 24: s.append ("mul"); break;
            case 26: s.append ("sqrt"); break;
            case 27: s.append ("dup"); break;
            case 28: s.append ("exch"); break;
            case 29: s.append ("index"); break;
            case 30: s.append ("roll"); break;
            case 34: s.append ("hflex"); break;
            case 35: s.append ("flex"); break;
            case 36: s.append ("hflex1"); break;
            case 37: s.append ("flex1"); break;
            default: s.append ("reserved12." + b1); break; }
          break; }

        case 14: s.append ("endchar"); break;
        case 18: s.append ("hstemhm"); break;
        case 19: s.append ("hintmask"); break;
        case 20: s.append ("cntrmask"); break;
        case 21: s.append ("rmoveto"); break;
        case 22: s.append ("hmoveto"); break;
        case 23: s.append ("vstemhm"); break;
        case 24: s.append ("rcurveline"); break;
        case 25: s.append ("rlinecurve"); break;
        case 26: s.append ("vvcurveto"); break;
        case 27: s.append ("hhcurveto"); break;
        case 28: s.append (getInt16 (data, offset)); offset += 2; break;
        case 29: s.append ("callgsubr"); break;
        case 30: s.append ("vhcurveto"); break;
        case 31: s.append ("hvcurveto"); break;

        case 255: {
          s.append (getInt16 (data, offset));
          offset += 2;
          s.append ("/");
          s.append (getCard16 (data, offset));
          offset += 2;
          break; }

        default: {
          if (32 &lt;= b0 &amp;&amp; b0 &lt;= 246) {
            s.append (b0 - 139); }

          else if (247 &lt;= b0 &amp;&amp; b0 &lt;= 250) {
            int b1 = getCard8 (data, offset);
            offset++;
            s.append ((b0 - 247) * 256 + b1 + 108); }

          else if (251 &lt;= b0 &amp;&amp; b0 &lt;= 254) {
            int b1 = getCard8 (data, offset);
            offset++;
            s.append (-(b0 - 251)*256 - b1 - 108); }

          else {
            s.append ("reserved" + b0); }

          break; }}
      s.append (" "); }
    return s.toString ();
  }
</code-fragment>
-->
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
        <title>ToBinary</title>

<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.toBinary</code-title>
  public void toBinary (ByteBuffer bb)
      throws InvalidFontException {

    if (charstrings == null) {
      startIndex (bb, 0); }
    else {
      IndexCursor indexCursor = startIndex (bb, charstrings.length);
      for (int i = 0; i &lt; charstrings.length; i++) {
        bb.addBytes (charstrings [i]);
        indexCursor = elementEntered (bb, indexCursor); }}
  }
</code-fragment>

    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

      <para>Type 2 Charstrings are very similar to DICTs: they are a
	sequence of operands and operators, each one represented by
	a byte sequence. For example, the "hmoveto" operator is
	represented by the byte 0x16, and the integer operand 0 is
	represented by the byte 0x8B.</para>

      <para> In our XML representation, we want the charstrings to be a
	bit more readable than a straight sequence of bytes. This is
	particularly useful when the XML representation is manually
	edited. In other words, we want to see "0 0 hmoveto" rather
	than the byte sequence "0x8B 0x8B 0x16".</para>

      <para>This conversion would be straightforward, except for a
	nasty property: the number of bytes occupied by the hint
	operators depends on the previously executed hint mask
	operators. This makes it impossible to decode charstrings
	without fully interpreting them, including proper
	interpretation of the subroutine calls.</para>

      <para>Our compromise is as follows: we also accept explicit
      bytes in our charstrings, in the form "%xx". Our decompiler only
      generates that form. Our compiler however accepts both forms,
      even mixed.</para>


<code-fragment id='schema'>
  charstrings = charstring *
  localSubrs =  charstring *
  globalSubrs = charstring *

  charstring =
    element charstring {
      attribute id { text },
      attribute name { text }?,
      attribute cid { text }?,

      text }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.fromXML</code-title>
  public void fromXML (Element e)
      throws InvalidFontException {
    NodeList nl = e.getChildNodes ();

    charstrings = new byte [nl.getLength ()][];

    for (int i = 0; i &lt; charstrings.length; i++) {
      Element cs = (Element) (nl.item (i));
      charstrings [i] = oneCharstringFromXML (cs.getFirstChild ().getNodeValue ()); }
  }

  public byte[] oneCharstringFromXML (String s)
       throws InvalidFontException {

    ByteBuffer bb = new ByteBuffer (256);

    char[] ch = s.toCharArray ();
    int chCount = ch.length;
    int i = 0;

    while (i &lt; chCount) {
      if ('a' &lt;= ch [i] &amp;&amp; ch [i] &lt;= 'z') {
        int start = i;
        while (   i &lt; chCount
               &amp;&amp; (   'a' &lt;= ch [i] &amp;&amp; ch [i] &lt; 'z'
                   || '0' &lt;= ch [i] &amp;&amp; ch [i] &lt;='9'
                   || '.' == ch [i])) {
          i++; }
        String op = s.substring (start, i).intern ();

        if (op == ("hstem")) {
          bb.addCard8 (1); }
        else if (op == ("vstem")) {
          bb.addCard8 (3); }
        else if (op == ("vmoveto")) {
          bb.addCard8 (4); }
        else if (op == ("rlineto")) {
          bb.addCard8 (5); }
        else if (op == ("hlineto")) {
          bb.addCard8 (6); }
        else if (op == ("vlineto")) {
          bb.addCard8 (7); }
        else if (op == ("rrcurveto")) {
          bb.addCard8 (8); }
        else if (op == ("callsubr")) {
          bb.addCard8 (10); }
        else if (op == ("return")) {
          bb.addCard8 (11); }

        else if (op == ("and")) {
          bb.addCard8 (12); bb.addCard8 (3); }
        else if (op == ("or")) {
          bb.addCard8 (12); bb.addCard8 (4); }
        else if (op == ("not")) {
          bb.addCard8 (12); bb.addCard8 (5); }
        else if (op == ("abs")) {
          bb.addCard8 (12); bb.addCard8 (9); }
        else if (op == ("add")) {
          bb.addCard8 (12); bb.addCard8 (10); }
        else if (op == ("sub")) {
          bb.addCard8 (12); bb.addCard8 (11); }
        else if (op == ("div")) {
          bb.addCard8 (12); bb.addCard8 (12); }
        else if (op == ("neg")) {
          bb.addCard8 (12); bb.addCard8 (14); }
        else if (op == ("eq")) {
          bb.addCard8 (12); bb.addCard8 (15); }
        else if (op == ("drop")) {
          bb.addCard8 (12); bb.addCard8 (18); }
        else if (op == ("put")) {
          bb.addCard8 (12); bb.addCard8 (20); }
        else if (op == ("get")) {
          bb.addCard8 (12); bb.addCard8 (21); }
        else if (op == ("ifelse")) {
          bb.addCard8 (12); bb.addCard8 (22); }
        else if (op == ("random")) {
          bb.addCard8 (12); bb.addCard8 (23); }
        else if (op == ("mul")) {
          bb.addCard8 (12); bb.addCard8 (24); }
        else if (op == ("sqrt")) {
          bb.addCard8 (12); bb.addCard8 (26); }
        else if (op == ("dup")) {
          bb.addCard8 (12); bb.addCard8 (27); }
        else if (op == ("exch")) {
          bb.addCard8 (12); bb.addCard8 (28); }
        else if (op == ("index")) {
          bb.addCard8 (12); bb.addCard8 (29); }
        else if (op == ("roll")) {
          bb.addCard8 (12); bb.addCard8 (30); }
        else if (op == ("hflex")) {
          bb.addCard8 (12); bb.addCard8 (34); }
        else if (op == ("flex")) {
          bb.addCard8 (12); bb.addCard8 (35); }
        else if (op == ("hflex1")) {
          bb.addCard8 (12); bb.addCard8 (36); }
        else if (op == ("flex1")) {
          bb.addCard8 (12); bb.addCard8 (37); }

        else if (op == ("endchar")) {
          bb.addCard8 (14); }
        else if (op == ("hstemhm")) {
          bb.addCard8 (18); }
        else if (op == ("hintmask")) {
          bb.addCard8 (19); }
        else if (op == ("cntrmask")) {
          bb.addCard8 (20); }
        else if (op == ("rmoveto")) {
          bb.addCard8 (21); }
        else if (op == ("hmoveto")) {
          bb.addCard8 (22); }
        else if (op == ("vstemhm")) {
          bb.addCard8 (23); }
        else if (op == ("rcurveline")) {
          bb.addCard8 (24); }
        else if (op == ("rlinecurve")) {
          bb.addCard8 (25); }
        else if (op == ("vvcurveto")) {
          bb.addCard8 (26); }
        else if (op == ("hhcurveto")) {
          bb.addCard8 (27); }
        else if (op == ("callgsubr")) {
          bb.addCard8 (29); }
        else if (op == ("vhcurveto")) {
          bb.addCard8 (30); }
        else if (op == ("hvcurveto")) {
          bb.addCard8 (31); }
        else {
          throw new InvalidFontException ("invalid Type2 operator: " + op); }}

      else if ('%' == ch [i]) { // comments
        i++;
        while (i &lt; chCount &amp;&amp; '%' != ch [i]) {
          i++; }
        i++; }

      else if ('[' == ch [i]) { // bitmask for hint operators, or other
                                // uninterpreted bytes
        i++;
        while (   i &lt; chCount
               &amp;&amp; (   ('0' &lt;= ch [i] &amp;&amp; ch[i] &lt;= '9')
                   || ('A' &lt;= ch [i] &amp;&amp; ch[i] &lt;= 'F'))) {

          int v = 0;
          if (ch [i] &lt;= '9') {
            v = (ch [i++] - '0'); }
          else {
            v = (ch [i++] - 'A' + 10); }
          v = v &lt;&lt; 4;
          if (ch [i] &lt;= '9') {
            v += (ch [i++] - '0'); }
          else {
            v += (ch [i++] - 'A' + 10); }

          while (i &lt; chCount &amp;&amp; ' ' == ch [i]) {
            i++; }

          bb.addCard8 (v); }
        i++; /* skip the closing ']' */ }

      else if (   '-' == ch [i]
               || ('0' &lt;= ch [i] &amp;&amp; ch [i] &lt;= '9')) {
        int n = 0;
        int sign = 1;
        if (ch [i] == '-') {
          sign = -1;
          i++; }
        while (   i &lt; chCount
               &amp;&amp; '0' &lt;= ch [i]
               &amp;&amp; ch [i] &lt;= '9') {
          n = n * 10 + (ch [i] - '0');
          i++; }
        n = n * sign;

        if (i &lt; chCount &amp;&amp; '/' == ch [i]) {
          i++;
          int d = 0;
          while (  i &lt; chCount
               &amp;&amp; '0' &lt;= ch [i]
               &amp;&amp; ch [i] &lt;= '9') {
            d = d * 10 + (ch [i] - '0');
            i++; }

          bb.addCard8 (255);
          bb.addCard16 (n);
          bb.addCard16 (d); }

        else {
          if (-107 &lt;= n &amp;&amp; n &lt;= 107) {
            bb.addCard8 (n + 139); }
          else if (108 &lt;= n &amp;&amp; n &lt;= 1131) {
            bb.addCard8 ((n - 108) / 256 + 247);
            bb.addCard8 ((n - 108) % 256); }
          else if (-1131 &lt;= n &amp;&amp; n &lt;= -108) {
            bb.addCard8 ((-108 - n) / 256 + 251);
            bb.addCard8 ((-108 - n) % 256); }
          else if (-32768 &lt;= n &amp;&amp; n &lt;= 32767) {
            bb.addCard8 (28);
            bb.addCard16 (n); }
          else {
            throw new InvalidFontException ("integer out of range"); }}}

      else {
        i++; }}

    byte [] result = bb.toArray ();

    return result;
  }
</code-fragment>

      <para>When parsing the charstrings for a name-keyed font, we
	return the glyph names:</para>

<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.fromXMLNames</code-title>
  public String[] fromXMLNames (Element e)
      throws InvalidFontException {
    NodeList nl = e.getChildNodes ();

    charstrings = new byte [nl.getLength ()][];
    String[] names = new String [nl.getLength ()];

    for (int i = 0; i &lt; charstrings.length; i++) {
      Element cs = (Element) (nl.item (i));
      names [i] = cs.getAttribute ("name");
      charstrings [i] = oneCharstringFromXML (cs.getFirstChild ().getNodeValue ()); }

    return names;
  }
</code-fragment>

      <para>When parsing the charstrings for a CID-keyed font, we
	return the CIDs:</para>

<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.fromXMLCids</code-title>
  public int[] fromXMLCids (Element e)
      throws InvalidFontException {
    NodeList nl = e.getChildNodes ();

    charstrings = new byte [nl.getLength ()][];
    int[] cids = new int [nl.getLength ()];

    for (int i = 0; i &lt; charstrings.length; i++) {
      Element cs = (Element) (nl.item (i));
      cids [i] = Integer.decode (cs.getAttribute ("cid")).intValue ();
      charstrings [i] = oneCharstringFromXML (cs.getFirstChild ().getNodeValue ()); }

    return cids;
  }
</code-fragment>

    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cfffontset.innerclasses'>
  <code-title>Type2Consumer class</code-title>
public class Type2Font2XML implements Type2Consumer {

  private CFFCharStrings localSubrs;
  private CFFCharStrings globalSubrs;

  private StringBuilder sb;
  private StringBuilder[] sbStack = new StringBuilder [48];
  private int sbStackDepth = 0;

  public void decompileCharstring (CFFCharStrings charstrings, int i,
                                   CFFCharStrings localSubrs,
				   CFFCharStrings globalSubrs) {

    this.localSubrs = localSubrs;
    this.globalSubrs = globalSubrs;

    sb = charstrings.sbs [i] = new StringBuilder ();
    sbStackDepth = 0;
    Type2Interpreter interp = new Type2Interpreter ();
    interp.decode (charstrings.charstrings [i],
                   localSubrs != null ? localSubrs.charstrings : null,
		   globalSubrs != null ? globalSubrs.charstrings : null,
		   this);
  }


  protected int getCard8 (byte[] data, int offset) {
    int x = data [offset];
    if (x &lt; 0) {
      x += 256; }
    return x;
  }


  public void hstem (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hstem ");
    }

  public void vstem (double stack[], int stackDepth) {
    if (sb != null) sb.append ("vstem ");
    }

  public void vmoveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("vmoveto ");
    }

  public void rlineto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("rlineto ");
    }

  public void hlineto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hlineto ");
    }

  public void vlineto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("vlineto ");
    }

  public void rrcurveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("rrcurveto ");
    }

  public void callsubr (double stack[], int stackDepth, int subr) {
    if (sb != null) sb.append ("callsubr % " + subr + "% ");

    sbStack [sbStackDepth++] = sb;
    if (localSubrs.sbs [subr] == null) {
      localSubrs.sbs [subr] = sb = new StringBuilder (); }
    else {
      sb = null; }
    }

  public void return_op (double stack[], int stackDepth) {
    if (sb != null) sb.append ("return");
    sb = sbStack [--sbStackDepth];
    }

  public void and (double stack[], int stackDepth) {
    if (sb != null) sb.append ("and ");
    }

  public void or (double stack[], int stackDepth) {
    if (sb != null) sb.append ("or ");
    }

  public void not (double stack[], int stackDepth) {
    if (sb != null) sb.append ("not ");
    }

  public void abs (double stack[], int stackDepth) {
    if (sb != null) sb.append ("abs ");
    }

  public void add (double stack[], int stackDepth) {
    if (sb != null) sb.append ("add ");
    }

  public void sub (double stack[], int stackDepth) {
    if (sb != null) sb.append ("sub ");
    }

  public void div (double stack[], int stackDepth) {
    if (sb != null) sb.append ("div ");
    }

  public void neg (double stack[], int stackDepth) {
    if (sb != null) sb.append ("neg ");
    }

  public void eq (double stack[], int stackDepth) {
    if (sb != null) sb.append ("eq ");
    }

  public void drop (double stack[], int stackDepth) {
    if (sb != null) sb.append ("drop ");
    }

  public void put (double stack[], int stackDepth) {
    if (sb != null) sb.append ("put ");
    }

  public void get (double stack[], int stackDepth) {
    if (sb != null) sb.append ("get ");
    }

  public void ifelse (double stack[], int stackDepth) {
    if (sb != null) sb.append ("ifelse ");
    }

  public void random (double stack[], int stackDepth) {
    if (sb != null) sb.append ("random ");
    }

  public void mul (double stack[], int stackDepth) {
    if (sb != null) sb.append ("mul ");
    }

  public void sqrt (double stack[], int stackDepth) {
    if (sb != null) sb.append ("sqrt ");
    }

  public void dup (double stack[], int stackDepth) {
    if (sb != null) sb.append ("dup ");
    }

  public void exch (double stack[], int stackDepth) {
    if (sb != null) sb.append ("exch ");
    }

  public void index (double stack[], int stackDepth) {
    if (sb != null) sb.append ("index ");
    }

  public void roll (double stack[], int stackDepth) {
    if (sb != null) sb.append ("roll ");
    }

  public void hflex (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hflex ");
    }

  public void flex (double stack[], int stackDepth) {
    if (sb != null) sb.append ("flex ");
    }

  public void hflex1 (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hflex1 ");
    }

  public void flex1 (double stack[], int stackDepth) {
    if (sb != null) sb.append ("flex1 ");
    }

  public void endchar (double stack[], int stackDepth) {
    if (sb != null) sb.append ("endchar");
    }

  public void hstemhm (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hstemhm ");
    }

  public void hintmask (double stack[], int stackDepth,
                        byte [] data, int offset, int length) {
    if (sb != null) {
      sb.append ("hintmask[");
      for (int i = offset; i &lt; offset + length; i++) {
        String s = Integer.toHexString (getCard8 (data ,i)).toUpperCase ();
        if (s.length () &lt; 2) {
          sb.append ('0'); }
        sb.append (s); }
      sb.append ("] "); }
  }

  public void cntrmask (double stack[], int stackDepth,
                        byte [] data, int offset, int length) {
    if (sb != null) {
      sb.append ("cntrmask[");
      for (int i = offset; i &lt; offset + length; i++) {
        String s = Integer.toHexString (getCard8 (data ,i)).toUpperCase ();
        if (s.length () &lt; 2) {
          sb.append ('0'); }
        sb.append (s); }
      sb.append ("] "); }
  }

  public void rmoveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("rmoveto ");
    }

  public void hmoveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hmoveto ");
    }

  public void vstemhm (double stack[], int stackDepth) {
    if (sb != null) sb.append ("vstemhm ");
    }

  public void implicit_vstemhm (double stack[], int stackDepth) {
    if (sb != null) sb.append ("% vstemhm % ");
  }

  public void rcurveline (double stack[], int stackDepth) {
    if (sb != null) sb.append ("rcurveline ");
    }

  public void rlinecurve (double stack[], int stackDepth) {
    if (sb != null) sb.append ("rlinecurve ");
    }

  public void vvcurveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("vvcurveto ");
    }

  public void hhcurveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hhcurveto ");
    }

  public void callgsubr (double stack[], int stackDepth, int subr) {
    if (sb != null) sb.append ("callgsubr % " + subr + " % ");

    sbStack [sbStackDepth++] = sb;
    if (globalSubrs.sbs [subr] == null) {
      globalSubrs.sbs [subr] = sb = new StringBuilder (); }
    else {
      sb = null; /* already visited */ }
    }

  public void vhcurveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("vhcurveto ");
    }

  public void hvcurveto (double stack[], int stackDepth) {
    if (sb != null) sb.append ("hvcurveto ");
    }

  public void integer (double stack[], int stackDepth, int i) {
    if (sb != null) sb.append ("" + i + " ");
    }

  public void fraction (double stack[], int stackDepth, int a, int b) {
    if (sb != null) {
      sb.append ("" + a + "/" + b + " "); }
    }

  public void reserved (double stack[], int stackDepth, int i) {
    if (sb != null) sb.append ("reserved/" + i + " ");
    }

  public void reserved2 (double stack[], int stackDepth, int i) {
    if (sb != null) sb.append ("reserved2/" + i + " ");
    }
}
</code-fragment>



<code-fragment id='cffcharstrings.methods'>
  <code-title>CFFCharStrings.toXML</code-title>
  public StringBuilder[] sbs = null;

  public void initSbs () {
    sbs = new StringBuilder [charstrings.length];
    for (int i = 0; i &lt; sbs.length; i++) {
      sbs [i] = null; }
  }

  public void toXML (ContentHandlerPlus ch, String s)
      throws org.xml.sax.SAXException {
    ch.startElement (s); {
      for (int i = 0; i &lt; charstrings.length; i++) {
        AttributesImpl at;
        at = new AttributesImpl ();
        at.addAttribute ("", "id", "id", "CDATA", "" + i);
        ch.startElement ("charstring", at); {
	  if (sbs [i] == null) {
	    ch.characters ("%**** UNUSED ****%"); }
          else {
            ch.characters (sbs[i].toString ()); }
          ch.endElement ("charstring"); }}
      ch.endElement (s); }
  }

  public String toXML (byte b[]) {
    StringBuilder s = new StringBuilder ();

    char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7',
                     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

    for (int i = 0; i &lt; b.length; i++) {
      s.append ('%');
      s.append (digits [(b[i] >>4) &amp; 0xf]);
      s.append (digits [b[i]       &amp; 0xf]);
      s.append (' '); }

    return s.toString ();
  }

  public void toXML (ContentHandlerPlus ch, String s, String[] glyphNames)
      throws org.xml.sax.SAXException {
    ch.startElement (s); {
      for (int i = 0; i &lt; charstrings.length; i++) {
        AttributesImpl at;
        at = new AttributesImpl ();
        at.addAttribute ("", "id", "id", "CDATA", "" + i);
        at.addAttribute ("", "name", "name", "CDATA", glyphNames [i]);
        ch.startElement ("charstring", at); {
          ch.characters (sbs [i].toString ());
          ch.endElement ("charstring"); }}
      ch.endElement (s); }
  }

  public void toXML (ContentHandlerPlus ch, String s, int[] cids)
      throws org.xml.sax.SAXException {
    ch.startElement (s); {
      for (int i = 0; i &lt; charstrings.length; i++) {
        AttributesImpl at;
        at = new AttributesImpl ();
        at.addAttribute ("", "id", "id", "CDATA", "" + i);
        at.addAttribute ("", "cid", "cid", "CDATA", "" + cids [i]);
        ch.startElement ("charstring", at); {
          ch.characters (sbs [i].toString ());
          ch.endElement ("charstring"); }}
      ch.endElement (s); }
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Private DICT Data</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
        <title>Specification</title>

        <para>The names of the Private DICT operators shown in Table
          23 are, where possible, the same as the corresponding Type 1
          dict keys. Operators that have no corresponding Type 1 dict
          key are indicated with a note in Table 23.</para>

        <table>
          <title>Private DICT Operators</title>
          <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='3pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='12pc'/>
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Value</entry>
                <entry>Operand(s)</entry>
                <entry>Default, notes</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>BlueValues</entry>
                <entry>6</entry>
                <entry>delta</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>OtherBlues</entry>
                <entry>7</entry>
                <entry>delta</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>FamilyBlues</entry>
                <entry>8</entry>
                <entry>delta</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>FamilyOtherBlues</entry>
                <entry>9</entry>
                <entry>delta</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>BlueScale</entry>
                <entry>12 9</entry>
                <entry>number</entry>
                <entry>0.039625</entry>
              </row>
              <row>
                <entry>BlueShift</entry>
                <entry>12 10</entry>
                <entry>number</entry>
                <entry>7</entry>
              </row>
              <row>
                <entry>BlueFuzz</entry>
                <entry>12 11</entry>
                <entry>number</entry>
                <entry>1</entry>
              </row>
              <row>
                <entry>StdHW</entry>
                <entry>10</entry>
                <entry>number</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>StdVW</entry>
                <entry>11</entry>
                <entry>number</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>StemSnapH</entry>
                <entry>12 12</entry>
                <entry>delta</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>StemSnapV</entry>
                <entry>12 13</entry>
                <entry>delta</entry>
                <entry>&#x2013;</entry>
              </row>
              <row>
                <entry>ForceBold</entry>
                <entry>12 14</entry>
                <entry>boolean</entry>
                <entry>false</entry>
              </row>
              <row>
                <entry>LanguageGroup</entry>
                <entry>12 17</entry>
                <entry>number</entry>
                <entry>0</entry>
              </row>
              <row>
                <entry>ExpansionFactor</entry>
                <entry>12 18</entry>
                <entry>number</entry>
                <entry>0.06</entry>
              </row>
              <row>
                <entry>initialRandomSeed</entry>
                <entry>12 19</entry>
                <entry>number</entry>
                <entry>0</entry>
              </row>
              <row>
                <entry>Subrs</entry>
                <entry>19</entry>
                <entry>number</entry>
                <entry>&#x2013;, Offset (self) to local subrs</entry>
              </row>
              <row>
                <entry>defaultWidthX</entry>
                <entry>20</entry>
                <entry>number</entry>
                <entry>0, see below</entry>
              </row>
              <row>
                <entry>nominalWidthX</entry>
                <entry>21</entry>
                <entry>number</entry>
                <entry>0, see below</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The local subrs offset is relative to the beginning of
          the Private DICT data.</para>
        <para>The defaultWidthX and nominalWidthX operators supply
          width values for glyphs. If a glyph width equals the
          defaultWidthX value it can be omitted from the charstring,
          otherwise the glyph width is computed by adding the
          charstring width to nominalWidthX value. If nominalWidthX is
          carefully chosen the bulk of the widths in the charstrings
          can be reduced from 2-byte to single-byte numbers thereby
          saving space.</para>
        <para>The OtherBlues and FamilyOtherBlues operators must occur
          after the BlueValues and FamilyBlues operators,
          respectively.</para>
        <para>A Private DICT is required, but may be specified as
          having a length of 0 if there are no non-default values to
          be stored.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>As mentioned previously, this section should be replicated
	within sections 9 and 19, with the appropriate specialization.</para>
    </section>

  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Local/Global Subrs INDEXes</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>Both Type 1 and Type 2 charstrings support the notion of
        subroutines or subrs. A subr is typically a sequence of
        charstring bytes representing a sub-program that occurs in
        more than one place in a font's charstring data. This
        subr may be stored once but referenced many times from
        within one or more charstrings by the use of the callsubr
        operator whose operand is the number of the subr to be
        called. The subrs are local to a particular font and cannot
        be shared between fonts. Type 2 charstrings also permit
        global subrs which function in the same way but are called
        by the callgsubr operator and may be shared across
        fonts.</para>
      <para>Local subrs are stored in an INDEX structure which is
        located via the offset operand of the Subrs operator in the
        Private DICT. A font without local subrs has no Subrs
        operator in the Private DICT.</para>
      <para>Global subrs are stored in an INDEX structure which
        follows the String INDEX. A FontSet without any global subrs
        is represented by an empty Global Subrs INDEX.</para>
      <para>Subr numbers in Type 2 charstrings are skewed by a
        number called the "subr number bias" which is calculated
        from the count of the subroutines in either the local or
        global subr INDEXes. The bias is calculated as
        follows:</para>

<code-fragment>
<![CDATA[
Card16 bias;
Card16 nSubrs = subrINDEX.count;
if (CharstringType == 1)
  bias = 0;
else if (nSubrs < 1240)
  bias = 107;
else if (nSubrs < 33900)
  bias = 1131;
else
  bias = 32768;
]]>
</code-fragment>

      <para>For correct subr selection the calculated bias must be
        added to the subr number operand before accessing the
        appropriate subr INDEX. This technique allows subr numbers
        to be specified using negative as well as positive numbers
        thereby fully utilizing the available number ranges and thus
        saving space. (The above calculation obviates the need for
        an explicit bias to be stored in the font which is currently
        the case for Type 1 fonts.) Tables 24, 25, and 26 show the
        relationship between subr indices, numbers, number sizes and
        range counts for the different biasing schemes (column
        headings are described following Table 26).</para>

      <table>
        <title>nSubrs &lt; 1240, bias = 107</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='3pc'/>
          <colspec colwidth='3pc'/>
          <thead>
            <row>
              <entry>Ordered index</entry>
              <entry>Reorder index</entry>
              <entry>Biased number</entry>
              <entry>Size</entry>
              <entry>Count</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0 &#x2013; 214</entry>
              <entry>0 &#x2013; 214</entry>
              <entry>-107 &#x2013; +107</entry>
              <entry>1</entry>
              <entry>215</entry>
            </row>
            <row>
              <entry>215 &#x2013; 1238</entry>
              <entry>215 &#x2013; 1238</entry>
              <entry>+108 &#x2013; +1131</entry>
              <entry>2</entry>
              <entry>1024</entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>Total</entry>
              <entry>1239</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>nSubrs &lt; 33900, bias = 1131</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='3pc'/>
          <colspec colwidth='3pc'/>
          <thead>
            <row>
              <entry>Ordered index</entry>
              <entry>Reorder index</entry>
              <entry>Biased number</entry>
              <entry>Size</entry>
              <entry>Count</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0 &#x2013; 214</entry>
              <entry>1024 &#x2013; 1238</entry>
              <entry>-107 &#x2013; +107</entry>
              <entry>1</entry>
              <entry>215</entry>
            </row>
            <row>
              <entry>215 &#x2013; 1238</entry>
              <entry>0 &#x2013; 1023</entry>
              <entry>-1131 &#x2013; -108</entry>
              <entry>2</entry>
              <entry>1024</entry>
            </row>
            <row>
              <entry>1239 &#x2013; 2262</entry>
              <entry>1239 &#x2013; 2262</entry>
              <entry>+108 &#x2013; +1131</entry>
              <entry>2</entry>
              <entry>1024</entry>
            </row>
            <row>
              <entry>2263 &#x2013; 33898</entry>
              <entry>2263 &#x2013; 33898</entry>
              <entry>+1132 &#x2013; +32767</entry>
              <entry>3</entry>
              <entry>31636</entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>Total</entry>
              <entry> 33899</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>nSubrs >= 33900, bias = 32768</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='3pc'/>
          <colspec colwidth='3pc'/>
          <thead>
            <row>
              <entry>Ordered index</entry>
              <entry>Reorder index</entry>
              <entry>Biased number</entry>
              <entry>Size</entry>
              <entry>Count</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0 &#x2013; 214</entry>
              <entry>32661 &#x2013; 32875</entry>
              <entry>-107 &#x2013; +107</entry>
              <entry>1</entry>
              <entry>215</entry>
            </row>
            <row>
              <entry>215 &#x2013; 1238</entry>
              <entry>31637 &#x2013; 32660</entry>
              <entry>-1131 &#x2013; -108</entry>
              <entry>2</entry>
              <entry>1024</entry>
            </row>
            <row>
              <entry>1239 &#x2013; 2262</entry>
              <entry>32876 &#x2013; 33899</entry>
              <entry>+108 &#x2013; +1131</entry>
              <entry>2</entry>
              <entry>1024</entry>
            </row>
            <row>
              <entry>2263 &#x2013; 33899</entry>
              <entry>0 &#x2013; 31636</entry>
              <entry>-32768 &#x2013; -1132</entry>
              <entry>3</entry>
              <entry>31637</entry>
            </row>
            <row>
              <entry>33900 &#x2013; 65535</entry>
              <entry>33900 &#x2013; 65535</entry>
              <entry>+1132 &#x2013; +32767</entry>
              <entry>3</entry>
              <entry>31636</entry>
            </row>
            <row>
              <entry></entry>
              <entry></entry>
              <entry></entry>
              <entry>Total</entry>
              <entry> 65536</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Where the column headings are interpreted as follows:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <tbody>
            <row>
              <entry>Ordered index</entry>
              <entry>subr index ordered by most frequent subr
                first.</entry>
            </row>
            <row>
              <entry>Reorder index</entry>
              <entry>ordered index reordered for bias (this is the
                index of subrs in the local/global Subr INDEX
                structures).</entry>
            </row>
            <row>
              <entry>Biased number</entry>
              <entry>reorder index with bias subtracted
                (callsubr/callgsubr operand).</entry>
            </row>
            <row>
              <entry>Size</entry>
              <entry>biased number size (bytes).</entry>
            </row>
            <row>
              <entry>Count</entry>
              <entry>number of subrs in range.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Synthetic Fonts</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>A synthetic font is a modification of another font by
        means of a different transformation matrix or encoding.
        Obliqued, expanded, and condensed fonts are examples of
        fonts that may be constructed as synthetic fonts.</para>

      <para>Synthetic fonts have a name and a Top DICT that refers
        to a base font. The Top DICT may contain the following
        operators: FullName, ItalicAngle, FontMatrix, SyntheticBase,
        and Encoding.</para>

      <para>The SyntheticBase operator is required and specifies the
        zero-based index of the font that is to be used as the base
        font. The FontMatrix and/or Encoding is applied to this font
        in order to algorithmically create a new font. The other
        operator values override those given in the base font. The
        Top DICT must begin with a SyntheticBase operator. The base
        font shall not be a CIDkeyed font or a synthetic
        font.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>The synthetic font mechanism applies only to CFF
        structures that contain more than one font (at least the
        base and the synthetic font).</para>

      <para>The legal operators in the TopDict of a synthetic are:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='15pc'/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Required</entry>
              <entry>Default</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>SyntheticBase</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry>must be the first operator in the Top DICT</entry>
            </row>
            <row>
              <entry>FullName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>ItalicAngle</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>FontMatrix</entry>
              <entry>N</entry>
              <entry>0.001 0 0 0.001 0 0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>Encoding</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>It is unclear if the FullName is required.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

<code-fragment id='cfffontset.innerclasses'>
  public class CFFSyntheticFont implements CFFFont {
    protected String name;
    protected Map&lt;String, Operator> topDICT;

    <code-include linkend='cffsyntheticfont.methods'/>
}
</code-fragment>

      <para></para>

<code-fragment id='cffsyntheticfont.methods'>
  public String getName () {
    return name;
  }

  public String getGlyphName (int gid) {
    return "TODO: Synthetic.getGlyphName";
  }

  public void getGlyphOutline (int gid, StringBuilder sb) {
    System.err.println ("TODO: Synthetic.getGlyphOutline");
  }

  public void getGlyphLinesAndCurves (int gid, StringBuilder sb) {
    System.err.println ("TODO: Synthetic.getGlyphLinesAndCurves");
  }

  public BoundingBox getGlyphBoundingBox (int gid) {
    System.err.println ("TODO: Synthetic.getGlyphBoundingBox");
    return new BoundingBox ();
  }

  public int getGlyphID (String glyphname) {
    System.err.println ("TODO: Synthetic.getGlyphID");
    return 0;
  }
</code-fragment>

      <para>Currently, we do not handle the conversion of synthetic
	fonts to CID.</para>

<code-fragment id='cffsyntheticfont.methods'>
  <code-title>Method to convert to CID</code-title>
  public CFFFont toCID () {
    return this;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

<code-fragment id='cffsyntheticfont.methods'>
  public void fromBinary (byte[] data,
                          String name,
                          Map&lt;String, Operator> topDICT,
                          String[] strings)
      throws InvalidFontException {

    this.name = name;
    this.topDICT = topDICT;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

<code-fragment id='schema'>
  synthetic-font =
    attribute name { text },

    element SyntheticBase { SyntheticBase },
    element FullName { FullName }?,
    element ItalicAngle { ItalicAngle }?,
    element FontMatrix { FontMatrix }?,
    element encoding { encoding }?
</code-fragment>
    </section>


    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

<code-fragment id='cffsyntheticfont.methods'>
  public void collectStrings (List&lt;String> strings) {
  }

  public void topDictToBinary (ByteBuffer bb, List&lt;String> strings) {
  }

  public void restToBinary (ByteBuffer bb, List&lt;String> strings) { }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
      <title>Compiler</title>

<code-fragment id='cffsyntheticfont.methods'>
  public void fromXML (Element cff) {
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

<code-fragment id='cffsyntheticfont.methods'>
  <code-title>Method to output to XML</code-title>
  public void toXML (com.adobe.aots.util.ContentHandlerPlus ch,
                     Type2Font2XML t2Processor)
      throws org.xml.sax.SAXException {
  }
</code-fragment>

    </section>

  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>CID-keyed Fonts</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>The representation of a CIDFont is designed to be
        separable from its encoding. In keeping with this strategy,
        the CFF representation does not include any encoding
        information which instead resides in a CMap file. If a need
        arises for a more compact representation of the CMap file,
        CFF can be extended to accommodate it.</para>

      <para>A CFF CIDFont has the CIDFontName in the Name INDEX and
        a corresponding Top DICT. The Top DICT begins with ROS
        operator which specifies the Registry-Ordering-Supplement
        for the font. This will indicate to a CFF parser that
        special CID processing should be applied to this font.
        Specifically:</para>

      <itemizedlist>
        <listitem>
          <para>The FDArray operator is expected to be present, with
            a single argument specifying an offset to the Font DICT
            INDEX. Each Font DICT in this array specifies
            information unique to a particular group of glyphs in
            the font. The mapping of glyphs to Font DICTs is
            specified by the FDSelect structure described below.
            Each Font DICT will specify a corresponding Private DICT
            with the Private DICT operator.</para>
        </listitem>
        <listitem>
          <para>The charset data, although in the same format as
            non- CIDFonts, will represent CIDs rather than SIDs,
            i.e. charstrings are "named" by CIDs in a CIDFont.
            In a complete CIDFont the charset table will specify an
            identity mapping (where GID equals CID for all glyphs)
            as a single range beginning at CID 1 (CID 0, the .notdef
            glyph, is omitted) that covers all the glyphs in the
            font. Subset CIDFonts will generally need to use a more
            complex charset table representing a non-identity
            mapping (where CID doesn't equal GID).</para>
        </listitem>
        <listitem>
          <para>The Top DICT will include an FDSelect operator
            specifying an offset to a charset-like data structure
            (see next section) which contains a, possibly
            range-encoded, list of indexes, from which a single
            index may be derived for each glyph. The index
            identifies the Font DICT, and therefore the Private
            DICT, to be used when rasterizing a glyph.</para>
        </listitem>
        <listitem>
          <para>The encoding data is omitted (see above); no
            Encoding operator will be present and the default
            StandardEncoding should not be applied.</para>
        </listitem>
      </itemizedlist>
    </section>

    <!--______________________________________________________________________-->
    <section>
      <title>Annotation</title>

      <para>The legal operators in the TopDict of a CID-keyed are:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='15pc'/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Required</entry>
              <entry>Default</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>ROS</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry>must be the first operator in the Top DICT</entry>
            </row>
            <row>
              <entry>CIDFontVersion</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>CIDFontRevision</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>CIDFontType</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry>[what is this?]</entry>
            </row>
            <row>
              <entry>CIDCount</entry>
              <entry>N</entry>
              <entry>8720</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UIDBase</entry>
              <entry>N</entry>
              <entry></entry>
              <entry>[what is this?]</entry>
            </row>
            <row>
              <entry>FDArray</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FDSelect</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>version</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Notice</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Copyright</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FullName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FamilyName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>Weight</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>isFixedPitch</entry>
              <entry>N</entry>
              <entry>0 (false)</entry>
              <entry></entry>
            </row>
            <row>
              <entry>ItalicAngle</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UnderlinePosition</entry>
              <entry>N</entry>
              <entry>-100</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UnderlineThickness</entry>
              <entry>N</entry>
              <entry>50</entry>
              <entry></entry>
            </row>
            <row>
              <entry>PaintType</entry>
              <entry>N</entry>
              <entry>2</entry>
              <entry></entry>
            </row>
            <row>
              <entry>CharstringType</entry>
              <entry>N</entry>
              <entry>2</entry>
              <entry></entry>
            </row>
            <row>
              <entry>UniqueID</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FontBBox</entry>
              <entry>N</entry>
              <entry>0 0 0 0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>StrokeWidth</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>XUID</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>charset</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry>maps GIDs to CIDs</entry>
            </row>
            <row>
              <entry>CharStrings</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>PostScript</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>BaseFontName</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>BaseFontBlend</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The legal operators in a Font DICT (pointed by FDArray in
        the Top DICT) are:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='15pc'/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Required</entry>
              <entry>Default</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>FontName</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FontMatrix</entry>
              <entry>N</entry>
              <entry>0.001 0 0 0.001 0 0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>Private</entry>
              <entry>Y</entry>
              <entry></entry>
              <entry>Private must point to a DICT, but that DICT can
                be empty</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>The legal operators in a Private DICT (pointed by Private in a
        Font DICT, itself pointed by FDArray in the Top DICT) are:</para>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='7pc'/>
          <colspec colwidth='15pc'/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Required</entry>
              <entry>Default</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>BlueValues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>OtherBlues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry>if present, BlueValues must be present, and
                OtherBlues must occur after BlueValues</entry>
            </row>
            <row>
              <entry>FamilyBlues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>FamilyOtherBlues</entry>
              <entry>N</entry>
              <entry></entry>
              <entry>if present, FamiliyBlues must be present, and
                FamilyOtherBlues must occur after FamilyBlues</entry>
            </row>
            <row>
              <entry>BlueScale</entry>
              <entry>N</entry>
              <entry>0.039625</entry>
              <entry></entry>
            </row>
            <row>
              <entry>BlueShift</entry>
              <entry>N</entry>
              <entry>7</entry>
              <entry></entry>
            </row>
            <row>
              <entry>BlueFuzz</entry>
              <entry>N</entry>
              <entry>1</entry>
              <entry></entry>
            </row>
            <row>
              <entry>StdHW</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>StdVW</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>StemSnapH</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>StemSnapV</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>ForceBold</entry>
              <entry>N</entry>
              <entry>0 (false)</entry>
              <entry></entry>
            </row>
            <row>
              <entry>LanguageGroup</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>ExpansionFactor</entry>
              <entry>N</entry>
              <entry>0.06</entry>
              <entry></entry>
            </row>
            <row>
              <entry>initialRandomSeed</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>Subrs</entry>
              <entry>N</entry>
              <entry></entry>
              <entry></entry>
            </row>
            <row>
              <entry>defaultWidthX</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
            <row>
              <entry>nominalWidthX</entry>
              <entry>N</entry>
              <entry>0</entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Note that each Private dictionary points to a set of
        subroutines. The same set of subroutines can be shared by
        all the Private dictionaries, or they can all be different,
        or anything in between.</para>

      <para>When interpreting the charstring for a glyph, local
        subroutine called are resolved against the Subrs of the Font
        DICT to which that glyph belongs.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Following our recommendation in section 2, here is the
        class that represents a CID-keyed font:</para>

<code-fragment id='cfffontset.innerclasses'>
  public class CFFCIDKeyedFont implements CFFFont {
    <code-include linkend='cffcidkeyedfont.members'/>
    <code-include linkend='cffcidkeyedfont.methods'/>
  }
</code-fragment>

      <para>Before we go further, we need to observe that a CID font
        is an agglomeration of components, each one with its
        dictionary, charstrings and local subroutines. Here is a
        class to capture just that:</para>

<code-fragment id='cfffontset.innerclasses'>
  public class CFFCIDComponentFont {
    public String name;
    public Map&lt;String, Operator> dict;
    public CFFCharStrings localSubrs;
  }
</code-fragment>

      <para>Here is the internal representation of cid-keyed fonts:
        <itemizedlist>
          <listitem>
            <para><varname>name</varname> contains the font name (from
              the Name INDEX).</para>
            </listitem>
          <listitem>
            <para><varname>dict</varname> contains the Top DICT</para>
          </listitem>
          <listitem>
            <para><varname>cids</varname> is an array indexed by
              glyphID; it contains the CID for that glyph.</para>
          </listitem>
          <listitem>
            <para><varname>components</varname> is an array that
              contains the components of the CID font.</para>
          </listitem>
        </itemizedlist></para>

<code-fragment id='cffcidkeyedfont.members'>
  <code-title>CFFCIDKeyedFont members</code-title>
  protected String name;
  protected Map&lt;String, Operator> dict;
  protected int[] cids;
  public CFFCharStrings charstrings;
  protected int[][] fdselect;

  protected CFFCIDComponentFont[] components;
</code-fragment>

      <para>Here are the implementation of the methods that
        answer questions about the font:</para>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>General purpose methods</code-title>
  public String getName () {
    return name;
  }

  public String getGlyphName (int gid) {
    return "TODO: CID.getGlyphName";
  }

  public void getGlyphOutline (int gid, StringBuilder sb) {
    int fdIndex = gid2fontdict (gid);
    Type22Pdf c = new Type22Pdf (sb, 0d, 0d);
    Type2Interpreter i = new Type2Interpreter ();
    i.decode (charstrings.charstrings [gid],
 	      components [fdIndex].localSubrs != null ?
	           components [fdIndex].localSubrs.charstrings : null,
	      globalSubrs != null ? globalSubrs.charstrings : null,
	      c);
  }

  class X extends Type2LinesAndCurves {

    protected StringBuilder sb;

    public X (StringBuilder sb) {
      this.sb = sb;
    }

    public void line (double x1, double y1, double x2, double y2) {
      sb.append ("line from " + x1 + ", " + y1 + " to " +
	               + x2 + ", " + y2 + "\n");
    }

    public void curve (double x1, double y1, double x2, double y2,
               double x3, double y3, double x4, double y4) {

      sb.append ("curve " + x1 + "," + y1 + "  " +
	               + x2 + "," + y2 + "  "
	               + x3 + "," + y3 + "  "
	               + x4 + "," + y4 + "\n");
    }
  }

  public void getGlyphLinesAndCurves (int gid, StringBuilder sb) {
    int fdIndex = gid2fontdict (gid);
    Type2Consumer c = new X (sb);
    Type2Interpreter i = new Type2Interpreter ();
    i.decode (charstrings.charstrings [gid],
 	      components [fdIndex].localSubrs != null ?
	           components [fdIndex].localSubrs.charstrings : null,
	      globalSubrs != null ? globalSubrs.charstrings : null,
	      c);
  }


  public BoundingBox getGlyphBoundingBox (int gid) {
    int fdIndex = gid2fontdict (gid);
    Type2BoundingBox c = new Type2BoundingBox ();
    Type2Interpreter i = new Type2Interpreter ();
    i.decode (charstrings.charstrings [gid],
 	      components [fdIndex].localSubrs != null ?
	           components [fdIndex].localSubrs.charstrings : null,
	      globalSubrs != null ? globalSubrs.charstrings : null,
	      c);
    return c.bb;
  }

  public int getGlyphID (String glyphname) {
    System.err.println ("TODO: CID.getGlyphID");
    return 0;
  }
</code-fragment>

      <para>There is not much to do convert a CID-keyed font to be
	CID-keyed!</para>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>Method to convert to CID</code-title>
  public CFFFont toCID () {
    return this;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

      <para>Here is our fromBinary method, which is given the
        topDICT and further explores the data from there to fill our
        internal representation.</para>

<code-fragment id='cffcidkeyedfont.methods'>
  public void fromBinary (byte[] data,
                          String name,
                          Map&lt;String, Operator> topDICT,
                          String[] strings)
      throws InvalidFontException {

    this.name = name;
    this.dict = topDICT;

    { IntegerOp o = (IntegerOp) dict.get ("CharStrings");
      if (o == null) {
        throw new InvalidFontException ("missing TopDICT/CharStrings"); }
      charstrings = new CFFCharStrings ();
      charstrings.fromBinary (data, o.value); }

    int numGlyphs = charstrings.numGlyphs ();

    { IntegerOp o = (IntegerOp) dict.get ("charset");
      int offset = 0;
      if (o != null) {
        offset = o.value; }
      cids = charsetFromBinary (data, offset, numGlyphs); }

    { IntegerOp o = (IntegerOp) dict.get ("FDArray");
      if (o != null) {
        int offset = o.value;

        int[] dictOffsets = getINDEXOffsets (data, offset);

        components = new CFFCIDComponentFont [dictOffsets.length - 1];

        for (int i = 0; i &lt; components.length; i++) {
          components [i] = new CFFCIDComponentFont ();
          components [i].dict = dictFromBinary (null,
                                                data,
                                                dictOffsets [i],
                                                dictOffsets [i+1] - dictOffsets [i],
                                                strings);

          { StringOp v2 = (StringOp) components [i].dict.get ("FontName");
            if (v2 == null) {
              throw new InvalidFontException ("FontDICT/FontName absent"); }
            components [i].name = v2.value; }

          { PrivateOp v2 = (PrivateOp) components [i].dict.get ("Private");
            if (v2 != null) {
              components [i].dict = dictFromBinary (components [i].dict,
                                                    data, v2.offset, v2.size,
                                                    strings);
              IntegerOp o3 = (IntegerOp) components [i].dict.get ("Subrs");
              if (o3 != null) {
                components [i].localSubrs = new CFFCharStrings ();
                components [i].localSubrs.fromBinary (data, v2.offset + o3.value);}}}}}}

    { IntegerOp v = (IntegerOp) dict.get ("FDSelect");
      if (v != null) {
        fdselect = fdSelectFromBinary (data, v.value, numGlyphs); }}
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>Our strategy to convert CID-keyed fonts is similar to that
	used for named-keyed fonts:</para>

<code-fragment id='cffcidkeyedfont.members'>
  <code-title>Remembering offsets locations</code-title>
  private OffsetOp charsetOp = null;
  private OffsetOp charstringsOp = null;
  private OffsetOp fdSelectOp = null;
  private OffsetOp fdArrayOp = null;
</code-fragment>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>Methods to convert to binary</code-title>
  public void collectStrings (List&lt;String> strings) {
    collectStringsInDict (strings, dict);

    for (int i = 0; i &lt; components.length; i++) {
      if (strings.indexOf (components [i].name) == -1) {
        strings.add (components [i].name); }
      collectStringsInDict (strings, components [i].dict); }
  }

  public void topDictToBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {
    String[] topKeys = {"ROS", "CIDFontVersion", "CIDFontRevision",
                        "CIDFontType", "CIDCount", "UIDBase", "FontName",

                      "version", "Notice", "Copyright", "FullName",
                      "FamilyName", "Weight", "isFixedPitch", "ItalicAngle",
                      "UnderlinePosition", "UnderlineThickness",
                      "PaintType", "CharstringType",
                      "UniqueID", "FontBBox", "StrokeWidth", "XUID",
                      "PostScript", "BaseFontName", "BaseFontBlend"};
    for (int i = 0; i &lt; topKeys.length; i++) {
      Operator op = (Operator) dict.get (topKeys [i]);
      if (op != null) {
         op.toBinary (bb, strings); }}

    // don't bother with predefined charsets
    charsetOp = new OffsetOp (true, 15, "charset");
    charsetOp.toBinary (bb, strings);

    charstringsOp = new OffsetOp (true, 17, "CharStrings");
    charstringsOp.toBinary (bb, strings);

    fdSelectOp = new OffsetOp (false, 37, "FDSelect");
    fdSelectOp.toBinary (bb, strings);

    fdArrayOp = new OffsetOp (false, 36, "FDArray");
    fdArrayOp.toBinary (bb, strings);
  }

  public void restToBinary (ByteBuffer bb, List&lt;String> strings)
        throws InvalidFontException {

    charsetOp.fixOffset (bb, bb.length ());
    numsetToBinary (bb, cids);

    charstringsOp.fixOffset (bb, bb.length ());
    charstrings.toBinary (bb);

    fdSelectOp.fixOffset (bb, bb.length ());
    fdSelectToBinary (bb, fdselect);

    fdArrayOp.fixOffset (bb, bb.length ());
    IndexCursor indexCursor = startIndex (bb, components.length);
    PrivateOp privateOps [] = new PrivateOp [components.length];
    for (int c = 0; c &lt; components.length; c++) {
      StringOp op = new StringOp (false, 38, "FontName");
      op.value = components [c].name;
      op.toBinary (bb, strings);

      MatrixOp op2 = (MatrixOp) components [c].dict.get ("FontMatrix");
      if (op2 != null) {
        op2.toBinary (bb, strings); }

      privateOps [c] = new PrivateOp (true, 18, "Private");
      privateOps [c].toBinary (bb, strings);

      indexCursor = elementEntered (bb, indexCursor); }

    String[] privateKeys = {"BlueValues", "OtherBlues", "FamilyBlues",
                          "FamilyOtherBlues", "BlueScale", "BlueShift",
                          "BlueFuzz", "StdHW", "StdVW", "StemSnapH",
                          "StemSnapV", "ForceBold", "LanguageGroup",
                          "ExpansionFactor", "initialRandomSeed",
                          "defaultWidthX", "nominalWidthX"};

    for (int c = 0; c &lt; components.length; c++) {
      privateOps [c].fixOffset (bb, bb.length ());
      int privateStart = bb.length ();

      for (int i = 0; i &lt; privateKeys.length; i++) {
        Operator op = (Operator) components [c].dict.get (privateKeys [i]);
        if (op != null) {
          op.toBinary (bb, strings); }}

      if (components [c].localSubrs != null) {
        OffsetOp subrsOp = new OffsetOp (true, 19, "Subrs");
        subrsOp.toBinary (bb, strings);

        privateOps [c].fixSize (bb, bb.length () - privateStart);

        subrsOp.fixOffset (bb, bb.length () - privateStart);
        components [c].localSubrs.toBinary (bb); }

      else {
        privateOps [c].fixSize (bb, bb.length () - privateStart); }}
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

<code-fragment id='schema'>
  cid-keyed-font =
    attribute name { text },

    element ROS    { ROS },
    element CIDFontVersion { CIDFontVersion }?,
    element CIDFontRevision { CIDFontRevision }?,
    element CIDFontType { CIDFontType }?,
    element CIDCount { CIDCount }?,
    element UIDBase { UIDBase }?,

    element version { version }?,
    element Notice { Notice }?,
    element Copyright { Copyright }?,
    element FullName { FullName }?,
    element FamilyName { FamilyName }?,
    element Weight { Weight }?,
    element isFixedPitch { isFixedPitch }?,
    element ItalicAngle { ItalicAngle }?,
    element UnderlinePosition { UnderlinePosition }?,
    element UnderlineThickness { UnderlineThickness }?,
    element PaintType { PaintType }?,
    element CharstringType { CharstringType }?,
    element UniqueID { UniqueID }?,
    element FontBBox { FontBBox }?,
    element StrokeWidth { StrokeWidth }?,
    element XUID { XUID }?,
    element PostScript { PostScript }?,
    element BaseFontName { BaseFontName }?,
    element BaseFontBlend { BaseFontBlend }?,

    element charstrings { charstrings },
    element cid-components { cid-components }?,
    element fdselect { fdselect }

  cid-components =
    element cid-component { cid-component }*

  cid-component =
    attribute name { text },

    element FontMatrix { FontMatrix }?,
    element BlueValues { BlueValues }?,
    element OtherBlues { OtherBlues }?,
    element FamilyBlues { FamilyBlues }?,
    element FamilyOtherBlues { FamilyOtherBlues }?,
    element BlueScale { BlueScale }?,
    element BlueShift { BlueShift }?,
    element BlueFuzz { BlueFuzz }?,
    element StdHW { StdHW }?,
    element StdVW { StdVW }?,
    element StemSnapH { StemSnapH }?,
    element StemSnapV { StemSnapV }?,
    element ForceBold { ForceBold }?,
    element LanguageGroup { LanguageGroup }?,
    element ExpansionFactor { ExpansionFactor }?,
    element initialRandomSeed { initialRandomSeed }?,
    element defaultWidthX { defaultWidthX }?,
    element nominalWidthX { nominalWidthX }?,

    element localSubrs { localSubrs }?
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
      <title>Compiler</title>

<code-fragment id='cffcidkeyedfont.methods'>
  public void fromXML (Element cidKeyedFont)
      throws InvalidFontException {
    name = cidKeyedFont.getAttribute ("name");

    dict = new java.util.HashMap&lt;String, Operator> ();

    NodeList nl = cidKeyedFont.getChildNodes ();
    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element e = (Element) nl.item (i);

      if ("charstrings".equals (e.getTagName ())) {
        charstrings = new CFFCharStrings ();
        cids = charstrings.fromXMLCids (e); }

      else if ("cid-components".equals (e.getTagName ())) {
        NodeList nl3 = e.getChildNodes ();
        components = new CFFCIDComponentFont [nl3.getLength ()];

        for (int k = 0; k &lt; nl3.getLength (); k++) {
          Element e3 = (Element) nl3.item (k);

          components [k] = new CFFCIDComponentFont ();
          components [k].name = e3.getAttribute ("name");
          components [k].dict = new java.util.HashMap&lt;String, Operator> ();

          NodeList nl2 =  e3.getChildNodes ();
          for (int j = 0; j &lt; nl2.getLength (); j++) {
            Element e2 = (Element) nl2.item (j);

            if ("localSubrs".equals (e2.getTagName ())) {
              components [k].localSubrs = new CFFCharStrings ();
              components [k].localSubrs.fromXML (e2); }

            else {
              for (int jj = 0; jj &lt; operators.length; jj++) {
                if ((operators [jj].name).equals (e2.getTagName ())) {
                  Operator operator = (Operator) operators [jj].clone ();
                  operator.fromXML (e2);
                  components [k].dict.put (operator.name, operator);
                  break; }}}}}}

      else if ("fdselect".equals (e.getTagName ())) {
        fdselect = fdSelectFromXML (e); }

      else {
        for (int j = 0; j &lt; operators.length; j++) {
          if ((operators [j].name).equals (e.getTagName ())) {
            Operator operator = (Operator) operators [j].clone ();
            operator.fromXML (e);
            dict.put (operator.name, operator);
            break; }}}}

  }
</code-fragment>
      </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>Method to output to XML</code-title>
  public void toXML (com.adobe.aots.util.ContentHandlerPlus ch,
                     Type2Font2XML t2Processor)
      throws org.xml.sax.SAXException {


    charstrings.initSbs ();
    for (int c = 0; c &lt; components.length; c++) {
      if (components [c].localSubrs != null) {
        components [c].localSubrs.initSbs (); }}

    for (int gid = 0; gid &lt; charstrings.numGlyphs (); gid++) {
      t2Processor.decompileCharstring (charstrings, gid,
                         components [gid2fontdict (gid)].localSubrs,
                          globalSubrs); }

    AttributesImpl at;

    at = new AttributesImpl ();
    at.addAttribute ("", "name", "name", "CDATA", "" + name);
    ch.startElement ("cid-keyed-font", at); {
      dictToXML (ch, dict);
      charstrings.toXML (ch, "charstrings", cids);

      ch.startElement ("cid-components"); {
        for (int i = 0; i &lt; components.length; i++) {
          at = new AttributesImpl ();
          at.addAttribute ("", "name", "name", "CDATA", components [i].name);
          ch.startElement ("cid-component", at); {
            dictToXML (ch, components [i].dict);
            if (components [i].localSubrs != null) {
              components[i].localSubrs.toXML (ch, "localSubrs"); }
            ch.endElement ("cid-component"); }}
        ch.endElement ("cid-components"); }

      fdSelectToXML (ch, fdselect);

      ch.endElement ("cid-keyed-font"); }
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>FDSelect</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>The FDSelect associates an FD (Font DICT) with a glyph
        by specifying an FD index for that glyph. The FD index is used
        to access one of the Font DICTs stored in the Font DICT
        INDEX.</para>

      <para>FDSelect data is located via the offset operand to the
        FDSelect operator in the Top DICT. FDSelect data specifies a
        format-type identifier byte followed by format-specific data.
        Two formats are currently defined, as shown in Tables 27 and
        28.</para>

      <table>
        <title>Format 0</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>format</entry>
              <entry>=0</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>fds [nGlyphs]</entry>
              <entry>FD selector array</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Each element of the fd array (fds) represents the FD
        index of the corresponding glyph. This format should be used
        when the FD indexes are in a fairly random order. The number
        of glyphs (nGlyphs) is the value of the count field in the
        CharStrings INDEX. (This format is identical to charset format
        0 except that the .notdef glyph is included in this
        case.)</para>

      <table>
        <title>Format 3</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card8</entry>
              <entry>format</entry>
              <entry>=3</entry>
            </row>
            <row>
              <entry>Card16</entry>
              <entry>nRanges</entry>
              <entry>Number of ranges</entry>
            </row>
            <row>
              <entry>struct</entry>
              <entry>Range3 [nRanges]</entry>
              <entry>Range3 array (see Table 29)</entry>
            </row>
            <row>
              <entry>Card16</entry>
              <entry>sentinel</entry>
              <entry>Sentinel GID (see below)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The format of a Range3 is shown in Table 29.</para>

      <table>
        <title>Range3 Format</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Card16</entry>
              <entry>first</entry>
              <entry>First glyph index in range</entry>
            </row>
            <row>
              <entry>Card8</entry>
              <entry>fd</entry>
              <entry>FD index for all glyphs in range</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Each Range3 describes a group of sequential GIDs that
        have the same FD index. Each range includes GIDs from the
        "first" GID up to, but not including, the "first" GID of the
        next range element. Thus, elements of the Range3 array are
        ordered by increasing "first" GIDs. The first range must have
        a "first" GID of 0. A sentinel GID follows the last range
        element and serves to delimit the last range in the array.
        (The sentinel GID is set equal to the number of glyphs in the
        font. That is, its value is 1 greater than the last GID in the
        font.) This format is particularly suited to FD indexes that
        are well ordered (the usual case).</para>
    </section>

    <!--______________________________________________________________________-->
    <section>
      <title>Annotation</title>

      <para>In the paragraph following the table for format 0, "(This
        format...case)" is pushing a bit far. Not only there is an
        entry for glyphID 0, but the array is made of Card8, intead of
        SID (or Card16). May be this observation should just be
        dropped.</para>

      <para>This innocuous little structure introduces a limitation of
        in the CFF format: the sentinel value, which must be one more
        than the last GID in the font, is represented in a Card16.
        Thus, the last GID in the font must be no more than
        0xfffe. A fairly simple change in the format would have
        removed that limitation: put a sentinel of 0xffff before the
        ranges, and have the ranges be described by their last glyph
        index; together with arithmetic modulo 0x10000, binary
        searches would have been just as simple.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Our internal representation of an FDSelect is as an
        array of three numbers element. Each element represents a
        range. The first number is the first glyphID in the range,
        the second number is the last glyphID in the range, and the
        last number is the index of the font DICT for the glyphIDs
        in the range.</para>

      <para>If there is FDSelect, all the glyphs are in the first
      (and only) font.</para>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>gid2fontdict</code-title>
  public int gid2fontdict (int gid) {
    if (fdselect == null) {
      return 0; }

    for (int i = 0; i &lt; fdselect.length; i++) {
      if (fdselect [i][0] &lt;= gid &amp;&amp; gid &lt;= fdselect [i][1]) {
        return fdselect [i][2]; }}
    return -1;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='loadingfrombinary'>
      <title>FromBinary</title>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>fdSelectFromBinary</code-title>
  public int[][] fdSelectFromBinary (byte[] data, int offset, int numGlyphs)
      throws InvalidFontException {

    int[][] result;

    int format = getCard8 (data, offset);
    offset++;

    switch (format) {

      case 0: {
        result = new int [numGlyphs][3];

        for (int i = 0; i &lt; numGlyphs; i++) {
          result [i][0] = i;
          result [i][1] = i;
          result [i][2] = getCard8 (data, offset);
          offset += 1; }
        break; }

      case 3: {
        int nRanges = getCard16 (data, offset);
        offset += 2;

        result = new int [nRanges][3];

        int currentGlyphID = getCard16 (data, offset);
        offset += 2;

        for (int r = 0; r &lt; nRanges; r++) {
          int fd = getCard8 (data, offset);
          offset++;
          int firstGlyphIDInNextRange = getCard16 (data, offset);
          offset += 2;

          result [r][0] = currentGlyphID;
          result [r][1] = firstGlyphIDInNextRange - 1;
          result [r][2] = fd;

          currentGlyphID = firstGlyphIDInNextRange; }

        break; }

      default: {
        throw new InvalidFontException ("Invalid FDSelect format: " + format); }}

    return result;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='unloadingtobinary'>
      <title>ToBinary</title>

      <para>Currently, we have a fairly trivial implementation which
        always generates a format 3 structure:</para>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>fdSelectToBinary</code-title>
  public void fdSelectToBinary (ByteBuffer bb, int[][] fdselect) {
    bb.addCard8 (3);
    bb.addCard16 (fdselect.length);
    bb.addCard16 (fdselect [0][0]);
    for (int i = 0; i &lt; fdselect.length; i++) {
      bb.addCard8 (fdselect [i][2]);
      bb.addCard16 (fdselect [i][1] + 1); }
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='xml-representation'>
      <title>XML Representation</title>

      <para>Our XML representation closely follows our internal
        representation:</para>

<code-fragment id='schema'>
  fdselect =
    element fdrange {
      attribute from { text },
      attribute to   { text },
      attribute name { text }
    }*
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='compiler'>
      <title>Compiler</title>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>fdSelectFromXML method</code-title>
  public int[][] fdSelectFromXML (Element e) {
    NodeList nl = e.getChildNodes ();
    int[][] result = new int [nl.getLength ()] [3];
    for (int i = 0; i &lt; result.length; i++) {
      Element e1 = (Element) nl.item (i);
      result [i][0] = Integer.decode (e1.getAttribute ("from")).intValue ();
      result [i][1] = Integer.decode (e1.getAttribute ("to")).intValue ();
      String name = e1.getAttribute ("name");
      for (int c = 0; c &lt; components.length; c++) {
        if (name.equals (components [c].name)) {
          result [i][2] = c; }}}
    return result;
  }
</code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='decompiler'>
      <title>Decompiler</title>

<code-fragment id='cffcidkeyedfont.methods'>
  <code-title>fdSelectToXML method</code-title>
  public void fdSelectToXML (com.adobe.aots.util.ContentHandlerPlus ch,
                             int[][] fdselect)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    ch.startElement ("fdselect"); {
      for (int i = 0; i &lt; fdselect.length; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "from", "from", "CDATA", "" + fdselect [i][0]);
        at.addAttribute ("", "to", "to", "CDATA", "" + fdselect [i][1]);
        at.addAttribute ("", "name", "name",  "CDATA",
                         components [fdselect [i][2]].name);
        ch.element ("fdrange", at); }
      ch.endElement ("fdselect"); }
  }
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix A: Standard Strings</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <informaltable>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>SID</entry>
              <entry>name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>space</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>exclam</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>quotedbl</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>numbersign</entry>
            </row>
            <row>
              <entry>5</entry>
              <entry>dollar</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>percent</entry>
            </row>
            <row>
              <entry>7</entry>
              <entry>ampersand</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>quoteright</entry>
            </row>
            <row>
              <entry>9</entry>
              <entry>parenleft</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>parenright</entry>
            </row>
            <row>
              <entry>11</entry>
              <entry>asterisk</entry>
            </row>
            <row>
              <entry>12</entry>
              <entry>plus</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>comma</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>hyphen</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>period</entry>
            </row>
            <row>
              <entry>16</entry>
              <entry>slash</entry>
            </row>
            <row>
              <entry>17</entry>
              <entry>zero</entry>
            </row>
            <row>
              <entry>18</entry>
              <entry>one</entry>
            </row>
            <row>
              <entry>19</entry>
              <entry>two</entry>
            </row>
            <row>
              <entry>20</entry>
              <entry>three</entry>
            </row>
            <row>
              <entry>21</entry>
              <entry>four</entry>
            </row>
            <row>
              <entry>22</entry>
              <entry>five</entry>
            </row>
            <row>
              <entry>23</entry>
              <entry>six</entry>
            </row>
            <row>
              <entry>24</entry>
              <entry>seven</entry>
            </row>
            <row>
              <entry>25</entry>
              <entry>eight</entry>
            </row>
            <row>
              <entry>26</entry>
              <entry>nine</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>colon</entry>
            </row>
            <row>
              <entry>28</entry>
              <entry>semicolon</entry>
            </row>
            <row>
              <entry>29</entry>
              <entry>less</entry>
            </row>
            <row>
              <entry>30</entry>
              <entry>equal</entry>
            </row>
            <row>
              <entry>31</entry>
              <entry>greater</entry>
            </row>
            <row>
              <entry>32</entry>
              <entry>question</entry>
            </row>
            <row>
              <entry>33</entry>
              <entry>at</entry>
            </row>
            <row>
              <entry>34</entry>
              <entry>A</entry>
            </row>
            <row>
              <entry>35</entry>
              <entry>B</entry>
            </row>
            <row>
              <entry>36</entry>
              <entry>C</entry>
            </row>
            <row>
              <entry>37</entry>
              <entry>D</entry>
            </row>
            <row>
              <entry>38</entry>
              <entry>E</entry>
            </row>
            <row>
              <entry>39</entry>
              <entry>F</entry>
            </row>
            <row>
              <entry>40</entry>
              <entry>G</entry>
            </row>
            <row>
              <entry>41</entry>
              <entry>H</entry>
            </row>
            <row>
              <entry>42</entry>
              <entry>I</entry>
            </row>
            <row>
              <entry>43</entry>
              <entry>J</entry>
            </row>
            <row>
              <entry>44</entry>
              <entry>K</entry>
            </row>
            <row>
              <entry>45</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>46</entry>
              <entry>M</entry>
            </row>
            <row>
              <entry>47</entry>
              <entry>N</entry>
            </row>
            <row>
              <entry>48</entry>
              <entry>O</entry>
            </row>
            <row>
              <entry>49</entry>
              <entry>P</entry>
            </row>
            <row>
              <entry>50</entry>
              <entry>Q</entry>
            </row>
            <row>
              <entry>51</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>52</entry>
              <entry>S</entry>
            </row>
            <row>
              <entry>53</entry>
              <entry>T</entry>
            </row>
            <row>
              <entry>54</entry>
              <entry>U</entry>
            </row>
            <row>
              <entry>55</entry>
              <entry>V</entry>
            </row>
            <row>
              <entry>56</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>57</entry>
              <entry>X</entry>
            </row>
            <row>
              <entry>58</entry>
              <entry>Y</entry>
            </row>
            <row>
              <entry>59</entry>
              <entry>Z</entry>
            </row>
            <row>
              <entry>60</entry>
              <entry>bracketleft</entry>
            </row>
            <row>
              <entry>61</entry>
              <entry>backslash</entry>
            </row>
            <row>
              <entry>62</entry>
              <entry>bracketright</entry>
            </row>
            <row>
              <entry>63</entry>
              <entry>asciicircum</entry>
            </row>
            <row>
              <entry>64</entry>
              <entry>underscore</entry>
            </row>
            <row>
              <entry>65</entry>
              <entry>quoteleft</entry>
            </row>
            <row>
              <entry>66</entry>
              <entry>a</entry>
            </row>
            <row>
              <entry>67</entry>
              <entry>b</entry>
            </row>
            <row>
              <entry>68</entry>
              <entry>c</entry>
            </row>
            <row>
              <entry>69</entry>
              <entry>d</entry>
            </row>
            <row>
              <entry>70</entry>
              <entry>e</entry>
            </row>
            <row>
              <entry>71</entry>
              <entry>f</entry>
            </row>
            <row>
              <entry>72</entry>
              <entry>g</entry>
            </row>
            <row>
              <entry>73</entry>
              <entry>h</entry>
            </row>
            <row>
              <entry>74</entry>
              <entry>i</entry>
            </row>
            <row>
              <entry>75</entry>
              <entry>j</entry>
            </row>
            <row>
              <entry>76</entry>
              <entry>k</entry>
            </row>
            <row>
              <entry>77</entry>
              <entry>l</entry>
            </row>
            <row>
              <entry>78</entry>
              <entry>m</entry>
            </row>
            <row>
              <entry>79</entry>
              <entry>n</entry>
            </row>
            <row>
              <entry>80</entry>
              <entry>o</entry>
            </row>
            <row>
              <entry>81</entry>
              <entry>p</entry>
            </row>
            <row>
              <entry>82</entry>
              <entry>q</entry>
            </row>
            <row>
              <entry>83</entry>
              <entry>r</entry>
            </row>
            <row>
              <entry>84</entry>
              <entry>s</entry>
            </row>
            <row>
              <entry>85</entry>
              <entry>t</entry>
            </row>
            <row>
              <entry>86</entry>
              <entry>u</entry>
            </row>
            <row>
              <entry>87</entry>
              <entry>v</entry>
            </row>
            <row>
              <entry>88</entry>
              <entry>w</entry>
            </row>
            <row>
              <entry>89</entry>
              <entry>x</entry>
            </row>
            <row>
              <entry>90</entry>
              <entry>y</entry>
            </row>
            <row>
              <entry>91</entry>
              <entry>z</entry>
            </row>
            <row>
              <entry>92</entry>
              <entry>braceleft</entry>
            </row>
            <row>
              <entry>93</entry>
              <entry>bar</entry>
            </row>
            <row>
              <entry>94</entry>
              <entry>braceright</entry>
            </row>
            <row>
              <entry>95</entry>
              <entry>asciitilde</entry>
            </row>
            <row>
              <entry>96</entry>
              <entry>exclamdown</entry>
            </row>
            <row>
              <entry>97</entry>
              <entry>cent</entry>
            </row>
            <row>
              <entry>98</entry>
              <entry>sterling</entry>
            </row>
            <row>
              <entry>99</entry>
              <entry>fraction</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>yen</entry>
            </row>
            <row>
              <entry>101</entry>
              <entry>florin</entry>
            </row>
            <row>
              <entry>102</entry>
              <entry>section</entry>
            </row>
            <row>
              <entry>103</entry>
              <entry>currency</entry>
            </row>
            <row>
              <entry>104</entry>
              <entry>quotesingle</entry>
            </row>
            <row>
              <entry>105</entry>
              <entry>quotedblleft</entry>
            </row>
            <row>
              <entry>106</entry>
              <entry>guillemotleft</entry>
            </row>
            <row>
              <entry>107</entry>
              <entry>guilsinglleft</entry>
            </row>
            <row>
              <entry>108</entry>
              <entry>guilsinglright</entry>
            </row>
            <row>
              <entry>109</entry>
              <entry>fi</entry>
            </row>
            <row>
              <entry>110</entry>
              <entry>fl</entry>
            </row>
            <row>
              <entry>111</entry>
              <entry>endash</entry>
            </row>
            <row>
              <entry>112</entry>
              <entry>dagger</entry>
            </row>
            <row>
              <entry>113</entry>
              <entry>daggerdbl</entry>
            </row>
            <row>
              <entry>114</entry>
              <entry>periodcentered</entry>
            </row>
            <row>
              <entry>115</entry>
              <entry>paragraph</entry>
            </row>
            <row>
              <entry>116</entry>
              <entry>bullet</entry>
            </row>
            <row>
              <entry>117</entry>
              <entry>quotesinglbase</entry>
            </row>
            <row>
              <entry>118</entry>
              <entry>quotedblbase</entry>
            </row>
            <row>
              <entry>119</entry>
              <entry>quotedblright</entry>
            </row>
            <row>
              <entry>120</entry>
              <entry>guillemotright</entry>
            </row>
            <row>
              <entry>121</entry>
              <entry>ellipsis</entry>
            </row>
            <row>
              <entry>122</entry>
              <entry>perthousand</entry>
            </row>
            <row>
              <entry>123</entry>
              <entry>questiondown</entry>
            </row>
            <row>
              <entry>124</entry>
              <entry>grave</entry>
            </row>
            <row>
              <entry>125</entry>
              <entry>acute</entry>
            </row>
            <row>
              <entry>126</entry>
              <entry>circumflex</entry>
            </row>
            <row>
              <entry>127</entry>
              <entry>tilde</entry>
            </row>
            <row>
              <entry>128</entry>
              <entry>macron</entry>
            </row>
            <row>
              <entry>129</entry>
              <entry>breve</entry>
            </row>
            <row>
              <entry>130</entry>
              <entry>dotaccent</entry>
            </row>
            <row>
              <entry>131</entry>
              <entry>dieresis</entry>
            </row>
            <row>
              <entry>132</entry>
              <entry>ring</entry>
            </row>
            <row>
              <entry>133</entry>
              <entry>cedilla</entry>
            </row>
            <row>
              <entry>134</entry>
              <entry>hungarumlaut</entry>
            </row>
            <row>
              <entry>135</entry>
              <entry>ogonek</entry>
            </row>
            <row>
              <entry>136</entry>
              <entry>caron</entry>
            </row>
            <row>
              <entry>137</entry>
              <entry>emdash</entry>
            </row>
            <row>
              <entry>138</entry>
              <entry>AE</entry>
            </row>
            <row>
              <entry>139</entry>
              <entry>ordfeminine</entry>
            </row>
            <row>
              <entry>140</entry>
              <entry>Lslash</entry>
            </row>
            <row>
              <entry>141</entry>
              <entry>Oslash</entry>
            </row>
            <row>
              <entry>142</entry>
              <entry>OE</entry>
            </row>
            <row>
              <entry>143</entry>
              <entry>ordmasculine</entry>
            </row>
            <row>
              <entry>144</entry>
              <entry>ae</entry>
            </row>
            <row>
              <entry>145</entry>
              <entry>dotlessi</entry>
            </row>
            <row>
              <entry>146</entry>
              <entry>lslash</entry>
            </row>
            <row>
              <entry>147</entry>
              <entry>oslash</entry>
            </row>
            <row>
              <entry>148</entry>
              <entry>oe</entry>
            </row>
            <row>
              <entry>149</entry>
              <entry>germandbls</entry>
            </row>
            <row>
              <entry>150</entry>
              <entry>onesuperior</entry>
            </row>
            <row>
              <entry>151</entry>
              <entry>logicalnot</entry>
            </row>
            <row>
              <entry>152</entry>
              <entry>mu</entry>
            </row>
            <row>
              <entry>153</entry>
              <entry>trademark</entry>
            </row>
            <row>
              <entry>154</entry>
              <entry>Eth</entry>
            </row>
            <row>
              <entry>155</entry>
              <entry>onehalf</entry>
            </row>
            <row>
              <entry>156</entry>
              <entry>plusminus</entry>
            </row>
            <row>
              <entry>157</entry>
              <entry>Thorn</entry>
            </row>
            <row>
              <entry>158</entry>
              <entry>onequarter</entry>
            </row>
            <row>
              <entry>159</entry>
              <entry>divide</entry>
            </row>
            <row>
              <entry>160</entry>
              <entry>brokenbar</entry>
            </row>
            <row>
              <entry>161</entry>
              <entry>degree</entry>
            </row>
            <row>
              <entry>162</entry>
              <entry>thorn</entry>
            </row>
            <row>
              <entry>163</entry>
              <entry>threequarters</entry>
            </row>
            <row>
              <entry>164</entry>
              <entry>twosuperior</entry>
            </row>
            <row>
              <entry>165</entry>
              <entry>registered</entry>
            </row>
            <row>
              <entry>166</entry>
              <entry>minus</entry>
            </row>
            <row>
              <entry>167</entry>
              <entry>eth</entry>
            </row>
            <row>
              <entry>168</entry>
              <entry>multiply</entry>
            </row>
            <row>
              <entry>169</entry>
              <entry>threesuperior</entry>
            </row>
            <row>
              <entry>170</entry>
              <entry>copyright</entry>
            </row>
            <row>
              <entry>171</entry>
              <entry>Aacute</entry>
            </row>
            <row>
              <entry>172</entry>
              <entry>Acircumflex</entry>
            </row>
            <row>
              <entry>173</entry>
              <entry>Adieresis</entry>
            </row>
            <row>
              <entry>174</entry>
              <entry>Agrave</entry>
            </row>
            <row>
              <entry>175</entry>
              <entry>Aring</entry>
            </row>
            <row>
              <entry>176</entry>
              <entry>Atilde</entry>
            </row>
            <row>
              <entry>177</entry>
              <entry>Ccedilla</entry>
            </row>
            <row>
              <entry>178</entry>
              <entry>Eacute</entry>
            </row>
            <row>
              <entry>179</entry>
              <entry>Ecircumflex</entry>
            </row>
            <row>
              <entry>180</entry>
              <entry>Edieresis</entry>
            </row>
            <row>
              <entry>181</entry>
              <entry>Egrave</entry>
            </row>
            <row>
              <entry>182</entry>
              <entry>Iacute</entry>
            </row>
            <row>
              <entry>183</entry>
              <entry>Icircumflex</entry>
            </row>
            <row>
              <entry>184</entry>
              <entry>Idieresis</entry>
            </row>
            <row>
              <entry>185</entry>
              <entry>Igrave</entry>
            </row>
            <row>
              <entry>186</entry>
              <entry>Ntilde</entry>
            </row>
            <row>
              <entry>187</entry>
              <entry>Oacute</entry>
            </row>
            <row>
              <entry>188</entry>
              <entry>Ocircumflex</entry>
            </row>
            <row>
              <entry>189</entry>
              <entry>Odieresis</entry>
            </row>
            <row>
              <entry>190</entry>
              <entry>Ograve</entry>
            </row>
            <row>
              <entry>191</entry>
              <entry>Otilde</entry>
            </row>
            <row>
              <entry>192</entry>
              <entry>Scaron</entry>
            </row>
            <row>
              <entry>193</entry>
              <entry>Uacute</entry>
            </row>
            <row>
              <entry>194</entry>
              <entry>Ucircumflex</entry>
            </row>
            <row>
              <entry>195</entry>
              <entry>Udieresis</entry>
            </row>
            <row>
              <entry>196</entry>
              <entry>Ugrave</entry>
            </row>
            <row>
              <entry>197</entry>
              <entry>Yacute</entry>
            </row>
            <row>
              <entry>198</entry>
              <entry>Ydieresis</entry>
            </row>
            <row>
              <entry>199</entry>
              <entry>Zcaron</entry>
            </row>
            <row>
              <entry>200</entry>
              <entry>aacute</entry>
            </row>
            <row>
              <entry>201</entry>
              <entry>acircumflex</entry>
            </row>
            <row>
              <entry>202</entry>
              <entry>adieresis</entry>
            </row>
            <row>
              <entry>203</entry>
              <entry>agrave</entry>
            </row>
            <row>
              <entry>204</entry>
              <entry>aring</entry>
            </row>
            <row>
              <entry>205</entry>
              <entry>atilde</entry>
            </row>
            <row>
              <entry>206</entry>
              <entry>ccedilla</entry>
            </row>
            <row>
              <entry>207</entry>
              <entry>eacute</entry>
            </row>
            <row>
              <entry>208</entry>
              <entry>ecircumflex</entry>
            </row>
            <row>
              <entry>209</entry>
              <entry>edieresis</entry>
            </row>
            <row>
              <entry>210</entry>
              <entry>egrave</entry>
            </row>
            <row>
              <entry>211</entry>
              <entry>iacute</entry>
            </row>
            <row>
              <entry>212</entry>
              <entry>icircumflex</entry>
            </row>
            <row>
              <entry>213</entry>
              <entry>idieresis</entry>
            </row>
            <row>
              <entry>214</entry>
              <entry>igrave</entry>
            </row>
            <row>
              <entry>215</entry>
              <entry>ntilde</entry>
            </row>
            <row>
              <entry>216</entry>
              <entry>oacute</entry>
            </row>
            <row>
              <entry>217</entry>
              <entry>ocircumflex</entry>
            </row>
            <row>
              <entry>218</entry>
              <entry>odieresis</entry>
            </row>
            <row>
              <entry>219</entry>
              <entry>ograve</entry>
            </row>
            <row>
              <entry>220</entry>
              <entry>otilde</entry>
            </row>
            <row>
              <entry>221</entry>
              <entry>scaron</entry>
            </row>
            <row>
              <entry>222</entry>
              <entry>uacute</entry>
            </row>
            <row>
              <entry>223</entry>
              <entry>ucircumflex</entry>
            </row>
            <row>
              <entry>224</entry>
              <entry>udieresis</entry>
            </row>
            <row>
              <entry>225</entry>
              <entry>ugrave</entry>
            </row>
            <row>
              <entry>226</entry>
              <entry>yacute</entry>
            </row>
            <row>
              <entry>227</entry>
              <entry>ydieresis</entry>
            </row>
            <row>
              <entry>228</entry>
              <entry>zcaron</entry>
            </row>
            <row>
              <entry>229</entry>
              <entry>exclamsmall</entry>
            </row>
            <row>
              <entry>230</entry>
              <entry>Hungarumlautsmall</entry>
            </row>
            <row>
              <entry>231</entry>
              <entry>dollaroldstyle</entry>
            </row>
            <row>
              <entry>232</entry>
              <entry>dollarsuperior</entry>
            </row>
            <row>
              <entry>233</entry>
              <entry>ampersandsmall</entry>
            </row>
            <row>
              <entry>234</entry>
              <entry>Acutesmall</entry>
            </row>
            <row>
              <entry>235</entry>
              <entry>parenleftsuperior</entry>
            </row>
            <row>
              <entry>236</entry>
              <entry>parenrightsuperior</entry>
            </row>
            <row>
              <entry>237</entry>
              <entry>twodotenleader</entry>
            </row>
            <row>
              <entry>238</entry>
              <entry>onedotenleader</entry>
            </row>
            <row>
              <entry>239</entry>
              <entry>zerooldstyle</entry>
            </row>
            <row>
              <entry>240</entry>
              <entry>oneoldstyle</entry>
            </row>
            <row>
              <entry>241</entry>
              <entry>twooldstyle</entry>
            </row>
            <row>
              <entry>242</entry>
              <entry>threeoldstyle</entry>
            </row>
            <row>
              <entry>243</entry>
              <entry>fouroldstyle</entry>
            </row>
            <row>
              <entry>244</entry>
              <entry>fiveoldstyle</entry>
            </row>
            <row>
              <entry>245</entry>
              <entry>sixoldstyle</entry>
            </row>
            <row>
              <entry>246</entry>
              <entry>sevenoldstyle</entry>
            </row>
            <row>
              <entry>247</entry>
              <entry>eightoldstyle</entry>
            </row>
            <row>
              <entry>248</entry>
              <entry>nineoldstyle</entry>
            </row>
            <row>
              <entry>249</entry>
              <entry>commasuperior</entry>
            </row>
            <row>
              <entry>250</entry>
              <entry>threequartersemdash</entry>
            </row>
            <row>
              <entry>251</entry>
              <entry>periodsuperior</entry>
            </row>
            <row>
              <entry>252</entry>
              <entry>questionsmall</entry>
            </row>
            <row>
              <entry>253</entry>
              <entry>asuperior</entry>
            </row>
            <row>
              <entry>254</entry>
              <entry>bsuperior</entry>
            </row>
            <row>
              <entry>255</entry>
              <entry>centsuperior</entry>
            </row>
            <row>
              <entry>256</entry>
              <entry>dsuperior</entry>
            </row>
            <row>
              <entry>257</entry>
              <entry>esuperior</entry>
            </row>
            <row>
              <entry>258</entry>
              <entry>isuperior</entry>
            </row>
            <row>
              <entry>259</entry>
              <entry>lsuperior</entry>
            </row>
            <row>
              <entry>260</entry>
              <entry>msuperior</entry>
            </row>
            <row>
              <entry>261</entry>
              <entry>nsuperior</entry>
            </row>
            <row>
              <entry>262</entry>
              <entry>osuperior</entry>
            </row>
            <row>
              <entry>263</entry>
              <entry>rsuperior</entry>
            </row>
            <row>
              <entry>264</entry>
              <entry>ssuperior</entry>
            </row>
            <row>
              <entry>265</entry>
              <entry>tsuperior</entry>
            </row>
            <row>
              <entry>266</entry>
              <entry>ff</entry>
            </row>
            <row>
              <entry>267</entry>
              <entry>ffi</entry>
            </row>
            <row>
              <entry>268</entry>
              <entry>ffl</entry>
            </row>
            <row>
              <entry>269</entry>
              <entry>parenleftinferior</entry>
            </row>
            <row>
              <entry>270</entry>
              <entry>parenrightinferior</entry>
            </row>
            <row>
              <entry>271</entry>
              <entry>Circumflexsmall</entry>
            </row>
            <row>
              <entry>272</entry>
              <entry>hyphensuperior</entry>
            </row>
            <row>
              <entry>273</entry>
              <entry>Gravesmall</entry>
            </row>
            <row>
              <entry>274</entry>
              <entry>Asmall</entry>
            </row>
            <row>
              <entry>275</entry>
              <entry>Bsmall</entry>
            </row>
            <row>
              <entry>276</entry>
              <entry>Csmall</entry>
            </row>
            <row>
              <entry>277</entry>
              <entry>Dsmall</entry>
            </row>
            <row>
              <entry>278</entry>
              <entry>Esmall</entry>
            </row>
            <row>
              <entry>279</entry>
              <entry>Fsmall</entry>
            </row>
            <row>
              <entry>280</entry>
              <entry>Gsmall</entry>
            </row>
            <row>
              <entry>281</entry>
              <entry>Hsmall</entry>
            </row>
            <row>
              <entry>282</entry>
              <entry>Ismall</entry>
            </row>
            <row>
              <entry>283</entry>
              <entry>Jsmall</entry>
            </row>
            <row>
              <entry>284</entry>
              <entry>Ksmall</entry>
            </row>
            <row>
              <entry>285</entry>
              <entry>Lsmall</entry>
            </row>
            <row>
              <entry>286</entry>
              <entry>Msmall</entry>
            </row>
            <row>
              <entry>287</entry>
              <entry>Nsmall</entry>
            </row>
            <row>
              <entry>288</entry>
              <entry>Osmall</entry>
            </row>
            <row>
              <entry>289</entry>
              <entry>Psmall</entry>
            </row>
            <row>
              <entry>290</entry>
              <entry>Qsmall</entry>
            </row>
            <row>
              <entry>291</entry>
              <entry>Rsmall</entry>
            </row>
            <row>
              <entry>292</entry>
              <entry>Ssmall</entry>
            </row>
            <row>
              <entry>293</entry>
              <entry>Tsmall</entry>
            </row>
            <row>
              <entry>294</entry>
              <entry>Usmall</entry>
            </row>
            <row>
              <entry>295</entry>
              <entry>Vsmall</entry>
            </row>
            <row>
              <entry>296</entry>
              <entry>Wsmall</entry>
            </row>
            <row>
              <entry>297</entry>
              <entry>Xsmall</entry>
            </row>
            <row>
              <entry>298</entry>
              <entry>Ysmall</entry>
            </row>
            <row>
              <entry>299</entry>
              <entry>Zsmall</entry>
            </row>
            <row>
              <entry>300</entry>
              <entry>colonmonetary</entry>
            </row>
            <row>
              <entry>301</entry>
              <entry>onefitted</entry>
            </row>
            <row>
              <entry>302</entry>
              <entry>rupiah</entry>
            </row>
            <row>
              <entry>303</entry>
              <entry>Tildesmall</entry>
            </row>
            <row>
              <entry>304</entry>
              <entry>exclamdownsmall</entry>
            </row>
            <row>
              <entry>305</entry>
              <entry>centoldstyle</entry>
            </row>
            <row>
              <entry>306</entry>
              <entry>Lslashsmall</entry>
            </row>
            <row>
              <entry>307</entry>
              <entry>Scaronsmall</entry>
            </row>
            <row>
              <entry>308</entry>
              <entry>Zcaronsmall</entry>
            </row>
            <row>
              <entry>309</entry>
              <entry>Dieresissmall</entry>
            </row>
            <row>
              <entry>310</entry>
              <entry>Brevesmall</entry>
            </row>
            <row>
              <entry>311</entry>
              <entry>Caronsmall</entry>
            </row>
            <row>
              <entry>312</entry>
              <entry>Dotaccentsmall</entry>
            </row>
            <row>
              <entry>313</entry>
              <entry>Macronsmall</entry>
            </row>
            <row>
              <entry>314</entry>
              <entry>figuredash</entry>
            </row>
            <row>
              <entry>315</entry>
              <entry>hypheninferior</entry>
            </row>
            <row>
              <entry>316</entry>
              <entry>Ogoneksmall</entry>
            </row>
            <row>
              <entry>317</entry>
              <entry>Ringsmall</entry>
            </row>
            <row>
              <entry>318</entry>
              <entry>Cedillasmall</entry>
            </row>
            <row>
              <entry>319</entry>
              <entry>questiondownsmall</entry>
            </row>
            <row>
              <entry>320</entry>
              <entry>oneeighth</entry>
            </row>
            <row>
              <entry>321</entry>
              <entry>threeeighths</entry>
            </row>
            <row>
              <entry>322</entry>
              <entry>fiveeighths</entry>
            </row>
            <row>
              <entry>323</entry>
              <entry>seveneighths</entry>
            </row>
            <row>
              <entry>324</entry>
              <entry>onethird</entry>
            </row>
            <row>
              <entry>325</entry>
              <entry>twothirds</entry>
            </row>
            <row>
              <entry>326</entry>
              <entry>zerosuperior</entry>
            </row>
            <row>
              <entry>327</entry>
              <entry>foursuperior</entry>
            </row>
            <row>
              <entry>328</entry>
              <entry>fivesuperior</entry>
            </row>
            <row>
              <entry>329</entry>
              <entry>sixsuperior</entry>
            </row>
            <row>
              <entry>330</entry>
              <entry>sevensuperior</entry>
            </row>
            <row>
              <entry>331</entry>
              <entry>eightsuperior</entry>
            </row>
            <row>
              <entry>332</entry>
              <entry>ninesuperior</entry>
            </row>
            <row>
              <entry>333</entry>
              <entry>zeroinferior</entry>
            </row>
            <row>
              <entry>334</entry>
              <entry>oneinferior</entry>
            </row>
            <row>
              <entry>335</entry>
              <entry>twoinferior</entry>
            </row>
            <row>
              <entry>336</entry>
              <entry>threeinferior</entry>
            </row>
            <row>
              <entry>337</entry>
              <entry>fourinferior</entry>
            </row>
            <row>
              <entry>338</entry>
              <entry>fiveinferior</entry>
            </row>
            <row>
              <entry>339</entry>
              <entry>sixinferior</entry>
            </row>
            <row>
              <entry>340</entry>
              <entry>seveninferior</entry>
            </row>
            <row>
              <entry>341</entry>
              <entry>eightinferior</entry>
            </row>
            <row>
              <entry>342</entry>
              <entry>nineinferior</entry>
            </row>
            <row>
              <entry>343</entry>
              <entry>centinferior</entry>
            </row>
            <row>
              <entry>344</entry>
              <entry>dollarinferior</entry>
            </row>
            <row>
              <entry>345</entry>
              <entry>periodinferior</entry>
            </row>
            <row>
              <entry>346</entry>
              <entry>commainferior</entry>
            </row>
            <row>
              <entry>347</entry>
              <entry>Agravesmall</entry>
            </row>
            <row>
              <entry>348</entry>
              <entry>Aacutesmall</entry>
            </row>
            <row>
              <entry>349</entry>
              <entry>Acircumflexsmall</entry>
            </row>
            <row>
              <entry>350</entry>
              <entry>Atildesmall</entry>
            </row>
            <row>
              <entry>351</entry>
              <entry>Adieresissmall</entry>
            </row>
            <row>
              <entry>352</entry>
              <entry>Aringsmall</entry>
            </row>
            <row>
              <entry>353</entry>
              <entry>AEsmall</entry>
            </row>
            <row>
              <entry>354</entry>
              <entry>Ccedillasmall</entry>
            </row>
            <row>
              <entry>355</entry>
              <entry>Egravesmall</entry>
            </row>
            <row>
              <entry>356</entry>
              <entry>Eacutesmall</entry>
            </row>
            <row>
              <entry>357</entry>
              <entry>Ecircumflexsmall</entry>
            </row>
            <row>
              <entry>358</entry>
              <entry>Edieresissmall</entry>
            </row>
            <row>
              <entry>359</entry>
              <entry>Igravesmall</entry>
            </row>
            <row>
              <entry>360</entry>
              <entry>Iacutesmall</entry>
            </row>
            <row>
              <entry>361</entry>
              <entry>Icircumflexsmall</entry>
            </row>
            <row>
              <entry>362</entry>
              <entry>Idieresissmall</entry>
            </row>
            <row>
              <entry>363</entry>
              <entry>Ethsmall</entry>
            </row>
            <row>
              <entry>364</entry>
              <entry>Ntildesmall</entry>
            </row>
            <row>
              <entry>365</entry>
              <entry>Ogravesmall</entry>
            </row>
            <row>
              <entry>366</entry>
              <entry>Oacutesmall</entry>
            </row>
            <row>
              <entry>367</entry>
              <entry>Ocircumflexsmall</entry>
            </row>
            <row>
              <entry>368</entry>
              <entry>Otildesmall</entry>
            </row>
            <row>
              <entry>369</entry>
              <entry>Odieresissmall</entry>
            </row>
            <row>
              <entry>370</entry>
              <entry>OEsmall</entry>
            </row>
            <row>
              <entry>371</entry>
              <entry>Oslashsmall</entry>
            </row>
            <row>
              <entry>372</entry>
              <entry>Ugravesmall</entry>
            </row>
            <row>
              <entry>373</entry>
              <entry>Uacutesmall</entry>
            </row>
            <row>
              <entry>374</entry>
              <entry>Ucircumflexsmall</entry>
            </row>
            <row>
              <entry>375</entry>
              <entry>Udieresissmall</entry>
            </row>
            <row>
              <entry>376</entry>
              <entry>Yacutesmall</entry>
            </row>
            <row>
              <entry>377</entry>
              <entry>Thornsmall</entry>
            </row>
            <row>
              <entry>378</entry>
              <entry>Ydieresissmall</entry>
            </row>
            <row>
              <entry>379</entry>
              <entry>001.000</entry>
            </row>
            <row>
              <entry>380</entry>
              <entry>001.001</entry>
            </row>
            <row>
              <entry>381</entry>
              <entry>001.002</entry>
            </row>
            <row>
              <entry>382</entry>
              <entry>001.003</entry>
            </row>
            <row>
              <entry>383</entry>
              <entry>Black</entry>
            </row>
            <row>
              <entry>384</entry>
              <entry>Bold</entry>
            </row>
            <row>
              <entry>385</entry>
              <entry>Book</entry>
            </row>
            <row>
              <entry>386</entry>
              <entry>Light</entry>
            </row>
            <row>
              <entry>387</entry>
              <entry>Medium</entry>
            </row>
            <row>
              <entry>388</entry>
              <entry>Regular</entry>
            </row>
            <row>
              <entry>389</entry>
              <entry>Roman</entry>
            </row>
            <row>
              <entry>390</entry>
              <entry>Semibold</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>Of course, our code needs to access the predefined
        strings:</para>

<code-fragment id='cfffontset.members'>
<code-title>Predefined CFF Strings</code-title>
  final static String[] predefinedCFFStrings = {
        ".notdef",
        "space",
        "exclam",
        "quotedbl",
        "numbersign",
        "dollar",
        "percent",
        "ampersand",
        "quoteright",
          "parenleft",
          "parenright",
          "asterisk",
          "plus",
          "comma",
          "hyphen",
          "period",
          "slash",
          "zero",
          "one",
          "two",
          "three",
          "four",
          "five",
          "six",
          "seven",
          "eight",
          "nine",
          "colon",
          "semicolon",
          "less",
          "equal",
          "greater",
          "question",
          "at",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          "bracketleft",
          "backslash",
          "bracketright",
          "asciicircum",
          "underscore",
          "quoteleft",
          "a",
          "b",
          "c",
          "d",
          "e",
          "f",
          "g",
          "h",
          "i",
          "j",
          "k",
          "l",
          "m",
          "n",
          "o",
          "p",
          "q",
          "r",
          "s",
          "t",
          "u",
          "v",
          "w",
          "x",
          "y",
          "z",
          "braceleft",
          "bar",
          "braceright",
          "asciitilde",
          "exclamdown",
          "cent",
          "sterling",
          "fraction",
          "yen",
          "florin",
          "section",
          "currency",
          "quotesingle",
          "quotedblleft",
          "guillemotleft",
          "guilsinglleft",
          "guilsinglright",
          "fi",
          "fl",
          "endash",
          "dagger",
          "daggerdbl",
          "periodcentered",
          "paragraph",
          "bullet",
          "quotesinglbase",
          "quotedblbase",
          "quotedblright",
          "guillemotright",
          "ellipsis",
          "perthousand",
          "questiondown",
          "grave",
          "acute",
          "circumflex",
          "tilde",
          "macron",
          "breve",
          "dotaccent",
          "dieresis",
          "ring",
          "cedilla",
          "hungarumlaut",
          "ogonek",
          "caron",
          "emdash",
          "AE",
          "ordfeminine",
          "Lslash",
          "Oslash",
          "OE",
          "ordmasculine",
          "ae",
          "dotlessi",
          "lslash",
          "oslash",
          "oe",
          "germandbls",
          "onesuperior",
          "logicalnot",
          "mu",
          "trademark",
          "Eth",
          "onehalf",
          "plusminus",
          "Thorn",
          "onequarter",
          "divide",
          "brokenbar",
          "degree",
          "thorn",
          "threequarters",
          "twosuperior",
          "registered",
          "minus",
          "eth",
          "multiply",
          "threesuperior",
          "copyright",
          "Aacute",
          "Acircumflex",
          "Adieresis",
          "Agrave",
          "Aring",
          "Atilde",
          "Ccedilla",
          "Eacute",
          "Ecircumflex",
          "Edieresis",
          "Egrave",
          "Iacute",
          "Icircumflex",
          "Idieresis",
          "Igrave",
          "Ntilde",
          "Oacute",
          "Ocircumflex",
          "Odieresis",
          "Ograve",
          "Otilde",
          "Scaron",
          "Uacute",
          "Ucircumflex",
          "Udieresis",
          "Ugrave",
          "Yacute",
          "Ydieresis",
          "Zcaron",
          "aacute",
          "acircumflex",
          "adieresis",
          "agrave",
          "aring",
          "atilde",
          "ccedilla",
          "eacute",
          "ecircumflex",
          "edieresis",
          "egrave",
          "iacute",
          "icircumflex",
          "idieresis",
          "igrave",
          "ntilde",
          "oacute",
          "ocircumflex",
          "odieresis",
          "ograve",
          "otilde",
          "scaron",
          "uacute",
          "ucircumflex",
          "udieresis",
          "ugrave",
          "yacute",
          "ydieresis",
          "zcaron",
          "exclamsmall",
          "Hungarumlautsmall",
          "dollaroldstyle",
          "dollarsuperior",
          "ampersandsmall",
          "Acutesmall",
          "parenleftsuperior",
          "parenrightsuperior",
          "twodotenleader",
          "onedotenleader",
          "zerooldstyle",
          "oneoldstyle",
          "twooldstyle",
          "threeoldstyle",
          "fouroldstyle",
          "fiveoldstyle",
          "sixoldstyle",
          "sevenoldstyle",
          "eightoldstyle",
          "nineoldstyle",
          "commasuperior",
          "threequartersemdash",
          "periodsuperior",
          "questionsmall",
          "asuperior",
          "bsuperior",
          "centsuperior",
          "dsuperior",
          "esuperior",
          "isuperior",
          "lsuperior",
          "msuperior",
          "nsuperior",
          "osuperior",
          "rsuperior",
          "ssuperior",
          "tsuperior",
          "ff",
          "ffi",
          "ffl",
          "parenleftinferior",
          "parenrightinferior",
          "Circumflexsmall",
          "hyphensuperior",
          "Gravesmall",
          "Asmall",
          "Bsmall",
          "Csmall",
          "Dsmall",
          "Esmall",
          "Fsmall",
          "Gsmall",
          "Hsmall",
          "Ismall",
          "Jsmall",
          "Ksmall",
          "Lsmall",
          "Msmall",
          "Nsmall",
          "Osmall",
          "Psmall",
          "Qsmall",
          "Rsmall",
          "Ssmall",
          "Tsmall",
          "Usmall",
          "Vsmall",
          "Wsmall",
          "Xsmall",
          "Ysmall",
          "Zsmall",
          "colonmonetary",
          "onefitted",
          "rupiah",
          "Tildesmall",
          "exclamdownsmall",
          "centoldstyle",
          "Lslashsmall",
          "Scaronsmall",
          "Zcaronsmall",
          "Dieresissmall",
          "Brevesmall",
          "Caronsmall",
          "Dotaccentsmall",
          "Macronsmall",
          "figuredash",
          "hypheninferior",
          "Ogoneksmall",
          "Ringsmall",
          "Cedillasmall",
          "questiondownsmall",
          "oneeighth",
          "threeeighths",
          "fiveeighths",
          "seveneighths",
          "onethird",
          "twothirds",
          "zerosuperior",
          "foursuperior",
          "fivesuperior",
          "sixsuperior",
          "sevensuperior",
          "eightsuperior",
          "ninesuperior",
          "zeroinferior",
          "oneinferior",
          "twoinferior",
          "threeinferior",
          "fourinferior",
          "fiveinferior",
          "sixinferior",
          "seveninferior",
          "eightinferior",
          "nineinferior",
          "centinferior",
          "dollarinferior",
          "periodinferior",
          "commainferior",
          "Agravesmall",
          "Aacutesmall",
          "Acircumflexsmall",
          "Atildesmall",
          "Adieresissmall",
          "Aringsmall",
          "AEsmall",
          "Ccedillasmall",
          "Egravesmall",
          "Eacutesmall",
          "Ecircumflexsmall",
          "Edieresissmall",
          "Igravesmall",
          "Iacutesmall",
          "Icircumflexsmall",
          "Idieresissmall",
          "Ethsmall",
          "Ntildesmall",
          "Ogravesmall",
          "Oacutesmall",
          "Ocircumflexsmall",
          "Otildesmall",
          "Odieresissmall",
          "OEsmall",
          "Oslashsmall",
          "Ugravesmall",
          "Uacutesmall",
          "Ucircumflexsmall",
          "Udieresissmall",
          "Yacutesmall",
          "Thornsmall",
          "Ydieresissmall",
          "001.000",
          "001.001",
          "001.002",
          "001.003",
          "Black",
          "Bold",
          "Book",
          "Light",
          "Medium",
          "Regular",
          "Roman",
          "Semibold"};
</code-fragment>
      </section>
    </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix B Predefined Encodings</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <table>
        <title>Standard Encoding</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>code</entry>
              <entry>SID</entry>
              <entry>name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>5</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>7</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>9</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>11</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>12</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>16</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>17</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>18</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>19</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>20</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>21</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>22</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>23</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>24</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>25</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>26</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>28</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>29</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>30</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>31</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>32</entry>
              <entry>1</entry>
              <entry>space</entry>
            </row>
            <row>
              <entry>33</entry>
              <entry>2</entry>
              <entry>exclam</entry>
            </row>
            <row>
              <entry>34</entry>
              <entry>3</entry>
              <entry>quotedbl</entry>
            </row>
            <row>
              <entry>35</entry>
              <entry>4</entry>
              <entry>numbersign</entry>
            </row>
            <row>
              <entry>36</entry>
              <entry>5</entry>
              <entry>dollar</entry>
            </row>
            <row>
              <entry>37</entry>
              <entry>6</entry>
              <entry>percent</entry>
            </row>
            <row>
              <entry>38</entry>
              <entry>7</entry>
              <entry>ampersand</entry>
            </row>
            <row>
              <entry>39</entry>
              <entry>8</entry>
              <entry>quoteright</entry>
            </row>
            <row>
              <entry>40</entry>
              <entry>9</entry>
              <entry>parenleft</entry>
            </row>
            <row>
              <entry>41</entry>
              <entry>10</entry>
              <entry>parenright</entry>
            </row>
            <row>
              <entry>42</entry>
              <entry>11</entry>
              <entry>asterisk</entry>
            </row>
            <row>
              <entry>43</entry>
              <entry>12</entry>
              <entry>plus</entry>
            </row>
            <row>
              <entry>44</entry>
              <entry>13</entry>
              <entry>comma</entry>
            </row>
            <row>
              <entry>45</entry>
              <entry>14</entry>
              <entry>hyphen</entry>
            </row>
            <row>
              <entry>46</entry>
              <entry>15</entry>
              <entry>period</entry>
            </row>
            <row>
              <entry>47</entry>
              <entry>16</entry>
              <entry>slash</entry>
            </row>
            <row>
              <entry>48</entry>
              <entry>17</entry>
              <entry>zero</entry>
            </row>
            <row>
              <entry>49</entry>
              <entry>18</entry>
              <entry>one</entry>
            </row>
            <row>
              <entry>50</entry>
              <entry>19</entry>
              <entry>two</entry>
            </row>
            <row>
              <entry>51</entry>
              <entry>20</entry>
              <entry>three</entry>
            </row>
            <row>
              <entry>52</entry>
              <entry>21</entry>
              <entry>four</entry>
            </row>
            <row>
              <entry>53</entry>
              <entry>22</entry>
              <entry>five</entry>
            </row>
            <row>
              <entry>54</entry>
              <entry>23</entry>
              <entry>six</entry>
            </row>
            <row>
              <entry>55</entry>
              <entry>24</entry>
              <entry>seven</entry>
            </row>
            <row>
              <entry>56</entry>
              <entry>25</entry>
              <entry>eight</entry>
            </row>
            <row>
              <entry>57</entry>
              <entry>26</entry>
              <entry>nine</entry>
            </row>
            <row>
              <entry>58</entry>
              <entry>27</entry>
              <entry>colon</entry>
            </row>
            <row>
              <entry>59</entry>
              <entry>28</entry>
              <entry>semicolon</entry>
            </row>
            <row>
              <entry>60</entry>
              <entry>29</entry>
              <entry>less</entry>
            </row>
            <row>
              <entry>61</entry>
              <entry>30</entry>
              <entry>equal</entry>
            </row>
            <row>
              <entry>62</entry>
              <entry>31</entry>
              <entry>greater</entry>
            </row>
            <row>
              <entry>63</entry>
              <entry>32</entry>
              <entry>question</entry>
            </row>
            <row>
              <entry>64</entry>
              <entry>33</entry>
              <entry>at</entry>
            </row>
            <row>
              <entry>65</entry>
              <entry>34</entry>
              <entry>A</entry>
            </row>
            <row>
              <entry>66</entry>
              <entry>35</entry>
              <entry>B</entry>
            </row>
            <row>
              <entry>67</entry>
              <entry>36</entry>
              <entry>C</entry>
            </row>
            <row>
              <entry>68</entry>
              <entry>37</entry>
              <entry>D</entry>
            </row>
            <row>
              <entry>69</entry>
              <entry>38</entry>
              <entry>E</entry>
            </row>
            <row>
              <entry>70</entry>
              <entry>39</entry>
              <entry>F</entry>
            </row>
            <row>
              <entry>71</entry>
              <entry>40</entry>
              <entry>G</entry>
            </row>
            <row>
              <entry>72</entry>
              <entry>41</entry>
              <entry>H</entry>
            </row>
            <row>
              <entry>73</entry>
              <entry>42</entry>
              <entry>I</entry>
            </row>
            <row>
              <entry>74</entry>
              <entry>43</entry>
              <entry>J</entry>
            </row>
            <row>
              <entry>75</entry>
              <entry>44</entry>
              <entry>K</entry>
            </row>
            <row>
              <entry>76</entry>
              <entry>45</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>77</entry>
              <entry>46</entry>
              <entry>M</entry>
            </row>
            <row>
              <entry>78</entry>
              <entry>47</entry>
              <entry>N</entry>
            </row>
            <row>
              <entry>79</entry>
              <entry>48</entry>
              <entry>O</entry>
            </row>
            <row>
              <entry>80</entry>
              <entry>49</entry>
              <entry>P</entry>
            </row>
            <row>
              <entry>81</entry>
              <entry>50</entry>
              <entry>Q</entry>
            </row>
            <row>
              <entry>82</entry>
              <entry>51</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>83</entry>
              <entry>52</entry>
              <entry>S</entry>
            </row>
            <row>
              <entry>84</entry>
              <entry>53</entry>
              <entry>T</entry>
            </row>
            <row>
              <entry>85</entry>
              <entry>54</entry>
              <entry>U</entry>
            </row>
            <row>
              <entry>86</entry>
              <entry>55</entry>
              <entry>V</entry>
            </row>
            <row>
              <entry>87</entry>
              <entry>56</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>88</entry>
              <entry>57</entry>
              <entry>X</entry>
            </row>
            <row>
              <entry>89</entry>
              <entry>58</entry>
              <entry>Y</entry>
            </row>
            <row>
              <entry>90</entry>
              <entry>59</entry>
              <entry>Z</entry>
            </row>
            <row>
              <entry>91</entry>
              <entry>60</entry>
              <entry>bracketleft</entry>
            </row>
            <row>
              <entry>92</entry>
              <entry>61</entry>
              <entry>backslash</entry>
            </row>
            <row>
              <entry>93</entry>
              <entry>62</entry>
              <entry>bracketright</entry>
            </row>
            <row>
              <entry>94</entry>
              <entry>63</entry>
              <entry>asciicircum</entry>
            </row>
            <row>
              <entry>95</entry>
              <entry>64</entry>
              <entry>underscore</entry>
            </row>
            <row>
              <entry>96</entry>
              <entry>65</entry>
              <entry>quoteleft</entry>
            </row>
            <row>
              <entry>97</entry>
              <entry>66</entry>
              <entry>a</entry>
            </row>
            <row>
              <entry>98</entry>
              <entry>67</entry>
              <entry>b</entry>
            </row>
            <row>
              <entry>99</entry>
              <entry>68</entry>
              <entry>c</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>69</entry>
              <entry>d</entry>
            </row>
            <row>
              <entry>101</entry>
              <entry>70</entry>
              <entry>e</entry>
            </row>
            <row>
              <entry>102</entry>
              <entry>71</entry>
              <entry>f</entry>
            </row>
            <row>
              <entry>103</entry>
              <entry>72</entry>
              <entry>g</entry>
            </row>
            <row>
              <entry>104</entry>
              <entry>73</entry>
              <entry>h</entry>
            </row>
            <row>
              <entry>105</entry>
              <entry>74</entry>
              <entry>i</entry>
            </row>
            <row>
              <entry>106</entry>
              <entry>75</entry>
              <entry>j</entry>
            </row>
            <row>
              <entry>107</entry>
              <entry>76</entry>
              <entry>k</entry>
            </row>
            <row>
              <entry>108</entry>
              <entry>77</entry>
              <entry>l</entry>
            </row>
            <row>
              <entry>109</entry>
              <entry>78</entry>
              <entry>m</entry>
            </row>
            <row>
              <entry>110</entry>
              <entry>79</entry>
              <entry>n</entry>
            </row>
            <row>
              <entry>111</entry>
              <entry>80</entry>
              <entry>o</entry>
            </row>
            <row>
              <entry>112</entry>
              <entry>81</entry>
              <entry>p</entry>
            </row>
            <row>
              <entry>113</entry>
              <entry>82</entry>
              <entry>q</entry>
            </row>
            <row>
              <entry>114</entry>
              <entry>83</entry>
              <entry>r</entry>
            </row>
            <row>
              <entry>115</entry>
              <entry>84</entry>
              <entry>s</entry>
            </row>
            <row>
              <entry>116</entry>
              <entry>85</entry>
              <entry>t</entry>
            </row>
            <row>
              <entry>117</entry>
              <entry>86</entry>
              <entry>u</entry>
            </row>
            <row>
              <entry>118</entry>
              <entry>87</entry>
              <entry>v</entry>
            </row>
            <row>
              <entry>119</entry>
              <entry>88</entry>
              <entry>w</entry>
            </row>
            <row>
              <entry>120</entry>
              <entry>89</entry>
              <entry>x</entry>
            </row>
            <row>
              <entry>121</entry>
              <entry>90</entry>
              <entry>y</entry>
            </row>
            <row>
              <entry>122</entry>
              <entry>91</entry>
              <entry>z</entry>
            </row>
            <row>
              <entry>123</entry>
              <entry>92</entry>
              <entry>braceleft</entry>
            </row>
            <row>
              <entry>124</entry>
              <entry>93</entry>
              <entry>bar</entry>
            </row>
            <row>
              <entry>125</entry>
              <entry>94</entry>
              <entry>braceright</entry>
            </row>
            <row>
              <entry>126</entry>
              <entry>95</entry>
              <entry>asciitilde</entry>
            </row>
            <row>
              <entry>127</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>128</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>129</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>130</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>131</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>132</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>133</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>134</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>135</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>136</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>137</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>138</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>139</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>140</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>141</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>142</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>143</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>144</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>145</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>146</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>147</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>148</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>149</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>150</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>151</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>152</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>153</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>154</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>155</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>156</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>157</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>158</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>159</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>160</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>161</entry>
              <entry>96</entry>
              <entry>exclamdown</entry>
            </row>
            <row>
              <entry>162</entry>
              <entry>97</entry>
              <entry>cent</entry>
            </row>
            <row>
              <entry>163</entry>
              <entry>98</entry>
              <entry>sterling</entry>
            </row>
            <row>
              <entry>164</entry>
              <entry>99</entry>
              <entry>fraction</entry>
            </row>
            <row>
              <entry>165</entry>
              <entry>100</entry>
              <entry>yen</entry>
            </row>
            <row>
              <entry>166</entry>
              <entry>101</entry>
              <entry>florin</entry>
            </row>
            <row>
              <entry>167</entry>
              <entry>102</entry>
              <entry>section</entry>
            </row>
            <row>
              <entry>168</entry>
              <entry>103</entry>
              <entry>currency</entry>
            </row>
            <row>
              <entry>169</entry>
              <entry>104</entry>
              <entry>quotesingle</entry>
            </row>
            <row>
              <entry>170</entry>
              <entry>105</entry>
              <entry>quotedblleft</entry>
            </row>
            <row>
              <entry>171</entry>
              <entry>106</entry>
              <entry>guillemotleft</entry>
            </row>
            <row>
              <entry>172</entry>
              <entry>107</entry>
              <entry>guilsinglleft</entry>
            </row>
            <row>
              <entry>173</entry>
              <entry>108</entry>
              <entry>guilsinglright</entry>
            </row>
            <row>
              <entry>174</entry>
              <entry>109</entry>
              <entry>fi</entry>
            </row>
            <row>
              <entry>175</entry>
              <entry>110</entry>
              <entry>fl</entry>
            </row>
            <row>
              <entry>176</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>177</entry>
              <entry>111</entry>
              <entry>endash</entry>
            </row>
            <row>
              <entry>178</entry>
              <entry>112</entry>
              <entry>dagger</entry>
            </row>
            <row>
              <entry>179</entry>
              <entry>113</entry>
              <entry>daggerdbl</entry>
            </row>
            <row>
              <entry>180</entry>
              <entry>114</entry>
              <entry>periodcentered</entry>
            </row>
            <row>
              <entry>181</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>182</entry>
              <entry>115</entry>
              <entry>paragraph</entry>
            </row>
            <row>
              <entry>183</entry>
              <entry>116</entry>
              <entry>bullet</entry>
            </row>
            <row>
              <entry>184</entry>
              <entry>117</entry>
              <entry>quotesinglbase</entry>
            </row>
            <row>
              <entry>185</entry>
              <entry>118</entry>
              <entry>quotedblbase</entry>
            </row>
            <row>
              <entry>186</entry>
              <entry>119</entry>
              <entry>quotedblright</entry>
            </row>
            <row>
              <entry>187</entry>
              <entry>120</entry>
              <entry>guillemotright</entry>
            </row>
            <row>
              <entry>188</entry>
              <entry>121</entry>
              <entry>ellipsis</entry>
            </row>
            <row>
              <entry>189</entry>
              <entry>122</entry>
              <entry>perthousand</entry>
            </row>
            <row>
              <entry>190</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>191</entry>
              <entry>123</entry>
              <entry>questiondown</entry>
            </row>
            <row>
              <entry>192</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>193</entry>
              <entry>124</entry>
              <entry>grave</entry>
            </row>
            <row>
              <entry>194</entry>
              <entry>125</entry>
              <entry>acute</entry>
            </row>
            <row>
              <entry>195</entry>
              <entry>126</entry>
              <entry>circumflex</entry>
            </row>
            <row>
              <entry>196</entry>
              <entry>127</entry>
              <entry>tilde</entry>
            </row>
            <row>
              <entry>197</entry>
              <entry>128</entry>
              <entry>macron</entry>
            </row>
            <row>
              <entry>198</entry>
              <entry>129</entry>
              <entry>breve</entry>
            </row>
            <row>
              <entry>199</entry>
              <entry>130</entry>
              <entry>dotaccent</entry>
            </row>
            <row>
              <entry>200</entry>
              <entry>131</entry>
              <entry>dieresis</entry>
            </row>
            <row>
              <entry>201</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>202</entry>
              <entry>132</entry>
              <entry>ring</entry>
            </row>
            <row>
              <entry>203</entry>
              <entry>133</entry>
              <entry>cedilla</entry>
            </row>
            <row>
              <entry>204</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>205</entry>
              <entry>134</entry>
              <entry>hungarumlaut</entry>
            </row>
            <row>
              <entry>206</entry>
              <entry>135</entry>
              <entry>ogonek</entry>
            </row>
            <row>
              <entry>207</entry>
              <entry>136</entry>
              <entry>caron</entry>
            </row>
            <row>
              <entry>208</entry>
              <entry>137</entry>
              <entry>emdash</entry>
            </row>
            <row>
              <entry>209</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>210</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>211</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>212</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>213</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>214</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>215</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>216</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>217</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>218</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>219</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>220</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>221</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>222</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>223</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>224</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>225</entry>
              <entry>138</entry>
              <entry>AE</entry>
            </row>
            <row>
              <entry>226</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>227</entry>
              <entry>139</entry>
              <entry>ordfeminine</entry>
            </row>
            <row>
              <entry>228</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>229</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>230</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>231</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>232</entry>
              <entry>140</entry>
              <entry>Lslash</entry>
            </row>
            <row>
              <entry>233</entry>
              <entry>141</entry>
              <entry>Oslash</entry>
            </row>
            <row>
              <entry>234</entry>
              <entry>142</entry>
              <entry>OE</entry>
            </row>
            <row>
              <entry>235</entry>
              <entry>143</entry>
              <entry>ordmasculine</entry>
            </row>
            <row>
              <entry>236</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>237</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>238</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>239</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>240</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>241</entry>
              <entry>144</entry>
              <entry>ae</entry>
            </row>
            <row>
              <entry>242</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>243</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>244</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>245</entry>
              <entry>145</entry>
              <entry>dotlessi</entry>
            </row>
            <row>
              <entry>246</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>247</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>248</entry>
              <entry>146</entry>
              <entry>lslash</entry>
            </row>
            <row>
              <entry>249</entry>
              <entry>147</entry>
              <entry>oslash</entry>
            </row>
            <row>
              <entry>250</entry>
              <entry>148</entry>
              <entry>oe</entry>
            </row>
            <row>
              <entry>251</entry>
              <entry>149</entry>
              <entry>germandbls</entry>
            </row>
            <row>
              <entry>252</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>253</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>254</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>255</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
          </tbody>
        </tgroup>
      </table>


      <table>
        <title>Expert Encoding</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>code</entry>
              <entry>SID</entry>
              <entry>name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>5</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>7</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>9</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>11</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>12</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>16</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>17</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>18</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>19</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>20</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>21</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>22</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>23</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>24</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>25</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>26</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>28</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>29</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>30</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>31</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>32</entry>
              <entry>1</entry>
              <entry>space</entry>
            </row>
            <row>
              <entry>33</entry>
              <entry>229</entry>
              <entry>exclamsmall</entry>
            </row>
            <row>
              <entry>34</entry>
              <entry>230</entry>
              <entry>Hungarumlautsmall</entry>
            </row>
            <row>
              <entry>35</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>36</entry>
              <entry>231</entry>
              <entry>dollaroldstyle</entry>
            </row>
            <row>
              <entry>37</entry>
              <entry>232</entry>
              <entry>dollarsuperior</entry>
            </row>
            <row>
              <entry>38</entry>
              <entry>233</entry>
              <entry>ampersandsmall</entry>
            </row>
            <row>
              <entry>39</entry>
              <entry>234</entry>
              <entry>Acutesmall</entry>
            </row>
            <row>
              <entry>40</entry>
              <entry>235</entry>
              <entry>parenleftsuperior</entry>
            </row>
            <row>
              <entry>41</entry>
              <entry>236</entry>
              <entry>parenrightsuperior</entry>
            </row>
            <row>
              <entry>42</entry>
              <entry>237</entry>
              <entry>twodotenleader</entry>
            </row>
            <row>
              <entry>43</entry>
              <entry>238</entry>
              <entry>onedotenleader</entry>
            </row>
            <row>
              <entry>44</entry>
              <entry>13</entry>
              <entry>comma</entry>
            </row>
            <row>
              <entry>45</entry>
              <entry>14</entry>
              <entry>hyphen</entry>
            </row>
            <row>
              <entry>46</entry>
              <entry>15</entry>
              <entry>period</entry>
            </row>
            <row>
              <entry>47</entry>
              <entry>99</entry>
              <entry>fraction</entry>
            </row>
            <row>
              <entry>48</entry>
              <entry>239</entry>
              <entry>zerooldstyle</entry>
            </row>
            <row>
              <entry>49</entry>
              <entry>240</entry>
              <entry>oneoldstyle</entry>
            </row>
            <row>
              <entry>50</entry>
              <entry>241</entry>
              <entry>twooldstyle</entry>
            </row>
            <row>
              <entry>51</entry>
              <entry>242</entry>
              <entry>threeoldstyle</entry>
            </row>
            <row>
              <entry>52</entry>
              <entry>243</entry>
              <entry>fouroldstyle</entry>
            </row>
            <row>
              <entry>53</entry>
              <entry>244</entry>
              <entry>fiveoldstyle</entry>
            </row>
            <row>
              <entry>54</entry>
              <entry>245</entry>
              <entry>sixoldstyle</entry>
            </row>
            <row>
              <entry>55</entry>
              <entry>246</entry>
              <entry>sevenoldstyle</entry>
            </row>
            <row>
              <entry>56</entry>
              <entry>247</entry>
              <entry>eightoldstyle</entry>
            </row>
            <row>
              <entry>57</entry>
              <entry>248</entry>
              <entry>nineoldstyle</entry>
            </row>
            <row>
              <entry>58</entry>
              <entry>27</entry>
              <entry>colon</entry>
            </row>
            <row>
              <entry>59</entry>
              <entry>28</entry>
              <entry>semicolon</entry>
            </row>
            <row>
              <entry>60</entry>
              <entry>249</entry>
              <entry>commasuperior</entry>
            </row>
            <row>
              <entry>61</entry>
              <entry>250</entry>
              <entry>threequartersemdash</entry>
            </row>
            <row>
              <entry>62</entry>
              <entry>251</entry>
              <entry>periodsuperior</entry>
            </row>
            <row>
              <entry>63</entry>
              <entry>252</entry>
              <entry>questionsmall</entry>
            </row>
            <row>
              <entry>64</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>65</entry>
              <entry>253</entry>
              <entry>asuperior</entry>
            </row>
            <row>
              <entry>66</entry>
              <entry>254</entry>
              <entry>bsuperior</entry>
            </row>
            <row>
              <entry>67</entry>
              <entry>255</entry>
              <entry>centsuperior</entry>
            </row>
            <row>
              <entry>68</entry>
              <entry>256</entry>
              <entry>dsuperior</entry>
            </row>
            <row>
              <entry>69</entry>
              <entry>257</entry>
              <entry>esuperior</entry>
            </row>
            <row>
              <entry>70</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>71</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>72</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>73</entry>
              <entry>258</entry>
              <entry>isuperior</entry>
            </row>
            <row>
              <entry>74</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>75</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>76</entry>
              <entry>259</entry>
              <entry>lsuperior</entry>
            </row>
            <row>
              <entry>77</entry>
              <entry>260</entry>
              <entry>msuperior</entry>
            </row>
            <row>
              <entry>78</entry>
              <entry>261</entry>
              <entry>nsuperior</entry>
            </row>
            <row>
              <entry>79</entry>
              <entry>262</entry>
              <entry>osuperior</entry>
            </row>
            <row>
              <entry>80</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>81</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>82</entry>
              <entry>263</entry>
              <entry>rsuperior</entry>
            </row>
            <row>
              <entry>83</entry>
              <entry>264</entry>
              <entry>ssuperior</entry>
            </row>
            <row>
              <entry>84</entry>
              <entry>265</entry>
              <entry>tsuperior</entry>
            </row>
            <row>
              <entry>85</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>86</entry>
              <entry>266</entry>
              <entry>ff</entry>
            </row>
            <row>
              <entry>87</entry>
              <entry>109</entry>
              <entry>fi</entry>
            </row>
            <row>
              <entry>88</entry>
              <entry>110</entry>
              <entry>fl</entry>
            </row>
            <row>
              <entry>89</entry>
              <entry>267</entry>
              <entry>ffi</entry>
            </row>
            <row>
              <entry>90</entry>
              <entry>268</entry>
              <entry>ffl</entry>
            </row>
            <row>
              <entry>91</entry>
              <entry>269</entry>
              <entry>parenleftinferior</entry>
            </row>
            <row>
              <entry>92</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>93</entry>
              <entry>270</entry>
              <entry>parenrightinferior</entry>
            </row>
            <row>
              <entry>94</entry>
              <entry>271</entry>
              <entry>Circumflexsmall</entry>
            </row>
            <row>
              <entry>95</entry>
              <entry>272</entry>
              <entry>hyphensuperior</entry>
            </row>
            <row>
              <entry>96</entry>
              <entry>273</entry>
              <entry>Gravesmall</entry>
            </row>
            <row>
              <entry>97</entry>
              <entry>274</entry>
              <entry>Asmall</entry>
            </row>
            <row>
              <entry>98</entry>
              <entry>275</entry>
              <entry>Bsmall</entry>
            </row>
            <row>
              <entry>99</entry>
              <entry>276</entry>
              <entry>Csmall</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>277</entry>
              <entry>Dsmall</entry>
            </row>
            <row>
              <entry>101</entry>
              <entry>278</entry>
              <entry>Esmall</entry>
            </row>
            <row>
              <entry>102</entry>
              <entry>279</entry>
              <entry>Fsmall</entry>
            </row>
            <row>
              <entry>103</entry>
              <entry>280</entry>
              <entry>Gsmall</entry>
            </row>
            <row>
              <entry>104</entry>
              <entry>281</entry>
              <entry>Hsmall</entry>
            </row>
            <row>
              <entry>105</entry>
              <entry>282</entry>
              <entry>Ismall</entry>
            </row>
            <row>
              <entry>106</entry>
              <entry>283</entry>
              <entry>Jsmall</entry>
            </row>
            <row>
              <entry>107</entry>
              <entry>284</entry>
              <entry>Ksmall</entry>
            </row>
            <row>
              <entry>108</entry>
              <entry>285</entry>
              <entry>Lsmall</entry>
            </row>
            <row>
              <entry>109</entry>
              <entry>286</entry>
              <entry>Msmall</entry>
            </row>
            <row>
              <entry>110</entry>
              <entry>287</entry>
              <entry>Nsmall</entry>
            </row>
            <row>
              <entry>111</entry>
              <entry>288</entry>
              <entry>Osmall</entry>
            </row>
            <row>
              <entry>112</entry>
              <entry>289</entry>
              <entry>Psmall</entry>
            </row>
            <row>
              <entry>113</entry>
              <entry>290</entry>
              <entry>Qsmall</entry>
            </row>
            <row>
              <entry>114</entry>
              <entry>291</entry>
              <entry>Rsmall</entry>
            </row>
            <row>
              <entry>115</entry>
              <entry>292</entry>
              <entry>Ssmall</entry>
            </row>
            <row>
              <entry>116</entry>
              <entry>293</entry>
              <entry>Tsmall</entry>
            </row>
            <row>
              <entry>117</entry>
              <entry>294</entry>
              <entry>Usmall</entry>
            </row>
            <row>
              <entry>118</entry>
              <entry>295</entry>
              <entry>Vsmall</entry>
            </row>
            <row>
              <entry>119</entry>
              <entry>296</entry>
              <entry>Wsmall</entry>
            </row>
            <row>
              <entry>120</entry>
              <entry>297</entry>
              <entry>Xsmall</entry>
            </row>
            <row>
              <entry>121</entry>
              <entry>298</entry>
              <entry>Ysmall</entry>
            </row>
            <row>
              <entry>122</entry>
              <entry>299</entry>
              <entry>Zsmall</entry>
            </row>
            <row>
              <entry>123</entry>
              <entry>300</entry>
              <entry>colonmonetary</entry>
            </row>
            <row>
              <entry>124</entry>
              <entry>301</entry>
              <entry>onefitted</entry>
            </row>
            <row>
              <entry>125</entry>
              <entry>302</entry>
              <entry>rupiah</entry>
            </row>
            <row>
              <entry>126</entry>
              <entry>303</entry>
              <entry>Tildesmall</entry>
            </row>
            <row>
              <entry>127</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>128</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>129</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>130</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>131</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>132</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>133</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>134</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>135</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>136</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>137</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>138</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>139</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>140</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>141</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>142</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>143</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>144</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>145</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>146</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>147</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>148</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>149</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>150</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>151</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>152</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>153</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>154</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>155</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>156</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>157</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>158</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>159</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>160</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>161</entry>
              <entry>304</entry>
              <entry>exclamdownsmall</entry>
            </row>
            <row>
              <entry>162</entry>
              <entry>305</entry>
              <entry>centoldstyle</entry>
            </row>
            <row>
              <entry>163</entry>
              <entry>306</entry>
              <entry>Lslashsmall</entry>
            </row>
            <row>
              <entry>164</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>165</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>166</entry>
              <entry>307</entry>
              <entry>Scaronsmall</entry>
            </row>
            <row>
              <entry>167</entry>
              <entry>308</entry>
              <entry>Zcaronsmall</entry>
            </row>
            <row>
              <entry>168</entry>
              <entry>309</entry>
              <entry>Dieresissmall</entry>
            </row>
            <row>
              <entry>169</entry>
              <entry>310</entry>
              <entry>Brevesmall</entry>
            </row>
            <row>
              <entry>170</entry>
              <entry>311</entry>
              <entry>Caronsmall</entry>
            </row>
            <row>
              <entry>171</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>172</entry>
              <entry>312</entry>
              <entry>Dotaccentsmall</entry>
            </row>
            <row>
              <entry>173</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>174</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>175</entry>
              <entry>313</entry>
              <entry>Macronsmall</entry>
            </row>
            <row>
              <entry>176</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>177</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>178</entry>
              <entry>314</entry>
              <entry>figuredash</entry>
            </row>
            <row>
              <entry>179</entry>
              <entry>315</entry>
              <entry>hypheninferior</entry>
            </row>
            <row>
              <entry>180</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>181</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>182</entry>
              <entry>316</entry>
              <entry>Ogoneksmall</entry>
            </row>
            <row>
              <entry>183</entry>
              <entry>317</entry>
              <entry>Ringsmall</entry>
            </row>
            <row>
              <entry>184</entry>
              <entry>318</entry>
              <entry>Cedillasmall</entry>
            </row>
            <row>
              <entry>185</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>186</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>187</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>188</entry>
              <entry>158</entry>
              <entry>onequarter</entry>
            </row>
            <row>
              <entry>189</entry>
              <entry>155</entry>
              <entry>onehalf</entry>
            </row>
            <row>
              <entry>190</entry>
              <entry>163</entry>
              <entry>threequarters</entry>
            </row>
            <row>
              <entry>191</entry>
              <entry>319</entry>
              <entry>questiondownsmall</entry>
            </row>
            <row>
              <entry>192</entry>
              <entry>320</entry>
              <entry>oneeighth</entry>
            </row>
            <row>
              <entry>193</entry>
              <entry>321</entry>
              <entry>threeeighths</entry>
            </row>
            <row>
              <entry>194</entry>
              <entry>322</entry>
              <entry>fiveeighths</entry>
            </row>
            <row>
              <entry>195</entry>
              <entry>323</entry>
              <entry>seveneighths</entry>
            </row>
            <row>
              <entry>196</entry>
              <entry>324</entry>
              <entry>onethird</entry>
            </row>
            <row>
              <entry>197</entry>
              <entry>325</entry>
              <entry>twothirds</entry>
            </row>
            <row>
              <entry>198</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>199</entry>
              <entry>0</entry>
              <entry>.notdef</entry>
            </row>
            <row>
              <entry>200</entry>
              <entry>326</entry>
              <entry>zerosuperior</entry>
            </row>
            <row>
              <entry>201</entry>
              <entry>150</entry>
              <entry>onesuperior</entry>
            </row>
            <row>
              <entry>202</entry>
              <entry>164</entry>
              <entry>twosuperior</entry>
            </row>
            <row>
              <entry>203</entry>
              <entry>169</entry>
              <entry>threesuperior</entry>
            </row>
            <row>
              <entry>204</entry>
              <entry>327</entry>
              <entry>foursuperior</entry>
            </row>
            <row>
              <entry>205</entry>
              <entry>328</entry>
              <entry>fivesuperior</entry>
            </row>
            <row>
              <entry>206</entry>
              <entry>329</entry>
              <entry>sixsuperior</entry>
            </row>
            <row>
              <entry>207</entry>
              <entry>330</entry>
              <entry>sevensuperior</entry>
            </row>
            <row>
              <entry>208</entry>
              <entry>331</entry>
              <entry>eightsuperior</entry>
            </row>
            <row>
              <entry>209</entry>
              <entry>332</entry>
              <entry>ninesuperior</entry>
            </row>
            <row>
              <entry>210</entry>
              <entry>333</entry>
              <entry>zeroinferior</entry>
            </row>
            <row>
              <entry>211</entry>
              <entry>334</entry>
              <entry>oneinferior</entry>
            </row>
            <row>
              <entry>212</entry>
              <entry>335</entry>
              <entry>twoinferior</entry>
            </row>
            <row>
              <entry>213</entry>
              <entry>336</entry>
              <entry>threeinferior</entry>
            </row>
            <row>
              <entry>214</entry>
              <entry>337</entry>
              <entry>fourinferior</entry>
           </row>
            <row>
              <entry>215</entry>
              <entry>338</entry>
              <entry>fiveinferior</entry>
            </row>
            <row>
              <entry>216</entry>
              <entry>339</entry>
              <entry>sixinferior</entry>
            </row>
            <row>
              <entry>217</entry>
              <entry>340</entry>
              <entry>seveninferior</entry>
            </row>
            <row>
              <entry>218</entry>
              <entry>341</entry>
              <entry>eightinferior</entry>
            </row>
            <row>
              <entry>219</entry>
              <entry>342</entry>
              <entry>nineinferior</entry>
            </row>
            <row>
              <entry>220</entry>
              <entry>343</entry>
              <entry>centinferior</entry>
            </row>
            <row>
              <entry>221</entry>
              <entry>344</entry>
              <entry>dollarinferior</entry>
            </row>
            <row>
              <entry>222</entry>
              <entry>345</entry>
              <entry>periodinferior</entry>
            </row>
            <row>
              <entry>223</entry>
              <entry>346</entry>
              <entry>commainferior</entry>
            </row>
            <row>
              <entry>224</entry>
              <entry>347</entry>
              <entry>Agravesmall</entry>
            </row>
            <row>
              <entry>225</entry>
              <entry>348</entry>
              <entry>Aacutesmall</entry>
            </row>
            <row>
              <entry>226</entry>
              <entry>349</entry>
              <entry>Acircumflexsmall</entry>
            </row>
            <row>
              <entry>227</entry>
              <entry>350</entry>
              <entry>Atildesmall</entry>
            </row>
            <row>
              <entry>228</entry>
              <entry>351</entry>
              <entry>Adieresissmall</entry>
            </row>
            <row>
              <entry>229</entry>
              <entry>352</entry>
              <entry>Aringsmall</entry>
            </row>
            <row>
              <entry>230</entry>
              <entry>353</entry>
              <entry>AEsmall</entry>
            </row>
            <row>
              <entry>231</entry>
              <entry>354</entry>
              <entry>Ccedillasmall</entry>
            </row>
            <row>
              <entry>232</entry>
              <entry>355</entry>
              <entry>Egravesmall</entry>
            </row>
            <row>
              <entry>233</entry>
              <entry>356</entry>
              <entry>Eacutesmall</entry>
            </row>
            <row>
              <entry>234</entry>
              <entry>357</entry>
              <entry>Ecircumflexsmall</entry>
            </row>
            <row>
              <entry>235</entry>
              <entry>358</entry>
              <entry>Edieresissmall</entry>
            </row>
            <row>
              <entry>236</entry>
              <entry>359</entry>
              <entry>Igravesmall</entry>
            </row>
            <row>
              <entry>237</entry>
              <entry>360</entry>
              <entry>Iacutesmall</entry>
            </row>
            <row>
              <entry>238</entry>
              <entry>361</entry>
              <entry>Icircumflexsmall</entry>
            </row>
            <row>
              <entry>239</entry>
              <entry>362</entry>
              <entry>Idieresissmall</entry>
            </row>
            <row>
              <entry>240</entry>
              <entry>363</entry>
              <entry>Ethsmall</entry>
            </row>
            <row>
              <entry>241</entry>
              <entry>364</entry>
              <entry>Ntildesmall</entry>
            </row>
            <row>
              <entry>242</entry>
              <entry>365</entry>
              <entry>Ogravesmall</entry>
            </row>
            <row>
              <entry>243</entry>
              <entry>366</entry>
              <entry>Oacutesmall</entry>
            </row>
            <row>
              <entry>244</entry>
              <entry>367</entry>
              <entry>Ocircumflexsmall</entry>
            </row>
            <row>
              <entry>245</entry>
              <entry>368</entry>
              <entry>Otildesmall</entry>
            </row>
            <row>
              <entry>246</entry>
              <entry>369</entry>
              <entry>Odieresissmall</entry>
            </row>
            <row>
              <entry>247</entry>
              <entry>370</entry>
              <entry>OEsmall</entry>
            </row>
            <row>
              <entry>248</entry>
              <entry>371</entry>
              <entry>Oslashsmall</entry>
            </row>
            <row>
              <entry>249</entry>
              <entry>372</entry>
              <entry>Ugravesmall</entry>
            </row>
            <row>
              <entry>250</entry>
              <entry>373</entry>
              <entry>Uacutesmall</entry>
            </row>
            <row>
              <entry>251</entry>
              <entry>374</entry>
              <entry>Ucircumflexsmall</entry>
            </row>
            <row>
              <entry>252</entry>
              <entry>375</entry>
              <entry>Udieresissmall</entry>
            </row>
            <row>
              <entry>253</entry>
              <entry>376</entry>
              <entry>Yacutesmall</entry>
            </row>
            <row>
              <entry>254</entry>
              <entry>377</entry>
              <entry>Thornsmall</entry>
            </row>
            <row>
              <entry>255</entry>
              <entry>378</entry>
              <entry>Ydieresissmall</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

<code-fragment id='cfffontset.constants'>
  <code-title>Predefined encodings</code-title>
  static final int[] standardEncoding = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          0,
          111,
          112,
          113,
          114,
          0,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          0,
          123,
          0,
          124,
          125,
          126,
          127,
          128,
          129,
          130,
          131,
          0,
          132,
          133,
          0,
          134,
          135,
          136,
          137,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          138,
          0,
          139,
          0,
          0,
          0,
          0,
          140,
          141,
          142,
          143,
          0,
          0,
          0,
          0,
          0,
          144,
          0,
          0,
          0,
          145,
          0,
          0,
          146,
          147,
          148,
          149,
          0,
          0,
          0,
          0};

  static final int[] expertEncoding = {
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          229,
          230,
          0,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          13,
          14,
          15,
          99,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          27,
          28,
          249,
          250,
          251,
          252,
          0,
          253,
          254,
          255,
          256,
          257,
          0,
          0,
          0,
          258,
          0,
          0,
          259,
          260,
          261,
          262,
          0,
          0,
          263,
          264,
          265,
          0,
          266,
          109,
          110,
          267,
          268,
          269,
          0,
          270,
          271,
          272,
          273,
          274,
          275,
          276,
          277,
          278,
          279,
          280,
          281,
          282,
          283,
          284,
          285,
          286,
          287,
          288,
          289,
          290,
          291,
          292,
          293,
          294,
          295,
          296,
          297,
          298,
          299,
          300,
          301,
          302,
          303,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          304,
          305,
          306,
          0,
          0,
          307,
          308,
          309,
          310,
          311,
          0,
          312,
          0,
          0,
          313,
          0,
          0,
          314,
          315,
          0,
          0,
          316,
          317,
          318,
          0,
          0,
          0,
          158,
          155,
          163,
          319,
          320,
          321,
          322,
          323,
          324,
          325,
          0,
          0,
          326,
          150,
          164,
          169,
          327,
          328,
          329,
          330,
          331,
          332,
          333,
          334,
          335,
          336,
          337,
          338,
          339,
          340,
          341,
          342,
          343,
          344,
          345,
          346,
          347,
          348,
          349,
          350,
          351,
          352,
          353,
          354,
          355,
          356,
          357,
          358,
          359,
          360,
          361,
          362,
          363,
          364,
          365,
          366,
          367,
          368,
          369,
          370,
          371,
          372,
          373,
          374,
          375,
          376,
          377,
          378};
</code-fragment>

      </section>
    </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix C: Predefined Charsets</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>All charsets are presented in GID order beginning with
        GID 1. (The .notdef glyph is implicitly GID 0 and is
        therefore not shown.)</para>

      <table>
        <title>ISOAdobe</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>SID</entry>
              <entry>name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>space</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>exclam</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>quotedbl</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>numbersign</entry>
            </row>
            <row>
              <entry>5</entry>
              <entry>dollar</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>percent</entry>
            </row>
            <row>
              <entry>7</entry>
              <entry>ampersand</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>quoteright</entry>
            </row>
            <row>
              <entry>9</entry>
              <entry>parenleft</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>parenright</entry>
            </row>
            <row>
              <entry>11</entry>
              <entry>asterisk</entry>
            </row>
            <row>
              <entry>12</entry>
              <entry>plus</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>comma</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>hyphen</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>period</entry>
            </row>
            <row>
              <entry>16</entry>
              <entry>slash</entry>
            </row>
            <row>
              <entry>17</entry>
              <entry>zero</entry>
            </row>
            <row>
              <entry>18</entry>
              <entry>one</entry>
            </row>
            <row>
              <entry>19</entry>
              <entry>two</entry>
            </row>
            <row>
              <entry>20</entry>
              <entry>three</entry>
            </row>
            <row>
              <entry>21</entry>
              <entry>four</entry>
            </row>
            <row>
              <entry>22</entry>
              <entry>five</entry>
            </row>
            <row>
              <entry>23</entry>
              <entry>six</entry>
            </row>
            <row>
              <entry>24</entry>
              <entry>seven</entry>
            </row>
            <row>
              <entry>25</entry>
              <entry>eight</entry>
            </row>
            <row>
              <entry>26</entry>
              <entry>nine</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>colon</entry>
            </row>
            <row>
              <entry>28</entry>
              <entry>semicolon</entry>
            </row>
            <row>
              <entry>29</entry>
              <entry>less</entry>
            </row>
            <row>
              <entry>30</entry>
              <entry>equal</entry>
            </row>
            <row>
              <entry>31</entry>
              <entry>greater</entry>
            </row>
            <row>
              <entry>32</entry>
              <entry>question</entry>
            </row>
            <row>
              <entry>33</entry>
              <entry>at</entry>
            </row>
            <row>
              <entry>34</entry>
              <entry>A</entry>
            </row>
            <row>
              <entry>35</entry>
              <entry>B</entry>
            </row>
            <row>
              <entry>36</entry>
              <entry>C</entry>
            </row>
            <row>
              <entry>37</entry>
              <entry>D</entry>
            </row>
            <row>
              <entry>38</entry>
              <entry>E</entry>
            </row>
            <row>
              <entry>39</entry>
              <entry>F</entry>
            </row>
            <row>
              <entry>40</entry>
              <entry>G</entry>
            </row>
            <row>
              <entry>41</entry>
              <entry>H</entry>
            </row>
            <row>
              <entry>42</entry>
              <entry>I</entry>
            </row>
            <row>
              <entry>43</entry>
              <entry>J</entry>
            </row>
            <row>
              <entry>44</entry>
              <entry>K</entry>
            </row>
            <row>
              <entry>45</entry>
              <entry>L</entry>
            </row>
            <row>
              <entry>46</entry>
              <entry>M</entry>
            </row>
            <row>
              <entry>47</entry>
              <entry>N</entry>
            </row>
            <row>
              <entry>48</entry>
              <entry>O</entry>
            </row>
            <row>
              <entry>49</entry>
              <entry>P</entry>
            </row>
            <row>
              <entry>50</entry>
              <entry>Q</entry>
            </row>
            <row>
              <entry>51</entry>
              <entry>R</entry>
            </row>
            <row>
              <entry>52</entry>
              <entry>S</entry>
            </row>
            <row>
              <entry>53</entry>
              <entry>T</entry>
            </row>
            <row>
              <entry>54</entry>
              <entry>U</entry>
            </row>
            <row>
              <entry>55</entry>
              <entry>V</entry>
            </row>
            <row>
              <entry>56</entry>
              <entry>W</entry>
            </row>
            <row>
              <entry>57</entry>
              <entry>X</entry>
            </row>
            <row>
              <entry>58</entry>
              <entry>Y</entry>
            </row>
            <row>
              <entry>59</entry>
              <entry>Z</entry>
            </row>
            <row>
              <entry>60</entry>
              <entry>bracketleft</entry>
            </row>
            <row>
              <entry>61</entry>
              <entry>backslash</entry>
            </row>
            <row>
              <entry>62</entry>
              <entry>bracketright</entry>
            </row>
            <row>
              <entry>63</entry>
              <entry>asciicircum</entry>
            </row>
            <row>
              <entry>64</entry>
              <entry>underscore</entry>
            </row>
            <row>
              <entry>65</entry>
              <entry>quoteleft</entry>
            </row>
            <row>
              <entry>66</entry>
              <entry>a</entry>
            </row>
            <row>
              <entry>67</entry>
              <entry>b</entry>
            </row>
            <row>
              <entry>68</entry>
              <entry>c</entry>
            </row>
            <row>
              <entry>69</entry>
              <entry>d</entry>
            </row>
            <row>
              <entry>70</entry>
              <entry>e</entry>
            </row>
            <row>
              <entry>71</entry>
              <entry>f</entry>
            </row>
            <row>
              <entry>72</entry>
              <entry>g</entry>
            </row>
            <row>
              <entry>73</entry>
              <entry>h</entry>
            </row>
            <row>
              <entry>74</entry>
              <entry>i</entry>
            </row>
            <row>
              <entry>75</entry>
              <entry>j</entry>
            </row>
            <row>
              <entry>76</entry>
              <entry>k</entry>
            </row>
            <row>
              <entry>77</entry>
              <entry>l</entry>
            </row>
            <row>
              <entry>78</entry>
              <entry>m</entry>
            </row>
            <row>
              <entry>79</entry>
              <entry>n</entry>
            </row>
            <row>
              <entry>80</entry>
              <entry>o</entry>
            </row>
            <row>
              <entry>81</entry>
              <entry>p</entry>
            </row>
            <row>
              <entry>82</entry>
              <entry>q</entry>
            </row>
            <row>
              <entry>83</entry>
              <entry>r</entry>
            </row>
            <row>
              <entry>84</entry>
              <entry>s</entry>
            </row>
            <row>
              <entry>85</entry>
              <entry>t</entry>
            </row>
            <row>
              <entry>86</entry>
              <entry>u</entry>
            </row>
            <row>
              <entry>87</entry>
              <entry>v</entry>
            </row>
            <row>
              <entry>88</entry>
              <entry>w</entry>
            </row>
            <row>
              <entry>89</entry>
              <entry>x</entry>
            </row>
            <row>
              <entry>90</entry>
              <entry>y</entry>
            </row>
            <row>
              <entry>91</entry>
              <entry>z</entry>
            </row>
            <row>
              <entry>92</entry>
              <entry>braceleft</entry>
            </row>
            <row>
              <entry>93</entry>
              <entry>bar</entry>
            </row>
            <row>
              <entry>94</entry>
              <entry>braceright</entry>
            </row>
            <row>
              <entry>95</entry>
              <entry>asciitilde</entry>
            </row>
            <row>
              <entry>96</entry>
              <entry>exclamdown</entry>
            </row>
            <row>
              <entry>97</entry>
              <entry>cent</entry>
            </row>
            <row>
              <entry>98</entry>
              <entry>sterling</entry>
            </row>
            <row>
              <entry>99</entry>
              <entry>fraction</entry>
            </row>
            <row>
              <entry>100</entry>
              <entry>yen</entry>
            </row>
            <row>
              <entry>101</entry>
              <entry>florin</entry>
            </row>
            <row>
              <entry>102</entry>
              <entry>section</entry>
            </row>
            <row>
              <entry>103</entry>
              <entry>currency</entry>
            </row>
            <row>
              <entry>104</entry>
              <entry>quotesingle</entry>
            </row>
            <row>
              <entry>105</entry>
              <entry>quotedblleft</entry>
            </row>
            <row>
              <entry>106</entry>
              <entry>guillemotleft</entry>
            </row>
            <row>
              <entry>107</entry>
              <entry>guilsinglleft</entry>
            </row>
            <row>
              <entry>108</entry>
              <entry>guilsinglright</entry>
            </row>
            <row>
              <entry>109</entry>
              <entry>fi</entry>
            </row>
            <row>
              <entry>110</entry>
              <entry>fl</entry>
            </row>
            <row>
              <entry>111</entry>
              <entry>endash</entry>
            </row>
            <row>
              <entry>112</entry>
              <entry>dagger</entry>
            </row>
            <row>
              <entry>113</entry>
              <entry>daggerdbl</entry>
            </row>
            <row>
              <entry>114</entry>
              <entry>periodcentered</entry>
            </row>
            <row>
              <entry>115</entry>
              <entry>paragraph</entry>
            </row>
            <row>
              <entry>116</entry>
              <entry>bullet</entry>
            </row>
            <row>
              <entry>117</entry>
              <entry>quotesinglbase</entry>
            </row>
            <row>
              <entry>118</entry>
              <entry>quotedblbase</entry>
            </row>
            <row>
              <entry>119</entry>
              <entry>quotedblright</entry>
            </row>
            <row>
              <entry>120</entry>
              <entry>guillemotright</entry>
            </row>
            <row>
              <entry>121</entry>
              <entry>ellipsis</entry>
            </row>
            <row>
              <entry>122</entry>
              <entry>perthousand</entry>
            </row>
            <row>
              <entry>123</entry>
              <entry>questiondown</entry>
            </row>
            <row>
              <entry>124</entry>
              <entry>grave</entry>
            </row>
            <row>
              <entry>125</entry>
              <entry>acute</entry>
            </row>
            <row>
              <entry>126</entry>
              <entry>circumflex</entry>
            </row>
            <row>
              <entry>127</entry>
              <entry>tilde</entry>
            </row>
            <row>
              <entry>128</entry>
              <entry>macron</entry>
            </row>
            <row>
              <entry>129</entry>
              <entry>breve</entry>
            </row>
            <row>
              <entry>130</entry>
              <entry>dotaccent</entry>
            </row>
            <row>
              <entry>131</entry>
              <entry>dieresis</entry>
            </row>
            <row>
              <entry>132</entry>
              <entry>ring</entry>
            </row>
            <row>
              <entry>133</entry>
              <entry>cedilla</entry>
            </row>
            <row>
              <entry>134</entry>
              <entry>hungarumlaut</entry>
            </row>
            <row>
              <entry>135</entry>
              <entry>ogonek</entry>
            </row>
            <row>
              <entry>136</entry>
              <entry>caron</entry>
            </row>
            <row>
              <entry>137</entry>
              <entry>emdash</entry>
            </row>
            <row>
              <entry>138</entry>
              <entry>AE</entry>
            </row>
            <row>
              <entry>139</entry>
              <entry>ordfeminine</entry>
            </row>
            <row>
              <entry>140</entry>
              <entry>Lslash</entry>
            </row>
            <row>
              <entry>141</entry>
              <entry>Oslash</entry>
            </row>
            <row>
              <entry>142</entry>
              <entry>OE</entry>
            </row>
            <row>
              <entry>143</entry>
              <entry>ordmasculine</entry>
            </row>
            <row>
              <entry>144</entry>
              <entry>ae</entry>
            </row>
            <row>
              <entry>145</entry>
              <entry>dotlessi</entry>
            </row>
            <row>
              <entry>146</entry>
              <entry>lslash</entry>
            </row>
            <row>
              <entry>147</entry>
              <entry>oslash</entry>
            </row>
            <row>
              <entry>148</entry>
              <entry>oe</entry>
            </row>
            <row>
              <entry>149</entry>
              <entry>germandbls</entry>
            </row>
            <row>
              <entry>150</entry>
              <entry>onesuperior</entry>
            </row>
            <row>
              <entry>151</entry>
              <entry>logicalnot</entry>
            </row>
            <row>
              <entry>152</entry>
              <entry>mu</entry>
            </row>
            <row>
              <entry>153</entry>
              <entry>trademark</entry>
            </row>
            <row>
              <entry>154</entry>
              <entry>Eth</entry>
            </row>
            <row>
              <entry>155</entry>
              <entry>onehalf</entry>
            </row>
            <row>
              <entry>156</entry>
              <entry>plusminus</entry>
            </row>
            <row>
              <entry>157</entry>
              <entry>Thorn</entry>
            </row>
            <row>
              <entry>158</entry>
              <entry>onequarter</entry>
            </row>
            <row>
              <entry>159</entry>
              <entry>divide</entry>
            </row>
            <row>
              <entry>160</entry>
              <entry>brokenbar</entry>
            </row>
            <row>
              <entry>161</entry>
              <entry>degree</entry>
            </row>
            <row>
              <entry>162</entry>
              <entry>thorn</entry>
            </row>
            <row>
              <entry>163</entry>
              <entry>threequarters</entry>
            </row>
            <row>
              <entry>164</entry>
              <entry>twosuperior</entry>
            </row>
            <row>
              <entry>165</entry>
              <entry>registered</entry>
            </row>
            <row>
              <entry>166</entry>
              <entry>minus</entry>
            </row>
            <row>
              <entry>167</entry>
              <entry>eth</entry>
            </row>
            <row>
              <entry>168</entry>
              <entry>multiply</entry>
            </row>
            <row>
              <entry>169</entry>
              <entry>threesuperior</entry>
            </row>
            <row>
              <entry>170</entry>
              <entry>copyright</entry>
            </row>
            <row>
              <entry>171</entry>
              <entry>Aacute</entry>
            </row>
            <row>
              <entry>172</entry>
              <entry>Acircumflex</entry>
            </row>
            <row>
              <entry>173</entry>
              <entry>Adieresis</entry>
            </row>
            <row>
              <entry>174</entry>
              <entry>Agrave</entry>
            </row>
            <row>
              <entry>175</entry>
              <entry>Aring</entry>
            </row>
            <row>
              <entry>176</entry>
              <entry>Atilde</entry>
            </row>
            <row>
              <entry>177</entry>
              <entry>Ccedilla</entry>
            </row>
            <row>
              <entry>178</entry>
              <entry>Eacute</entry>
            </row>
            <row>
              <entry>179</entry>
              <entry>Ecircumflex</entry>
            </row>
            <row>
              <entry>180</entry>
              <entry>Edieresis</entry>
            </row>
            <row>
              <entry>181</entry>
              <entry>Egrave</entry>
            </row>
            <row>
              <entry>182</entry>
              <entry>Iacute</entry>
            </row>
            <row>
              <entry>183</entry>
              <entry>Icircumflex</entry>
            </row>
            <row>
              <entry>184</entry>
              <entry>Idieresis</entry>
            </row>
            <row>
              <entry>185</entry>
              <entry>Igrave</entry>
            </row>
            <row>
              <entry>186</entry>
              <entry>Ntilde</entry>
            </row>
            <row>
              <entry>187</entry>
              <entry>Oacute</entry>
            </row>
            <row>
              <entry>188</entry>
              <entry>Ocircumflex</entry>
            </row>
            <row>
              <entry>189</entry>
              <entry>Odieresis</entry>
            </row>
            <row>
              <entry>190</entry>
              <entry>Ograve</entry>
            </row>
            <row>
              <entry>191</entry>
              <entry>Otilde</entry>
            </row>
            <row>
              <entry>192</entry>
              <entry>Scaron</entry>
            </row>
            <row>
              <entry>193</entry>
              <entry>Uacute</entry>
            </row>
            <row>
              <entry>194</entry>
              <entry>Ucircumflex</entry>
            </row>
            <row>
              <entry>195</entry>
              <entry>Udieresis</entry>
            </row>
            <row>
              <entry>196</entry>
              <entry>Ugrave</entry>
            </row>
            <row>
              <entry>197</entry>
              <entry>Yacute</entry>
            </row>
            <row>
              <entry>198</entry>
              <entry>Ydieresis</entry>
            </row>
            <row>
              <entry>199</entry>
              <entry>Zcaron</entry>
            </row>
            <row>
              <entry>200</entry>
              <entry>aacute</entry>
            </row>
            <row>
              <entry>201</entry>
              <entry>acircumflex</entry>
            </row>
            <row>
              <entry>202</entry>
              <entry>adieresis</entry>
            </row>
            <row>
              <entry>203</entry>
              <entry>agrave</entry>
            </row>
            <row>
              <entry>204</entry>
              <entry>aring</entry>
            </row>
            <row>
              <entry>205</entry>
              <entry>atilde</entry>
            </row>
            <row>
              <entry>206</entry>
              <entry>ccedilla</entry>
            </row>
            <row>
              <entry>207</entry>
              <entry>eacute</entry>
            </row>
            <row>
              <entry>208</entry>
              <entry>ecircumflex</entry>
            </row>
            <row>
              <entry>209</entry>
              <entry>edieresis</entry>
            </row>
            <row>
              <entry>210</entry>
              <entry>egrave</entry>
            </row>
            <row>
              <entry>211</entry>
              <entry>iacute</entry>
            </row>
            <row>
              <entry>212</entry>
              <entry>icircumflex</entry>
            </row>
            <row>
              <entry>213</entry>
              <entry>idieresis</entry>
            </row>
            <row>
              <entry>214</entry>
              <entry>igrave</entry>
            </row>
            <row>
              <entry>215</entry>
              <entry>ntilde</entry>
            </row>
            <row>
              <entry>216</entry>
              <entry>oacute</entry>
            </row>
            <row>
              <entry>217</entry>
              <entry>ocircumflex</entry>
            </row>
            <row>
              <entry>218</entry>
              <entry>odieresis</entry>
            </row>
            <row>
              <entry>219</entry>
              <entry>ograve</entry>
            </row>
            <row>
              <entry>220</entry>
              <entry>otilde</entry>
            </row>
            <row>
              <entry>221</entry>
              <entry>scaron</entry>
            </row>
            <row>
              <entry>222</entry>
              <entry>uacute</entry>
            </row>
            <row>
              <entry>223</entry>
              <entry>ucircumflex</entry>
            </row>
            <row>
              <entry>224</entry>
              <entry>udieresis</entry>
            </row>
            <row>
              <entry>225</entry>
              <entry>ugrave</entry>
            </row>
            <row>
              <entry>226</entry>
              <entry>yacute</entry>
            </row>
            <row>
              <entry>227</entry>
              <entry>ydieresis</entry>
            </row>
            <row>
              <entry>228</entry>
              <entry>zcaron</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Expert</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>SID</entry>
              <entry>name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>space</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>comma</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>hyphen</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>period</entry>
            </row>
            <row>
              <entry>99</entry>
              <entry>fraction</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>colon</entry>
            </row>
            <row>
              <entry>28</entry>
              <entry>semicolon</entry>
            </row>
            <row>
              <entry>229</entry>
              <entry>exclamsmall</entry>
            </row>
            <row>
              <entry>230</entry>
              <entry>Hungarumlautsmall</entry>
            </row>
            <row>
              <entry>231</entry>
              <entry>dollaroldstyle</entry>
            </row>
            <row>
              <entry>232</entry>
              <entry>dollarsuperior</entry>
            </row>
            <row>
              <entry>233</entry>
              <entry>ampersandsmall</entry>
            </row>
            <row>
              <entry>234</entry>
              <entry>Acutesmall</entry>
            </row>
            <row>
              <entry>235</entry>
              <entry>parenleftsuperior</entry>
            </row>
            <row>
              <entry>236</entry>
              <entry>parenrightsuperior</entry>
            </row>
            <row>
              <entry>237</entry>
              <entry>twodotenleader</entry>
            </row>
            <row>
              <entry>238</entry>
              <entry>onedotenleader</entry>
            </row>
            <row>
              <entry>239</entry>
              <entry>zerooldstyle</entry>
            </row>
            <row>
              <entry>240</entry>
              <entry>oneoldstyle</entry>
            </row>
            <row>
              <entry>241</entry>
              <entry>twooldstyle</entry>
            </row>
            <row>
              <entry>242</entry>
              <entry>threeoldstyle</entry>
            </row>
            <row>
              <entry>243</entry>
              <entry>fouroldstyle</entry>
            </row>
            <row>
              <entry>244</entry>
              <entry>fiveoldstyle</entry>
            </row>
            <row>
              <entry>245</entry>
              <entry>sixoldstyle</entry>
            </row>
            <row>
              <entry>246</entry>
              <entry>sevenoldstyle</entry>
            </row>
            <row>
              <entry>247</entry>
              <entry>eightoldstyle</entry>
            </row>
            <row>
              <entry>248</entry>
              <entry>nineoldstyle</entry>
            </row>
            <row>
              <entry>249</entry>
              <entry>commasuperior</entry>
            </row>
            <row>
              <entry>250</entry>
              <entry>threequartersemdash</entry>
            </row>
            <row>
              <entry>251</entry>
              <entry>periodsuperior</entry>
            </row>
            <row>
              <entry>252</entry>
              <entry>questionsmall</entry>
            </row>
            <row>
              <entry>253</entry>
              <entry>asuperior</entry>
            </row>
            <row>
              <entry>254</entry>
              <entry>bsuperior</entry>
            </row>
            <row>
              <entry>255</entry>
              <entry>centsuperior</entry>
            </row>
            <row>
              <entry>256</entry>
              <entry>dsuperior</entry>
            </row>
            <row>
              <entry>257</entry>
              <entry>esuperior</entry>
            </row>
            <row>
              <entry>258</entry>
              <entry>isuperior</entry>
            </row>
            <row>
              <entry>259</entry>
              <entry>lsuperior</entry>
            </row>
            <row>
              <entry>260</entry>
              <entry>msuperior</entry>
            </row>
            <row>
              <entry>261</entry>
              <entry>nsuperior</entry>
            </row>
            <row>
              <entry>262</entry>
              <entry>osuperior</entry>
            </row>
            <row>
              <entry>263</entry>
              <entry>rsuperior</entry>
            </row>
            <row>
              <entry>264</entry>
              <entry>ssuperior</entry>
            </row>
            <row>
              <entry>265</entry>
              <entry>tsuperior</entry>
            </row>
            <row>
              <entry>266</entry>
              <entry>ff</entry>
            </row>
            <row>
              <entry>109</entry>
              <entry>fi</entry>
            </row>
            <row>
              <entry>110</entry>
              <entry>fl</entry>
            </row>
            <row>
              <entry>267</entry>
              <entry>ffi</entry>
            </row>
            <row>
              <entry>268</entry>
              <entry>ffl</entry>
            </row>
            <row>
              <entry>269</entry>
              <entry>parenleftinferior</entry>
            </row>
            <row>
              <entry>270</entry>
              <entry>parenrightinferior</entry>
            </row>
            <row>
              <entry>271</entry>
              <entry>Circumflexsmall</entry>
            </row>
            <row>
              <entry>272</entry>
              <entry>hyphensuperior</entry>
            </row>
            <row>
              <entry>273</entry>
              <entry>Gravesmall</entry>
            </row>
            <row>
              <entry>274</entry>
              <entry>Asmall</entry>
            </row>
            <row>
              <entry>275</entry>
              <entry>Bsmall</entry>
            </row>
            <row>
              <entry>276</entry>
              <entry>Csmall</entry>
            </row>
            <row>
              <entry>277</entry>
              <entry>Dsmall</entry>
            </row>
            <row>
              <entry>278</entry>
              <entry>Esmall</entry>
            </row>
            <row>
              <entry>279</entry>
              <entry>Fsmall</entry>
            </row>
            <row>
              <entry>280</entry>
              <entry>Gsmall</entry>
            </row>
            <row>
              <entry>281</entry>
              <entry>Hsmall</entry>
            </row>
            <row>
              <entry>282</entry>
              <entry>Ismall</entry>
            </row>
            <row>
              <entry>283</entry>
              <entry>Jsmall</entry>
            </row>
            <row>
              <entry>284</entry>
              <entry>Ksmall</entry>
            </row>
            <row>
              <entry>285</entry>
              <entry>Lsmall</entry>
            </row>
            <row>
              <entry>286</entry>
              <entry>Msmall</entry>
            </row>
            <row>
              <entry>287</entry>
              <entry>Nsmall</entry>
            </row>
            <row>
              <entry>288</entry>
              <entry>Osmall</entry>
            </row>
            <row>
              <entry>289</entry>
              <entry>Psmall</entry>
            </row>
            <row>
              <entry>290</entry>
              <entry>Qsmall</entry>
            </row>
            <row>
              <entry>291</entry>
              <entry>Rsmall</entry>
            </row>
            <row>
              <entry>292</entry>
              <entry>Ssmall</entry>
            </row>
            <row>
              <entry>293</entry>
              <entry>Tsmall</entry>
            </row>
            <row>
              <entry>294</entry>
              <entry>Usmall</entry>
            </row>
            <row>
              <entry>295</entry>
              <entry>Vsmall</entry>
            </row>
            <row>
              <entry>296</entry>
              <entry>Wsmall</entry>
            </row>
            <row>
              <entry>297</entry>
              <entry>Xsmall</entry>
            </row>
            <row>
              <entry>298</entry>
              <entry>Ysmall</entry>
            </row>
            <row>
              <entry>299</entry>
              <entry>Zsmall</entry>
            </row>
            <row>
              <entry>300</entry>
              <entry>colonmonetary</entry>
            </row>
            <row>
              <entry>301</entry>
              <entry>onefitted</entry>
            </row>
            <row>
              <entry>302</entry>
              <entry>rupiah</entry>
            </row>
            <row>
              <entry>303</entry>
              <entry>Tildesmall</entry>
            </row>
            <row>
              <entry>304</entry>
              <entry>exclamdownsmall</entry>
            </row>
            <row>
              <entry>305</entry>
              <entry>centoldstyle</entry>
            </row>
            <row>
              <entry>306</entry>
              <entry>Lslashsmall</entry>
            </row>
            <row>
              <entry>307</entry>
              <entry>Scaronsmall</entry>
            </row>
            <row>
              <entry>308</entry>
              <entry>Zcaronsmall</entry>
            </row>
            <row>
              <entry>309</entry>
              <entry>Dieresissmall</entry>
            </row>
            <row>
              <entry>310</entry>
              <entry>Brevesmall</entry>
            </row>
            <row>
              <entry>311</entry>
              <entry>Caronsmall</entry>
            </row>
            <row>
              <entry>312</entry>
              <entry>Dotaccentsmall</entry>
            </row>
            <row>
              <entry>313</entry>
              <entry>Macronsmall</entry>
            </row>
            <row>
              <entry>314</entry>
              <entry>figuredash</entry>
            </row>
            <row>
              <entry>315</entry>
              <entry>hypheninferior</entry>
            </row>
            <row>
              <entry>316</entry>
              <entry>Ogoneksmall</entry>
            </row>
            <row>
              <entry>317</entry>
              <entry>Ringsmall</entry>
            </row>
            <row>
              <entry>318</entry>
              <entry>Cedillasmall</entry>
            </row>
            <row>
              <entry>158</entry>
              <entry>onequarter</entry>
            </row>
            <row>
              <entry>155</entry>
              <entry>onehalf</entry>
            </row>
            <row>
              <entry>163</entry>
              <entry>threequarters</entry>
            </row>
            <row>
              <entry>319</entry>
              <entry>questiondownsmall</entry>
            </row>
            <row>
              <entry>320</entry>
              <entry>oneeighth</entry>
            </row>
            <row>
              <entry>321</entry>
              <entry>threeeighths</entry>
            </row>
            <row>
              <entry>322</entry>
              <entry>fiveeighths</entry>
            </row>
            <row>
              <entry>323</entry>
              <entry>seveneighths</entry>
            </row>
            <row>
              <entry>324</entry>
              <entry>onethird</entry>
            </row>
            <row>
              <entry>325</entry>
              <entry>twothirds</entry>
            </row>
            <row>
              <entry>326</entry>
              <entry>zerosuperior</entry>
            </row>
            <row>
              <entry>150</entry>
              <entry>onesuperior</entry>
            </row>
            <row>
              <entry>164</entry>
              <entry>twosuperior</entry>
            </row>
            <row>
              <entry>169</entry>
              <entry>threesuperior</entry>
            </row>
            <row>
              <entry>327</entry>
              <entry>foursuperior</entry>
            </row>
            <row>
              <entry>328</entry>
              <entry>fivesuperior</entry>
            </row>
            <row>
              <entry>329</entry>
              <entry>sixsuperior</entry>
            </row>
            <row>
              <entry>330</entry>
              <entry>sevensuperior</entry>
            </row>
            <row>
              <entry>331</entry>
              <entry>eightsuperior</entry>
            </row>
            <row>
              <entry>332</entry>
              <entry>ninesuperior</entry>
            </row>
            <row>
              <entry>333</entry>
              <entry>zeroinferior</entry>
            </row>
            <row>
              <entry>334</entry>
              <entry>oneinferior</entry>
            </row>
            <row>
              <entry>335</entry>
              <entry>twoinferior</entry>
            </row>
            <row>
              <entry>336</entry>
              <entry>threeinferior</entry>
            </row>
            <row>
              <entry>337</entry>
              <entry>fourinferior</entry>
            </row>
            <row>
              <entry>338</entry>
              <entry>fiveinferior</entry>
            </row>
            <row>
              <entry>339</entry>
              <entry>sixinferior</entry>
            </row>
            <row>
              <entry>340</entry>
              <entry>seveninferior</entry>
            </row>
            <row>
              <entry>341</entry>
              <entry>eightinferior</entry>
            </row>
            <row>
              <entry>342</entry>
              <entry>nineinferior</entry>
            </row>
            <row>
              <entry>343</entry>
              <entry>centinferior</entry>
            </row>
            <row>
              <entry>344</entry>
              <entry>dollarinferior</entry>
            </row>
            <row>
              <entry>345</entry>
              <entry>periodinferior</entry>
            </row>
            <row>
              <entry>346</entry>
              <entry>commainferior</entry>
            </row>
            <row>
              <entry>347</entry>
              <entry>Agravesmall</entry>
            </row>
            <row>
              <entry>348</entry>
              <entry>Aacutesmall</entry>
            </row>
            <row>
              <entry>349</entry>
              <entry>Acircumflexsmall</entry>
            </row>
            <row>
              <entry>350</entry>
              <entry>Atildesmall</entry>
            </row>
            <row>
              <entry>351</entry>
              <entry>Adieresissmall</entry>
            </row>
            <row>
              <entry>352</entry>
              <entry>Aringsmall</entry>
            </row>
            <row>
              <entry>353</entry>
              <entry>AEsmall</entry>
            </row>
            <row>
              <entry>354</entry>
              <entry>Ccedillasmall</entry>
            </row>
            <row>
              <entry>355</entry>
              <entry>Egravesmall</entry>
            </row>
            <row>
              <entry>356</entry>
              <entry>Eacutesmall</entry>
            </row>
            <row>
              <entry>357</entry>
              <entry>Ecircumflexsmall</entry>
            </row>
            <row>
              <entry>358</entry>
              <entry>Edieresissmall</entry>
            </row>
            <row>
              <entry>359</entry>
              <entry>Igravesmall</entry>
            </row>
            <row>
              <entry>360</entry>
              <entry>Iacutesmall</entry>
            </row>
            <row>
              <entry>361</entry>
              <entry>Icircumflexsmall</entry>
            </row>
            <row>
              <entry>362</entry>
              <entry>Idieresissmall</entry>
            </row>
            <row>
              <entry>363</entry>
              <entry>Ethsmall</entry>
            </row>
            <row>
              <entry>364</entry>
              <entry>Ntildesmall</entry>
            </row>
            <row>
              <entry>365</entry>
              <entry>Ogravesmall</entry>
            </row>
            <row>
              <entry>366</entry>
              <entry>Oacutesmall</entry>
            </row>
            <row>
              <entry>367</entry>
              <entry>Ocircumflexsmall</entry>
            </row>
            <row>
              <entry>368</entry>
              <entry>Otildesmall</entry>
            </row>
            <row>
              <entry>369</entry>
              <entry>Odieresissmall</entry>
            </row>
            <row>
              <entry>370</entry>
              <entry>OEsmall</entry>
            </row>
            <row>
              <entry>371</entry>
              <entry>Oslashsmall</entry>
            </row>
            <row>
              <entry>372</entry>
              <entry>Ugravesmall</entry>
            </row>
            <row>
              <entry>373</entry>
              <entry>Uacutesmall</entry>
            </row>
            <row>
              <entry>374</entry>
              <entry>Ucircumflexsmall</entry>
            </row>
            <row>
              <entry>375</entry>
              <entry>Udieresissmall</entry>
            </row>
            <row>
              <entry>376</entry>
              <entry>Yacutesmall</entry>
            </row>
            <row>
              <entry>377</entry>
              <entry>Thornsmall</entry>
            </row>
            <row>
              <entry>378</entry>
              <entry>Ydieresissmall</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Expert Subset</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='22pc'/>
          <thead>
            <row>
              <entry>SID</entry>
              <entry>name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>space</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>comma</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>hyphen</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>period</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>colon</entry>
            </row>
            <row>
              <entry>28</entry>
              <entry>semicolon</entry>
            </row>
            <row>
              <entry>99</entry>
              <entry>fraction</entry>
            </row>
            <row>
              <entry>109</entry>
              <entry>fi</entry>
            </row>
            <row>
              <entry>110</entry>
              <entry>fl</entry>
            </row>
            <row>
              <entry>150</entry>
              <entry>onesuperior</entry>
            </row>
            <row>
              <entry>155</entry>
              <entry>onehalf</entry>
            </row>
            <row>
              <entry>158</entry>
              <entry>onequarter</entry>
            </row>
            <row>
              <entry>163</entry>
              <entry>threequarters</entry>
            </row>
            <row>
              <entry>164</entry>
              <entry>twosuperior</entry>
            </row>
            <row>
              <entry>169</entry>
              <entry>threesuperior</entry>
            </row>
            <row>
              <entry>231</entry>
              <entry>dollaroldstyle</entry>
            </row>
            <row>
              <entry>232</entry>
              <entry>dollarsuperior</entry>
            </row>
            <row>
              <entry>235</entry>
              <entry>parenleftsuperior</entry>
            </row>
            <row>
              <entry>236</entry>
              <entry>parenrightsuperior</entry>
            </row>
            <row>
              <entry>237</entry>
              <entry>twodotenleader</entry>
            </row>
            <row>
              <entry>238</entry>
              <entry>onedotenleader</entry>
            </row>
            <row>
              <entry>239</entry>
              <entry>zerooldstyle</entry>
            </row>
            <row>
              <entry>240</entry>
              <entry>oneoldstyle</entry>
            </row>
            <row>
              <entry>241</entry>
              <entry>twooldstyle</entry>
            </row>
            <row>
              <entry>242</entry>
              <entry>threeoldstyle</entry>
            </row>
            <row>
              <entry>243</entry>
              <entry>fouroldstyle</entry>
            </row>
            <row>
              <entry>244</entry>
              <entry>fiveoldstyle</entry>
            </row>
            <row>
              <entry>245</entry>
              <entry>sixoldstyle</entry>
            </row>
            <row>
              <entry>246</entry>
              <entry>sevenoldstyle</entry>
            </row>
            <row>
              <entry>247</entry>
              <entry>eightoldstyle</entry>
            </row>
            <row>
              <entry>248</entry>
              <entry>nineoldstyle</entry>
            </row>
            <row>
              <entry>249</entry>
              <entry>commasuperior</entry>
            </row>
            <row>
              <entry>250</entry>
              <entry>threequartersemdash</entry>
            </row>
            <row>
              <entry>251</entry>
              <entry>periodsuperior</entry>
            </row>
            <row>
              <entry>253</entry>
              <entry>asuperior</entry>
            </row>
            <row>
              <entry>254</entry>
              <entry>bsuperior</entry>
            </row>
            <row>
              <entry>255</entry>
              <entry>centsuperior</entry>
            </row>
            <row>
              <entry>256</entry>
              <entry>dsuperior</entry>
            </row>
            <row>
              <entry>257</entry>
              <entry>esuperior</entry>
            </row>
            <row>
              <entry>258</entry>
              <entry>isuperior</entry>
            </row>
            <row>
              <entry>259</entry>
              <entry>lsuperior</entry>
            </row>
            <row>
              <entry>260</entry>
              <entry>msuperior</entry>
            </row>
            <row>
              <entry>261</entry>
              <entry>nsuperior</entry>
            </row>
            <row>
              <entry>262</entry>
              <entry>osuperior</entry>
            </row>
            <row>
              <entry>263</entry>
              <entry>rsuperior</entry>
            </row>
            <row>
              <entry>264</entry>
              <entry>ssuperior</entry>
            </row>
            <row>
              <entry>265</entry>
              <entry>tsuperior</entry>
            </row>
            <row>
              <entry>266</entry>
              <entry>ff</entry>
            </row>
            <row>
              <entry>267</entry>
              <entry>ffi</entry>
            </row>
            <row>
              <entry>268</entry>
              <entry>ffl</entry>
            </row>
            <row>
              <entry>269</entry>
              <entry>parenleftinferior</entry>
            </row>
            <row>
              <entry>270</entry>
              <entry>parenrightinferior</entry>
            </row>
            <row>
              <entry>272</entry>
              <entry>hyphensuperior</entry>
            </row>
            <row>
              <entry>300</entry>
              <entry>colonmonetary</entry>
            </row>
            <row>
              <entry>301</entry>
              <entry>onefitted</entry>
            </row>
            <row>
              <entry>302</entry>
              <entry>rupiah</entry>
            </row>
            <row>
              <entry>305</entry>
              <entry>centoldstyle</entry>
            </row>
            <row>
              <entry>314</entry>
              <entry>figuredash</entry>
            </row>
            <row>
              <entry>315</entry>
              <entry>hypheninferior</entry>
            </row>
            <row>
              <entry>320</entry>
              <entry>oneeighth</entry>
            </row>
            <row>
              <entry>321</entry>
              <entry>threeeighths</entry>
            </row>
            <row>
              <entry>322</entry>
              <entry>fiveeighths</entry>
            </row>
            <row>
              <entry>323</entry>
              <entry>seveneighths</entry>
            </row>
            <row>
              <entry>324</entry>
              <entry>onethird</entry>
            </row>
            <row>
              <entry>325</entry>
              <entry>twothirds</entry>
            </row>
            <row>
              <entry>326</entry>
              <entry>zerosuperior</entry>
            </row>
            <row>
              <entry>327</entry>
              <entry>foursuperior</entry>
            </row>
            <row>
              <entry>328</entry>
              <entry>fivesuperior</entry>
            </row>
            <row>
              <entry>329</entry>
              <entry>sixsuperior</entry>
            </row>
            <row>
              <entry>330</entry>
              <entry>sevensuperior</entry>
            </row>
            <row>
              <entry>331</entry>
              <entry>eightsuperior</entry>
            </row>
            <row>
              <entry>332</entry>
              <entry>ninesuperior</entry>
            </row>
            <row>
              <entry>333</entry>
              <entry>zeroinferior</entry>
            </row>
            <row>
              <entry>334</entry>
              <entry>oneinferior</entry>
            </row>
            <row>
              <entry>335</entry>
              <entry>twoinferior</entry>
            </row>
            <row>
              <entry>336</entry>
              <entry>threeinferior</entry>
            </row>
            <row>
              <entry>337</entry>
              <entry>fourinferior</entry>
            </row>
            <row>
              <entry>338</entry>
              <entry>fiveinferior</entry>
            </row>
            <row>
              <entry>339</entry>
              <entry>sixinferior</entry>
            </row>
            <row>
              <entry>340</entry>
              <entry>seveninferior</entry>
            </row>
            <row>
              <entry>341</entry>
              <entry>eightinferior</entry>
            </row>
            <row>
              <entry>342</entry>
              <entry>nineinferior</entry>
            </row>
            <row>
              <entry>343</entry>
              <entry>centinferior</entry>
            </row>
            <row>
              <entry>344</entry>
              <entry>dollarinferior</entry>
            </row>
            <row>
              <entry>345</entry>
              <entry>periodinferior</entry>
            </row>
            <row>
              <entry>346</entry>
              <entry>commainferior</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='implementation'>
      <title>Implementation</title>

      <para>The same data, in a form usable by our code:</para>

<code-fragment id='cfffontset.constants'>
  <code-title>Predefined strings and charsets</code-title>
  static final int[] isoAdobeCharset = {
      0,      // .notdef
      1,       // space
      2,       // exclam
      3,       // quotedbl
      4,       // numbersign
      5,       // dollar
      6,       // percent
      7,       // ampersand
      8,       // quoteright
      9,       // parenleft
      10,      // parenright
      11,      // asterisk
      12,      // plus
      13,      // comma
      14,      // hyphen
      15,      // period
      16,      // slash
      17,      // zero
      18,      // one
      19,      // two
      20,      // three
      21,      // four
      22,      // five
      23,      // six
      24,      // seven
      25,      // eight
      26,      // nine
      27,      // colon
      28,      // semicolon
      29,      // less
      30,      // equal
      31,      // greater
      32,      // question
      33,      // at
      34,      // A
      35,      // B
      36,      // C
      37,      // D
      38,      // E
      39,      // F
      40,      // G
      41,      // H
      42,      // I
      43,      // J
      44,      // K
      45,      // L
      46,      // M
      47,      // N
      48,      // O
      49,      // P
      50,      // Q
      51,      // R
      52,      // S
      53,      // T
      54,      // U
      55,      // V
      56,      // W
      57,      // X
      58,      // Y
      59,      // Z
      60,      // bracketleft
      61,      // backslash
      62,      // bracketright
      63,      // asciicircum
      64,      // underscore
      65,      // quoteleft
      66,      // a
      67,      // b
      68,      // c
      69,      // d
      70,      // e
      71,      // f
      72,      // g
      73,      // h
      74,      // i
      75,      // j
      76,      // k
      77,      // l
      78,      // m
      79,      // n
      80,      // o
      81,      // p
      82,      // q
      83,      // r
      84,      // s
      85,      // t
      86,      // u
      87,      // v
      88,      // w
      89,      // x
      90,      // y
      91,      // z
      92,      // braceleft
      93,      // bar
      94,      // braceright
      95,      // asciitilde
      96,      // exclamdown
      97,      // cent
      98,      // sterling
      99,      // fraction
      100,      // yen
      101,      // florin
      102,      // section
      103,      // currency
      104,      // quotesingle
      105,      // quotedblleft
      106,      // guillemotleft
      107,      // guilsinglleft
      108,      // guilsinglright
      109,      // fi
      110,      // fl
      111,      // endash
      112,      // dagger
      113,      // daggerdbl
      114,      // periodcentered
      115,      // paragraph
      116,      // bullet
      117,      // quotesinglbase
      118,      // quotedblbase
      119,      // quotedblright
      120,      // guillemotright
      121,      // ellipsis
      122,      // perthousand
      123,      // questiondown
      124,      // grave
      125,      // acute
      126,      // circumflex
      127,      // tilde
      128,      // macron
      129,      // breve
      130,      // dotaccent
      131,      // dieresis
      132,      // ring
      133,      // cedilla
      134,      // hungarumlaut
      135,      // ogonek
      136,      // caron
      137,      // emdash
      138,      // AE
      139,      // ordfeminine
      140,      // Lslash
      141,      // Oslash
      142,      // OE
      143,      // ordmasculine
      144,      // ae
      145,      // dotlessi
      146,      // lslash
      147,      // oslash
      148,      // oe
      149,      // germandbls
      150,      // onesuperior
      151,      // logicalnot
      152,      // mu
      153,      // trademark
      154,      // Eth
      155,      // onehalf
      156,      // plusminus
      157,      // Thorn
      158,      // onequarter
      159,      // divide
      160,      // brokenbar
      161,      // degree
      162,      // thorn
      163,      // threequarters
      164,      // twosuperior
      165,      // registered
      166,      // minus
      167,      // eth
      168,      // multiply
      169,      // threesuperior
      170,      // copyright
      171,      // Aacute
      172,      // Acircumflex
      173,      // Adieresis
      174,      // Agrave
      175,      // Aring
      176,      // Atilde
      177,      // Ccedilla
      178,      // Eacute
      179,      // Ecircumflex
      180,      // Edieresis
      181,      // Egrave
      182,      // Iacute
      183,      // Icircumflex
      184,      // Idieresis
      185,      // Igrave
      186,      // Ntilde
      187,      // Oacute
      188,      // Ocircumflex
      189,      // Odieresis
      190,      // Ograve
      191,      // Otilde
      192,      // Scaron
      193,      // Uacute
      194,      // Ucircumflex
      195,      // Udieresis
      196,      // Ugrave
      197,      // Yacute
      198,      // Ydieresis
      199,      // Zcaron
      200,      // aacute
      201,      // acircumflex
      202,      // adieresis
      203,      // agrave
      204,      // aring
      205,      // atilde
      206,      // ccedilla
      207,      // eacute
      208,      // ecircumflex
      209,      // edieresis
      210,      // egrave
      211,      // iacute
      212,      // icircumflex
      213,      // idieresis
      214,      // igrave
      215,      // ntilde
      216,      // oacute
      217,      // ocircumflex
      218,      // odieresis
      219,      // ograve
      220,      // otilde
      221,      // scaron
      222,      // uacute
      223,      // ucircumflex
      224,      // udieresis
      225,      // ugrave
      226,      // yacute
      227,      // ydieresis
      228};     // zcaron

  static final int[] expertCharset = {
          0,    // .notdef
      1,    // space
      229,    // exclamsmall
      230,    // Hungarumlautsmall
      231,    // dollaroldstyle
      232,    // dollarsuperior
      233,    // ampersandsmall
      234,    // Acutesmall
      235,    // parenleftsuperior
      236,    // parenrightsuperior
      237,    // twodotenleader
      238,    // onedotenleader
      27,    // colon
      28,    // semicolon
      13,    // comma
      14,    // hyphen
      15,    // period
      99,    // fraction
      239,    // zerooldstyle
      240,    // oneoldstyle
      241,    // twooldstyle
      242,    // threeoldstyle
      243,    // fouroldstyle
      244,    // fiveoldstyle
      245,    // sixoldstyle
      246,    // sevenoldstyle
      247,    // eightoldstyle
      248,    // nineoldstyle
      249,    // commasuperior
      250,    // threequartersemdash
      251,    // periodsuperior
      252,    // questionsmall
      253,    // asuperior
      254,    // bsuperior
      255,    // centsuperior
      256,    // dsuperior
      257,    // esuperior
      258,    // isuperior
      259,    // lsuperior
      260,    // msuperior
      261,    // nsuperior
      262,    // osuperior
      263,    // rsuperior
      264,    // ssuperior
      265,    // tsuperior
      266,    // ff
      109,    // fi
      110,    // fl
      267,    // ffi
      268,    // ffl
      269,    // parenleftinferior
      270,    // parenrightinferior
      271,    // Circumflexsmall
      272,    // hyphensuperior
      273,    // Gravesmall
      274,    // Asmall
      275,    // Bsmall
      276,    // Csmall
      277,    // Dsmall
      278,    // Esmall
      279,    // Fsmall
      280,    // Gsmall
      281,    // Hsmall
      282,    // Ismall
      283,    // Jsmall
      284,    // Ksmall
      285,    // Lsmall
      286,    // Msmall
      287,    // Nsmall
      288,    // Osmall
      289,    // Psmall
      290,    // Qsmall
      291,    // Rsmall
      292,    // Ssmall
      293,    // Tsmall
      294,    // Usmall
      295,    // Vsmall
      296,    // Wsmall
      297,    // Xsmall
      298,    // Ysmall
      299,    // Zsmall
      300,    // colonmonetary
      301,    // onefitted
      302,    // rupiah
      303,    // Tildesmall
      304,    // exclamdownsmall
      305,    // centoldstyle
      306,    // Lslashsmall
      307,    // Scaronsmall
      308,    // Zcaronsmall
      309,    // Dieresissmall
      310,    // Brevesmall
      311,    // Caronsmall
      312,    // Dotaccentsmall
      313,    // Macronsmall
      314,    // figuredash
      315,    // hypheninferior
      316,    // Ogoneksmall
      317,    // Ringsmall
      318,    // Cedillasmall
      158,    // onequarter
      155,    // onehalf
      163,    // threequarters
      319,    // questiondownsmall
      320,    // oneeighth
      321,    // threeeighths
      322,    // fiveeighths
      323,    // seveneighths
      324,    // onethird
      325,    // twothirds
      326,    // zerosuperior
      150,    // onesuperior
      164,    // twosuperior
      169,    // threesuperior
      327,    // foursuperior
      328,    // fivesuperior
      329,    // sixsuperior
      330,    // sevensuperior
      331,    // eightsuperior
      332,    // ninesuperior
      333,    // zeroinferior
      334,    // oneinferior
      335,    // twoinferior
      336,    // threeinferior
      337,    // fourinferior
      338,    // fiveinferior
      339,    // sixinferior
      340,    // seveninferior
      341,    // eightinferior
      342,    // nineinferior
      343,    // centinferior
      344,    // dollarinferior
      345,    // periodinferior
      346,    // commainferior
      347,    // Agravesmall
      348,    // Aacutesmall
      349,    // Acircumflexsmall
      350,    // Atildesmall
      351,    // Adieresissmall
      352,    // Aringsmall
      353,    // AEsmall
      354,    // Ccedillasmall
      355,    // Egravesmall
      356,    // Eacutesmall
      357,    // Ecircumflexsmall
      358,    // Edieresissmall
      359,    // Igravesmall
      360,    // Iacutesmall
      361,    // Icircumflexsmall
      362,    // Idieresissmall
      363,    // Ethsmall
      364,    // Ntildesmall
      365,    // Ogravesmall
      366,    // Oacutesmall
      367,    // Ocircumflexsmall
      368,    // Otildesmall
      369,    // Odieresissmall
      370,    // OEsmall
      371,    // Oslashsmall
      372,    // Ugravesmall
      373,    // Uacutesmall
      374,    // Ucircumflexsmall
      375,    // Udieresissmall
      376,    // Yacutesmall
      377,    // Thornsmall
      378};    // Ydieresissmall

  static final int[] expertSubsetCharset = {
      0,    // .notdef
      1,    // space
      231,    // dollaroldstyle
      232,    // dollarsuperior
      235,    // parenleftsuperior
      236,    // parenrightsuperior
      237,    // twodotenleader
      238,    // onedotenleader
      13,    // comma
      14,    // hyphen
      15,    // period
      99,    // fraction
      239,    // zerooldstyle
      240,    // oneoldstyle
      241,    // twooldstyle
      242,    // threeoldstyle
      243,    // fouroldstyle
      244,    // fiveoldstyle
      245,    // sixoldstyle
      246,    // sevenoldstyle
      247,    // eightoldstyle
      248,    // nineoldstyle
      27,    // colon
      28,    // semicolon
      249,    // commasuperior
      250,    // threequartersemdash
      251,    // periodsuperior
      253,    // asuperior
      254,    // bsuperior
      255,    // centsuperior
      256,    // dsuperior
      257,    // esuperior
      258,    // isuperior
      259,    // lsuperior
      260,    // msuperior
      261,    // nsuperior
      262,    // osuperior
      263,    // rsuperior
      264,    // ssuperior
      265,    // tsuperior
      266,    // ff
      109,    // fi
      110,    // fl
      267,    // ffi
      268,    // ffl
      269,    // parenleftinferior
      270,    // parenrightinferior
      272,    // hyphensuperior
      300,    // colonmonetary
      301,    // onefitted
      302,    // rupiah
      305,    // centoldstyle
      314,    // figuredash
      315,    // hypheninferior
      158,    // onequarter
      155,    // onehalf
      163,    // threequarters
      320,    // oneeighth
      321,    // threeeighths
      322,    // fiveeighths
      323,    // seveneighths
      324,    // onethird
      325,    // twothirds
      326,    // zerosuperior
      150,    // onesuperior
      164,    // twosuperior
      169,    // threesuperior
      327,    // foursuperior
      328,    // fivesuperior
      329,    // sixsuperior
      330,    // sevensuperior
      331,    // eightsuperior
      332,    // ninesuperior
      333,    // zeroinferior
      334,    // oneinferior
      335,    // twoinferior
      336,    // threeinferior
      337,    // fourinferior
      338,    // fiveinferior
      339,    // sixinferior
      340,    // seveninferior
      341,    // eightinferior
      342,    // nineinferior
      343,    // centinferior
      344,    // dollarinferior
      345,    // periodinferior
      346};    // commainferior
</code-fragment>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix D: Example CFF Font </title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>This appendix illustrates the CFF format with an example font.
        The font shown is a subset with just the .notdef and space
        glyphs of the Times* font program that has been renamed. This
        font has no subrs and uses predefined encoding and charset.
        Binary dump (147 bytes):</para>

<code-fragment>
<![CDATA[
0000000 0100 0401 0001 0101 1341 4243 4445 462b |?.??.????ABCDEF+|
0000010 5469 6d65 732d 526f 6d61 6e00 0101 011f |Times-Roman.????|
0000020 f81b 00f8 1c02 f81d 03f8 1904 1c6f 000d |??.??????????o.?|
0000030 fb3c fb6e fa7c fa16 05e9 11b8 f112 0003 |?<?n?|????????.?|
0000040 0101 0813 1830 3031 2e30 3037 5469 6d65 |?????001.007Time|
0000050 7320 526f 6d61 6e54 696d 6573 0000 0002 |s RomanTimes...?|
0000060 0101 0203 0e0e 7d99 f92a 99fb 7695 f773 |??????}??*??v??s|
0000070 8b06 f79a 93fc 7c8c 077d 99f8 5695 f75e |??????|??}??V??^|
0000080 9908 fb6e 8cf8 7393 f710 8b09 a70a df0b |???n??s?????????|
0000090 f78e 14 |??? |
]]>
</code-fragment>

      <para>Annotated dump:</para>

<code-fragment>
<![CDATA[
### Header (00000000)
major =1
minor =0
hdrSize=4
offSize=1
### Name INDEX (00000004)
count =1
offSize=1
--- offset[index]=value
[0]=1 [1]=19
--- object[index]=<value>
[0]=<ABCDEF+Times-Roman>
### Top DICT INDEX (0000001b)
count =1
offSize=1
--- offset[index]=value
[0]=1 [1]=31
--- object[index]=<value>
[0]=<391 version 392 FullName 393 FamilyName 389 Weight 28416
UniqueID -168 -218 1000 898 FontBBox 94 CharStrings 45 102 Private>
### String INDEX (0000003e)
count =3
offSize=1
--- offset[index]=value
[0]=1 [1]=8 [2]=19 [3]=24
--- object[index]=<value>
[0]=<001.007> [1]=<Times Roman> [2]=<Times>
### Global Subrs INDEX (0000005c)
count =0
### CharStrings INDEX (0000005e)
count =2
offSize=1
--- offset[index]=value
[0]=1 [1]=2 [2]=3
--- object[index]=<value>
[0]=<endchar> [1]=<endchar>
### Private DICT (00000066)
-14 14 662 14 -226 10 223 0 BlueValues 262 8 -488 1 OtherBlues
-14 14 450 10 202 14 FamilyBlues -218 1 479 8 124 0 FamilyOtherBlues
28 StdHW 84 StdVW 250 defaultWidthX
]]></code-fragment>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>
  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix E PostScript File Structure</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>CFF data is enclosed in a wrapper and treated as a file
        when used by a PostScript interpreter that supports the
        FontSet resource. The wrapper allows the file to be directly
        executed by the interpreter, and permits insertion or
        removal by a DSC (Document Structuring Convention)-aware
        driver. A well-formatted FontSet file has the following
        structure:</para>

<code-fragment>
<![CDATA[
%!PS-Adobe-3.0 Resource-FontSet
%%DocumentNeededResources: ProcSet (FontSetInit)
%%EndComments
%%IncludeResource: ProcSet (FontSetInit)
%%BeginResource: FontSet (<fontsetname>)
%%Title: (FontSet/<fontsetname>)
%%Version: <realversion> [<intrevision>]
/FontSetInit /ProcSet findresource begin
%%BeginData: <m> Binary Bytes
/<fontsetname> <n> StartData<space><n-binary-data-bytes>
%%EndData
%%EndResource
%%EOF
]]>
</code-fragment>

      <para>A single space (0x20) follows the StartData procedure
        call which is followed immediately by &lt;n> binary data
        bytes. Note that the %%EndData DSC comment must be preceded
        by a newline character (that is not part of the binary data)
        so that it is correctly parsed. The count &lt;m> in the
        %%BeginData: DSC is greater than that used by the StartData
        procedure call by the number of characters in the call
        itself.</para>

      <para>All the (0) offsets in the &lt;binary data> are relative
        to the start of the &lt;binary data>. That is, the byte
        following the space that terminates StartData is numbered
        0.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix F Embedded PostScript</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>A Top DICT may contain at most one embedded PostScript
        operator. It must be in the main font dictionary, not in the
        Private dictionary. If present, this string is executed
        after the font dictionary has been completely constructed,
        but before definefont. At that time, the interpreter:</para>

      <itemizedlist>
        <listitem>
          <para>Pushes the top-level font dictionary (that is under
            construction) on the dictionary stack;</para>
        </listitem>
        <listitem>
          <para>Executes the PostScript string;</para>
        </listitem>
        <listitem>
          <para>Pops the dictionary stack.</para>
        </listitem>
      </itemizedlist>

      <para>At the time of execution, the FontInfo, Encoding,
        CharStrings, and all other elements of the font dictionary
        have been defined, including ones that are set to default
        values. (There is no Private dictionary, however. In CFF,
        the Private dictionary is never processed as PostScript, so
        there is no opportunity for embedded PostScript to alter
        it.)</para>
      <para>A CFF CIDFont may contain an embedded PostScript
        operator in the Top DICT or in any FDs.</para>
      <para>If it is in the Top DICT, the embedded PostScript string
        is processed as described above. This occurs after the font
        dictionary has been completely constructed (including all
        FDArray sub-dictionaries), but before definefont.</para>
      <para>If it is in one of the nested sub-dictionaries in the
        FDArray, it is executed after the sub-dictionary has been
        completely constructed (including default values), but
        before it has been incorporated as an element of the main
        font dictionary. The subdictionary is on the dictionary
        stack; there is no way to access the main dictionary.</para>
      <para>A CFF consumer that does not interpret PostScript can
        ignore the embedded PostScript string. The font should still
        work, but without the feature that the embedded PostScript
        would have activated.</para>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix G Related Documentation</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>The following documents may be consulted for further
        information on Adobe font technology. All are available at
        http://partners.adobe.com/asn/developer/technotes.html.</para>

      <itemizedlist>
        <listitem>
          <para>Adobe Type 1 Font Format. Addison-Wesley, 1991; ISBN
            0- 201-57044-0.</para>
        </listitem>
        <listitem>
          <para>PostScript Language Reference, Third Edition.
            Addison- Wesley, 1999; ISBN 0-201-37922-8.</para>
        </listitem>
        <listitem>
          <para>Technical Note #5014: "Adobe CMap and CIDFont Files
            Specification."</para>
        </listitem>
        <listitem>
          <para>Technical Note #5015: "The Type 1 Font Format
            Supplement." This document contains all updates to the
            Type 1 format.</para>
        </listitem>
        <listitem>
          <para>Technical Note #5040: "Supporting Downloadable
            PostScript Fonts." Describes how Type 1 fonts have
            traditionally been packaged for use in the
            Macintosh&#xae; and Windows&#xae; environments &#x2013;
            specifically, the use of POST resources for Macintosh
            fonts and the PFB compressed binary format for Windows
            fonts.</para>
        </listitem>
        <listitem>
          <para>Technical Note #5088: "Font Naming Issues." In
            addition to a discussion of general font name issues,
            this document explains the naming conventions for
            multiple master fonts.</para>
        </listitem>
        <listitem>
          <para>Technical Note #5092: "CID-Keyed Font File Format
            Overview."</para>
        </listitem>
        <listitem>
          <para>Technical Note #5177: "Type 2 Charstring
            Format."</para>
        </listitem>
      </itemizedlist>

    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

  </section>

  <!--========================================================================-->
  <section role='fragment'>
    <title>Appendix H: CFF DICT Encoding</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <table>
        <title>One-byte CFF DICT Operators</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Dec</entry>
              <entry>Hex</entry>
              <entry>Operator</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>00</entry>
              <entry>version</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>01</entry>
              <entry>Notice</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>02</entry>
              <entry>FullName</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>03</entry>
              <entry>FamilyName</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>04</entry>
              <entry>Weight</entry>
              </row>
            <row>
              <entry>5</entry>
              <entry>05</entry>
              <entry>FontBBox</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>06</entry>
              <entry>BlueValues</entry>
            </row>
            <row>
              <entry>7</entry>
              <entry>07</entry>
              <entry>OtherBlues</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>08</entry>
              <entry>FamilyBlues</entry>
            </row>
            <row>
              <entry>9</entry>
              <entry>09</entry>
              <entry>FamilyOtherBlues</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>0a</entry>
              <entry>StdHW</entry>
            </row>
            <row>
              <entry>11</entry>
              <entry>0b</entry>
              <entry>StdVW</entry>
            </row>
            <row>
              <entry>12<footnote>
                  <para>First byte of a 2-byte operator.</para>
                </footnote></entry>
              <entry>0c</entry>
              <entry>escape</entry>
            </row>
            <row>
              <entry>13</entry>
              <entry>0d</entry>
              <entry>UniqueID</entry>
            </row>
            <row>
              <entry>14</entry>
              <entry>0e</entry>
              <entry>XUID</entry>
            </row>
            <row>
              <entry>15</entry>
              <entry>0f</entry>
              <entry>charset</entry>
            </row>
            <row>
              <entry>16</entry>
              <entry>10</entry>
              <entry>Encoding</entry>
            </row>
            <row>
              <entry>17</entry>
              <entry>11</entry>
              <entry>CharStrings</entry>
            </row>
            <row>
              <entry>18</entry>
              <entry>12</entry>
              <entry>Private</entry>
            </row>
            <row>
              <entry>19</entry>
              <entry>13</entry>
              <entry>Subrs</entry>
            </row>
            <row>
              <entry>20</entry>
              <entry>14</entry>
              <entry>defaultWidthX</entry>
            </row>
            <row>
              <entry>21</entry>
              <entry>15</entry>
              <entry>nominalWidthX</entry>
            </row>
            <row>
              <entry>22</entry>
              <entry>16</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>23</entry>
              <entry>17</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>24</entry>
              <entry>18</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>25</entry>
              <entry>19</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>26</entry>
              <entry>1a</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>27</entry>
              <entry>1b</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>28<footnote>
                  <para>First byte of a 3-byte sequence specifying a
                    number.</para>
                </footnote></entry>
              <entry>1c</entry>
              <entry>shortint</entry>
            </row>
            <row>
              <entry>29</entry>
              <entry>1d</entry>
              <entry>longint</entry>
            </row>
            <row>
              <entry>30</entry>
              <entry>1e</entry>
              <entry>BCD</entry>
            </row>
            <row>
              <entry>31</entry>
              <entry>1f</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>32246</entry>
              <entry>20f6</entry>
              <entry>&lt;numbers></entry>
            </row>
            <row>
              <entry>247-254<footnote>
                  <para>First byte of a 2-byte sequence specifying a
                    number.</para>
                </footnote></entry>
              <entry>f7-fe</entry>
              <entry>&lt;numbers></entry>
            </row>
            <row>
              <entry>255</entry>
              <entry>ff</entry>
              <entry>-Reserved-</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>Two-byte CFF DICT Operators</title>
        <tgroup>
          <colspec colwidth='8pc'/>
          <colspec colwidth='8pc'/>
          <colspec colwidth='14pc'/>
          <thead>
            <row>
              <entry>Dec</entry>
              <entry>Hex</entry>
              <entry>Operator</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>12 0</entry>
              <entry>0c 00</entry>
              <entry>Copyright</entry>
            </row>
            <row>
              <entry>12 1</entry>
              <entry>0c 01</entry>
              <entry>isFixedPitch</entry>
            </row>
            <row>
              <entry>12 2</entry>
              <entry>0c 02</entry>
              <entry>ItalicAngle</entry>
            </row>
            <row>
              <entry>12 3</entry>
              <entry>0c 03</entry>
              <entry>UnderlinePosition</entry>
            </row>
            <row>
              <entry>12 4</entry>
              <entry>0c 04</entry>
              <entry>UnderlineThickness</entry>
            </row>
            <row>
              <entry>12 5</entry>
              <entry>0c 05</entry>
              <entry>PaintType</entry>
            </row>
            <row>
              <entry>12 6</entry>
              <entry>0c 06</entry>
              <entry>CharstringType</entry>
            </row>
            <row>
              <entry>12 7</entry>
              <entry>0c 07</entry>
              <entry>FontMatrix</entry>
            </row>
            <row>
              <entry>12 8</entry>
              <entry>0c 08</entry>
              <entry>StrokeWidth</entry>
            </row>
            <row>
              <entry>12 9</entry>
              <entry>0c 09</entry>
              <entry>BlueScale</entry>
            </row>
            <row>
              <entry>12 10</entry>
              <entry>0c 0a</entry>
              <entry>BlueShift</entry>
            </row>
            <row>
              <entry>12 11</entry>
              <entry>0c 0b</entry>
              <entry>BlueFuzz</entry>
            </row>
            <row>
              <entry>12 12</entry>
              <entry>0c 0c</entry>
              <entry>StemSnapH</entry>
            </row>
            <row>
              <entry>12 13</entry>
              <entry>0c 0d</entry>
              <entry>StemSnapV</entry>
            </row>
            <row>
              <entry>12 14</entry>
              <entry>0c 0e</entry>
              <entry>ForceBold</entry>
            </row>
            <row>
              <entry>12 15</entry>
              <entry>0c 0f</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 16</entry>
              <entry>0c 10</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 17</entry>
              <entry>0c 11</entry>
              <entry>LanguageGroup</entry>
            </row>
            <row>
              <entry>12 18</entry>
              <entry>0c 12</entry>
              <entry>ExpansionFactor</entry>
            </row>
            <row>
              <entry>12 19</entry>
              <entry>0c 13</entry>
              <entry>initialRandomSeed</entry>
            </row>
            <row>
              <entry>12 20</entry>
              <entry>0c 14</entry>
              <entry>SyntheticBase</entry>
            </row>
            <row>
              <entry>12 21</entry>
              <entry>0c 15</entry>
              <entry>PostScript</entry>
            </row>
            <row>
              <entry>12 22</entry>
              <entry>0c 16</entry>
              <entry>BaseFontName</entry>
            </row>
            <row>
              <entry>12 23</entry>
              <entry>0c 17</entry>
              <entry>BaseFontBlend</entry>
            </row>
            <row>
              <entry>12 24</entry>
              <entry>0c 18</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 25</entry>
              <entry>0c 19</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 26</entry>
              <entry>0c 1a</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 27</entry>
              <entry> 0c 1b</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 28</entry>
              <entry>0c 1c</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 29</entry>
              <entry>0c 1d</entry>
              <entry>-Reserved-</entry>
            </row>
            <row>
              <entry>12 30</entry>
              <entry>0c 1e</entry>
              <entry>ROS</entry>
            </row>
            <row>
              <entry>12 31</entry>
              <entry>0c 1f</entry>
              <entry>CIDFontVersion</entry>
            </row>
            <row>
              <entry>12 32</entry>
              <entry>0c 20</entry>
              <entry>CIDFontRevision</entry>
            </row>
            <row>
              <entry>12 33</entry>
              <entry>0c 21</entry>
              <entry>CIDFontType</entry>
            </row>
            <row>
              <entry>12 34</entry>
              <entry>0c 22</entry>
              <entry>CIDCount</entry>
            </row>
            <row>
              <entry>12 35</entry>
              <entry>0c 23</entry>
              <entry>UIDBase</entry>
            </row>
            <row>
              <entry>12 36</entry>
              <entry>0c 24</entry>
              <entry>FDArray</entry>
            </row>
            <row>
              <entry>12 37</entry>
              <entry>0c 25</entry>
              <entry>FDSelect</entry>
            </row>
            <row>
              <entry>12 38</entry>
              <entry>0c 26</entry>
              <entry>FontName</entry>
            </row>
            <row>
              <entry>12 39 - 12 255</entry>
              <entry>0c 27 - 0c ff</entry>
              <entry>-Reserved-</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>Interestingly, this is the only place that spells out
        explicitely the reserved operators in Dict.</para>
    </section>
  </section>

  <!--========================================================================-->
    <section role='fragment'>
      <title>Appendix I: Changes Since Earlier Versions</title>

    <!--______________________________________________________________________-->
    <section role='specification'>
      <title>Specification</title>

      <para>The following changes and revisions have been made since
        the initial publication date of 18 November 1996.</para>

      <para>Changes in the 16 March 2000 document</para>

      <itemizedlist>
        <listitem>
          <para>Removed all material about multiple master and
            chameleon fonts.</para>
        </listitem>
        <listitem>
          <para>Section 4, DICT Data &#x2013; specified the order of
            nibble data stored in a byte; also specified the range of
            values in the first byte of an operator or operand that
            can be used to distinguish between operators and
            operands.</para>
        </listitem>
        <listitem>
          <para>Section 12, Encodings &#x2013; clarified that glyphs
            not specified by custom or predefined encodings are, by
            definition, unencoded.</para>
        </listitem>
        <listitem>
          <para>Section 15, Private DICT Data &#x2013; added
            statement that Private DICT is required, but may be
            specified as having 0 length.</para>
        </listitem>
        <listitem>
          <para>Section 15, Private DICT Data &#x2013; removed
            entries for ForceBoldThreshhold and lenIV from Table
            23.</para>
        </listitem>
        <listitem>
          <para> Section 17, PS File Structure &#x2013; moved this
            section to Appendix E; the previous Appendix E and all
            subsequent appendices moved accordingly.</para>
        </listitem>
        <listitem>
          <para>Section 18, Copyright and Trademark Notices &#x2013;
            removed entire section.</para>
        </listitem>
        <listitem>
          <para>Section 22, FDSelect &#x2013; added clarification of
            the values of GIDs.</para>
        </listitem>
        <listitem>
          <para>Added appendix summarizing CFF DICT encoding.</para>
        </listitem>
      </itemizedlist>

      <para>Note: The version number of the format has not changed
        for this revision.</para>

      <para>Changes in the 18 March 1998 document</para>

      <itemizedlist>
        <listitem>
          <para>Table 25, it was noted that the only value supported
            for lenIV is -1.</para>
        </listitem>
        <listitem>
          <para>Section 13, Charsets &#x2013; statement added that
            CID fonts must not use predefined charsets.</para>
        </listitem>
        <listitem>
          <para>Section 22, FDSelect &#x2013; first paragraph; the
            FD index is used to access one of the Font DICTs stored in
            the Font DICT INDEX (not the previously stated
            "FDArray").</para>
        </listitem>
      </itemizedlist>

      <para>Changes in the 15 October 1997 document</para>

      <itemizedlist>
        <listitem>
          <para>Minor changes were made to clarify existing
            text.</para>
        </listitem>
        <listitem>
          <para>In Table 2, the string id range was changed to
            0&#x2013;64999.</para>
        </listitem>
        <listitem>
          <para>In Table 9, the default for the FontBBox array was
            specified as "0 0 0 0".</para>
        </listitem>
        <listitem>
          <para>The specification of multiple master fonts was
            changed in several sections.</para>
        </listitem>
        <listitem>
          <para>Section 17, PostScript File Structure &#x2013;
            corrections made to DSC comments.</para>
        </listitem>
        <listitem>
          <para>Section 19, Synthetic Fonts &#x2013; new capability
            added to specify encodings for synthetic fonts.</para>
        </listitem>
        <listitem>
          <para>Appendix D, Example CFF Font &#x2013; corrected
            operator name in example; FamilyBlueValues changed to
            FamilyBlues.</para>
        </listitem>
      </itemizedlist>

      <para>Changes in the 16 December 1996 document</para>

      <para>A variety of minor changes were made to clarify existing
        text; the technical content was not affected.</para>
    </section>
    <!--______________________________________________________________________-->
    <section role='annotation'>
      <title>Annotation</title>

      <para>None.</para>
    </section>

  </section>
</article>
