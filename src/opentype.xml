<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<!--____________________________________________________________________________

	Copyright 2000-2016 Adobe Systems Incorporated. All Rights Reserved.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use these files except in compliance with the License.
	You may obtain a copy of the License at

	 http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
  ___________________________________________________________________________-->


<article xmlns:web='http://aots.adobe.com/2001/web'
         xmlns:rng='http://relaxng.org/ns/structure/1.0'
         xmlns:ots="http://aots.adobe.com/2001/ots"
	 xmlns:aots="http://aots.adobe.com/2001/aots"
         xmlns=''>
    <title>Annotated OpenType Specification</title>

  <!--************************************************************************-->
  <section id='chapter.about'>
    <title>About this specification</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This specification details the format of OpenType fonts,
          the TrueType and CFF outline formats, and the TrueType
          hinting language. This specification has been developed
          jointly by Adobe and Microsoft. Because OpenType is an extension
          of TrueType, there is also information in this document that
          was originally authored by Apple.</para>

        <para>Many references to both TrueType and PostScript exist
          throughout this document, as OpenType fonts combine the two
          technologies.</para>

        <para>If you have comments or suggestions about this document,
          please send mail to the Microsoft Typography Group.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The &#x201c;Annotation&#x201d; sections provides
          clarification of the published specification, sometimes by
          suggesting a different wording, sometimes by providing
          background information.</para>

        <para>The &#x201c;Specification&#x201d; sections
          contain the exact text of version 1.3 of the OpenType
          specification.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

        <para>The &#x201c;XML representation&#x201d; sections propose
         an XML representation of OpenType fonts. The mains goals are:
          <itemizedlist>
            <listitem>
              <para>allow the precise representation of fonts in an
                XML form, to facilitate exchange, manipulation by
                programs, or archival of fonts.</para>
            </listitem>
            <listitem>
              <para>be a convenient form to author fonts or fragments
                of fonts; in particular, facilitate the creation of
                fonts to test OpenType engines.</para>
            </listitem>
          </itemizedlist></para>

        <para>The XML representation is currently formalized in
          a Relax NG schema, expressed here in the compact syntax.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>The &#x201c;Compiler&#x201d; sections are the source
        code for a compiler that converts from the XML representation
        to actual font files.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

        <para>The &#x201c;Decompiler&#x201d; sections are the source
        code for a decompiler that converts from the actual font files
        to their XML representation.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>The &#x201c;Implementation&#x201d; sections are the
        source code for classes that represent fonts, as well as
        support usual operations. For example, the implementation code
        for the <ottable>cmap</ottable> table includes method to
        convert a code point to a glyph ID.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <para>The &#x201c;Test Suite&#x201d; sections are test fonts
        and test cases which exercise the implementation. As much as
        possible, those test cases have been designed to be usable
        with any implementation, assuming a test harness is
        provided.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

        <para>The &#x201c;Validation&#x201d; sections are the source
          code for a font validator. The intent is that the validator
          would detect violation of the specification, as well as
          violation of additional rules and dubious constructs.</para>
      </section>

    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.overview'>
    <title>Overview</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The OpenType font format is an extension of the TrueType
	font format, adding support for PostScript font data. The
	OpenType font format was developed jointly by Microsoft and
	Adobe. OpenType fonts and the operating system services which
	support OpenType fonts provide users with a simple way to
	install and use fonts, whether the fonts contain TrueType
	outlines or CFF (PostScript) outlines.</para>


	<para>The OpenType font format addresses the following goals:

	  <itemizedlist>
	    <listitem>
	      <para>broader multi-platform support</para>
	    </listitem>
	    <listitem>
	      <para>better support for international character sets</para>
	    </listitem>
	    <listitem>
	      <para>better protection for font data</para>
	    </listitem>
	    <listitem>
	      <para>smaller file sizes to make font distribution more
	      efficient</para>
	    </listitem>
	    <listitem>
	      <para>broader support for advanced typographic control</para>
	    </listitem>
	  </itemizedlist></para>

	<para>OpenType fonts are also referred to as TrueType Open
	v.2.0 fonts, because they use the TrueType 'sfnt' font file
	format. PostScript data included in OpenType fonts may be
	directly rasterized or converted to the TrueType outline
	format for rendering, depending on which rasterizers have been
	installed in the host operating system. But the user model is
	the same: OpenType fonts just work. Users will not need to be
	aware of the type of outline data in OpenType fonts. And font
	creators can use whichever outline format they feel provides
	the best set of features for their work, without worrying
	about limiting a font's usability.</para>

	<para>OpenType fonts can include the OpenType Layout tables,
	which allow font creators to design better international and
	high-end typographic fonts. The OpenType Layout tables contain
	information on glyph substitution, glyph positioning,
	justification, and baseline positioning, enabling
	text-processing applications to improve text layout.</para>

	<para>As with TrueType fonts, OpenType fonts allow the
	handling of large glyph sets using Unicode encoding. Such
	encoding allows broad international support, as well as
	support for typographic glyph variants.</para>

	<para>Additionally, OpenType fonts may contain digital
	signatures, which allows operating systems and browsing
	applications to identify the source and integrity of font
	files, including embedded font files obtained in web
	documents, before using them. Also, font developers can encode
	embedding restrictions in OpenType fonts, and these
	restrictions cannot be altered in a font signed by the
	developer.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Related documentation</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The following documents may be consulter for further
	information:</para>

	<itemizedlist>
	  <listitem>
	    <para>Adobe Technical Note #5176: "The Compact Font Format
	      Specification."</para>
	  </listitem>
	  <listitem>
	    <para>Adobe Technical Note #5177: "Type 2 Charstring Format."</para>
	  </listitem>
	  <listitem>
	    <para>TrueType 1.0 Font Files, Technical
	      Specification. Microsoft.</para>
	  </listitem>
	  <listitem>
	    <para>OpenType Layout Font Specification. Microsoft.</para>
	  </listitem>
	  <listitem>
	    <para>Adobe Type 1 Font Format. Addison Wesley, 1991; ISBN
	      0-201-57044-0.</para>
	  </listitem>
	  <listitem>
	    <para>Adobe Technical Note #5015: "The Type 1 Font Format
	      Supplement." This document contains all updates to the
	      Type 1 format.</para>
	  </listitem>
	  <listitem>
	    <para>Adobe Technical Note #5087: "Multiple Master Font
	      Programs for the Macintosh."</para>
	  </listitem>
	  <listitem>
	    <para>Adobe Technical Note #5088 "Font Naming Issues."
	      This document discusses general font name issues. </para>
	  </listitem>
	  <listitem>
	    <para>Adobe's Unicode and Glyph Names guide.</para>
	  </listitem>
	</itemizedlist>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.font_file'>
    <title>The OpenType Font File</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>An OpenType font file contains data, in table format,
          that comprises either a TrueType or a PostScript outline
          font. Rasterizers use combinations of data from the tables
          contained in the font to render the TrueType or PostScript
          glyph outlines. Some of this supporting data is used no
          matter which outline format is used; some of the supporting
          data is specific to either TrueType or PostScript.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>Here is the scrap that collects all the definitions for
	  our Relax NG grammar:</para>

<code-fragment file='opentype.rnc' method='text'>
  <code-title>OpenType Relax NG Schema</code-title>

##_____________________________________________________________________________
##
##  Copyright 2000-2016 Adobe Systems Incorporated. All Rights Reserved.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use these files except in compliance with the License.
##  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##_____________________________________________________________________________

start =
  element font {
    attribute name { text }?,
    base-font?,
    (BASE?
     &amp; CFF?
     &amp; glyf?
     &amp; DSIG?
     &amp; GDEF?
     &amp; GPOS?
     &amp; GSUB?
     &amp; OS2?
     &amp; cmap?
     &amp; head?
     &amp; hhea?
     &amp; hmtx?
     &amp; hdmx?
     &amp; VDMX?
     &amp; vhea?
     &amp; vmtx?
     &amp; maxp?
     &amp; name?
     &amp; post?
     &amp; VORG?)
  }

  base-font =
    element base-font {
      attribute name { text }
    }

  yesOrNo = "yes" | "no"

  <code-include linkend='schema'/>
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>The compiler is really a simple shell that parses an XML
          document, passes it to the <varname>fromXML</varname> method
          of a <varname>Font</varname> object to build an internal
          representation of the font, and then invokes the
          <varname>toBinary</varname> method of that object to create
          an actual font file.</para>

<code-fragment package='com.adobe.aots.opentype' class='Compiler'>
  <code-title>Compiler class</code-title>
package com.adobe.aots.opentype;

import java.io.File;
import java.net.URL;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import org.xml.sax.InputSource;
import org.xml.sax.SAXParseException;

import com.thaiopensource.validate.ValidationDriver;
import com.thaiopensource.validate.rng.CompactSchemaReader;


public class Compiler implements org.xml.sax.ErrorHandler {

  private boolean isWhiteSpace (String s) {
    boolean result = true;
    for (int i = 0; i &lt; s.length (); i++) {
      char c = s.charAt (i);
      if (c != ' ' &amp;&amp; c != '\t' &amp;&amp; c != '\n') {
	result = false;
        break; }}
    return result;
  }

  private void removeWhiteSpace (Node n) {
    NodeList nl = n.getChildNodes ();
    int nbChildren = nl.getLength ();
    for (int i = 0; i &lt; nbChildren; i++) {
      removeWhiteSpace (nl.item (i)); }
    for (int i = 0; i &lt; nbChildren; i++) {
      if (nl.item (i).getNodeType () == Node.TEXT_NODE) {
	Text t = (Text) nl.item (i);
        if (isWhiteSpace (t.getData ())) {
	  n.removeChild (t);
	  nbChildren--; }}}
  }

  private Document parse (String inputFilename)
      throws Exception {
    inputFilename = new File (inputFilename).getAbsolutePath ();

    javax.xml.parsers.DocumentBuilderFactory dbf
      = javax.xml.parsers.DocumentBuilderFactory.newInstance ();
    dbf.setValidating (false);
    dbf.setIgnoringComments (true);
    dbf.setIgnoringElementContentWhitespace (true);
    javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder ();

    return  db.parse (new InputSource (inputFilename));
  }

  private boolean validate (Document font, String filename)
     throws Exception {
    ValidationDriver vd = new ValidationDriver (CompactSchemaReader.getInstance ());
    if (! vd.loadSchema (new InputSource (Compiler.class.getResource ("opentype.rnc").toString ()))) {
        throw new Exception ("failed to load schema"); }

    return vd.validate (vd.fileInputSource (filename));
  }


  public void error (SAXParseException e) {
    System.err.println ("Parse error: " + e);
  }

  public void fatalError (SAXParseException e) {
    System.err.println ("Parse fatal error: " + e);
  }

  public void warning (SAXParseException e) {
    System.err.println ("Parse warning: " + e);
  }

  private void compile (URL base, Element font, String outfile)
      throws Exception {
    Font f = new Font ();
    f.fromXML (base, font);
    f.toBinary (outfile);
  }

  private void doMain (String args[]) throws Exception {
    String out = "";

    for (int i = 0; i &lt; args.length; i++) {
      if (args[i].equals ("-o")) {
        i++;
        out = args[i]; }

      else {
        File f = new File (args[i]);
        Document doc = parse (args [i]);

	boolean valid = validate (doc, args[i]);
	if (valid) {
  	  removeWhiteSpace (doc);
	  compile (f.getAbsoluteFile().toURL (),
	  doc.getDocumentElement (), out); }}}
  }

  public static void main (String args[]) throws Exception {
    new Compiler ().doMain (args);
  }
}
</code-fragment>

        <para>A number of OpenType tables are made of blocks of data
          that point to one another. For example, a cmap table has a
          header block, which points to blocks for the various
          subtables. To facilitate the creation of these tables
          blocks, we have a class, named <varname>Block</varname>. The
          main methods are to set fields in blocks
          (<varname>setint16</varname>, <varname>setuint32</varname>,
          etc), to make one block point to another one
          (<varname>setOffset</varname>,
          <varname>setBigOffset</varname>), and finally to serialize
          all the blocks that make up a table
          (<varname>serialize</varname>).</para>

<code-fragment package='com.adobe.aots.opentype' class='Block'>
  <code-title>Block class</code-title>
package com.adobe.aots.opentype;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Vector;

  public class Block {
    public byte [] content;
    Block [] references;
    int [] referencePositions;
    boolean [] referenceBig;
    int currentReference = 0;
    int globalOffset = -1;

    public Block (int size, int referenceCount) {
      content = new byte [size];
      references = new Block [referenceCount];
      referencePositions = new int [referenceCount];
      referenceBig = new boolean [referenceCount];
    }

    public void setFixed (int offset, int major, int minor) {
      setuint16 (offset, major);
      setuint16 (offset + 2, minor);
    }

    public void setOffset (int offset, Block target) {
      referenceBig [currentReference] = false;
      referencePositions [currentReference] = offset;
      references [currentReference++] = target;
      setuint16 (offset, 0);
    }

    public void setBigOffset (int offset, Block target) {
      referenceBig [currentReference] = true;
      referencePositions [currentReference] = offset;
      references [currentReference++] = target;
      setuint32 (offset, 0x1234567);
    }

    public void setuint8 (int offset, int value) {
      content [offset] = (byte) value;
    }

    public void setint8 (int offset, int value) {
      content [offset] = (byte) value;
    }

    public void setuint16 (int offset, int value) {
      content [offset] = (byte) ((value >> 8) &amp; 0xff);
      content [offset+1] = (byte) (value &amp; 0xff);
    }

    public void setFWord(int offset, int value) {
      setuint16 (offset, value);
    }

    public void setuFWord (int offset, int value) {
      setuint16 (offset, value);
    }

    public void setuint24 (int offset, int value) {
      content [offset]   = (byte) ((value >> 16) &amp; 0xff);
      content [offset+1] = (byte) ((value >>  8) &amp; 0xff);
      content [offset+2] = (byte) (value         &amp; 0xff);
    }

    public void setuint32 (int offset, int value) {
      content [offset]   = (byte) ((value >> 24) &amp; 0xff);
      content [offset+1] = (byte) ((value >> 16) &amp; 0xff);
      content [offset+2] = (byte) ((value >>  8) &amp; 0xff);
      content [offset+3] = (byte) (value         &amp; 0xff);
    }

    public void setint32 (int offset, int value) {
      setuint32 (offset, value);
    }

    public void setint16 (int offset, int value) {
      content [offset] = (byte)((value >> 8) &amp; 0xff);
      content [offset+1] = (byte)(value &amp; 0xff);
    }

    public void setTag (int offset, String tag) {
      String t = tag + "    ";
      setuint8 (offset+0, t.charAt (0));
      setuint8 (offset+1, t.charAt (1));
      setuint8 (offset+2, t.charAt (2));
      setuint8 (offset+3, t.charAt (3));
    }

    public void setLONGDATETIME (int offset, long date) {
      content [offset+0] = (byte) ((date >> 56) &amp; 0xff);
      content [offset+1] = (byte) ((date >> 48) &amp; 0xff);
      content [offset+2] = (byte) ((date >> 40) &amp; 0xff);
      content [offset+3] = (byte) ((date >> 32) &amp; 0xff);
      content [offset+4] = (byte) ((date >> 24) &amp; 0xff);
      content [offset+5] = (byte) ((date >> 16) &amp; 0xff);
      content [offset+6] = (byte) ((date >>  8) &amp; 0xff);
      content [offset+7] = (byte) ((date      ) &amp; 0xff);
    }

    public void setValue (int offset, Value value) {
      setValue (offset, value.format, value);
    }

    public void setValue (int offset, int valueFormat, Value value) {
      if (value == null) {
        value = new Value (); }
      if ((valueFormat &amp; 0x001) != 0) {
        setint16 (offset, value.xPlacement);
        offset += 2; }
      if ((valueFormat &amp; 0x002) != 0) {
        setint16 (offset,value.yPlacement);
        offset += 2; }
      if ((valueFormat &amp; 0x004) != 0) {
        setint16 (offset, value.xAdvance);
        offset += 2; }
      if ((valueFormat &amp; 0x008) != 0) {
        setint16 (offset, value.yAdvance);
        offset += 2; }
      return;
    }

    public void setGlyphID (int offset, int glyphID) {
      setuint16 (offset, glyphID);
    }



    protected boolean visited = false;

    private void fillBlocks (Vector&lt;Block> blocks, int depth) {

      if (visited) {
        return; }

      visited = true;

      depth++;
//      System.err.println ("block of size " + this.content.length + " at depth " + depth);

      blocks.add (this);
      for (int i = 0; i &lt; references.length; i++) {
        if (references [i] != null) {
          references[i].fillBlocks (blocks, depth); }}
    }

    public byte[] serialize () {
      if (references.length == 0) {
         // a single block, we already have it
         return content; }

      // collect all the blocks pointed directly or indirectly by this one
      Vector&lt;Block> blocks= new Vector&lt;Block> ();
      fillBlocks (blocks, 0);

      // compute the total size
      int totalSize = 0;
      for (Block b : blocks) {
        totalSize += b.content.length; }

      // System.err.println ("----------");
      // for (Block b : blocks) {
      //   System.err.println (" " + b.content.length + "  0x" + Integer.toHexString (b.content.length)); }

      byte [] data = new byte [totalSize];

      while (blocks.size () > 0) {

        //find a block with no unresolved children
        Block toPos = null;

        Iterator it = blocks.iterator ();
        while (toPos == null &amp;&amp; it.hasNext ()) {
          Block t = (Block) it.next ();
          boolean hasDependency = false;
          for (int i = 0; i &lt; t.references.length; i++) {
            if (   t.references [i] != null
                &amp;&amp; t.references [i].globalOffset == -1) {
              hasDependency = true;
              break; }}
          if (! hasDependency) {
            toPos = t; }}

        // put toPos at the end
        totalSize -= toPos.content.length;
        toPos.globalOffset = totalSize;

        //System.out.println ("Setting " + toPos + " at " + toPos.globalOffset);

        // resolve references
        for (int p = 0; p &lt; toPos.references.length; p++) {
          int offset = toPos.references [p] == null ? 0 :
                          toPos.references [p].globalOffset - toPos.globalOffset;
          if (toPos.referenceBig [p]) {
            toPos.setuint32 (toPos.referencePositions [p], offset); }
          else {
	    if (offset > 0xffff) {
	      System.err.println ("cannot arrange block (offset="
	                          + Integer.toHexString (offset)); }
            toPos.setuint16 (toPos.referencePositions [p], offset); }}

        // copy in result table
        System.arraycopy (toPos.content, 0,
                          data, toPos.globalOffset,
                          toPos.content.length);

        blocks.remove (toPos); }

      return data;
    }


    public void dump () {
      System.out.println ("block " + this + ", size='" + content.length + "'");

      System.out.print ("  content: ");
      for (int i = 0; i &lt; content.length; i++) {
        System.out.print (Integer.toHexString (content[i]) + " "); }
      System.out.println ("");

      System.out.print ("  references: ");
      for (int i = 0; i &lt; references.length; i++) {
        System.out.print ("" + referencePositions [i] + "/" + references[i]
      + " "); }
      System.out.println ("");
    }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>When decompiling a font, we do have a number of choices,
	such as whether the XML reflects the exact formats used in the
	font, or whether is provides the most readable view of the
	font. This and other parameters are captured in a DecompilerConfig
	object:</para>

<code-fragment package='com.adobe.aots.opentype' class='DecompilerConfig'>
  <code-title></code-title>
package com.adobe.aots.opentype;

import java.io.File;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.net.URL;

import com.adobe.aots.util.ContentHandlerPlus;

import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;

public class DecompilerConfig extends org.xml.sax.helpers.DefaultHandler {
  public ContentHandlerPlus ch;

  public boolean preciseCoverageFormat;
  public boolean preciseClassDefFormat;
  public boolean preciseCmap;

  public enum PointersAreShown { never, asNeeded, always };
  public PointersAreShown pointers;

  public enum Gid { byNumber, byName};
  public Gid gid;
  public String[] glyphNames;
  protected java.util.Map&lt;String, String> userGlyphNames = null;


  DecompilerConfig () {
    makeReadable ();
  }

  public void makeReadable () {
    preciseCoverageFormat = false;
    preciseClassDefFormat = false;
    preciseCmap = false;
    pointers = PointersAreShown.never;
    gid = Gid.byNumber;
  }

  public void makeExact () {
    preciseCoverageFormat = true;
    preciseClassDefFormat = true;
    preciseCmap = true;
    pointers = PointersAreShown.asNeeded;
    gid = Gid.byNumber;
  }

  public void sendOutputTo (javax.xml.transform.Result result)
      throws javax.xml.transform.TransformerConfigurationException {

    TransformerFactory tfactory = TransformerFactory.newInstance ();
    if (!tfactory.getFeature (SAXSource.FEATURE)) {
      System.err.println ("SAXSource.FEATURE not supported"); }

    SAXTransformerFactory sfactory = (SAXTransformerFactory) tfactory;

    TransformerHandler handler = sfactory.newTransformerHandler ();

//    handler.setResult (new StreamResult (System.out));
    handler.setResult (result);

    Transformer transformer = handler.getTransformer ();
    transformer.setOutputProperty (OutputKeys.INDENT, "yes");
    transformer.setOutputProperty (OutputKeys.STANDALONE, "yes");

    ch = new ContentHandlerPlus (handler);
  }



  public void startElement (String namespaceURI, String localName, String qName,
                            org.xml.sax.Attributes atts)
      throws org.xml.sax.SAXException {
    if (localName.equals ("glyph")) {
      userGlyphNames.put (atts.getValue ("id"), atts.getValue ("name")); }
  }

  public void parseGlyphNames (String filename)
      throws javax.xml.parsers.ParserConfigurationException,
             org.xml.sax.SAXException,
             java.io.IOException {
    userGlyphNames = new java.util.HashMap&lt;String, String> ();

    javax.xml.parsers.SAXParserFactory spf
      = javax.xml.parsers.SAXParserFactory.newInstance ();
    spf.setNamespaceAware (true);
    javax.xml.parsers.SAXParser sp = spf.newSAXParser ();
    sp.parse (filename, this);
  }

  public void incorporateUserGlyphNames (int nGlyphs) {
    if (userGlyphNames == null) {
      return; }

    if (glyphNames == null) {
      glyphNames = new String [nGlyphs]; }

    for (String g : userGlyphNames.keySet ()) {
      int gid = Integer.parseInt (g);
      glyphNames [gid] = userGlyphNames.get (g); }
  }


}
</code-fragment>

        <para>The decompiler is really a simple shell that creates a
          <varname>Font</varname>, calls its
          <varname>fromBinary</varname> method to initializes it with
          the content of an existing font, calls its
          <varname>toXML</varname> method to create the XML
          representation and serializes it.</para>

<code-fragment package='com.adobe.aots.opentype' class='Decompiler'>
  <code-title>Decompiler class</code-title>
package com.adobe.aots.opentype;


import java.io.File;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.net.URL;

import com.adobe.aots.util.ContentHandlerPlus;

import org.w3c.dom.Element;

import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;

public class Decompiler {

  public static void main (String args[]) throws Exception {

    try {
      long [] tags = null;
      int ttcIndex = -1;
      boolean roundtrip = false;
      OutputStream output = System.out;
      DecompilerConfig conf = new DecompilerConfig ();
      URL base = null;

      for (int i = 0; i &lt; args.length; i++) {
        if ("-ttc".equals (args [i])) {
          i++;
          ttcIndex = Integer.parseInt (args [i]); }

        else if ("-t".equals (args [i])) {
          i++;
  	  tags = Tag.string2tags (args [i]); }

        else if ("-exact".equals (args [i])) {
	  conf.makeExact (); }

	else if ("-readable".equals (args [i])) {
          conf.makeReadable (); }

	else if ("-pointers=never".equals (args [i])) {
	  conf.pointers = DecompilerConfig.PointersAreShown.never; }

	else if ("-pointers=asneeded".equals (args [i])) {
	  conf.pointers = DecompilerConfig.PointersAreShown.asNeeded; }

	else if ("-pointers=always".equals (args [i])) {
	  conf.pointers = DecompilerConfig.PointersAreShown.always; }

        else if ("-gid=names".equals (args[i])) {
	  conf.gid = DecompilerConfig.Gid.byName; }

        else if ("-gid=numbers".equals (args [i])) {
	  conf.gid = DecompilerConfig.Gid.byNumber; }

        else if (args [i].startsWith ("-gid=")) {
	  conf.gid = DecompilerConfig.Gid.byName;
          conf.parseGlyphNames (args [i].substring (5)); }

	else if ("-coverages=exact".equals (args [i])) {
	  conf.preciseCoverageFormat = true; }

	else if ("-coverages=readable".equals (args [i])) {
	  conf.preciseCoverageFormat = false; }

	else if ("-classdefs=exact".equals (args [i])) {
	  conf.preciseClassDefFormat = true; }

	else if ("-classdefs=readable".equals (args [i])) {
	  conf.preciseClassDefFormat = false; }

	else if ("-roundtrip".equals (args [i])) {
	  roundtrip = true; }

	else if ("-b".equals (args [i])) {
	  i++;
	  base = new File (args [i]).toURL (); }

        else if ("-o".equals (args [i])) {
	  i++;
          output = new FileOutputStream (args [i]); }

	else if ("-h".equals (args [i])
	         || "--help".equals (args)
		 || "-u".equals (args)) {
	  i++;
	  System.out.println ("Decompiler [options] fontfile\n"
+ "\n"
+ "-t&lt;table>[,&lt;table>]    decompile selected tables\n"
+ "-exact                 show the font content exactly\n"
+ "-readable              show the font content readably\n"
+ "-pointers=never        inline all blocks\n"
+ "-pointers=asneeded     inline blocks with a single reference\n"
+ "-pointers=always       never inline blocks\n"
+ "-coverages=exact       show the coverages exactly\n"
+ "-coverages=readable    show the coverages readably\n"
+ "-classdefs=exact       show the class definitions exactly\n"
+ "-classdefs=readably    show the class definitions readably\n"
+ "-gid=names             show gids by their name\n"
+ "-gid=numbers           show gids by their numbers"); }

        else if (args [i].startsWith ("-")) {
	  i++;
	  System.out.println ("invalid option: " + args [i]);
	  System.out.println ("-h for help"); }

        else {
          URL source = new File (args [i]).getAbsoluteFile().toURL ();
          Font font = new Font ();
          if (ttcIndex == -1) {
            font.fromBinary (source); }
          else {
            font.fromBinary (source, ttcIndex); }

          if (! roundtrip) {
            conf.sendOutputTo (new StreamResult (output));
            conf.ch.startDocument (); {
              font.toXML (conf, tags, base != null ? base : source);
              conf.ch.endDocument (); }}

          else {
            DOMResult stage1 = new DOMResult ();
            conf.sendOutputTo (stage1);
            conf.ch.startDocument (); {
              font.toXML (conf, tags, source);
              conf.ch.endDocument (); }

            Font f2 = new Font ();
            f2.fromXML (null, (Element)stage1.getNode ().getFirstChild ());
	    f2.toBinary (output); }
          output.close (); }}}

    catch (Exception e) {
      System.err.println ("Exception: " + e.getMessage ());
      e.printStackTrace ();
      System.exit (1); }
  }
}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Filenames</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>OpenType fonts may have the extension .OTF or .TTF,
          depending on the kind of outlines in the font and the
          creator's desire for compatibility on systems without native
          OpenType support.</para>

        <itemizedlist>
          <listitem>
            <para>In all cases, fonts with only CFF data (no TrueType
              outlines) always have an .OTF extension.</para>
          </listitem>
          <listitem>
            <para>Fonts containing TrueType outlines may have either
              .OTF or .TTF, depending on the desire for backward
              compatibility on older systems or with previous versions
              of the font. TrueType Collection fonts should have a
              .TTC extension whether or not the fonts have OpenType
              layout tables present.</para>
          </listitem>
        </itemizedlist>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Data Types</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The following data types are used in the OpenType font
        file. All OpenType fonts use Motorola-style byte ordering (Big
        Endian):</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="8pc"/>
            <colspec colwidth="22pc"/>
            <thead>
              <row>
                <entry>Data Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>BYTE</entry>
                <entry>8-bit unsigned integer.</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>8-bit signed integer.</entry>
              </row>
              <row>
                <entry>USHORT</entry>
                <entry>16-bit unsigned integer.</entry>
              </row>
              <row>
                <entry>SHORT</entry>
                <entry>16-bit signed integer.</entry>
              </row>
              <row>
                <entry>UINT24</entry>
                <entry>24-bit signed integer.</entry>
              </row>
              <row>
                <entry>ULONG</entry>
                <entry>32-bit unsigned integer.</entry>
              </row>
              <row>
                <entry>LONG</entry>
                <entry>32-bit signed integer.</entry>
              </row>
              <row>
                <entry>Fixed</entry>
                <entry>32-bit signed fixed-point number (16.16)</entry>
              </row>
              <row>
                <entry>FUNIT</entry>
                <entry>Smallest measurable distance in the em space.</entry>
              </row>
	      <row>
		<entry>FWORD</entry>
		<entry>16-bit signed integer (SHORT) that describes a
		  quantity in FUnits.</entry>
	      </row>
	      <row>
		<entry>UFWORD</entry>
		<entry>16-bit unsigned integer (USHORT) that describes
		  a quantity in FUnits.</entry>
	      </row>
              <row>
                <entry>F2DOT14</entry>
                <entry>16-bit signed fixed number with the low 14 bits of
            fraction (2.14).</entry>
              </row>
              <row>
                <entry>LONGDATETIME</entry>
                <entry>Date represented in number of seconds since 12:00
            midnight, January 1, 1904. The value is represented as a
            signed 64-bit integer.</entry>
              </row>
              <row>
                <entry>Tag</entry>
                <entry>Array of four uint8s (length = 32 bits) used to
            identify a script, language system, feature, or
            baseline</entry>
              </row>
              <row>
                <entry>GlyphID</entry>
                <entry>Glyph index number, same as uint16 (length = 16
                bits)</entry>
              </row>
              <row>
                <entry>Offset</entry>
                <entry> Offset to a table, same as uint16 (length = 16
            bits), NULL offset = 0x0000</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The F2DOT14 format consists of a signed, 2's
        complement mantissa and an unsigned fraction. To compute the
        actual value, take the mantissa and add the fraction. Examples
        of 2.14 values are:</para>

        <informaltable>
          <tgroup cols='4'>
            <colspec colwidth="7.5pc"/>
            <colspec colwidth="7.5pc"/>
            <colspec colwidth="7.5pc"/>
            <colspec colwidth="7.5pc"/>
            <thead>
              <row>
                <entry>Decimal Value</entry>
                <entry>Hex Value</entry>
                <entry>Mantissa</entry>
                <entry>Fraction</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1.999939</entry>
                <entry>0x7fff</entry>
                <entry>1</entry>
                <entry>16383/16384</entry>
              </row>
              <row>
                <entry>1.75</entry>
                <entry>0x7000</entry>
                <entry>1</entry>
                <entry>12288/16384</entry>
              </row>
              <row>
                <entry>0.000061</entry>
                <entry>0x0001</entry>
                <entry>0</entry>
                <entry>1/16384</entry>
              </row>
              <row>
                <entry>0.0</entry>
                <entry>0x0000</entry>
                <entry>0</entry>
                <entry>0/16384</entry>
              </row>
              <row>
                <entry>-0.000061</entry>
                <entry>0xffff</entry>
                <entry>-1</entry>
                <entry>16383/16384</entry>
              </row>
              <row>
                <entry>-2.0</entry>
                <entry>0x8000</entry>
                <entry>-2</entry>
                <entry>0/16384</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>A number of synonyms are used for throughout the
          specification. They should be documented, and may be even
          replace the type above, as their names are more useful:</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="15pc"/>
            <colspec colwidth="15pc"/>
            <tbody>
              <row>
                <entry>uint8</entry>
                <entry>BYTE</entry>
              </row>
              <row>
                <entry>int8</entry>
                <entry>CHAR</entry>
              </row>
              <row>
                <entry>uint16</entry>
                <entry>USHORT</entry>
              </row>
              <row>
                <entry>int16</entry>
                <entry>SHORT</entry>
              </row>
              <row>
                <entry>uint32</entry>
                <entry>ULONG</entry>
              </row>
              <row>
                <entry>int32</entry>
                <entry>LONG</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Note that some of the offsets are of type 'Offset' and
        are 16 bit quantities, while other offsets are of type 'ULONG'
        and are 32 bit quantities. Since we represent a table in an
        array, we are limited to Java-int offsets, so we have to
        verify ULONG offsets.</para>

<code-fragment id='table.methods'>
  <code-title>Data Access routines</code-title>
  protected final int getuint8 (int offset) {
    int x = data [offset];
    if (x &lt; 0) {
      x += 256; }
    return x;
  }

  protected final int getint8 (int offset) {
    return data [offset];
  }

  protected final void setuint8 (int offset, int v) {
    data [offset] = (byte) (v &amp; 0xff);
  }

  protected final int getuint16 (int offset) {
    int b1 = ((int)(getuint8 (offset    ))) &lt;&lt;  8;
    int b2 = ((int)(getuint8 (offset + 1)));
    return (b1 | b2);
  }

  protected final void setuint16 (int offset, int v) {
    data [offset]   = (byte) ((v >> 8) &amp; 0xff);
    data [offset+1] = (byte) ((v     ) &amp; 0xff);
  }

  protected final int getuint24 (int offset) {
    int b1 = ((int)(getuint8 (offset    ))) &lt;&lt; 16;
    int b2 = ((int)(getuint8 (offset + 1))) &lt;&lt;  8;
    int b3 = ((int)(getuint8 (offset + 2)));
    return (b1 | b2 | b3);
  }

  protected final int getGlyphID (int offset) {
    return getuint16 (offset);
  }

  protected final int getint16 (int offset) {
    int x = ((int)data [offset]) * 256;
    return x + getuint8 (offset + 1);
  }

  protected final int getOffset (int offset) {
    return getuint16 (offset);
  }

  protected final int getOffset (int base, int offset) {
    if (getOffset (base + offset) != 0) {
      return base + getOffset (base + offset); }
    else {
      return 0; }
  }

  protected final long getuint32 (int offset) {
    long b1 = ((long)(getuint8 (offset    ))) &lt;&lt; 24;
    long b2 = ((long)(getuint8 (offset + 1))) &lt;&lt; 16;
    long b3 = ((long)(getuint8 (offset + 2))) &lt;&lt;  8;
    long b4 = ((long)(getuint8 (offset + 3)));
    return (b1 | b2 | b3 | b4);
  }

  protected final int getint32 (int offset) {
    int x = ((int)data [offset]) * 256;
    x = (x + getuint8 (offset + 1)) * 256;
    x = (x + getuint8 (offset + 2)) * 256;
    return x + getuint8 (offset + 3);
  }

  protected final void setuint32 (int offset, int value) {
    data [offset]   = (byte) ((value >> 24) &amp; 0xff);
    data [offset+1] = (byte) ((value >> 16) &amp; 0xff);
    data [offset+2] = (byte) ((value >>  8) &amp; 0xff);
    data [offset+3] = (byte) (value         &amp; 0xff);
  }

  protected final void setint32 (int offset, int value) {
    data [offset]   = (byte) ((value >> 24) &amp; 0xff);
    data [offset+1] = (byte) ((value >> 16) &amp; 0xff);
    data [offset+2] = (byte) ((value >>  8) &amp; 0xff);
    data [offset+3] = (byte) (value         &amp; 0xff);
  }

  protected final int getLOffset (int offset) {
    long o = getuint32 (offset);
    if (o > Integer.MAX_VALUE) {
      System.out.println ("Offset too big!"); }
    return (int) o;
  }

  protected final int getLOffset (int base, int offset) {
    if (getLOffset (base + offset) != 0) {
      return base + getLOffset (base + offset); }
    else {
      return 0; }
  }

  protected final int[] getFixed (int offset) {
    int[] result = new int[2];
    result[0] = getuint16 (offset);
    result[1] = getuint16 (offset + 2);
    return result;
  }

  protected final void setFixed (int offset, int major, int minor) {
    setuint16 (offset, major);
    setuint16 (offset + 2, minor);
  }

  protected final int getFWord (int offset) {
    return getint16 (offset);
  }

  protected final int getuFWord (int offset) {
    return getuint16 (offset);
  }

  protected final long getLONGDATETIME (int offset) {
    long x = getint32 (offset) &lt;&lt; 32;
    x += getuint32 (offset + 4);
    return x;
  }

  public void setLONGDATETIME (int offset, long date) {
    data [offset+0] = (byte) ((date >> 56) &amp; 0xff);
    data [offset+1] = (byte) ((date >> 48) &amp; 0xff);
    data [offset+2] = (byte) ((date >> 40) &amp; 0xff);
    data [offset+3] = (byte) ((date >> 32) &amp; 0xff);
    data [offset+4] = (byte) ((date >> 24) &amp; 0xff);
    data [offset+5] = (byte) ((date >> 16) &amp; 0xff);
    data [offset+6] = (byte) ((date >>  8) &amp; 0xff);
    data [offset+7] = (byte) ((date      ) &amp; 0xff);
  }

  /** return the uint32 at <code>offset</code> in the table
   * as an int.
   * @param offset the offset of the uint32
   * @param exceptionMsg the detail message for the exception, if thrown
   * @throws  UnsupportedFontException if the value
   * cannot be represented in an int.
   */
  protected final int getuint32asint (int offset, String exceptionMsg)
      throws UnsupportedFontException {
    if (getuint8 (offset) > 0x7f) {
      throw new UnsupportedFontException (exceptionMsg); }
    return (int) getuint32 (offset);
  }
</code-fragment>

        <para>Here is a class in which we collect common tag
          values:</para>

<code-fragment package='com.adobe.aots.opentype' class='Tag'>
package com.adobe.aots.opentype;

public class Tag {
  static public final long ttcf = 0x74746366;

  static public final long BASE = 0x42415345;
  static public final long CFF  = 0x43464620;
  static public final long DSIG = 0x44534947;
  static public final long GDEF = 0x47444546;
  static public final long GPOS = 0x47504f53;
  static public final long GSUB = 0x47535542;
  static public final long VORG = 0x564f5247;
  static public final long cmap = 0x636d6170;
  static public final long cvt  = 0x63767420;
  static public final long head = 0x68656164;
  static public final long hhea = 0x68686561;
  static public final long hdmx = 0x68646d78;
  static public final long hmtx = 0x686d7478;
  static public final long vhea = 0x76686561;
  static public final long vmtx = 0x766d7478;
  static public final long fpgm = 0x6670676d;
  static public final long glyf = 0x676c7966;
  static public final long loca = 0x6c6f6361;
  static public final long maxp = 0x6d617870;
  static public final long name = 0x6e616d65;
  static public final long os2  = 0x4f532f32;   // OS/2
  static public final long post = 0x706f7374;
  static public final long prep = 0x70726570;
  static public final long VDMX = 0x56444d58;

  // script tags

  static public final long arab = 0x61726162;
  static public final long armn = 0x61726d6e;
  static public final long beng = 0x62656e67;
  static public final long bopo = 0x626f706f;
  static public final long brai = 0x62726169;
  static public final long byzm = 0x62797a6d;
  static public final long cans = 0x63616e73;
  static public final long cher = 0x63686572;
  static public final long hani = 0x68616e69;
  static public final long cyrl = 0x6379726c;
  static public final long deva = 0x64657661;
  static public final long ethi = 0x65746869;
  static public final long geor = 0x67656f72;
  static public final long grek = 0x6772656b;
  static public final long gujr = 0x67756a72;
  static public final long guru = 0x67757277;
  static public final long jamo = 0x6a6a6d6f;
  static public final long hang = 0x68616e67;
  static public final long hebr = 0x68656272;
  static public final long knda = 0x6b6e6461;
  static public final long latn = 0x6c61746e;
  static public final long mlym = 0x6d6c796d;
  static public final long mymr = 0x6d796d72;
  static public final long telu = 0x74656c75;
  static public final long thai = 0x74686169;


  static public final long ARA  = 0x41524120;
  static public final long BEN  = 0x42454e20;
  static public final long BRM  = 0x42524d20;
  static public final long ELL  = 0x454c4c20;
  static public final long ENG  = 0x454e4720;
  static public final long GAE  = 0x47414520;
  static public final long GUJ  = 0x47554a20;
  static public final long HIN  = 0x48494e20;
  static public final long HYE  = 0x48594520;
  static public final long IWR  = 0x49575220;
  static public final long JAN  = 0x4a414e20;
  static public final long KAN  = 0x4b414e20;
  static public final long KOR  = 0x4b4f5220;
  static public final long MAL  = 0x4d414c20;
  static public final long MAR  = 0x4d415220;
  static public final long MLR  = 0x4d4c5220;
  static public final long PAL  = 0x50414c20;
  static public final long PAN  = 0x50414e20;
  static public final long PTG  = 0x50544720;
  static public final long ROM  = 0x524f4d20;
  static public final long RUS  = 0x52555320;
  static public final long SAN  = 0x53414e20;
  static public final long TEL  = 0x54454c20;
  static public final long THA  = 0x54484120;
  static public final long TUR  = 0x54555220;
  static public final long VIT  = 0x56495420;
  static public final long ZHS  = 0x5a485320;
  static public final long ZHT  = 0x5a485420;

  static public final long abvm = 0x6162766d;
  static public final long abvs = 0x61627673;
  static public final long akhn = 0x616b686e;
  static public final long blwf = 0x626c7766;
  static public final long blwm = 0x626c776d;
  static public final long blws = 0x626c7773;
  static public final long calt = 0x63616c74;
  static public final long ccmp = 0x63636d70;
  static public final long clig = 0x636c6967;
  static public final long cswh = 0x63737768;
  static public final long curs = 0x63757273;
  static public final long dist = 0x64697374;
  static public final long dlig = 0x646c6967;
  static public final long dnom = 0x646e6f6d;
  static public final long fina = 0x66696e61;
  static public final long frac = 0x66726163;
  static public final long half = 0x68616c66;
  static public final long haln = 0x68616c6e;
  static public final long init = 0x696e6974;
  static public final long isol = 0x69736f6c;
  static public final long kern = 0x6b65726e;
  static public final long liga = 0x6c696761;
  static public final long locl = 0x6c6f636c;
  static public final long mark = 0x6d61726b;
  static public final long medi = 0x6d656469;
  static public final long mkmk = 0x6d6b6d6b;
  static public final long mset = 0x6d736574;
  static public final long nukt = 0x6e756b74;
  static public final long numr = 0x6e756d72;
  static public final long onum = 0x6f6e756d;
  static public final long pnum = 0x706e756d;
  static public final long pres = 0x70726573;
  static public final long pstf = 0x70737466;
  static public final long psts = 0x70737473;
  static public final long rlig = 0x726c6967;
  static public final long rphf = 0x72706866;
  static public final long size = 0x73697a65;
  static public final long subs = 0x73756273;
  static public final long sups = 0x73757073;
  static public final long vatu = 0x76617475;

  public static String tag2string (long tag) {
    char[] chars = new char[4];
    for (int i = 3; i &gt;= 0; i--) {
      chars [i] = (char)(tag &amp; 0xff);
      if (chars [i] == 0x0) {
        chars [i] = 0x20; }
      tag = tag >> 8; }
    return new String (chars);
  }

  public static long string2tag (String s) {
    String t = s + "    ";
    long result = 0;
    for (int i = 0; i &lt; 4; i++) {
      result = (result &lt;&lt; 8) + t.charAt (i); }
    return result;
  }

  public static long[] string2tags (String s) {
    String[] tags = s.split (",");
    long[] result = new long [tags.length];
    for (int i = 0; i &lt; result.length; i++) {
      result [i] = string2tag (tags[i].trim ()); }
    return result;
  }
}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version Numbers</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Most tables have version numbers, and the version number
	  for the entire font is contained in the Table
	  Directory. Note that there are two different table version
	  number types, each with its own numbering scheme. USHORT
	  version numbers always start at zero (0). Fixed version
	  numbers always start at one (1.0 or 0x00010000), except
	  where noted (<ottable>EBDT</ottable>,
	  <ottable>EBLC</ottable> and <ottable>EBSC</ottable>
	  tables).</para>

        <para>Implementations reading tables must include code to
        check version numbers so that if and when the format and
        therefore the version number changes, older implementations
        will reject newer versions gracefully, if the changes are
        incompatible.</para>

        <para>When a Fixed number is used as a version, the upper 16
        bits comprise a major version number, and the lower 16 bits a
        minor. Tables with non-zero minor version numbers always
        specify the literal value of the version number since the
        normal representation of Fixed numbers is not necessarily
        followed. For example, the version number of
        <ottable>maxp</ottable> table version 0.5 is 0x00005000, and
        that of <ottable>vhea</ottable> table version 1.1 is
        0x00011000. If an implementation understands a major version
        number, then it can safely proceed reading the table. The
        minor version number indicates extensions to the format that
        are undetectable by implementations that do not support
        them.</para>

        <para>The only exception to this is the Offset Table's sfnt
        version. This serves solely to identify whether the OpenType
        font contains TrueType outlines (a value of 1.0) or CFF data
        (the tag 'OTTO'), as described in the section below,
        <link linkend="organization">Organization of an OpenType
        font</link>.</para>

        <para>When a USHORT number is used to indicate version, it
        should be treated as though it were a minor version number;
        i.e., all format changes are compatible extensions.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='version_subroutines'>
  <code-title>Procedures to verify versions</code-title>

  private void verifyFixedVersion (byte[] data, int offset, int major, int minor)
    throws UnsupportedVersionException {
    int actualMajor = getuint16 (data, offset);
    int actualMinor = getuint16 (data, offset+2);

    if (major != actualMajor || actualMinor &lt; minor) {
      System.out.println ("major = " + major + "/" + actualMajor
                          + " minor = " + minor + "/" + actualMinor);
      throw new UnsupportedVersionException (); }
  }

  private void verifyUSHORTVersion (byte[] data, int offset, int minor)
    throws UnsupportedVersionException {
    int actualMinor = getuint16 (data, offset);
    if (actualMinor &lt; minor) {
      System.out.println ( " minor = " + minor + "/" + actualMinor);
      throw new UnsupportedVersionException (); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment' id='organization'>
      <title>Organization of an OpenType Font</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A key characteristic of the OpenType format is the
        TrueType sfnt "wrapper", which provides organization for a
        collection of tables in a general and extensible
        manner.</para>

        <para>The OpenType font file begins with the Offset Table. If
	  the font file contains only one font, the Offset Table will
	  begin at byte 0 of the file. If the font file is a TrueType
	  collection, the beginning point of the Offset Table for each
	  font is indicated in the TTCHeader.</para>

        <otformat>
	  <title>Offset Table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>sfnt version</otfieldname>
            <otfielddesc>0x00010000 for version 1.0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numTables</otfieldname>
            <otfielddesc>Number of tables.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>searchRange</otfieldname>
            <otfielddesc>(Maximum power of 2 &lt;= numTables) x
              16.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>entrySelector</otfieldname>
            <otfielddesc>Log2(maximum power of 2 &lt;=
              numTables).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rangeShift</otfieldname>
            <otfielddesc>NumTables x 16-searchRange.</otfielddesc>
          </otfield>
        </otformat>

        <para>OpenType fonts that contain TrueType outlines should use
          the value of 1.0 for the sfnt version. OpenType fonts
          containing CFF data should use the tag 'OTTO' as the sfnt
          version number.</para>

	<para>Note: The Apple specification for TrueType fonts allows
	  for 'true' and 'typ1' for sfnt version. These version tags
	  should not be used for fonts which contain OpenType
	  tables.</para>

        <para>The Offset Table is followed immediately by the Table
          Directory entries. Entries in the Table Directory must be
          sorted in ascending order by tag. Offset values in the Table
          Directory are measured from the start of the font
          file.</para>

        <otformat>
	  <title>Table Directory</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>tag</otfieldname>
            <otfielddesc>4 -byte identifier.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>checkSum</otfieldname>
            <otfielddesc>CheckSum for this table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>offset</otfieldname>
            <otfielddesc>Offset from beginning of TrueType font
              file.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>Length of this table.</otfielddesc>
          </otfield>
        </otformat>

        <para>The Table Directory makes it possible for a given font
        to contain only those tables it actually needs. As a result
        there is no standard value for numTables.</para>

        <para>Tags are the names given to tables in the OpenType font
        file. All tag names consist of four characters. Names with
        less than four letters are allowed if followed by the
        necessary trailing spaces. All tag names defined within a font
        (e.g., table names, feature tags, language tags) must be built
        from printing characters represented by ASCII values
        32-126</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>For clarity, is may be worth to add "or 'OTTO'" to the
          description of the field snft version in the first
          table. I realize that the paragraph following the table
          makes that clear, but users of the specification familiar
          with it are likely to look at the tables only.</para>

        <para>The type of the tag field in the second table should
          probably be 'Tag'.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='table.methods'>
  <code-title>Compilation methods</code-title>
  public Element getTarget (Element e, String tagMustBe) {
    return getTarget (e);
  }

  public Element getTarget (Element e) {
    String targetName = e.getAttribute ("target");
    Element target = e.getOwnerDocument ().getElementById (targetName);
    if (target == null) {
      warning ("cannot find element with id '" + targetName + "'"); }
    return target;
  }

  public int getIndex (Element e) {
    return Integer.parseInt (getTarget (e).getAttribute ("index"));
  }

  public int[] getGlyphs (String s) {

    return parseGlyphList (s);
  }

  public int countGlyphs (String s) {
    return getGlyphs (s).length;
  }

  public static int parseOneInt (String s) {
    int radix = 10;
    int start = 0;

    if (   s.length() >= 2
        &amp;&amp; s.charAt (0) == '0'
        &amp;&amp; s.charAt (1) == 'x') {
      start += 2;
      radix = 16; }

    return Integer.parseInt (s.substring (start), radix);
  }

  public static int[] parseIntList (String s) {
    int i;
    int len = s.length ();
    int count = 0;

    i = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; s.charAt (i) == ' ') {
        i++; }
      if (i == len) {
        break; }
      int j = i;
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ') {
        i++; }
      String x = s.substring (j, i);
      int column = x.indexOf (':');
      if (column != -1) {
        int v1 = parseOneInt (x.substring (0, column));
	int v2 = parseOneInt (x.substring (column + 1));
        count += v2 - v1 + 1; }
      else {
        count++; }}

    int[] list = new int [count];

    i = 0;
    count = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; s.charAt (i) == ' ') {
        i++; }
      if (i == len) {
        break; }
      int start = i;
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ') {
        i++; }

      String x = s.substring (start, i);
      int column = x.indexOf (':');
      if (column != -1) {
        int v1 = parseOneInt (x.substring (0, column));
	int v2 = parseOneInt (x.substring (column + 1));
        for (int k = v1; k &lt;= v2; k++) {
          list [count++] = k; }}
      else {
        list [count++] = parseOneInt (x); }}

    return list;
  }


  public int parseOneGlyph (String s) {
    if (font.post != null) {
      int gid = font.post.getGid (s);
      if (gid != -1) {
        return gid; }}

    if (   s.length() >= 2
        &amp;&amp; s.charAt (0) == '0'
        &amp;&amp; s.charAt (1) == 'x') {
      return Integer.parseInt (s.substring (2), 16); }

    return Integer.parseInt (s);
  }

  public int[] parseGlyphList (String s) {
    int i;
    int len = s.length ();
    int count = 0;

    i = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; s.charAt (i) == ' ') {
        i++; }
      if (i == len) {
        break; }
      int j = i;
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ') {
        i++; }
      String x = s.substring (j, i);
      int column = x.indexOf (':');
      if (column != -1) {
        int v1 = parseOneGlyph (x.substring (0, column));
	int v2 = parseOneGlyph (x.substring (column + 1));
        count += v2 - v1 + 1; }
      else {
        count++; }}

    int[] list = new int [count];

    i = 0;
    count = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; s.charAt (i) == ' ') {
        i++; }
      if (i == len) {
        break; }
      int start = i;
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ') {
        i++; }

      String x = s.substring (start, i);
      int column = x.indexOf (':');
      if (column != -1) {
        int v1 = parseOneGlyph (x.substring (0, column));
	int v2 = parseOneGlyph (x.substring (column + 1));
        for (int k = v1; k &lt;= v2; k++) {
          list [count++] = k; }}
      else {
        list [count++] = parseOneGlyph (x); }}

    return list;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='table.methods'>
  <code-title>Decompilation methods</code-title>
  protected String glyphToXML (DecompilerConfig conf, int gid) {
    if (conf.glyphNames != null) {
      return conf.glyphNames [gid]; }
    else {
      return "" + gid; }
  }

  protected void glyphToXML (DecompilerConfig conf, StringBuilder s, int gid) {
    if (s.length () != 0) {
      s.append (' '); }
    if (conf.glyphNames != null) {
      s.append (conf.glyphNames [gid]); }
    else {
      s.append (gid); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Each table type is implemented as a class; all those
          classes derive from the class Table. Note that we record the
          font to which a table belong when creating it; this allows
          one table to access other tables when performing some
          operation (such as GSUB using GDEF).</para>

<code-fragment package='com.adobe.aots.opentype' class='Table'>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

import java.io.InputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.SortedSet;
import java.util.TreeSet;

public abstract class Table {
  protected long tag;
  protected Font font;

  public Table (long tag) {
    this.tag = tag;
    this.font = null;
  }

  public Table (long tag, Font font) {
    this.tag = tag;
    this.font = font;
  }

  public long getTag () {
    return tag;
  }
  <code-include linkend='table.methods'/>
}
</code-fragment>

<code-fragment id='schema'>
  unknownTable =
    element unknownTable {
      attribute tag { text },
      text
    }
</code-fragment>

<code-fragment package='com.adobe.aots.opentype' class='UnknownTable'>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

public class UnknownTable extends Table {
  public UnknownTable (long tag, Font font) {
    super (tag, font);
  }

  public void fromXML (Element e)
    throws InvalidFontException, UnsupportedFontException {

    // TODO: recover the content
  }

  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException,
             InvalidFontException,
             UnsupportedFontException {

    AttributesImpl at = new AttributesImpl ();
    at.addAttribute ("", "tag", "tag", "CDATA", Tag.tag2string (tag));

    conf.ch.startElement ("unknownTable", at); {
       // TODO: dump the content of the table
       conf.ch.endElement ("unknownTable"); }
  }
}
</code-fragment>


        <para>Each subclass of Table will essentially hold an internal
          representation of the table, and provide methods to access
          the data in the table, or may be apply that data (e.g. GSUB
          and GPOS).</para>

        <para>The internal representation can be built from two
          sources: from an actual font file or from an XML
          representation of the font; this is achieved by the
          fromBinary and fromXML methods. Similarly, the internal
          representation can be expressed as either a fragment of a
          font, or in XML; this is achieved by the toBinary and toXML
          methods.</para>

        <para>In many cases, the internal representation is actually
          the binary form of the table, and a couple of methods are
          trivial. The Table class provides an implementation for that
          case.</para>

<code-fragment id='table.methods'>
  <code-title>Import/export methods</code-title>
  public byte[] data;

  public int fromBinary (InputStream in, int length)
      throws IOException, InvalidFontException {
    data = new byte [length];
    return in.read (data);
  }

  public byte[] toBinary () {
    return data;
  }

  abstract public void fromXML (Element e)
    throws InvalidFontException, UnsupportedFontException;

  abstract public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException,
             InvalidFontException,
             UnsupportedFontException;
</code-fragment>

        <para>Technically, the header is not a table, but it is
        convenient for our purposes to pretend so.</para>

<code-fragment package='com.adobe.aots.opentype' class='Header'>
  <code-title>Header class</code-title>
package com.adobe.aots.opentype;

import java.util.Iterator;
import java.io.InputStream;
import java.io.IOException;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Header extends Table {

  public Header () {
    super (0, null);
  }

  public Header (Font font) {
    super (0, font);
  }

  <code-include linkend='header.methods'/>

  public void toXML (DecompilerConfig conf) {
     // never called
  }
  public void fromXML (Element cmap)
      throws InvalidFontException, UnsupportedFontException {
     // never called
  }
}
</code-fragment>

        <para>The fromBinary method has a slightly different
          signature: the header contains its own size, which is not
          generally true for the other tables.</para>

<code-fragment id='header.methods'>
  <code-title>Header.fromBinary</code-title>
  public int fromBinary (InputStream in)
      throws IOException, InvalidFontException {
    byte top[] = new byte[12];
    int curOffset = in.read (top);

    data = top;

    if (getuint32 (0) == Tag.ttcf) {
      return fromTTCBinary2 (in, 0, curOffset, top); }

    int numTables = getuint16 (4);

    data = new byte [curOffset + numTables*16];
    System.arraycopy (top, 0, data, 0, curOffset);
    int m = in.read (data, curOffset, numTables*16);

    return curOffset + m;
  }

  public int fromTTCBinary (InputStream in, int ttcIndex)
       throws IOException, InvalidFontException {

    int curOffset = 0;

    byte top[] = new byte [12];
    curOffset += in.read (top);

    data = top;

    return fromTTCBinary2 (in, ttcIndex, curOffset, top);
  }

  public int fromTTCBinary2 (InputStream in, int ttcIndex, int curOffset, byte[] top)
       throws IOException, InvalidFontException {

    long tag = getuint32 (0);
    if (tag != Tag.ttcf) {
      throw new InvalidFontException ("invalid TTCTag"); }

    long version = getuint32 (4);
    long ttcCount = getuint32 (8);
    int ttcHeaderSize = 0;

    if (version == 0x00010000) {
      ttcHeaderSize = 12 + 4 * (int)(ttcCount); }
    else if (version == 0x00020000) {
      ttcHeaderSize = 24 + 4 * (int)(ttcCount); }
    else {
      throw new InvalidFontException ("invalid TTHeader version"); }

    if (ttcIndex >= ttcCount) {
      throw new InvalidFontException ("no such font (ttcIndex=" +
                   ttcIndex + ", ttcCount=" + ttcCount + ")"); }

    data = new byte [ttcHeaderSize];
    System.arraycopy (top, 0, data, 0, 12);
    curOffset += in.read (data, 12, ttcHeaderSize - 12);

    long offsetTableOffset = getuint32 (12 + ttcIndex * 4);

    while (curOffset != offsetTableOffset) {
      curOffset += in.skip (offsetTableOffset - curOffset); }

    curOffset += fromBinary (in);

    return curOffset;
  }
</code-fragment>

        <para>Often, we will need to iterate over the tables. Here is
          a helper class to describe a table:</para>

<code-fragment id='header.methods'>
  <code-title>Helper class TableDesc</code-title>
  public class TableDesc {
    public long tag;
    public int offset;
    public int length;
  };

  public class TableDescByTag extends TableDesc implements Comparable {
    public int compareTo (Object o) {
      TableDesc td = (TableDesc) o;
      if (this.tag > td.tag) {
        return 1; }
      else if (this.tag == td.tag) {
        return 0; }
      else {
        return -1; }}
  };

  public class TableDescByOffset extends TableDesc implements Comparable {
    public int compareTo (Object o) {
      TableDesc td = (TableDesc) o;
      if (this.offset > td.offset) {
        return 1; }
      else if (this.offset == td.offset) {
        return 0; }
      else {
        return -1; }}
  };
</code-fragment>

        <para>And here is an iterator given an array of
          TableDesc:</para>

<code-fragment id='header.methods'>
  <code-title>Helper class TableIterator</code-title>
  private class TablesIterator implements Iterator {
    private TableDesc[] tds;
    private int current;

    public TablesIterator (TableDesc[] tds) {
      this.current = 0;
      this.tds = tds;
    }

    public boolean hasNext () {
      return current &lt; tds.length;
    }

    public Object next () {
      return tds [current++];
    }

    public void remove () {
    }
  };
</code-fragment>

        <para>Our first iterator returns the tables by increasing tag
          values.</para>

<code-fragment id='header.methods'>
  <code-title>Helper class TableDesc</code-title>
  public Iterator tablesByTag () {
    TableDesc[] tds = new TableDesc [getuint16 (4)];
    for (int i = 0; i &lt; tds.length; i++) {
      tds [i] = new TableDescByTag ();
      tds [i].tag    = getuint32   (12 + 16*i);
      tds [i].offset = getLOffset (12 + 16*i + 8);
      tds [i].length = getLOffset (12 + 16*i + 12); }

    java.util.Arrays.sort (tds);

    return new TablesIterator (tds);
  }

  public Iterator tablesByOffset () {
    TableDesc[] tds = new TableDesc [getuint16 (4)];
    for (int i = 0; i &lt; tds.length; i++) {
      tds [i] = new TableDescByOffset ();
      tds [i].tag    = getuint32   (12 + 16*i);
      tds [i].offset = getLOffset (12 + 16*i + 8);
      tds [i].length = getLOffset (12 + 16*i + 12); }

    java.util.Arrays.sort (tds);

    return new TablesIterator (tds);
  }
</code-fragment>





<code-fragment id='table.methods'>
  protected void warning (String msg) {
    System.out.println ("Warning: " + msg);
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

        <para>When validating a table, we want to make sure that there
          is are no "dead" pieces in it, and that we don't have
          pointers in the middle. Here are some helper methods:</para>

<code-fragment id='table.methods'>
  <code-title> </code-title>
  class Range {
    public String s;
    public int from;
    public int size;
    public boolean exclusive;

    public Range (String s, int from, int size, boolean exclusive) {
      this.s = s;
      this.from = from;
      this.size = size;
      this.exclusive = exclusive;
    }};

  private int nbRanges = 0;
  private Range[] ranges = null;

  public boolean claim (String s, int from, int size) {
    return claim (s, from, size, true);
  }

  public boolean claim (String s, int from, int size, boolean exclusive) {
    if (data.length &lt; from + size) {
      System.out.println ("cannot claim " + size + " bytes from 0x"
                          + Integer.toHexString (from) + " for " + s);
      return false; }

    if (ranges == null) {
      ranges = new Range [100]; }

    if (nbRanges == ranges.length) {
      Range[] temp = new Range [nbRanges + 100];
      System.arraycopy (ranges, 0, temp, 0, nbRanges);
      ranges = temp; }

    ranges [nbRanges++] = new Range (s, from, size, exclusive);

    return true;
  }

  public void reportError (String s) {
    System.out.println ("Error: " + s);
  }

  public void reportMistake (String s) {
    System.out.println ("Mistake: " + s);
  }

  public void reportWarning (String s) {
    System.out.println ("Warning: " + s);
  }

  public void report () {
    String[] mask = new String [data.length];
    boolean[] exclusive = new boolean [data.length];

    for (int b = 0; b &lt; mask.length; b++) {
      mask [b] = null; }

    for (int r = 0; r &lt; nbRanges; r++) {
      for (int b = ranges [r].from; b &lt; ranges [r].from + ranges [r].size; b++) {

        if (mask [b] != null) {
          if (exclusive [b] || ranges[r].exclusive) {
            System.out.println ("byte 0x" + Integer.toHexString (b)
                                + " claimed by both '"
                                + mask[b] + "' and '" + ranges[r].s); }}
        else {
          mask [b] = ranges [r].s;
          exclusive [b] = ranges [r].exclusive; }}}

    for (int b = 0; b &lt; mask.length; b++) {
      if (mask[b] == null) {
        System.out.println ("byte 0x" + Integer.toHexString (b)
                            + " not claimed"); }}
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Calculating Checksums</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Table checksums are the unsigned sum of the longs of a
        given table. In C, the following function can be used to
        determine a checksum:</para>

<literallayout>
ULONG
CalcTableChecksum(ULONG *Table, ULONG Length)
{
ULONG Sum = 0L;
ULONG *Endptr = Table+((Length+3) &amp; ~3) / sizeof(ULONG);

while (Table &lt; EndPtr)
        Sum += *Table++;
return Sum;
}
</literallayout>

        <blockquote>
          <para>Note: This function implies that the length of a table
          must be a multiple of four bytes. In fact, a font is not
          considered structurally proper without the correct padding.
          All tables must begin on four byte boundries, and any
          remaining space between tables is padded with zeros. The
          length of all tables should be recorded in the table
          directory with their actual length (not their padded
          length).</para>
        </blockquote>

        <para>To calculate the checkSum for the <ottable>head</ottable>
          table which itself includes the checkSumAdjustment entry for
          the entire font, do the following:</para>

        <orderedlist>
          <listitem>
            <para>Set the checkSumAdjustment to 0.</para>
          </listitem>
          <listitem>
            <para>Calculate the checksum for all the tables including
              the <ottable>head</ottable> table and enter that value
              into the table directory.</para>
          </listitem>
          <listitem>
            <para>Calculate the checksum for the entire font.</para>
          </listitem>
          <listitem>
            <para>Subtract that value from the hex value B1B0AFBA.</para>
          </listitem>
          <listitem>
            <para>Store the result in checkSumAdjustment.</para>
          </listitem>
        </orderedlist>

        <para>The checkSum for the head table which includes the
          checkSumAdjustment entry for the entire font is now
          incorrect. That is not a problem. Do not change it. An
          application attempting to verify that the <ottable>head</ottable> table has
          not changed should calculate the checkSum for that table by
          not including the checkSumAdjustment value, and compare the
          result with the entry in the table directory.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Here is a method to compile the checksum of a byte
          sequence:</para>

<code-fragment id='font.methods'>
  <code-title>Checksum method</code-title>
  private long checksum (byte[] data) {
    long checksum = 0;
    int i = 0;
    while (i &lt; data.length) {
      int b1 = data [i++] &amp; 0xff;

      int b2 = 0;
      if (i &lt; data.length) {
        b2 = data [i++] &amp; 0xff; }

      int b3 = 0;
      if (i &lt; data.length) {
        b3 = data [i++] &amp; 0xff; }

      int b4 = 0;
      if (i &lt; data.length) {
        b4 = data [i++] &amp; 0xff; }

      int word = b1 &lt;&lt; 24 | b2 &lt;&lt;16 | b3 &lt;&lt; 8 | b4;
      checksum = (checksum + word) &amp; 0xffffffffL; }

    return checksum;
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>TrueType Collections</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A TrueType Collection (TTC) is a means of delivering
        multiple OpenType fonts in a single file structure. TrueType
        Collections are most useful when the fonts to be delivered
        together share many glyphs in common. By allowing multiple
        fonts to share glyph sets, TTCs can result in a significant
        saving of file space.</para>

        <para>For example, a group of Japanese fonts may each have
        their own designs for the kana glyphs, but share identical
        designs for the kanji. With ordinary OpenType font files, the
        only way to include the common kanji glyphs is to copy their
        glyph data into each font. Since the kanji represent much more
        data than the kana, this results in a great deal of wasteful
        duplication of glyph data. TTCs were defined to solve this
        problem.</para>

        <para>The CFF rasterizer does not currently support TTC
        files.</para>

      </section>
    </section>


    <!--======================================================================-->
    <section role='fragment'>
      <title>The TTC File Structure</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A TrueType Collection file consists of a single TTC
	  Header table, one or more Offset Tables with Table
	  Directories, and a number of OpenType tables. The TTC Header
	  must be located at the beginning of the TTC file.</para>

        <para>Each OpenType table in a TTC file is referenced through
	  the Offset Table and Table Directories of each font which
	  uses that table. Some of the OpenType tables must appear multiple
	  times, once for each font included in the TTC; while other
	  tables should be shared by multiple fonts in the TTC.</para>

        <para>As an example, consider a TTC file which combines two
          Japanese fonts (Font1 and Font2). The fonts have different
          kana designs (Kana1 and Kana2) but use the same design for
          kanji. The TTC file contains a single
          <ottable>glyf</ottable> table which includes both designs of
          kana together with the kanji; both fonts' Table Directories
          point to this <ottable>glyf</ottable> table. But each font's
          Table Directory points to a different
          <ottable>cmap</ottable> table, which identifies the glyph
          set to use. Font1's <ottable>cmap</ottable> table points to
          the Kana1 region of the <ottable>loca</ottable> and
          <ottable>glyf</ottable> tables for kana glyphs, and to the
          kanji region for the kanji. Font2's <ottable>cmap</ottable>
          table points to the Kana2 region of the
          <ottable>loca</ottable> and <ottable>glyf</ottable> tables
          for kana glyphs, and to the same kanji region for the
          kanji.</para>

        <para>The tables that should have a unique copy per font are
          those that are used by the system in identifying the font
          and its character mapping, including
          <ottable>cmap</ottable>, <ottable>name</ottable>, and
          <ottable>OS/2</ottable>. The tables that should be shared by
          fonts in the TTC are those that define glyph and instruction
          data or use glyph indices to access data:
          <ottable>glyf</ottable>, <ottable>loca</ottable>,
          <ottable>hmtx</ottable>, <ottable>hdmx</ottable>,
          <ottable>LTSH</ottable>, <ottable>cvt </ottable>,
          <ottable>fpgm</ottable>, <ottable>prep</ottable>,
          <ottable>EBLC</ottable>, <ottable>EBDT</ottable>,
          <ottable>EBSC</ottable>, <ottable>maxp</ottable>, and so
          on. In practice, any tables which have identical data for
          two or more fonts may be shared.</para>

        <para>A tool is available from Microsoft to help build .TTC
          files. The process involves paying close attention the issue
          of glyph renumbering in a font and the side effects that can
          result, in the <ottable>cmap</ottable> table and elsewhere.
          The fonts to be merged must also have compatible TrueType
          instructions-that is, their preprograms, function
          definitions, and control values must not conflict.</para>

        <para>TrueType Collection files use the filename suffix
        .TTC.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>TTC Header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>There are two versions of the TTC Header: Version 1.0
        has been used for TTC files without digital
        signatures. Version 2.0 can be used for TTC files with or
        without digital signatures &#x2019; if there's no signature, then
        the last three fields of the version 2.0 header are left
        null</para>

        <para>If a digital signature is used, the DSIG table for the
        file must be the last table in the TTC file. Signatures in a
        TTC file are expected to be Format 1 signatures</para>

        <para>The purpose of the TTC Header table is to locate the
        different Offset Tables within a TTC file. The TTC Header
        is located at the beginning of the TTC file (offset = 0). It
        consists of an identification tag, a version number, a count
        of the number of OpenType fonts (Table Directories) in the
        file, and an array of offsets to each Offset Table.</para>

        <otformat>
          <title>TTC Header Version 1.0</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>TAG</otfieldtype>
            <otfieldname>TTCTag</otfieldname>
            <otfielddesc>TrueType Collection ID string:
              'ttcf'</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the TTC Header (1.0),
              0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numFonts</otfieldname>
            <otfielddesc>Number of fonts in the TTC</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>OffsetTable [numFonts]</otfieldname>
            <otfielddesc>Array of offsets to Offset Table for each
	      font from the beginning of the file</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulDsigTag</otfieldname>
            <otfielddesc>Tag indicating that a DSIG table exists. This
              tag should equal 0x44534947 (<ottable>DSIG</ottable>)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulDsigLength</otfieldname>
            <otfielddesc>The length (in bytes) of the DSIG
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulDsigOffset</otfieldname>
            <otfielddesc>The offset (in bytes) of the DSIG table from
              the beginning of the TTC file</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>TTC Header Version 2.0</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>TAG</otfieldtype>
            <otfieldname>TTCTag</otfieldname>
            <otfielddesc>TrueType Collection ID string:
              'ttcf'</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the TTC Header (2.0),
              0x00020000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numFonts</otfieldname>
            <otfielddesc>Number of fonts in TTC</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
	    <otfieldname>OffsetTable [numFonts]</otfieldname>
	    <otfielddesc>Array of offsets to Offset Table for each
	      font from the beginning of the file</otfielddesc>
          </otfield>

          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulDsigTag</otfieldname> <otfielddesc>Tag
            indicating that a DSIG table exists, 0x44534947
            (<ottable>DSIG</ottable>) (null if no
            signature)</otfielddesc>
          </otfield>

          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulDsigLength</otfieldname>
            <otfielddesc>The length (in bytes) of the DSIG table (null
              if no signature)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulDsigOffset</otfieldname>
            <otfielddesc>The offset (in bytes) of the DSIG table from
              the beginning of the TTC file (null if no
              signature)</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The type of the TTCTag field in both format should
          probably be 'Tag' instead of 'TAG'.</para>

        <para>The value of the Version field in both tables seems to
          be wrong; it's missing a 0 at the end.</para>

        <para>The description of the difference between version 1.0
          and version 2.0 seems to contradict the content of the
          version 1.0 table. If a version 1.0 table is for files
          without a digital signature, what is the meaning of the
          fields ulDsigTag, ulDsigLength and ulDsigOffset?</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Font Tables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>  The rasterizer has a much easier time traversing
        tables if they are padded so that each table begins on a
        4-byte boundary. It is highly recommended that all tables be
        long-aligned and padded with zeroes.</para>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.opentype_tables'>
    <title>OpenType Tables</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>OpenType Tables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Whether TrueType or PostScript outlines are used in an
        OpenType font, the following tables are required for the font
        to function correctly:</para>

        <table>
          <title>Required Tables</title>
          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ottable>cmap</ottable></entry>
                <entry>Character to glyph mapping</entry>
              </row>
              <row>
                <entry><ottable>head</ottable></entry>
                <entry>Font header</entry>
              </row>
              <row>
                <entry><ottable>hhea</ottable></entry>
                <entry>Horizontal header</entry>
              </row>
              <row>
                <entry><ottable>hmtx</ottable></entry>
                <entry>Horizontal metrics</entry>
              </row>
              <row>
                <entry><ottable>maxp</ottable></entry>
                <entry>Maximum profile</entry>
              </row>
              <row>
                <entry><ottable>name</ottable></entry>
                <entry>Naming table</entry>
              </row>
              <row>
                <entry><ottable>OS/2</ottable></entry>
                <entry>OS/2 and Windows specific metrics</entry>
              </row>
              <row>
                <entry><ottable>post</ottable></entry>
                <entry>PostScript information</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>For OpenType fonts based on TrueType outlines, the
        following tables are used:</para>


        <table>
          <title>Tables Related to TrueType Outlines</title>
          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ottable>cvt</ottable></entry>
                <entry>Control Value Table</entry>
              </row>
              <row>
                <entry><ottable>fpgm</ottable></entry>
                <entry>Font program</entry>
              </row>
              <row>
                <entry><ottable>glyf</ottable></entry>
                <entry>Glyph data</entry>
              </row>
              <row>
                <entry><ottable>loca</ottable></entry>
                <entry>Index to location</entry>
              </row>
              <row>
                <entry><ottable>prep</ottable></entry>
                <entry>CVT Program</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <para>The PostScript font extensions define a new set of
        tables containing data specific to PostScript fonts that are
        used instead of the tables listed above.</para>


        <table>
          <title>Tables Related to PostScript Outlines</title>
          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ottable>CFF</ottable></entry>
                <entry>PostScript font program (compact font format)</entry>
              </row>
              <row>
                <entry><ottable>VORG</ottable></entry>
                <entry>Vertical Origin</entry>
              </row>
            </tbody>
          </tgroup>
        </table>




        <para>Multiple Master support in OpenType, has been
          discontinued as of version 1.3 of the specification. The
          'fvar', 'MMSD', 'MMFX' tables have hence been
          removed.</para>


        <para>There are also several optional tables that support
        vertical layout as well as other advanced typographic
        functions:</para>

        <table>
          <title>Advanced Typographic Tables</title>
          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ottable>BASE</ottable></entry>
                <entry>Baseline data</entry>
              </row>
              <row>
                <entry><ottable>GDEF</ottable></entry>
                <entry> Glyph definition data</entry>
              </row>
              <row>
                <entry><ottable>GPOS</ottable></entry>
                <entry> Glyph positioning data</entry>
              </row>
              <row>
                <entry><ottable>GSUB</ottable></entry>
                <entry> Glyph substitution data</entry>
              </row>
              <row>
                <entry><ottable>JSTF</ottable></entry>
                <entry> Justification data</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>For information on common table formats, please see
          <link linkend="common_tables">OpenType Layout Common Table
            Formats</link>.</para>

        <para>OpenType fonts may also contain bitmaps of glyphs, in
          addition to outlines. Hand-tuned bitmaps are especially
          useful in OpenType fonts for representing complex glyphs at
          very small sizes. If a bitmap for a particular size is
          provided in a font, it will be used by the system instead of
          the outline when rendering the glyph. (Note: ATM does not
          currently support hinted bitmaps in OpenType fonts.)</para>

        <table>
          <title>Tables Related to Bitmap Glyphs</title>
          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ottable>EBDT</ottable></entry>
                <entry>Embedded bitmap data</entry>
              </row>
              <row>
                <entry><ottable>EBLC</ottable></entry>
                <entry>Embedded bitmap location data</entry>
              </row>
              <row>
                <entry><ottable>EBSC</ottable></entry>
                <entry>Embedded bitmap scaling data</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <table>
          <title>Other OpenType Tables</title>

          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Tag</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><ottable>DSIG</ottable></entry>
                <entry>Digital signature</entry>
              </row>
              <row>
                <entry><ottable>gasp</ottable></entry>
                <entry>Grid-fitting/Scan-conversion</entry>
              </row>
              <row>
                <entry><ottable>hdmx</ottable></entry>
                <entry>Horizontal device metrics</entry>
              </row>
              <row>
                <entry><ottable>kern</ottable></entry>
                <entry>Kerning</entry>
              </row>
              <row>
                <entry><ottable>LTSH</ottable></entry>
                <entry>Linear threshold data</entry>
              </row>
              <row>
                <entry><ottable>PCLT</ottable></entry>
                <entry>PCL 5 data</entry>
              </row>
              <row>
                <entry><ottable>VDMX</ottable></entry>
                <entry>Vertical device metrics</entry>
              </row>
              <row>
                <entry><ottable>vhea</ottable></entry>
                <entry>Vertical Metrics header</entry>
              </row>
              <row>
                <entry><ottable>vmtx</ottable></entry>
                <entry>Vertical Metrics</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The sentence that introduces the tables related to
        PostScript outlines should probably be better phrased: "For
        OpenType fonts based on PostScript outlines, the following
        tables are used:" It parallels the sentence for TT outlines.</para>

        <para>The sentence that points to the "OpenType Layout Common
        Table Formats" should probably be moved to the paragraph that
        introduces the Advanced Typographic Tables. Currently, it is
        between the paragraph that introduces bitmap related tables
        and the list of those tables.</para>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.cmap'>
    <title>cmap - Character to Glyph Index Mapping Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table defines the mapping of character codes to the
          glyph index values used in the font. It may contain more
          than one subtable, in order to support more than one
          character encoding scheme. Character codes that do not
          correspond to any glyph in the font should be mapped to
          glyph index 0. The glyph at this location must be a special
          glyph representing a missing character, commonly known as
          .notdef.</para>

        <para>The table header indicates the character encodings for
          which subtables are present. Each subtable is in one of seven
          possible formats and begins with a format code indicating
          the format used.</para>

        <para>The platform ID and platform-specific encoding ID in the
          header entry (and, in the case of the Macintosh platform,
          the language field in the subtable itself) are used to
          specify a particular <ottable>cmap</ottable>
          encoding.The header entries must be sorted first by platform
          ID, then by platform-specific encoding ID, and then by the
          version field in the corresponding subtable. Each platform
          ID, platform-specific encoding ID, and subtable language
          combination may appear only once in the
          <ottable>cmap</ottable> table.</para>

        <para>When building a Unicode font for Windows, the platform
          ID should be 3 and the encoding ID should be 1. When
          building a symbol font for Windows, the platform ID should
          be 3 and the encoding ID should be 0. When building a font
          that will be used on the Macintosh, the platform ID should
          be 1 and the encoding ID should be 0.</para>

        <para>All Microsoft Unicode encodings (Platform ID = 3,
          Encoding ID = 1) must provide at least a Format 4
          <ottable>cmap</ottable> subtable. If the font is meant to
          support supplementary Unicode characters, it will additionally
          need a Format 12 subtable with a platform encoding ID 10.
          The contents of the Format 12 subtable need to be a superset
          of the contents of the Format 4 subtable. Microsoft
          <emphasis>strongly</emphasis> recommends using a Unicode
          <ottable>cmap</ottable> for all fonts. However, some other
          encodings that appear in current fonts follow:</para>

        <table>
	  <title>Microsoft Encodings</title>
          <tgroup cols='3'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="10pc"/>
            <colspec colwidth="10pc"/>
            <thead>
              <row>
                <entry>Platform ID</entry>
                <entry>Encoding ID</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>3</entry>
                <entry>0</entry>
                <entry>Symbol</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>1</entry>
                <entry>Unicode</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>2</entry>
                <entry>ShiftJIS</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>3</entry>
                <entry>PRC</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>4</entry>
                <entry>Big5</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>5</entry>
                <entry>Wansung</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>6</entry>
                <entry>Johab</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>7</entry>
                <entry>Reserved</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>9</entry>
                <entry>Reserved</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>9</entry>
                <entry>Reserved</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>10</entry>
                <entry>UCS-4</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Unicode Variation Sequences supported by the font may be
        specified in the cmap table under platform ID 0 and encoding
        ID 5, using a format 14 cmap subtable.</para>

        <para>The Character To Glyph Index Mapping Table is organized
          as follows:</para>

        <otformat>
	  <title>cmap Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Table version number (0).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numTables</otfieldname>
            <otfielddesc>Number of encoding tables that follow.</otfielddesc>
          </otfield>
        </otformat>

        <para>The cmap table header is followed by an array of
	  encoding records that specify the particular encoding and
	  the offset to the subtable for that encoding. The number of
	  encoding records is numTables. An encoding record entry
	  looks like:</para>

        <otformat>
	  <title>Encoding Record</title>
          <otfield>
            <otfieldoffs>4+8i</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>platformID</otfieldname>
            <otfielddesc>Platform ID.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+8i+2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>encodingID</otfieldname>
            <otfielddesc>Platform-specific encoding ID.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+8i+4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>offset</otfieldname>
            <otfielddesc>Byte offset from beginning of table to the
                  subtable for this encoding.</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The first paragraph covers three cases of missing
          glyphs: (1) there is a cmap subtable for the encoding but
          the character code is not covered by the subtable; (2) there
          is no subtable for the encoding; (3) there is a cmap for the
          encoding, but the format of that subtable is not 0, 2, 4 or
          6, 8, 10, or 12 (the currently defined formats). It is quite
          clear that the described behaviour applies to the first
          case, but it is not clear that this is the mandated
          behaviour in the second or third case. We assume it is.
          Recommendation: make that clear, by rephrasing: "Character
          codes that do not correspond to any glyph in the font
          (either because there is no subtable for their encoding or
          or because the subtable in a format not supported by the
          application or because the subtable does not map them)
          should be mapped to glyph index 0."</para>

        <para>The case of unknown formats is a bit more complicated.
          The recommendation is to mandate that all characters codes
          should map to glyph 0 for subtables in unknown
          formats.</para>

        <para>The descriptions of the fields of this table do not include
          names for them, as most other tables do. The recommendation
          is to include them: version, numTables, platformID,
          encodingID, offset.</para>

        <para>In the fifth paragraph, "UCS-4 (surrogate) characters"
          should be replaced by "Unicode supplemental characters" or
          "Unicode supplemental (non-BMP) characters". BMP characters are also
          UCS-4 characters. And anyways, UCS-4 is an encoding, not a
          character collection.</para>

        <para>It is legal to have a single subtable which is referenced
          from multiple entries? This is useful when a given character
          encoding is present on multiple platforms. For example, if
          there is a Unicode cmap subtable, it can be referenced from
          one entry with platformID/encodingID (0, 3), and from
          another entry with (3, 1).</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>A cmap table is represented by a <sgmltag>cmap</sgmltag>
	element, with each entry represented by a
	<sgmltag>mapping</sgmltag> element. Each cmap subtalble will
	contribute a bunch of attributes and elements. As usual, those
	can be attached directly to the <sgmltag>mapping</sgmltag>
	element, or they can be attached to a
	<sgmltag>cmapsubtable</sgmltag> element. In the latter case,
	the <sgmltag>mapping</sgmltag> element carries an IDREF
	<sgmltag>name</sgmltag> attribute, and the
	<sgmltag>cmapsubtable</sgmltag> carries a corresponding ID
	<sgmltag>id</sgmltag> attribute. This mechanism is useful,
	e.g. when a cmapsutable is listed under both Microsoft/Unicode
	BMP (3/1) and Unicode/BMP (1/0).</para>

	<para>We pull the language field of each cmap subtable in the
	<sgmltag>mapping</sgmltag> entry, as it logically belongs
	there. However, this creates a validity constraint: if a
	<sgmltag>cmapsubtable</sgmltag> is referenced from multiple
	entries, then all those entries must have the same
	<sgmltag>language</sgmltag>.</para>

	<para>When we do not care about the format of a cmap subtable,
	we set the <sgmltag>format</sgmltag> attribute to
	<sgmltag>any</sgmltag> and simply list the code point to glyph
	correspondance.</para>

	<para>Each cmap subtable format is also dual: it can either be
	expressed (mostly) as a bunch of mappings, or it can be
	precise, recording all the details specific to the format. We
	need this flexibility, because many font consumers impose that
	the subtable for a given platform/encoding be in a specific
	format, yet we want to describe the mappings simply.</para>

<code-fragment id='schema'>
  <code-title>cmap table</code-title>
  cmap =
    element cmap {
      attribute version { "0" },
      element mapping {
        attribute platformid { text },
        attribute encodingid { text },
        attribute language { text },
        cmapsubtableOffset }*,

      standaloneCmapsubtable*
    }

  standaloneCmapsubtable =
    element cmapsubtable { attribute id { text }, cmapsubtable }

  cmapsubtableOffset = attribute name { text } | cmapsubtable

  cmapsubtable |=
    attribute format { "any" },
    element map {
      attribute code { text },
      attribute glyph { text }}*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  public void fromXML (Element cmap)
      throws InvalidFontException, UnsupportedFontException {

    int version = Integer.parseInt (cmap.getAttribute ("version"));
    if (version != 0) {
      throw new UnsupportedFontException ( "invalid cmap version: " + version); }

    NodeList cmaps = cmap.getChildNodes ();

    int cmapsCount = 0;

    for (int i = 0; i &lt; cmaps.getLength (); i++) {
      Element e = (Element) cmaps.item (i);
      if ("mapping".equals (e.getTagName ())) {
        cmapsCount++; }}

    Block[] cmapsSubtables = new Block [cmapsCount];
    int[] platformids = new int [cmapsCount];
    int[] encodingids = new int [cmapsCount];
    int[] languages = new int [cmapsCount];
    int format;

    for (int i = 0; i &lt; cmapsCount; i++) {
      Element cmaptable = (Element) cmaps.item (i);
      platformids [i] = Integer.parseInt (cmaptable.getAttribute ("platformid"));
      encodingids [i] = Integer.parseInt (cmaptable.getAttribute ("encodingid"));
      languages [i]   = Integer.parseInt (cmaptable.getAttribute ("language"));

      { String name = cmaptable.getAttribute ("name");
        if (name != null &amp;&amp; ! "".equals (name)) {
          cmaptable = resolveXMLid (cmap, name); }}

      format = Integer.parseInt (cmaptable.getAttribute ("format"));
      cmapsSubtables [i] = null;

      if (format == 0) {
        cmapsSubtables [i] = format0FromXML (cmaptable, languages [i]); }
      else if (format == 2) {
        cmapsSubtables [i] = format2FromXML (cmaptable, languages [i]); }
      else if (format == 4) {
        cmapsSubtables [i] = format4FromXML (cmaptable, languages [i]); }
      else if (format == 6) {
        cmapsSubtables [i] = format6FromXML (cmaptable, languages [i]); }
      else if (format == 8) {
        cmapsSubtables [i] = format8FromXML (cmaptable, languages [i]); }
      else if (format == 10) {
        cmapsSubtables [i] = format10FromXML (cmaptable, languages [i]); }
      else if (format == 12) {
        cmapsSubtables [i] = format12FromXML (cmaptable, languages [i]); }
      else if (format == 14) {
        cmapsSubtables [i] = format14FromXML (cmaptable, languages [i]); }}


    for (int i = 0; i &lt; cmapsCount; i++) {
      for (int j = i + 1; j &lt; cmapsCount; j++) {
        boolean swap = false;
        if (platformids [i] > platformids [j]) {
          swap = true; }
        else if (platformids [i] == platformids [j]) {
          if (encodingids [i] > encodingids [j]) {
            swap = true; }
          else if (encodingids [i] == encodingids [j]) {
            if (languages [i] > languages [j]) {
              swap = true; }}}

        if (swap) {
          { int tmp = platformids [j];
            platformids [j] = platformids [i];
            platformids [i] = tmp; }

          { int tmp = encodingids [j];
            encodingids [j] = encodingids [i];
            encodingids [i] = tmp; }

          { int tmp = languages [j];
            languages [j] = languages [i];
            languages [i] = tmp; }

          { Block tmp = cmapsSubtables [j];
            cmapsSubtables [j] = cmapsSubtables [i];
            cmapsSubtables [i] = tmp; }}}}


    int size = 4 + cmapsCount * 8;
    Block me = new Block (size, cmapsCount);
    me.setuint16 (0, version);
    me.setuint16 (2, cmapsCount);

    int offset = 4;
    for (int i = 0; i &lt; cmapsCount; i++) {
      me.setuint16 (offset, platformids [i]);
      me.setuint16 (offset+2, encodingids [i]);
      me.setBigOffset (offset + 4, cmapsSubtables [i]);
      offset += 8; }

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.methods'>
  <code-title>Decompile a cmap table</code-title>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, UnsupportedFontException, InvalidFontException {

    AttributesImpl at;

    at = new AttributesImpl ();
    at.addAttribute ("", "version", "version", "CDATA", "" + getuint16 (0));
    conf.ch.startElement ("cmap", at); {

      int[] counts = new int [data.length];
      for (int o = 0; o &lt; counts.length; o++) {
        counts [o] = 0; }

      for (int st = 0; st &lt; getuint16 (2); st++) {
        int stOffset = getLOffset (4 + 8*st + 4);
	counts [stOffset]++; }

      if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
        for (int i = 0; i &lt; counts.length; i++) {
          counts [i] = 1; }}
      if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
        for (int i = 0; i &lt; counts.length; i++) {
          counts [i] = 2; }}

      for (int st = 0; st &lt; getuint16 (2); st++) {
        at = new AttributesImpl ();
        int stOffset = getLOffset (4 + 8*st + 4);

	int platformID = getuint16 (4 + 8*st);
        int encodingID = getuint16 (4 + 8*st + 2);

        at.addAttribute ("", "platformid", "platformid", "CDATA",
                         "" + platformID);
        at.addAttribute ("", "encodingid", "encodingid", "CDATA",
                         "" + encodingID);
        at.addAttribute ("", "language", "language", "CDATA",
                         "" + getuint16 (stOffset + 4));

        if (counts [stOffset] != 1) {
          at.addAttribute ("", "name", "name", "CDATA",
	                   "cmapsubtable_" + Integer.toHexString (stOffset));
          conf.ch.element ("mapping", at); }

        else {
          oneSubtableToXML (conf, counts, stOffset, platformID, encodingID,
                            "mapping", at); }}

      for (int st = 0; st &lt; getuint16 (2); st++) {
        int stOffset = getLOffset (4 + 8*st + 4);
	int platformID = getuint16 (4 + 8*st);
        int encodingID = getuint16 (4 + 8*st + 2);
        if (counts [stOffset] != 1) {
	  at = new AttributesImpl ();
	  at.addAttribute ("", "id", "id", "CDATA",
	                   "cmapsubtable_" + Integer.toHexString (stOffset));
          oneSubtableToXML (conf, counts, stOffset, platformID, encodingID,
                            "cmapsubtable", at);
          counts [stOffset] = 1; }}

      conf.ch.endElement ("cmap"); }
  }

  void oneSubtableToXML (DecompilerConfig conf, int[] counts, int stOffset,
                         int platformID, int encodingID,
                         String element, AttributesImpl at)
      throws org.xml.sax.SAXException, UnsupportedFontException, InvalidFontException {

    int format = getuint16 (stOffset);
    at.addAttribute ("", "format", "format", "CDATA", "" + format);

    switch (format) {
      case 0: { <code-include linkend='cmap.decompile.format0.att'/>; break; }
      case 2: { <code-include linkend='cmap.decompile.format2.att'/>; break; }
      case 4: { <code-include linkend='cmap.decompile.format4.att'/>; break; }
      case 6: { <code-include linkend='cmap.decompile.format6.att'/>; break; }
      case 8: { <code-include linkend='cmap.decompile.format8.att'/>; break; }
      case 10: { <code-include linkend='cmap.decompile.format10.att'/>; break; }
      case 12: { <code-include linkend='cmap.decompile.format12.att'/>; break; }
      case 14: { <code-include linkend='cmap.decompile.format14.att'/>; break; }
      default: { break; }}

     conf.ch.startElement (element, at); {

      switch (format) {
        case 0: { <code-include linkend='cmap.decompile.format0.elt'/>; break; }
        case 2: { <code-include linkend='cmap.decompile.format2.elt'/>; break; }
        case 4: { <code-include linkend='cmap.decompile.format4.elt'/>; break; }
        case 6: { <code-include linkend='cmap.decompile.format6.elt'/>; break; }
        case 8: { <code-include linkend='cmap.decompile.format8.elt'/>; break; }
        case 10: { <code-include linkend='cmap.decompile.format10.elt'/>; break; }
        case 12: { <code-include linkend='cmap.decompile.format12.elt'/>; break; }
        case 14: { <code-include linkend='cmap.decompile.format14.elt'/>; break; }
        default: { break; }}

      if (! conf.preciseCmap) {
        SortedMap&lt;Integer, Integer> m = getMap (platformID, encodingID);

        if (m != null) {
          for (int c : m.keySet ()) {
            int g = m.get (c);
            at = new AttributesImpl ();
            at.addAttribute ("", "code", "code", "CDATA",
                             "0x" + Integer.toHexString (c));
            at.addAttribute ("", "glyph", "glyph", "CDATA", glyphToXML (conf, g));
            conf.ch.element ("map", at); }}}

       conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Here is the class representing a <ottable>cmap</ottable>
          table.</para>

<code-fragment package='com.adobe.aots.opentype' class='Cmap'>
  <code-title>Cmap class</code-title>

package com.adobe.aots.opentype;

import java.util.Iterator;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.Arrays;
import java.util.Vector;

import java.net.URL;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Cmap extends Table {

  public Cmap () {
    super (Tag.cmap, null);
  }

  public Cmap (Font font) {
    super (Tag.cmap, font);
  }

  <code-include linkend='cmap.methods'/>
}
</code-fragment>

        <para>Here is a helper class to represent cmap selection:</para>

<code-fragment id='cmap.methods'>
  <code-title>Index class</code-title>
static public class Index implements Comparable {
  int platformID;
  int encodingID;
  int language;

  public Index (int platformID, int encodingID) {
    this.platformID = platformID;
    this.encodingID = encodingID;
  }

  public Index (int platformID, int encodingID, int language) {
    this.platformID = platformID;
    this.encodingID = encodingID;
    this.language = language;
  }

  public int compareTo (Object o) {
    Index index = (Index) o;

    if (this.platformID &lt; index.platformID) {
      return -1; }
    if (this.platformID > index.platformID) {
      return 1; }

    if (this.encodingID &lt; index.platformID) {
      return -1; }
    if (this.encodingID > index.encodingID) {
      return 1; }

    if (this.platformID == 1) {
      if (this.language &lt; index.language) {
        return -1; }
      if (this.language > index.language) {
        return 1; }}

    return 0;
  }
}

static public Index WinUnicode1 = new Index (3, 1);
static public Index WinUnicode10 = new Index (3, 10);
</code-fragment>


        <para>Our internal representation decomposes a cmap in its
        subtables:</para>

<!--code-fragment id='cmap.methods'>
  private java.util.Map subtables;

  public int fromBinary (InputStream in, int length)
      throws IOException, InvalidFontException {

    byte[] head = new byte[4];
</code-fragment-->

        <para>The basic operation on a cmap is to find a glyph given a
          platformID, encodingID and character code.</para>

        <para>As noted earlier, a subtable can be in a number of
          formats. We need to go a little bit ahead of the
          specification and note that the first USHORT of a subtable
          is that format.</para>

<code-fragment id='cmap.methods'>
  <code-title>Character to Glyph Method</code-title>
  public int char2glyph (int platformID, int encodingID, int charCode)
     throws UnsupportedFontException {

    int numTables = getuint16 (2);

    for (int st = 0; st &lt; numTables; st++) {
      if (   platformID == getuint16 (4 + 8*st)
          &amp;&amp; encodingID == getuint16 (4 + 8*st + 2)) {
        int stOffset = getLOffset (4 + 8*st + 4);
        int format = getuint16 (stOffset);
        switch (format) {
          case 0: { <code-include linkend='cmap_format0'/> }
          case 2: { <code-include linkend='cmap_format2'/> }
          case 4: { <code-include linkend='cmap_format4'/> }
          case 6: { <code-include linkend='cmap_format6'/> }
          case 8: { <code-include linkend='cmap_format8'/> }
          case 10: { <code-include linkend='cmap_format10'/> }
          case 12: { <code-include linkend='cmap_format12'/> }
          default: return 0; }}}

    return 0;
  }

  public int unicodechar2glyph (int charCode) throws UnsupportedFontException {

    int numTables = getuint16 (2);
    int encodingID = 1;

    for (int st = 0; st &lt; numTables; st++) {
      if (getuint16 (4 + 8*st) == 3 &amp;&amp; getuint16 (4 + 8*st + 2) == 10) {
        encodingID = 10; }}

    return char2glyph (3, encodingID, charCode);
  }
</code-fragment>

<code-fragment id='cmap.methods'>
  <code-title>map generator</code-title>
  public java.util.SortedMap&lt;Integer, Integer> getMap (int platformID, int encodingID)
      throws UnsupportedFontException {
    return getMap (platformID, encodingID, 0, 0x7fffffff);
  }

  public java.util.SortedMap&lt;Integer, Integer>
           getMap (int platformID, int encodingID, int from, int to)
      throws UnsupportedFontException {

    int numTables = getuint16 (2);

    for (int st = 0; st &lt; numTables; st++) {
      if (   platformID == getuint16 (4 + 8*st)
          &amp;&amp; encodingID == getuint16 (4 + 8*st + 2)) {
        int stOffset = getLOffset (4 + 8*st + 4);
        int format = getuint16 (stOffset);
        switch (format) {
          case 0: { <code-include linkend='cmap_format0_iterator'/>}
          case 2: { <code-include linkend='cmap_format2_iterator'/>}
          case 4: { <code-include linkend='cmap_format4_iterator'/>}
          case 6: { <code-include linkend='cmap_format6_iterator'/>}
          case 8: { <code-include linkend='cmap_format8_iterator'/>}
          case 10: { <code-include linkend='cmap_format10_iterator'/>}
          case 12: { <code-include linkend='cmap_format12_iterator'/>}
          default: return null; }}}

    return null;
  }
</code-fragment>

        <para>Once we know how to convert a single character, it's
          easy to convert a bunch of them:</para>

<code-fragment id='cmap.methods'>
  <code-title>Characters to Glyphs Method</code-title>
  public int[] char2glyph (int platformID, int encodingID, int[] charCodes)
      throws UnsupportedFontException {
    int[] glyphIDs = new int [charCodes.length];
    for (int i = 0; i &lt; charCodes.length; i++) {
      glyphIDs [i] = char2glyph (platformID, encodingID, charCodes [i]); }
    return glyphIDs;
  }
</code-fragment>

        <para>The inverse transformation, i.e. to find a character
          which maps to a given glyphID, is also possible. It can be
          that there is no character that maps the glyphID (in which
          case we return the special value -1), and it can be that
          there are multiple characters that map to the glyphID (in
          which case we return one of them).</para>

        <para>The main reason to expose this functionality is that not
          all software systems permit the access to glyphs in a font
          through glyphIDs; for example, SVG supports the
          specification of glyphs by their ids, but Adobe's SVG Viewer
          1.0 does not implement that. In such a case, the renderer
          has to be presented with characters, hence this
          functionality. Some font vendors (e.g. Adobe) also construct
          their fonts such that every glyph is mapped from the Unicode
          cmap, precisely to allow this scheme to work.</para>

<code-fragment id='cmap.methods'>
  <code-title>Glyph to Character Method</code-title>
  public int glyph2char (int platformID, int encodingID, int glyphID)
      throws UnsupportedFontException {

    int numTables = getuint16 (2);

    for (int st = 0; st &lt; numTables; st++) {
      if (   platformID == getuint16 (4 + 8*st)
          &amp;&amp; encodingID == getuint16 (4 + 8*st + 2)) {
        int stOffset = getLOffset (4 + 8*st + 4);

        int format = getuint16 (stOffset);
        switch (format) {
          case  0: { <code-include linkend='cmap_format0_inv'/>}
          case  2: { <code-include linkend='cmap_format2_inv'/>}
          case  4: { <code-include linkend='cmap_format4_inv'/>}
          case  6: { <code-include linkend='cmap_format6_inv'/>}
          case  8: { <code-include linkend='cmap_format8_inv'/>}
          case 10: { <code-include linkend='cmap_format10_inv'/>}
          case 12: { <code-include linkend='cmap_format12_inv'/>}}}}
    return -1;
  }

  public int glyph2unicodechar (int glyphID) throws UnsupportedFontException {

    int numTables = getuint16 (2);
    int encodingID = 1;

    for (int st = 0; st &lt; numTables; st++) {
      if (getuint16 (4 + 8*st) == 3 &amp;&amp; getuint16 (4 + 8*st + 2) == 10) {
        encodingID = 10; }}

    return glyph2char (3, encodingID, glyphID);
  }
</code-fragment>

        <para>Again, it's easy to handle a bunch of glyphs:</para>

<code-fragment id='cmap.methods'>
  <code-title>Glyphs to Characters Method</code-title>
  public int [] glyph2char (int platformID, int encodingID, int[] glyphIDs)
       throws UnsupportedFontException {
    int[] charCodes = new int [glyphIDs.length];
    for (int i = 0; i &lt; glyphIDs.length; i++) {
      charCodes [i] = glyph2char (platformID, encodingID, glyphIDs [i]); }
    return charCodes;
  }
</code-fragment>

	<para>Here is another version that returns all the characters
	  that map to a given glyphID:</para>

<code-fragment id='cmap.methods'>
  <code-title>Glyph to Characters Method</code-title>
  public int[] glyph2chars (int platformID, int encodingID, int glyphID) {

    java.util.Vector&lt;Integer> v = new java.util.Vector&lt;Integer> ();

    int numTables = getuint16 (2);

    for (int st = 0; st &lt; numTables; st++) {
      if (   platformID == getuint16 (4 + 8*st)
          &amp;&amp; encodingID == getuint16 (4 + 8*st + 2)) {
        int stOffset = getLOffset (4 + 8*st + 4);

        int format = getuint16 (stOffset);

        switch (format) {
          case  0: { <code-include linkend='cmap_format0_inv2'/>; break;}
          case  2: { <code-include linkend='cmap_format2_inv2'/>; break;}
          case  4: { <code-include linkend='cmap_format4_inv2'/>; break;}
          case  6: { <code-include linkend='cmap_format6_inv2'/>; break;}
          case  8: { <code-include linkend='cmap_format8_inv2'/>; break;}
          case 10: { <code-include linkend='cmap_format10_inv2'/>; break;}
          case 12: { <code-include linkend='cmap_format12_inv2'/>; break;}}}}

    int[] result = new int [v.size ()];
    for (int i = 0; i &lt; v.size (); i++) {
      result [i] = v.get (i); }
    return result;
  }

  public int[] glyph2unicodechars (int glyphID) {

    int numTables = getuint16 (2);
    int encodingID = 1;

    for (int st = 0; st &lt; numTables; st++) {
      if (getuint16 (4 + 8*st) == 3 &amp;&amp; getuint16 (4 + 8*st + 2) == 10) {
        encodingID = 10; }}

    return glyph2chars (3, encodingID, glyphID);
  }
</code-fragment>

        <para>Another useful operation is to probe for the presence of
          a cmap for a particular plaftformID/encodingID:</para>

<code-fragment id='cmap.methods'>
  <code-title>Cmap subtable probe</code-title>
  public boolean hasCmapSubtable (int platformID, int encodingID, int languageID) {
    int numTables = getuint16 (2);

    for (int st = 0; st &lt; numTables; st++) {
      if (   platformID == getuint16 (4 + 8*st)
          &amp;&amp; encodingID == getuint16 (4 + 8*st + 2)) {
        return true; }}
    return false;
  }
</code-fragment>


<code-fragment id='cmap.methods2'>
  <code-title>??</code-title>
  public void addDirectMappings () {
    java.util.SortedMap m;

    boolean has310 = true;
    m = getMap (3, 10);
    if (m == null) {
      has310 = false;
      m = getMap (3, 1); }

    for (int g = 0; g &lt; font.maxp.getNumGlyphs ()) {
      m.add (new Integer (0x100000 + g), new Integer (g)); }

    Block b = toBinaryFormat12 (m);

    if (has310)
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <para>Our test framework is simply to convert a sequence of
          characters to a sequence of glyphs.</para>

<code-fragment package='com.adobe.aots.opentype' class='CmapTester'>
  <code-title>CmapTest class</code-title>
  package com.adobe.aots.opentype;

  <code-include linkend='test_imports'/>

  public class CmapTester {

    <code-include linkend='test_methods'/>

    public static void main (String[] args) throws Exception {

      try {
        String testName = "anonymousTest";
	URL fontURL = null;
	Font font = null;
	int platformID = 3;
	int encodingID = 10;
        int[] inputs= null;
	int[] expected = null;

        for (int i = 0; i &lt; args.length; i++) {
          if ("-testname".equals (args [i])) {
	    i++;
	    testName = args [i]; }

	  if ("-font".equals (args [i])) {
	    i++;
	    fontURL = new File (args [i]).getAbsoluteFile ().toURL ();
	    font = new Font ();
	    font.fromBinary (fontURL); }

	  if ("-platform".equals (args [i])) {
	    i++;
	    platformID = Integer.parseInt (args [i]); }

	  if ("-encoding".equals (args [i])) {
	    i++;
	    encodingID = Integer.parseInt (args [i]); }

	  if ("-inputs".equals (args [i])) {
	    i++;
	    inputs = parseIntList (args [i]); }

	  if ("-expected".equals (args [i])) {
	    i++;
	    expected = parseIntList (args [i]); }}

        int[] outputs = font.cmap.char2glyph (platformID, encodingID, inputs);

        if (expected != null) {
	  boolean pass = compareIntLists (expected, outputs) ;
	  if (! pass) {
  	    System.err.print ("  expected:");
	    for (int i = 0; i &lt; expected.length; i++) {
              System.err.print (" " + expected [i]); }
	    System.err.println ("");

  	    System.err.print ("  actual:  ");
	    for (int i = 0; i &lt; outputs.length; i++) {
              System.err.print (" " + outputs [i]); }
	    System.err.println (""); }

          reportStatus (testName, pass); }
        else {
          System.out.println ("outputs: ");
          printIntList (outputs); }}

      catch (Exception e) {
        System.out.println ("Exception: " + e.getMessage ());
        e.printStackTrace (); }
    }
  }
</code-fragment>


<code-fragment package='com.adobe.aots.opentype' class='CmapUVSTester'>
  <code-title>CmapUVSTest class</code-title>
  package com.adobe.aots.opentype;

  <code-include linkend='test_imports'/>

  public class CmapUVSTester {

    <code-include linkend='test_methods'/>

    public static void main (String[] args) throws Exception {

      try {
        String testName = "anonymousTest";
	URL fontURL = null;
	Font font = null;
	int platformID = 3;
	int encodingID = 10;
        int[] inputs= null;
	int[] expected = null;

        for (int i = 0; i &lt; args.length; i++) {
          if ("-testname".equals (args [i])) {
	    i++;
	    testName = args [i]; }

	  if ("-font".equals (args [i])) {
	    i++;
	    fontURL = new File (args [i]).getAbsoluteFile ().toURL ();
	    font = new Font ();
	    font.fromBinary (fontURL); }

	  if ("-inputs".equals (args [i])) {
	    i++;
	    inputs = parseIntList (args [i]); }

	  if ("-expected".equals (args [i])) {
	    i++;
	    expected = parseIntList (args [i]); }}

        int[] outputs = new int [inputs.length / 2];

        for (int i = 0; i &lt; inputs.length; i += 2) {
          outputs [i/2] = font.cmap.uvs2glyph (inputs [i], inputs [i+1]); }

        if (expected != null) {
	  boolean pass = compareIntLists (expected, outputs) ;
	  if (! pass) {
  	    System.err.print ("  expected:");
	    for (int i = 0; i &lt; expected.length; i++) {
              System.err.print (" " + expected [i]); }
	    System.err.println ("");

  	    System.err.print ("  actual:  ");
	    for (int i = 0; i &lt; outputs.length; i++) {
              System.err.print (" " + outputs [i]); }
	    System.err.println (""); }

          reportStatus (testName, pass); }
        else {
          System.out.println ("outputs: ");
          printIntList (outputs); }}

      catch (Exception e) {
        System.out.println ("Exception: " + e.getMessage ());
        e.printStackTrace (); }
    }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

        <para>Let's start by verifying the header.</para>

<code-fragment id='validate_header'>
  <code-title>Validate header and set 'numTables'</code-title>
  if (! claim ("cmap header", 0, 4)) {
    return; }

  int version = getuint16 (0);
  if (version > 0) {
    reportError ("cmap table version (" + version
                   + ") not part of the specification"); }

  int numTables = getuint16 (2);
  if (numTables == 0) {
    reportMistake ("font does not have any cmap subtables"); }
</code-fragment>

        <para>Let's move on to the directory of subtables. We first
          need to claim the bytes:</para>

<code-fragment id='validate_directory'>
  <code-title>Validate directory</code-title>
  if (! claim ("cmap directory", 4, 8*numTables)) {
    return; }
</code-fragment>

        <para>Another check is to make sure that the subtables are
          properly ordered:</para>

<code-fragment id='validate_directory_order'>
  <code-title>Validate directory order</code-title>
  int lastPlatformID = -1;
  int lastEncodingID = -1;

  for (int st = 0; st &lt; numTables; st++) {
    int platformID = getuint16 (4 + 8*st);
    int encodingID = getuint16 (4 + 8*st + 2);

    if (   platformID &lt; lastPlatformID
        || (   platformID == lastPlatformID
            &amp;&amp; encodingID &lt;= lastEncodingID)) {
      reportError ("cmap subtables not ordered by (platformID, encodingID)"); }

    lastPlatformID = platformID;
    lastEncodingID = encodingID; }
</code-fragment>

        <para>Another check is that there are entries for 3/1 and 0/3,
          and that they point ot the same subtable. This is a
          requirement for Adobe fonts only.</para>

<code-fragment id='validate_directory_has_unicode'>
  <code-title>Check there are 3/1 and 0/3 entries for the same
  subtable</code-title>
  int subtable03offset = -1;
  int subtable31offset = -1;

  for (int st = 0; st &lt; numTables; st++) {
    int platformID = getuint16 (4 + 8*st);
    int encodingID = getuint16 (4 + 8*st + 2);

    if (platformID == 0 &amp;&amp; encodingID == 3) {
      subtable03offset = getLOffset (4 + 8*st + 4); }

    if (platformID == 3 &amp;&amp; encodingID == 1) {
      subtable31offset = getLOffset (4 + 8*st + 4); }}

  if (subtable03offset == -1) {
    reportMistake ("no 0_3 subtable defined"); }
  if (subtable31offset == -1) {
    reportMistake ("no 3_1 subtable defined"); }

  if (   subtable03offset != subtable31offset
      &amp;&amp; subtable03offset != -1
      &amp;&amp; subtable31offset != -1) {
    reportMistake ("subtable 0_3 and 3_1 are not the same"); }
</code-fragment>


        <para>We validate each unique subtable on its own.</para>

<code-fragment id='validate_subtables'>
  <code-title>Validate each subtable</code-title>
  for (int st = 0; st &lt; numTables; st++) {
    String stPrefix = "cmap subtable " + st;
    int stOffset = getLOffset (4 + 8*st + 4);
    boolean checked = false;
    for (int st2 = 0; st2 &lt; st; st2++) {
      int st2Offset = getLOffset (4 + 8*st2 + 4);
      if (st2Offset == stOffset) {
         checked = true; }}

    if (checked) {
      continue; }

    int format = getuint16 (stOffset);
    switch (format) {
      case 0: { <code-include linkend='validate_cmap_format0'/>; break; }
      case 2: { <code-include linkend='validate_cmap_format2'/>; break; }
      case 4: { <code-include linkend='validate_cmap_format4'/>; break; }
      case 6: { <code-include linkend='validate_cmap_format6'/>; break; }
      default:{
        reportError (stPrefix + " is in an invalid format (" + format + ")");
        break; }}}
</code-fragment>

        <para>Finally, we verify that the Unicode cmap subtable is in
          the  appropriate format:</para>

<code-fragment id='validate_unicode_subtable_format'>
  <code-title>Check the format of the Microsoft Unicode subtable</code-title>
  for (int st = 0; st &lt; numTables; st++) {
    int platformID = getuint16 (4 + 8*st);
    int encodingID = getuint16 (4 + 8*st + 2);

    if (platformID == 3 &amp;&amp; encodingID == 1) {
      int stOffset = getLOffset (4 + 8*st + 4);
      int format = getuint16 (stOffset);
      if (format != 4) {
        reportError ("cmap subtable 3/1 must be in format 4"); }
      break; }}
</code-fragment>


        <para>Time to put everything together:</para>

<code-fragment id='cmap.methods'>
  <code-title>Cmap Validation Method</code-title>
  public void validate () {

    <code-include linkend='validate_header'/>

    <code-include linkend='validate_directory'/>
    <code-include linkend='validate_directory_order'/>
    <code-include linkend='validate_directory_has_unicode'/>

    <code-include linkend='validate_subtables'/>
    <code-include linkend='validate_unicode_subtable_format'/>

    report ();
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment' id='cmap_cust'>
      <title>OTF Windows NT compatibility mapping</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>If a platform ID 4 (custom), encoding ID 0-255 (OTF
          Windows NT compatibility mapping) <ottable>cmap</ottable>
          encoding is present in an OpenType font with CFF outlines,
          then the OTF font driver in Windows NT will: (a) superimpose
          the glyphs encoded at character codes 0-255 in the encoding
          on the corresponding Windows ANSI (code page 1252) Unicode
          values in the Unicode encoding it reports to the system; (b)
          add Windows ANSI (CharSet 0) to the list of CharSets
          supported by the font; and (c) consider the value of the
          encoding ID to be a Windows CharSet value and add it to the
          list of CharSets supported by the font. Note: The
          <ottable>cmap</ottable> subtable must use Format 0 or 6 for
          its subtable, and the encoding must be identical to the
          CFF's encoding.</para>

        <para>This <ottable>cmap</ottable> encoding is not required.
          It provides a compatibility mechanism for non-Unicode
          applications that use the font as if it were Windows ANSI
          encoded. Non-Windows ANSI Type 1 fonts, such as Cyrillic and
          Central European fonts, that Adobe shipped in the past had
          "0" (Windows ANSI) recorded in the CharSet field of the .PFM
          file; ATM for Windows 9x ignores the CharSet altogether.
          Adobe provides this compatibility <ottable>cmap</ottable>
          encoding in every OTF converted from a Type1 font in which
          the Encoding is not StandardEncoding.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment' id='language_note'>
      <title>Note on the language field in <ottable>cmap</ottable>
        subtables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This field must be set to zero for all
          <ottable>cmap</ottable> subtables whose platform IDs are
          other than Macintosh (platform ID 1). For
          <ottable>cmap</ottable> subtables whose platform IDs are
          Macintosh, set this field to the Macintosh language ID of
          the <ottable>cmap</ottable> subtable plus one, or to zero if
          the <ottable>cmap</ottable> subtable is not
          language-specific. For example, a Mac OS Turkish
          <ottable>cmap</ottable> subtable must set this field to 18,
          since the Macintosh language ID for Turkish is 17. A Mac OS
          Roman <ottable>cmap</ottable> subtable must set this field
          to 0, since Mac OS Roman is not a language-specific
          encoding.</para>
      </section>
    </section>


    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 0: Byte encoding table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This is the Apple standard character to glyph index
          mapping table.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Format number is set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in cmap subtables</link> in this
              document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>glyphIdArray[256]</otfieldname>
            <otfielddesc>An array that maps character codes to glyph
              index values.</otfielddesc>
          </otfield>
        </otformat>

        <para>This is a simple 1 to 1 mapping of character codes to
          glyph indices. The glyph set is limited to 256. Note that if
          this format is used to index into a larger glyph set, only
          the first 256 glyphs will be accessible.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>As the declaration stands, the length field seems
          superfluous, since the table appears to always be 262 bytes
          long. This can be explained in one of two ways:

          <itemizedlist>
            <listitem>
              <para>the length field is included to make the first three
                words of all cmap subtables similar; it must always be
                262.</para>
            </listitem>
            <listitem>
              <para>the glyphIdArray does not need to be always 256
                elements long, it can be shorter.</para>
            </listitem>
          </itemizedlist></para>

        <para>In the spirit of "generate conservatively, accept
          liberally", we recommend that font designers always put 256
          entries in glyphIdArray (and consequently set length to 262), and
          that font consumers be ready to handle fonts where the
          glyphIdArray contains length - 6 entries (but no more than
          256).</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  cmapsubtable |=
    attribute format { "0" },
    element map {
      attribute code { text },
      attribute glyph { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  <code-title>Method to compile a format 0 cmap</code-title>
  private Block format0FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();
    int m[] = new int [256];

    for (int i = 0; i &lt; children.getLength (); i++) {
      Element map = (Element) children.item (i);

        int charcode = Integer.decode (map.getAttribute ("code")).intValue ();
        int glyphid = Integer.decode (map.getAttribute ("glyph")).intValue ();

        if (charcode >= 256) {
          warning ("charcode too big in cmap format 0"); }

        m [charcode] = glyphid; }

    Block b = new Block (262, 0);
    b.setuint16 (0, 0);
    b.setuint16 (2, 262);
    b.setuint16 (4, language);
    int offset = 6;
    for (int i = 0; i &lt;= 255; i++) {
      b.setuint8 (offset, m[i]);
      offset += 1; }

    return b;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.decompile.format0.elt'>
  <code-title>Generate elements for the format 0 cmap subtable at 'stOffset'</code-title>
  for (int i = 0; i &lt; 256; i++) {
    if (conf.preciseCmap || getuint8 (stOffset + 6 + i) != 0) {
      at = new AttributesImpl ();
      at.addAttribute ("", "code", "code", "CDATA",
                       "0x" + Integer.toHexString (i));
      at.addAttribute ("", "glyph", "glyph", "CDATA",
                       "" + getuint8 (stOffset + 6 + i));
      conf.ch.element ("map", at); }}

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='cmap_format0'>
  <code-title>Return glyph for 'charCode', using format 0 subtable at 'stOffset'</code-title>
  { int size = getuint16 (stOffset + 2) - 6;
    if (0 &lt;= charCode &amp;&amp; charCode &lt; size) {
      return getuint8 (stOffset + 6 + charCode); }
    else {
      return 0; }}
</code-fragment>

<code-fragment id='cmap_format0_iterator'>
  <code-title>Enumerate mappings in format 0 subtable at 'stOffset'</code-title>
  { java.util.TreeMap&lt;Integer, Integer> m
        = new java.util.TreeMap&lt;Integer, Integer> ();

    int size = getuint16 (stOffset + 2) - 6;
    for (int i = 0; i &lt; size; i++) {
      if (from &lt;= i &amp;&amp; (i &lt;= to || to == -1)) {
        m.put (i, getuint8 (stOffset + 6 + i)); }}

    return m; }
</code-fragment>

<code-fragment id='cmap_format0_inv'>
  <code-title>Return character for 'glyphID', using format 0 subtable at 'stOffset'</code-title>
  { int size = getuint16 (stOffset + 2) - 6;
    for (int i = 0; i &lt; size; i++) {
      if (getuint8 (stOffset + 6 + i) == glyphID) {
        return i; }}
    return -1; }
</code-fragment>

<code-fragment id='cmap_format0_inv2'>
  <code-title>Fill 'v' with characters for 'glyphID', using format 0 subtable at 'stOffset'</code-title>
  { int size = getuint16 (stOffset + 2) - 6;
    for (int i = 0; i &lt; size; i++) {
      if (getuint8 (stOffset + 6 + i) == glyphID) {
        v.add (new Integer (i)); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap0_font1: basic test</title>

          <para>Let's start with a simple case:</para>

<aots:test-font id='cmap0_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='0'>
      <map code="0x34" glyph="17"/>
      <map code="0x35" glyph="56"/>
      <map code="0x36" glyph="12"/>
    </mapping>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap0_test1' font='cmap0_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  0x01, 0x33, 0x34, 0x35, 0x36, 0x37, 0xffff'
            outputs='0,  0,       0,   17,   56,   12,    0,      0'/>
        </section>

      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

        <para>In line with our annotation, the validation code generates a
          warning if the glyphIdArray does not have exactly 256
          entries.</para>

<code-fragment id='validate_cmap_format0'>
  <code-title>Validate cmap 0 subtable at stOffset</code-title>
  if (! claim (stPrefix + " header", stOffset, 6)) {
    break; }

  int stVersion = getuint16 (stOffset + 4);
  if (stVersion > 0) {
    reportError ("cmap@" + stOffset + " table version (" + stVersion
                 + ") not part of the specification"); }

  int size = getuint16 (stOffset + 2);
  if (size &lt; 6) {
    reportError ("cmap subtable at " + stOffset + " has length &lt;  6"); }
  if (size &gt; 6 + 256) {
    reportError ("cmap subtable at " + stOffset
                     + " has more than 256 entries"); }
  if (size &lt; 6 + 256) {
    reportWarning ("cmap subtable at " + stOffset
                   + " has less than 256 entries"); }
  // check that each glyphID in glyphIdArray is a valid glyph

  claim (stPrefix + " glyphIDArray", stOffset + 6, size - 6);
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 2: High-byte mapping through table </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This subtable is useful for the national character code
          standards used for Japanese, Chinese, and Korean characters.
          These code standards use a mixed 8/16-bit encoding, in which
          certain byte values signal the first byte of a 2-byte
          character (but these values are also legal as the second
          byte of a 2-byte character).</para>

        <para>In addition, even for the 2-byte characters, the mapping
          of character codes to glyph index values depends heavily on
          the first byte. Consequently, the table begins with an array
          that maps the first byte to a 4-word subHeader. For 2-byte
          character codes, the subHeader is used to map the second
          byte's value through a subArray, as described below. When
          processing mixed 8/16-bit text, subHeader 0 is special: it
          is used for single-byte character codes. When subHeader zero
          is used, a second byte is not needed; the single byte value
          is mapped through the subArray.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Format number is set to 2.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>subHeaderKeys [256]</otfieldname>
            <otfielddesc>Array that maps high bytes to subHeaders:
              value is subHeader index * 8.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>518</otfieldoffs>
            <otfieldtype>4 words struct</otfieldtype>
            <otfieldname>subHeaders []</otfieldname>
            <otfielddesc>Variable-length array of subHeader
              structures.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphIndexArray []</otfieldname>
            <otfielddesc>Variable-length array containing subarrays
              used for mapping the low byte of 2-byte
              characters.</otfielddesc>
          </otfield>
        </otformat>

        <para>A subHeader is structured as follows:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>firstCode</otfieldname>
            <otfielddesc>First valid low byte for this
              subHeader.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>entryCount</otfieldname>
            <otfielddesc>Number of valid low bytes for this
              subHeader.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>idDelta</otfieldname>
            <otfielddesc>See text below.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>idRangeOffset</otfieldname>
            <otfielddesc>See text below.</otfielddesc>
          </otfield>
        </otformat>

        <para>The firstCode and entryCount values specify a subrange
          that begins at firstCode and has a length equal to the value
          of entryCount. This subrange stays within the 0-255 range of
          the byte being mapped. Bytes outside of this subrange are
          mapped to glyph index 0 (missing glyph). The offset of the
          byte within this subrange is then used as index into a
          corresponding subarray of glyphIndexArray. This subarray is
          also of length entryCount. The value of the idRangeOffset is
          the number of bytes past the actual location of the
          idRangeOffset word where the glyphIndexArray element
          corresponding to firstCode appears.</para>

        <para>Finally, if the value obtained from the subarray is not
          0 (which indicates the missing glyph), you should add
          idDelta to it in order to get the glyphIndex. The value
          idDelta permits the same subarray to be used for several
          different subheaders. The idDelta arithmetic is modulo
          65536.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>How about an intelligible description of the use of this
        format? Assuming that it intends to describe the same
        structure as the Apple True Type format, simply switching to
        their version would already be a vast improvement.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>We do not represent explicitly the subHeaderKeys
	array. Rather, we represent the subHeaders structure directly,
	and collect the subHeaderKeys from which they are referenced
	in the <sgmltag>subHeaderKeys</sgmltag> attribute. The first </para>

	<para>The idRangeOffset field can be interpreted only when one
	knows its location in the cmap subtable. Since this datum
	disappears in our XML representation, the field
	<sgmltag>idRangeOffset</sgmltag> is the
	index of the first integer corresponding to the subHeader in
	the <sgmltag>glyphIndexArray</sgmltag>.</para>

	<para>If we are given only the mapping from code points to
	glyphs, we have no way of knowing which code points are
	represented on one byte, and which are represented in two
	bytes. Therefore, this format contributes an attribute
	<sgmltag>singleBytes</sgmltag> to record those. We need this
	attribute only when we use the 'bunch of mappings'
	representation; when we have all the details, the first
	<sgmltag>subheader</sgmltag> element carries the single byte
	code points.</para>

<code-fragment id='schema'>
  <code-title>XML representation of format 2 cmap subtables</code-title>
  cmapsubtable |=
    attribute format { "2" },

    ((element subheader {
        attribute subHeaderKeys { text },
        attribute firstCode { text },
        attribute entryCount { text },
        attribute idDelta { text },
        attribute idRangeOffset { text }
      }*,

      element glyphIndex {
        attribute v { text }
      })
    |
     (attribute singleBytes { text },
      element map {
        attribute code { text },
        attribute glyph { text }}*))
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>When we are given a bunch of simple mappings, we want to
	build a fairly compact representation. Our strategy will not
	necessarily yield the smallest representation, but it should
	come pretty close. We start by building a 256 by 256 matrix of
	mappings, each row corresponding to a high byte. We normalize
	each row by computing a delta for it, such that the smallest
	non-zero entry in the row is delta + 1, and this delta will be
	the idDelta value for the row. Then find the smallest subset
	of distinct rows, building the mapping from high byte to
	row. We then trim each row, removing the initial and final
	zeros (except for the first row, which apparently must be
	completely represented).</para>

<code-fragment id='cmap.methods'>
  <code-title>Method to compile a format 2 cmap</code-title>
  private static class SubHeader {
    int highByte;

    int first;
    int count;
    int delta;
    int glyphIndexArray;
  }

  private Block format2FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    String singleBytesAtt = t.getAttribute ("singleBytes");

    if (singleBytesAtt != null) {
      int[] singleBytes = parseIntList (singleBytesAtt);
      Arrays.sort (singleBytes);

      // initialize the map to 0s
      int[][] map = new int [256][];
      int[] singleMap = new int [256];
      for (int r = 0; r &lt;= 0xff; r++) {
        singleMap [r] = 0;
        map [r] = new int [256];
	for (int c = 0; c &lt;= 0xff; c++) {
	  map [r][c] = 0; }}

      // fill the map with the requested values
      NodeList maps = t.getChildNodes ();
      for (int i = 0; i &lt; maps.getLength (); i++) {
        Element m = (Element) maps.item (i);
        int charcode = Integer.decode (m.getAttribute ("code")).intValue ();
        int glyphid = Integer.decode (m.getAttribute ("glyph")).intValue ();
	if (charcode &lt;= 0xff &amp;&amp; Arrays.binarySearch (singleBytes, charcode) >= 0) {
	  singleMap [charcode] = glyphid; }
        else {
  	  map [charcode >> 8] [charcode &amp; 0xff] = glyphid; }}


      // We need two special subHeaders:
      // - the first (0) is for single byte characters
      // - the second (1) is for those high bytes such that no character with
      //   that high byte is mapped
      // For the other high bytes, there is no good chance of sharing
      // the subHeaders, as they are likely to differ either on idDelta
      // (sharing the same glyphIndexArray fragment) or on idRangeOffset

      int[] subHeaderKeys = new int [256];

      Vector&lt;SubHeader> subHeaders = new Vector&lt;SubHeader> ();
      Vector&lt;int[]> glyphIndexArrays = new Vector&lt;int[]> ();

      { SubHeader sh = new SubHeader ();
        sh.highByte = -1;
        sh.first = 0;
        sh.count = 256;
        sh.delta = 0;
        sh.glyphIndexArray = glyphIndexArrays.size ();
	subHeaders.add (sh);

	int[] gia = new int [256];
	for (int singleByte = 0; singleByte &lt;= 0xff; singleByte++) {
  	  gia [singleByte] = singleMap [singleByte]; }
        glyphIndexArrays.add (gia); }

      { SubHeader sh = new SubHeader ();
        sh.highByte = -2;
        sh.first = 0;
        sh.count = 0;
        sh.delta = 0;
        sh.glyphIndexArray = glyphIndexArrays.size ();
        subHeaders.add (sh);

	int[] gia = new int [0];
        glyphIndexArrays.add (gia); }

      for (int firstByte = 0; firstByte &lt;= 0xff; firstByte++) {
        if (Arrays.binarySearch (singleBytes, firstByte) >= 0) {
	  subHeaderKeys [firstByte] = 0; }
	else {
          int minNonNull = Integer.MAX_VALUE;
	  for (int lowByte = 0; lowByte &lt;= 0xff; lowByte++) {
            if (map [firstByte][lowByte] > 0) {
	      minNonNull = Math.min (map [firstByte][lowByte], minNonNull); }}

	  if (minNonNull == Integer.MAX_VALUE) {
	    // all entries to 0
	    subHeaderKeys [firstByte] = 1; }
	  else {
            subHeaderKeys [firstByte] = subHeaders.size ();

	    SubHeader sh = new SubHeader ();
            sh.first = 0;
            sh.count = 0;
            sh.delta = minNonNull - 1;

	    sh.first = 0;
	    while (   sh.first &lt;= 0xff
                   &amp;&amp; map [firstByte] [sh.first] == 0) {
	      sh.first++; }
            sh.count = 0x100 - sh.first;
	    while (   sh.count > 0
                   &amp;&amp; map [firstByte] [sh.first + sh.count - 1] == 0) {
	      sh.count--; }

	    int[] gia = new int [sh.count];
	    for (int lowByte = sh.first; lowByte &lt; sh.first + sh.count; lowByte++) {
	      int gid = map [firstByte][lowByte];
	      gia [lowByte - sh.first] = (gid == 0) ? 0 : (gid - sh.delta); }


	    int pos = -1;
            for (int i = 0; i &lt; glyphIndexArrays.size (); i++) {
	      if (Arrays.equals (gia, glyphIndexArrays.elementAt (i))) {
                pos = i;
                break; }}

	    if (pos == -1) {
	      sh.glyphIndexArray = glyphIndexArrays.size ();
	      glyphIndexArrays.add (gia); }
	    else {
              sh.glyphIndexArray = pos; }

            subHeaders.add (sh); }}}

      // compute the size of our block
      int blockSize = 6 + 2*256 + 8*subHeaders.size ();
      int[] giaOffsets = new int [glyphIndexArrays.size ()];
      int kk = 0;
      for (int[] gia : glyphIndexArrays) {
        giaOffsets [kk++] = blockSize;
        blockSize += 2 * gia.length; }

      Block me = new Block (blockSize, 0);
      me.setuint16 (0, 2);
      me.setuint16 (2, blockSize);
      me.setuint16 (4, 0);
      int o = 6;
      for (int r = 0; r &lt;= 0xff; r++) {
        me.setuint16 (o, subHeaderKeys [r] * 8);
	o += 2; }
      for (SubHeader sh : subHeaders) {
        me.setuint16 (o, sh.first);
        o += 2;
        me.setuint16 (o, sh.count);
        o += 2;
        me.setint16 (o, sh.delta);
        o += 2;
        me.setuint16 (o, giaOffsets [sh.glyphIndexArray] - o);
        o += 2; }
      for (int[] gia : glyphIndexArrays) {
        for (int i = 0; i &lt; gia.length; i++) {
          me.setuint16 (o, gia [i]);
          o += 2; }}

      return me; }

    // the explicit representation
    NodeList children = t.getChildNodes ();
    int[] subHeaderKeys = new int [256];
    int subHeadersCount = children.getLength () - 1;
    SubHeader[] subHeaders = new SubHeader [subHeadersCount];
    for (int c = 0; c &lt; subHeadersCount; c++) {
      Element e = (Element) children.item (c);
      SubHeader sh = new SubHeader ();
      sh.first = Integer.decode (e.getAttribute ("firstCode")).intValue ();
      sh.count = Integer.decode (e.getAttribute ("entryCount")).intValue ();
      sh.delta = Integer.decode (e.getAttribute ("idDelta")).intValue ();
      sh.glyphIndexArray = Integer.decode (e.getAttribute ("idRangeOffset")).intValue ();
      subHeaders [c] = sh;

      int[] mappedFrom = parseIntList (e.getAttribute ("subHeaderKeys"));
      for (int i = 0; i &lt; mappedFrom.length; i++) {
        subHeaderKeys [mappedFrom [i]] = c;}}

    Element e = (Element) (children.item (subHeadersCount));
    int[] glyphIndexArray = parseIntList (e.getAttribute ("v"));

    int giaStart = 6 + 512 + 8*subHeadersCount;
    int blockSize = giaStart + 2*glyphIndexArray.length;
    Block me = new Block (blockSize, 0);
    me.setuint16 (0, 2);
    me.setuint16 (2, blockSize);
    me.setuint16 (4, language);
    int o = 6;
    for (int i = 0; i &lt; 256; i++) {
      me.setuint16 (o, subHeaderKeys [i] * 8);
      o += 2; }
    for (int c = 0; c &lt; subHeadersCount; c++) {
      SubHeader sh = subHeaders [c];
      me.setuint16 (o, sh.first);
      o += 2;
      me.setuint16 (o, sh.count);
      o += 2;
      me.setint16 (o, sh.delta);
      o += 2;
      me.setuint16 (o, giaStart + 2*sh.glyphIndexArray - o);
      o += 2; }
    for (int i = 0; i &lt; glyphIndexArray.length; i++) {
      me.setuint16 (o, glyphIndexArray [i]);
      o += 2; }

    return me;
  }


</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>When we generate a simple mapping representation, we
	also need to record which bytes are single bytes:</para>

<code-fragment id='cmap.decompile.format2.att'>
  <code-title>Generate attributes for the format 2 cmap subtable at 'stOffset'</code-title>
  if (! conf.preciseCmap) {
    StringBuilder sb = new StringBuilder ();
    for (int key = 0; key &lt; 256; key++) {
      int subHeadersIndex = getuint16 (stOffset + 6 + 2*key) / 8;
      if (subHeadersIndex == 0) {
        sb.append (" 0x");
        sb.append (Integer.toHexString (key)); }}
    at.addAttribute ("", "singleBytes", "singleBytes", "CDATA", sb.toString ()); }
</code-fragment>

        <para>We have no real indication of where the glyphIndexArray
        starts. For example, one could increase all the idRangeOffset
        values by 10, increase the size of the glyphIndexArray by 10,
        and shift all its values by 10 slots. Consequently, we also
        have not real indication of the actual number of
        subHeaders. All we know is that given a code point, the
        computation of the corresponding glyphID will interpret the
        content of the table appropriately; it is even possible
        that a given byte will be interpreted as part of a subHeader
        for one code point, and as part of the glyphIndexArray for
        another code point! (although that would require a
        non-straightforward font generator, which probably does not
        exists at this point)</para>

	<para>Our strategy to handle this is to do a symbolic
	inteperpretation of the table (or equivalently, a dataflow
	analyzis). First, we traverse the subHeaderKeys, recording the
	indices of the subHeaders that are used; in fact, we even
	build a map for subHeaders to the subHeaderKeys that point to
	them:</para>

<code-fragment id='cmap.decompile.format2.elt.1'>
  <code-title>Build a map from subHeaders to subHeaderKeys</code-title>
  SortedMap&lt;Integer, SortedSet&lt;Integer>> subHeader2keys
    = new TreeMap&lt;Integer, SortedSet&lt;Integer>> ();

  for (int key = 0; key &lt; 256; key++) {
    int subHeader = getuint16 (stOffset + 6 + 2*key) / 8;
    SortedSet&lt;Integer> keys = subHeader2keys.get (subHeader);
    if (keys == null) {
      keys = new TreeSet&lt;Integer> ();
      subHeader2keys.put (subHeader, keys); }
    keys.add (key); }
</code-fragment>

        <para>Next, we traverse the subheaders, to find the offset of
        the first byte that is used as a glyphIndexArray element, and
        the index following the last byte used that way. Those offsets
        are recorded as byte offsets from the start of the cmap
        table (i.e, as indices in our 'data' array):</para>

<code-fragment id='cmap.decompile.format2.elt.2'>
  <code-title>Find the boundaries of glyphIndexArray</code-title>
   int minGlyphIndexOffset = stOffset + getuint16 (stOffset + 2);
   int maxGlyphIndexOffset = stOffset;

    for (int subHeader : subHeader2keys.keySet ()) {
      int subHeaderOffset = stOffset + 6 + 512 + 8*subHeader;
      int entryCount = getuint16 (subHeaderOffset + 2);
      int idRangeOffset = getuint16 (subHeaderOffset + 6);
      if (entryCount > 0) {
        int firstGlyphIndexOffset = subHeaderOffset + 6 + idRangeOffset;
        int lastGlyphIndexOffset = firstGlyphIndexOffset + 2 * entryCount;

        if (firstGlyphIndexOffset &lt; minGlyphIndexOffset) {
          minGlyphIndexOffset = firstGlyphIndexOffset; }
	if (maxGlyphIndexOffset &lt; lastGlyphIndexOffset) {
	  maxGlyphIndexOffset = lastGlyphIndexOffset; }}}
</code-fragment>


        <para>With that, we can build the representations of the
        subHeaders;</para>

<code-fragment id='cmap.decompile.format2.elt.3'>
  <code-title>Generate elements for the subHeaders</code-title>
  for (int subHeader : subHeader2keys.keySet ()) {
    at = new AttributesImpl ();

    { SortedSet&lt;Integer> keys = subHeader2keys.get (subHeader);
      StringBuilder sb = new StringBuilder ();
      for (int key : keys) {
        sb.append (" 0x");
 	  sb.append (Integer.toHexString (key)); }
      at.addAttribute ("", "highBytes", "highBytes", "CDATA", sb.toString ()); }

    int subHeaderOffset = stOffset + 6 + 512 + 8*subHeader;
    int firstCode = getuint16 (subHeaderOffset);
    int entryCount = getuint16 (subHeaderOffset + 2);
    int idDelta = getuint16 (subHeaderOffset + 4);
    int idRangeOffset = getuint16 (subHeaderOffset + 6);
    int firstGlyphIndexOffset = subHeaderOffset + 6 + idRangeOffset;

    at.addAttribute ("", "firstCode", "firstCode", "CDATA",
                     "0x" + Integer.toHexString (firstCode));
    at.addAttribute ("", "entryCount", "entryCount", "CDATA", "" + entryCount);
    at.addAttribute ("", "idDelta", "idDelta", "CDATA", "" + idDelta);
    at.addAttribute ("", "idRangeOffset", "idRangeOffset", "CDATA",
                     "" + ((firstGlyphIndexOffset - minGlyphIndexOffset) / 2));

    conf.ch.element ("subheader", at); }
</code-fragment>

        <para>And we can also build the representation of
        glyphIndexArray:</para>

<code-fragment id='cmap.decompile.format2.elt.4'>
  <code-title>Generate an element for glyphIndexArray</code-title>
  { StringBuilder sb = new StringBuilder ();
    for (int i = minGlyphIndexOffset; i &lt; maxGlyphIndexOffset; i += 2) {
      sb.append (" ");
      sb.append (getuint16 (i)); }
    at = new AttributesImpl ();
    at.addAttribute ("", "v", "v", "CDATA", sb.toString ());

    conf.ch.element ("glyphIndex", at); }
</code-fragment>

        <para>We are ready to put everything together:</para>

<code-fragment id='cmap.decompile.format2.elt'>
  <code-title>Generate elements for the format 2 cmap subtable at 'stOffset'</code-title>
  if (conf.preciseCmap) {
    <code-include linkend='cmap.decompile.format2.elt.1'/>
    <code-include linkend='cmap.decompile.format2.elt.2'/>
    <code-include linkend='cmap.decompile.format2.elt.3'/>
    <code-include linkend='cmap.decompile.format2.elt.4'/> }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>This cmap subtable format is really supporting two
	operations: find the bytes that represent a character in the
	input stream and convert those to a glyphID. The first part is
	supported only though a sequential scan of the bytes, and so
	amounts to deciding whether a first byte is representing a
	character on its own, or is the high byte of a byte pair. We
	do not really want to support the first part in our interface:
	the client must already determine the boundaries of
	characters, and assemble the bytes in code points.</para>

	<para>This creates a little difficulty: consider the case
	where we get at our interface a code point
	<emphasis>c</emphasis> between 0x00 and 0xff. Was it the
	result of a single byte <emphasis>c</emphasis> (in which case
	we should index in subHeaderKeys with that value) or was it
	the result of a two byte sequence 0x00 <emphasis>c</emphasis>
	(in which case we should index subHeaderKeys with 0)?
	Fortunately, we can inspect subHeaderKeys[c] to distinguish
	the cases. The situation does not happen for code points above
	0xff, as those are by necessity on two bytes.</para>

	<para>It is worth noting that the confusion is unlikely in
	practice, as the byte 0x00 is representing entirely a
	character in essentially all one/two bytes encodings. However,
	this is not implied by the cmap subtable format, so we need
	to handle the situation.</para>

	<para>The next observation is that we really have two indexing
	operations at play: the first in subHeaderKeys, the second in
	glyphIndexArray. For code points represented by a single byte,
	that byte is used for both operations. Otherwise, the first
	byte is used for the indexing, and the second byte is used for
	the second indexing.</para>

	<para>Combining all that, our strategy is to figure out the
	two byte values used for the indexing operations, and then
	perform them.</para>

<code-fragment id='cmap_format2'>
  <code-title>Return glyph for 'charCode', using format 2 subtable at
  'stOffset'</code-title>
{ int headerIndexByte;
  int glyphIndexArrayIndexByte;

  { int highByte = (charCode >> 8) &amp; 0xff;
    int lowByte = (charCode) &amp; 0xff;

    if (highByte == 0 &amp;&amp; getuint16 (stOffset + 6 + 2*lowByte) == 0) {
      // lowByte is a single byte character
      headerIndexByte = lowByte; }
    else {
      headerIndexByte = highByte; }

    glyphIndexArrayIndexByte = lowByte; }

  int subHeaderKey = getuint16 (stOffset + 6 + 2*headerIndexByte) / 8;
  int subHeaderOffset = stOffset + 518 + 8*subHeaderKey;
  int firstCode = getuint16 (subHeaderOffset);
  int entryCount = getuint16 (subHeaderOffset + 2);

  if (   glyphIndexArrayIndexByte &lt; firstCode
      || firstCode + entryCount &lt;= glyphIndexArrayIndexByte) {
    return 0; }

  int idDelta = getuint16 (subHeaderOffset + 4);
  int idRange = getuint16 (subHeaderOffset + 6);
  int glyphIndexOffset = subHeaderOffset + 6 + idRange;
  int g = getuint16 (glyphIndexOffset + 2 * (glyphIndexArrayIndexByte - firstCode));

  if (g == 0) {
    return 0; }
  else {
    return (g + idDelta) % 0x10000; }
}
</code-fragment>

        <para>We have less difficulty when enumerating the mappings,
        as we do not have to reconcile with an outside operation, but
        instead let us be driven by the cmap subtable content.</para>

<code-fragment id='cmap_format2_iterator'>
  <code-title>Enumerate mappings in format 2 subtable at 'stOffset'</code-title>
{ java.util.TreeMap&lt;Integer, Integer> m
      = new java.util.TreeMap&lt;Integer, Integer> ();

  for (int firstByte = 0; firstByte &lt;= 0xff; firstByte++) {
    int subHeaderIndex = getuint16 (stOffset + 6 + 2*firstByte) / 8;
    int subHeaderOffset = stOffset + 518 + subHeaderIndex * 8;
    int firstCode = getuint16 (subHeaderOffset);
    int entryCount = getuint16 (subHeaderOffset + 2);
    int idDelta = getuint16 (subHeaderOffset + 4);
    int idRange = getuint16 (subHeaderOffset + 6);
    int glyphIndexOffset = subHeaderOffset + 6 + idRange;

    if (subHeaderIndex == 0) {
      int g = getuint16 (glyphIndexOffset + 2 * (firstByte - firstCode));
	if (g != 0) {
        m.put (firstByte, (g + idDelta) % 0x10000); }}

    else {
      for (int secondByte = firstCode;
           secondByte &lt; firstCode + entryCount;
           secondByte++) {
	int g = getuint16 (glyphIndexOffset + 2 * (secondByte - firstCode));
        if (g != 0) {
          m.put ((firstByte &lt;&lt; 8) + secondByte,
                 (g + idDelta) % 0x10000); }}}}

  return m; }
</code-fragment>


        <para>Since the inversion is non-trivial, and the meaning of
        this format is so unclear, let's wait to implement this one.</para>

<code-fragment id='cmap_format2_inv'>
  <code-title>Return a character that maps to 'glyphID', using format 2 subtable at 'stOffset'</code-title>
{ return -1; }
</code-fragment>

<code-fragment id='cmap_format2_inv2'>
  <code-title>Fill 'v' with characters that map to 'glyphID', using format 2 subtable at 'stOffset'</code-title>
  {}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap2_font1: basic test</title>

          <para>Let's start with a simple case:</para>

<aots:test-font id='cmap2_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='2'
             singleBytes='0x34 0x35 0x36'>
      <map code="0x34" glyph="17"/>
      <map code="0x35" glyph="56"/>
      <map code="0x36" glyph="12"/>

      <map code='0x8432' glyph='20'/>
      <map code='0x8433' glyph='21'/>
      <map code='0x8434' glyph='22'/>

      <map code='0x9232' glyph='23'/>
      <map code='0x9233' glyph='24'/>
      <map code='0x9234' glyph='25'/>

    </mapping>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap2_test1' font='cmap2_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 0x33, 0x34, 0x35, 0x36, 0x37, 0x8431, 0x8432, 0x8434, 0x9232, 0xffff'
            outputs='0,  0,    0,   17,   56,   12,    0,      0,     20,     22,     23, 0'/>
        </section>

      </section>


      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

<code-fragment id='validate_cmap_format2'>
  <code-title>Validate cmap 2 subtable at stOffset</code-title>
  if (! claim (stPrefix + " header", stOffset + 2, 4)) {
    break; }

  int stVersion = getuint16 (stOffset + 4);
  if (stVersion > 0) {
    reportError ("cmap@" + stOffset + " table version (" + stVersion
                 + ") not part of the specification"); }

  int length = getuint16 (stOffset + 2);
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 4: Segment mapping to delta values</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This is the Microsoft standard character to glyph index
          mapping table for fonts that support Unicode ranges other
          than the range [U+D800 - U+DFFF] (defined as Surrogates
          Area, in Unicode v 3.0) which is used for UCS-4
          characters. If a font supports this character range (i.e. in
          turn supports the UCS-4 characters) a subtable in this
          format with a platform specific encoding ID 1 is yet needed,
          in addition to a subtable in format 12 with a platform
          specific encoding ID 10. Please see details on format 12
          below, for fonts that support UCS-4 characters on
          Windows.</para>

        <para>This format is used when the character codes for the
          characters represented by a font fall into several
          contiguous ranges, possibly with holes in some or all of the
          ranges (that is, some of the codes in a range may not have a
          representation in the font). The format-dependent data is
          divided into three parts, which must occur in the following
          order:</para>

        <orderedlist>
          <listitem>
            <para>A four-word header gives parameters for an optimized
              search of the segment list;</para>
          </listitem>
          <listitem>
            <para>Four parallel arrays describe the segments (one
              segment for each contiguous range of codes);</para>
          </listitem>
          <listitem>
            <para>A variable-length array of glyph IDs (unsigned
              words).</para>
          </listitem>
        </orderedlist>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Format number is set to 4.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>segCountX2</otfieldname>
            <otfielddesc>2 x segCount.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>searchRange</otfieldname>
            <otfielddesc>2 x (2**floor(log2(segCount)))</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>entrySelector</otfieldname>
            <otfielddesc>log2(searchRange/2)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rangeShift</otfieldname>
            <otfielddesc>2 x segCount - searchRange</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>endCount [segCount]</otfieldname>
            <otfielddesc>End characterCode for each segment,
              last=0xFFFF.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14+2i</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>reservedPad</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16+2i</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>startCount [segCount]</otfieldname>
            <otfielddesc>Start character code for each
              segment.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16+4i</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>idDelta [segCount]</otfieldname>
            <otfielddesc>Delta for all character codes in
              segment.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16+6i</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>idRangeOffset [segCount]</otfieldname>
            <otfielddesc>Offsets into glyphIdArray or 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16+8i</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphIdArray []</otfieldname>
            <otfielddesc>Glyph index array (arbitrary length)
            </otfielddesc>
          </otfield>
        </otformat>

        <para>The number of segments is specified by segCount, which
          is not explicitly in the header; however, all of the header
          parameters are derived from it. The searchRange value is
          twice the largest power of 2 that is less than or equal to
          segCount. For example, if segCount=39, we have the
          following:</para>


        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="10pc"/>
            <colspec colwidth="10pc"/>
            <tbody>
              <row>
                <entry>segCountX2</entry>
                <entry>78</entry>
                <entry></entry>
              </row>
              <row>
                <entry>searchRange</entry>
                <entry>64</entry>
                <entry>(2 * largest power of 2 &lt;=39)</entry>
              </row>
              <row>
                <entry>entrySelector</entry>
                <entry>5</entry>
                <entry>log2 (32)</entry>
              </row>
              <row>
                <entry>rangeShift</entry>
                <entry>14</entry>
                <entry>2 x 39 - 64</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>Each segment is described by a startCode and endCode,
          along with an idDelta and an idRangeOffset, which are used
          for mapping the character codes in the segment. The segments
          are sorted in order of increasing endCode values, and the
          segment values are specified in four parallel arrays. You
          search for the first endCode that is greater than or equal
          to the character code you want to map. If the corresponding
          startCode is less than or equal to the character code, then
          you use the corresponding idDelta and idRangeOffset to map
          the character code to a glyph index (otherwise, the
          missingGlyph is returned). For the search to terminate, the
          final endCode value must be 0xFFFF. This segment need not
          contain any valid mappings. (It can just map the single
          character code 0xFFFF to missingGlyph). However, the segment
          must be present.</para>

        <para>If the idRangeOffset value for the segment is not 0, the
          mapping of character codes relies on glyphIdArray. The
          character code offset from startCode is added to the
          idRangeOffset value. This sum is used as an offset from the
          current location within idRangeOffset itself to index out
          the correct glyphIdArray value. This obscure indexing trick
          works because glyphIdArray immediately follows idRangeOffset
          in the font file. The C expression that yields the glyph
          index is:</para>

    <literallayout>
  *(idRangeOffset[i]/2
    + (c - startCount[i])
    + &amp;idRangeOffset[i])
    </literallayout>

        <para>The value c is the character code in question, and i is
          the segment index in which c appears. If the value obtained
          from the indexing operation is not 0 (which indicates
          missingGlyph), idDelta[i] is added to it to get the glyph
          index. The idDelta arithmetic is modulo 65536.</para>

        <para>If the idRangeOffset is 0, the idDelta value is added
          directly to the character code offset (i.e. idDelta[i] + c)
          to get the corresponding glyph index. Again, the idDelta
          arithmetic is modulo 65536.</para>

        <para>As an example, the variant part of the table to map
          characters 10-20, 30-90, and 153-480 onto a contiguous range
          of glyph indices may look like this:</para>

        <informaltable>
          <tgroup cols='5'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <tbody>
              <row>
                <entry>segCountX2:</entry>
                <entry>8</entry>
                <entry></entry>
                <entry></entry>
                <entry></entry>
              </row>
              <row>
                <entry>searchRange:</entry>
                <entry>8</entry>
                <entry></entry>
                <entry></entry>
                <entry></entry>
              </row>
              <row>
                <entry>entrySelector:</entry>
                <entry>4</entry>
                <entry></entry>
                <entry></entry>
                <entry></entry>
              </row>
              <row>
                <entry>rangeShift:</entry>
                <entry>0</entry>
                <entry></entry>
                <entry></entry>
                <entry></entry>
              </row>
              <row>
                <entry>endCode:</entry>
                <entry>20</entry>
                <entry>90</entry>
                <entry>480</entry>
                <entry>0Xffff</entry>
              </row>
              <row>
                <entry>reservedPad:</entry>
                <entry>0</entry>
                <entry></entry>
                <entry></entry>
                <entry></entry>
              </row>
              <row>
                <entry>startCode:</entry>
                <entry>10</entry>
                <entry>30</entry>
                <entry>153</entry>
                <entry>0Xffff</entry>
              </row>
              <row>
                <entry>idDelta:</entry>
                <entry>-9</entry>
                <entry>-18</entry>
                <entry>-27</entry>
                <entry>1</entry>
              </row>
              <row>
                <entry>idRangeOffset:</entry>
                <entry>0</entry>
                <entry>0</entry>
                <entry>0</entry>
                <entry>0</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>This table performs the following mappings:</para>

    <literallayout>
10 -> 10 - 9 = 1
20 -> 20 - 9 = 11
30 -> 30 - 18 = 12
90 -> 90 - 18 = 72
...and so on.
</literallayout>

        <para>Note that the delta values could be reworked so as to
          reorder the segments.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The first sentence should probably be changed to
        "... for fonts that support Unicode BMP characters".</para>

        <para>In the table that describes the fields, it seems that
          the fields startCount and endCount should instead be
          startCode and endCode. These are better names, and are the
          names used in the text.</para>

        <para>In the example, the idDelta of the third range should
          probably be -80, so that the character code 153 is mapped to
          the glyphID 153-80 = 73.</para>

        <para>The meaning of the last sentence escapes me. May be it
        should be removed?</para>

        <para>It seems a necessary property of this format that the
          segments be disjoint, yet it is not mentionned
          explicitly.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  cmapsubtable |=
    attribute format { "4" },

    ((element segment {
        attribute startCode { text },
        attribute endCode { text },
        attribute idDelta { text },
        attribute idRangeOffset { text }}*,

      element glyphIndex {
        attribute v { text }})
    |
     (element map {
        attribute code { text },
        attribute glyph { text }}*))
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>We have three cases to consider: when the cmap is empty;
          when it is described by <sgmltag>segment</sgmltag> elements;
          and when it is described by <sgmltag>map</sgmltag>
          elements.</para>

<code-fragment id='cmap.methods'>
  <code-title>Method to compile a format 4 cmap</code-title>
  private Block format4FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();
    if (children.getLength () == 0) {
      <code-include linkend='compileCmapFormat4.empty'/> }
    else if ("segment".equals (((Element)children.item (0)).getTagName ())) {
      <code-include linkend='compileCmapFormat4.segments'/> }
    else {
      <code-include linkend='compileCmapFormat4.maps'/> }
  }
</code-fragment>

        <para>The empty cmap case is fairly straightforward:</para>

<code-fragment id='compileCmapFormat4.empty'>
  <code-title>Generate empty format 4 cmap</code-title>
{   int segCount = 1;
    int segCountX2 = 2;
    int searchRange = 1;
    int entrySelector = 0;
    int rangeShift = 1;

    int length = 24;
    Block me = new Block (length, 0);
    me.setuint16 (0, 4);
    me.setuint16 (2, length);
    me.setuint16 (4, language);
    me.setuint16 (6, segCountX2);
    me.setuint16 (8, searchRange);
    me.setuint16 (10, entrySelector);
    me.setuint16 (12, rangeShift);

    me.setuint16 (14, 0xffff);
    me.setuint16 (16, 0); // reservedPad
    me.setuint16 (18, 0xffff);
    me.setint16  (20, 1);
    me.setuint16 (22, 0);

    return me; }
</code-fragment>


<code-fragment id="compileCmapFormat4.maps">
  <code-title>Generate format 4 cmap from maps</code-title>
{ int[] m = new int [0x10000];     // char -> gid

  for (int i = 0; i &lt; 0x10000; i++) {
    m [i] = 0; }

    NodeList maps = t.getChildNodes ();
    for (int i = 0; i &lt; maps.getLength (); i++) {
      Element e = (Element) maps.item (i);
      int charcode = Integer.decode (e.getAttribute ("code")).intValue ();
      int glyphid  = Integer.decode (e.getAttribute ("glyph")).intValue ();
      String c = e.getAttribute ("count");
      int count;
      if (c.equals ("")) {
         count = 1; }
      else {
         count = Integer.decode (c).intValue (); }

      for (int j = charcode; j &lt; charcode + count; j++) {
        m [j] = glyphid++; }}

    int segCount = 0;
    int glyphIdArraySize = 0;

    class Segment {
      int start;
      int end;
      boolean consecutive; }

    Segment[] segments = new Segment [0x10000];

    int current = 0;
    while (current &lt; 0x10000) {
      while (current &lt; 0x10000 &amp;&amp; m [current] == 0) {
        current++; }

      if (current == 0x10000) {
        break; }

      int first = current;
      boolean consecutive = true;

      current++;
      while (current &lt; 0x10000 &amp;&amp; m [current] != 0) {
        if (m[current] != m[current-1] + 1) {
          consecutive = false; }
        current++; }

      segments [segCount] = new Segment ();
      segments [segCount].start = first;
      segments [segCount].end = current - 1;
      segments [segCount].consecutive = consecutive;
      if (! consecutive) {
        glyphIdArraySize += current - first; }
      segCount++; }

    if (m [0xffff] == 0) {
      segments [segCount] = new Segment ();
      segments [segCount].start = 0xffff;
      segments [segCount].end = 0xffff;
      segments [segCount].consecutive = true;
      segCount++; }

    int segCountX2 = segCount * 2;
    int searchRange = 1;
    int entrySelector = -1;
    while (searchRange &lt; segCount) {
      searchRange *= 2;
      entrySelector++; }
    int rangeShift = 2 * segCount - searchRange;

    int length = 16 + 8*segCount + glyphIdArraySize*2;
    Block me = new Block (length, 0);
    me.setuint16 (0, 4);
    me.setuint16 (2, length);
    me.setuint16 (4, language);
    me.setuint16 (6, segCountX2);
    me.setuint16 (8, searchRange);
    me.setuint16 (10, entrySelector);
    me.setuint16 (12, rangeShift);

    int offset = 14;
    int glyphIdArrayOffset = 16 + 8 * segCount;;

    for (int i = 0; i &lt; segCount; i++) {
      me.setuint16 (offset, segments [i].end);
      me.setuint16 (offset + 2 + 2*segCount, segments [i].start);

      if (segments [i].consecutive) {
        int firstCode = segments [i].start;
        me.setint16  (offset + 2 + 4*segCount,
                      (m[firstCode] - firstCode) % 0x10000);
        me.setuint16 (offset + 2 + 6*segCount, 0); }

      else {
        me.setint16  (offset + 2 + 4*segCount, 0);
        me.setuint16 (offset + 2 + 6*segCount,
                      glyphIdArrayOffset - 16 - 6*segCount - 2*i);
        for (int j = segments [i].start; j &lt;= segments [i].end; j++) {
          me.setuint16 (glyphIdArrayOffset, m [j]);
          glyphIdArrayOffset += 2; }}

      offset += 2; }

    me.setuint16 (offset, 0); // reservedPad

    return me; }
</code-fragment>


<code-fragment id='compileCmapFormat4.segments'>
  <code-title>Generate format 4 cmap from segments</code-title>
{   NodeList segments = t.getChildNodes ();
    int glyphIdArraySize = 0;
    int lastEndCode = 0;

    int segCount = segments.getLength () - 1; // omit "glyphIndex" element
    Element glyphIndexElt = (Element) segments.item (segCount);
    int[]  glyphIndexVals = parseIntList (glyphIndexElt.getAttribute ("v"));

    int segCountX2 = segCount * 2;
    int searchRange = 1;
    int entrySelector = 0;
    while (searchRange &lt; segCount) {
      searchRange *= 2;
      entrySelector++; }
    searchRange *= 2;
    int rangeShift = 2 * segCount - searchRange;

    int length = 16 + 8*segCount + glyphIndexVals.length *2;
    Block me = new Block (length, 0);
    me.setuint16 (0, 4);
    me.setuint16 (2, length);
    me.setuint16 (4, language);
    me.setuint16 (6, segCountX2);
    me.setuint16 (8, searchRange);
    me.setuint16 (10, entrySelector);
    me.setuint16 (12, rangeShift);

    int offset = 14;
    int glyphIdArrayOffset = 0;

    for (int i = 0; i &lt; segCount; i++) {
      Element segment = (Element) segments.item (i);

      int startCode = Integer.decode (segment.getAttribute ("startCode")).intValue ();
      int endCode = Integer.decode (segment.getAttribute ("endCode")).intValue ();
      int idDelta = Integer.decode (segment.getAttribute ("idDelta")).intValue ();
      int idRangeOffset = Integer.decode (segment.getAttribute ("idRangeOffset")).intValue ();

      me.setuint16 (offset, endCode);
      me.setuint16 (offset + 2 + 2*segCount, startCode);
      me.setint16 (offset + 2 + 4*segCount, idDelta);
      me.setint16 (offset + 2 + 6*segCount, idRangeOffset);

      offset += 2; }

    me.setuint16 (offset, 0); // reservedPad
    offset += 2;

    offset += 6*segCount; // skip startCount, idDelta and idRangeOffset;

    for (int i = 0; i &lt; glyphIndexVals.length; i++) {
      me.setuint16 (offset, glyphIndexVals [i]);
      offset += 2; }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.decompile.format4.elt'>
  <code-title>Generate elements for the format 4 cmap subtable at 'stOffset'</code-title>
  if (conf.preciseCmap) {
    int segCount = getuint16 (stOffset + 6) / 2;

    for (int s = 0; s &lt; segCount; s++) {
      int endCode = getuint16 (stOffset + 14 + 2*s);
      int startCode = getuint16 (stOffset + 16 + 2*segCount + 2*s);
      int idDelta = getuint16 (stOffset + 16 + 4*segCount + 2*s);
      int idRangeOffset = getuint16 (stOffset + 16 + 6*segCount + 2*s);

      at = new AttributesImpl ();
      at.addAttribute ("", "startCode", "startCode", "CDATA",
    	                 "0x" + Integer.toHexString (startCode));
      at.addAttribute ("", "endCode", "endCode", "CDATA",
    	                 "0x" + Integer.toHexString (endCode));
      at.addAttribute ("", "idDelta", "idDelta", "CDATA",
    	                 "0x" + Integer.toHexString (idDelta));
      at.addAttribute ("", "idRangeOffset", "idRangeOffset", "CDATA",
    	                 "0x" + Integer.toHexString (idRangeOffset));
      conf.ch.element ("segment", at); }


    StringBuilder sb = new StringBuilder ();
    int glyphIndexOffset = stOffset + 16 + 8*segCount;
    int glyphIndexCount = (getuint16 (stOffset + 2) - (16 + 8*segCount)) / 2;
    for (int i = 0; i &lt; glyphIndexCount; i++) {
      sb.append (" ");
      sb.append (getuint16 (glyphIndexOffset + 2*i)); }

    at = new AttributesImpl ();
    at.addAttribute ("", "v", "v", "CDATA", sb.toString ());

    conf.ch.element ("glyphIndex", at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>It should be clear that many of the values in this table
          are computed to be used in a very specific algorithm. On the
          other hand, even is there are 64K ranges (the maximum), a
          simple binary search will get us there in 16 steps. It seems
          hardly worthwhile to recover the algorithm that takes best
          advantage of those values.</para>

        <para>Instead, we use a basic binary search. The invariant of
          the loop is: if there is a segment with index s that covers
          charCode, then min &lt;= s &lt;= max;. This is initially
          true since min and max are the indices of the first and last
          segment. Since the segments are disjoint and ordered it
          remains true across an iteration of the loop. Finally, the
          loop terminates since max - min is reduced at each
          iteration.</para>

<code-fragment id='cmap_format4'>
  <code-title>Return glyph for 'charCode', using format 4 subtable at 'stOffset'</code-title>
  { int segCount = getuint16 (stOffset + 6) / 2;
    int min = 0;
    int max = segCount - 1;

    while (min &lt;= max) {
      int s = (min + max) / 2;
      int startCount = getuint16 (stOffset + 16 + 2*segCount + 2*s);
      int endCount = getuint16 (stOffset + 14 + 2*s);

      if (charCode &lt; startCount) {
        max = s - 1; }
      else if (endCount &lt; charCode) {
        min = s + 1; }
      else {
        <code-include linkend='compute_glyphid'/> }}

    return 0; }
</code-fragment>

        <para>Once we have located the segment, we can find the glyph.
          Note that in the C expression given in the specification,
          idRangeOffset is a pointer to a 16 bit quantity; since we
          deal in byte offsets, we need to multiply the increment to
          that pointer by 2.</para>

<code-fragment id='compute_glyphid'>
  <code-title>Return glyph for 'charCode' covered by range 's'</code-title>
  int idRangeOffset = getuint16 (stOffset + 16 + 6*segCount + 2*s);
  int idDelta = getint16 (stOffset + 16 + 4*segCount + 2*s);

  if (idRangeOffset == 0) {
    return (charCode + idDelta) &amp; 0xffff; }

  int offset = stOffset + 16 + 6*segCount + 2*s
                + idRangeOffset
                + 2*(charCode - startCount);
  int glyphIdArrayValue = getuint16 (offset);

  if (glyphIdArrayValue == 0) {
    return 0; }

  return (glyphIdArrayValue + idDelta) &amp; 0xffff;
</code-fragment>

<code-fragment id='cmap_format4_iterator'>
  <code-title>Enumerate mappings in format 4 subtable at stOffset</code-title>
  { java.util.TreeMap&lt;Integer, Integer> m
        = new java.util.TreeMap&lt;Integer, Integer> ();

    int segCount = getuint16 (stOffset + 6) / 2;
    for (int s = 0; s &lt; segCount; s++) {

      int startCount = getuint16 (stOffset + 16 + 2*segCount + 2*s);
      int endCount = getuint16 (stOffset + 14 + 2*s);
      int idRangeOffsetOffset = stOffset + 16 + 6*segCount + 2*s;
      int idRangeOffset = getuint16 (idRangeOffsetOffset);
      int idDelta = getint16 (stOffset + 16 + 4*segCount + 2*s);

      for (int c = startCount; c &lt;= endCount; c++) {
        if (idRangeOffset == 0) {
          int glyphID = (c + idDelta) &amp; 0xffff;
          if (glyphID != 0) {
            if (from &lt;= c &amp;&amp; (c &lt;= to || to == -1)) {
              m.put (c, glyphID); }}}
        else {
          int offset = stOffset + 16 + 6*segCount + 2*s
                        + idRangeOffset
                        + 2*(c - startCount);
          /* offset = offset % 0x10000; */ /* why did we have that ? */
          int glyphIdArrayValue = getuint16 (offset);

          if (glyphIdArrayValue != 0) {
            int glyphID = (glyphIdArrayValue + idDelta) &amp; 0xffff;
            if (glyphID != 0) {
              if (from &lt;= c &amp;&amp; (c &lt;= to || to == -1)) {
                m.put (c, glyphID); }}}}}}

     return m; }
</code-fragment>

<code-fragment id='cmap_format4_inv'>
  <code-title>Return character for 'glyphID', using format 4 subtable at stOffset</code-title>
  { int segCount = getuint16 (stOffset + 6) / 2;

    for (int s = 0; s &lt; segCount; s++) {
      int startCount = getuint16 (stOffset + 16 + 2*segCount + 2*s);
      int endCount = getuint16 (stOffset + 14 + 2*s);
      int idRangeOffsetOffset = stOffset + 16 + 6*segCount + 2*s;
      int idRangeOffset = getuint16 (idRangeOffsetOffset);
      int idDelta = getint16 (stOffset + 16 + 4*segCount + 2*s);

      if (idRangeOffset == 0) {
        int charCode = (glyphID - idDelta) &amp; 0xffff;
        if (startCount &lt;= charCode &amp;&amp; charCode &lt;= endCount) {
          return charCode; }}
      else {
        int glyphOffset = idRangeOffsetOffset + idRangeOffset;
        int lastGlyphOffset = glyphOffset + 2 * (endCount - startCount);
        int charCode = startCount;

        while (glyphOffset &lt;= lastGlyphOffset) {
          if (glyphID == getuint16 (glyphOffset)) {
            return charCode; }
          charCode++;
          glyphOffset += 2; }}}

    return -1; }
</code-fragment>

<code-fragment id='cmap_format4_inv2'>
  <code-title>Fill 'v' with characters for 'glyphID', using format 4 subtable at stOffset</code-title>
  { int segCount = getuint16 (stOffset + 6) / 2;

    for (int s = 0; s &lt; segCount; s++) {
      int startCount = getuint16 (stOffset + 16 + 2*segCount + 2*s);
      int endCount = getuint16 (stOffset + 14 + 2*s);
      int idRangeOffsetOffset = stOffset + 16 + 6*segCount + 2*s;
      int idRangeOffset = getuint16 (idRangeOffsetOffset);
      int idDelta = getint16 (stOffset + 16 + 4*segCount + 2*s);

      if (idRangeOffset == 0) {
        int charCode = (glyphID - idDelta) &amp; 0xffff;
        if (startCount &lt;= charCode &amp;&amp; charCode &lt;= endCount) {
          v.add (new Integer (charCode)); }}
      else {
        int glyphOffset = idRangeOffsetOffset + idRangeOffset;
        int lastGlyphOffset = glyphOffset + 2 * (endCount - startCount);
        int charCode = startCount;

        while (glyphOffset &lt;= lastGlyphOffset) {
          if (glyphID == getuint16 (glyphOffset)) {
            v.add (new Integer (charCode)); }
          charCode++;
          glyphOffset += 2; }}}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap4_font1: basic test</title>

          <para>Let&#x2019;s start with a simple case:</para>

<aots:test-font id='cmap4_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format="4">
	<segment startCode='17' endCode='30'
		 idDelta='23' idRangeOffset='0'/>
	<segment startCode='200' endCode='210'
		 idDelta='56' idRangeOffset='0'/>
	<glyphIndex v=''/>
    </mapping>
  </cmap>
</aots:test-font>

	  <aots:cmap-test id='cmap4_test1' font='cmap4_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 16, 17, 18, 30, 31, 199, 200, 205, 210, 211, 0xffff'
            outputs='0,  0,  0, 40, 41, 53,  0,   0, 256, 261, 266,   0,      0'/>
        </section>

        <section>
          <title>cmap4_font2,3: boundary cases</title>

          <para>The first boundary case is when the cmap is as empty
          as possible, i.e. with a single segment for 0xffff. Since
          the compiler takes care of adding such a segment, it means
          no segments in the XML declaration:</para>

<aots:test-font id='cmap4_font2'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='4'/>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap4_test2' font='cmap4_font2'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 16, 17, 18, 30, 31, 199, 200, 205, 210, 211, 0xffff'
            outputs='0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,      0'/>

          <para>Of course, we can have a single segment for 0xffff,
            but map it to something other than 0: </para>

<aots:test-font id='cmap4_font3'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='4'>
      <segment startCode='65535' endCode='65535' idDelta='-1' idRangeOffset='0'/>
      <glyphIndex v=''/>
    </mapping>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap4_test3' font='cmap4_font3'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 16, 17, 18, 30, 31, 199, 200, 205, 210, 211, 0xffff'
            outputs='0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0, 0xfffe'/>

          <para>Here is a test font specifically for the idDelta modulo
          arithmethic:</para>

<aots:test-font id='cmap4_font4'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='4'>
      <segment startCode='100'   endCode='1000'  idDelta='-500' idRangeOffset='0'/>
      <segment startCode='45000' endCode='45100' idDelta='-500' idRangeOffset='0'/>
      <segment startCode='65000' endCode='65100' idDelta='500' idRangeOffset='0'/>
      <glyphIndex v=''/>
    </mapping>
  </cmap>
</aots:test-font>

          <para>Let's start with the second segment, which deals with
          negative idDelta:</para>

          <aots:cmap-test id='cmap4_test4a' font='cmap4_font4'
			  platformID='3' encodingID='1'
            inputs ='0,  44999, 45000, 45001, 45099, 45100, 45101'
            outputs='0,      0, 44500, 44501, 44599, 44600,     0'/>

          <para>The third segment tests the modulo arithmetic by overflow:</para>

          <aots:cmap-test id='cmap4_test4b' font='cmap4_font4'
			  platformID='3' encodingID='1'
            inputs ='0,  64999, 65000, 65001, 65035, 65036, 65037, 65100, 65101'
            outputs='0,      0, 65500, 65501, 65535,     0,     1,    64,     0'/>

          <para>Finally, the first segment tests both negative idDelta
          and modulo arithmetic by underflow:</para>

          <aots:cmap-test id='cmap4_test4c' font='cmap4_font4'
			  platformID='3' encodingID='1'
            inputs ='0,  99,   100,  499, 500, 501, 1000, 1001'
            outputs='0,  0,  65136, 65535, 0,    1,  500,    0'/>

        </section>
      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

<code-fragment id='validate_cmap_format4'>
  <code-title>Validate cmap 4 subtable at stOffset</code-title>
  if (! claim (stPrefix + " header", stOffset + 2, 12)) {
    break; }

  int stVersion = getuint16 (stOffset + 4);
  if (stVersion > 0) {
    reportError ("cmap@" + stOffset + " table version (" + stVersion
                 + ") not part of the specification"); }

  int length = getuint16 (stOffset + 2);

  int segCountX2 = getuint16 (stOffset + 6);
  if (segCountX2 % 2 != 0) {
    reportError ("cmap@" + stOffset + " segCountX2 is not even");
    break; }
  int segCount = segCountX2 / 2;

  int searchRange = getuint16 (stOffset + 8);
  // verify searchRange = 2 x (2 ^ (log2 (segCount)))

  int entrySelector = getuint16 (stOffset + 10);
  // verify entrySelector = log2 (searchRange/2)

  int rangeShift = getuint16 (stOffset + 12);
  if (rangeShift != segCountX2 - searchRange) {
    reportError ("cmap@" + stOffset + " has wrong rangeShift value"); }

  if (! claim (stPrefix + " data 1",
                     stOffset + 14, segCount * 8 + 2)) {
    break; }

  int lastEndCount = -1;
  int glyphIdSizeNeeded = 0;

  for (int s = 0; s &lt; segCount; s++) {
    int endCount = getuint16 (stOffset + 14 + 2*s);
    int startCount = getuint16 (stOffset + 14 + 2*segCount + 2 + 2*s);

    if (startCount > endCount) {
      reportError ("cmap@" + stOffset + ", range " + s
                   + ", startCount>endCount");
      break; }

    if (startCount &lt;= lastEndCount) {
      reportError ("cmap@" + stOffset + ", range " + s
                   + ", overlaps with previous range"); }
    lastEndCount = endCount;

    int rangeOffset = stOffset + 14 + 6*segCount + 2 + 2*s;
    int range = getuint16 (rangeOffset);

    if (range != 0) {
      claim (stPrefix + " range " + s,
                   rangeOffset + range, 2 * (endCount - startCount + 1)); }}

  if (lastEndCount != 0xffff) {
    reportError ("cmap@" + stOffset + ", last range does not end at 0xffff"); }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 6: Trimmed table mapping </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Format number is set to 6.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>firstCode</otfieldname>
            <otfielddesc>First character code of
              subrange.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>entryCount</otfieldname>
            <otfielddesc>Number of character codes in
              subrange.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphIdArray [entryCount]</otfieldname>
            <otfielddesc>Array of glyph index values for character
              codes in the range. </otfielddesc>
          </otfield>
        </otformat>


        <para>The firstCode and entryCount values specify a subrange
          (beginning at firstCode, length = entryCount) within the
          range of possible character codes. Codes outside of this
          subrange are mapped to glyph index 0. The offset of the code
          (from the first code) within this subrange is used as index
          to the glyphIdArray, which provides the glyph index
          value.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>It is unclear whether the entryCount can be 0. We assume
          it can and recommend to add a sentence to that
          effect.</para>

        <para>This format is very similar to format 0, in that there
          is an explicit list of glyph indices for a contiguous range
          of character code. However, there are two intersting
          properties: the range can be bigger than 256; and more
          importantly, the glyph indices are USHORT instead of
          BYTE. So this format can be used for byte encodings to reach
          glyphs other than the first 256 glyphs.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  cmapsubtable |=
    attribute format { "6" },

    element map {
      attribute code { text },
      attribute glyph { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  private Block format6FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();
    int firstCharCode = 0xffff;
    int lastCharCode = 0;
    java.util.Map&lt;Integer, Integer> m
          = new java.util.HashMap&lt;Integer, Integer> ();

    if (children.getLength () == 0) {
      firstCharCode = 0;
      lastCharCode = -1; }

    else {
      for (int i = 0; i &lt; children.getLength (); i++) {
        Element map = (Element) children.item (i);
        int charcode = Integer.decode (map.getAttribute ("code")).intValue ();
        int glyphid = Integer.decode (map.getAttribute ("glyph")).intValue ();

        if (i == 0) {
          firstCharCode = charcode;
          lastCharCode = charcode; }
        else {
          firstCharCode = Math.min (charcode, firstCharCode);
          lastCharCode = Math.max (charcode, lastCharCode); }

        if (m.put (charcode, glyphid) != null) {
          warning ("duplicate charcode in cmap format6 (0x"
                    + Integer.toHexString (charcode) + ")"); }}

      for (int i = firstCharCode; i &lt;= lastCharCode; i++) {
        if (! m.containsKey (i)) {
          //warning ("no entry for charcode " + i + " in cmap format 6");
          m.put (i, 0); }}}

    int length = 10 + (lastCharCode - firstCharCode + 1)*2;
    Block b = new Block (length, 0);

    b.setuint16 (0, 6);
    b.setuint16 (2, length);
    b.setuint16 (4, language);
    b.setuint16 (6, firstCharCode);
    b.setuint16 (8, lastCharCode - firstCharCode + 1);
    int offset = 10;
    for (int i = firstCharCode; i &lt;= lastCharCode; i++) {
      int glyphid = m.get (i);
       b.setuint16 (offset, glyphid);
       offset += 2; }

    return b;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.decompile.format6.elt'>
  <code-title>Generate elements for the format 6 cmap subtable at 'stOffset'</code-title>
  if (conf.preciseCmap) {

    int firstCode = getuint16 (stOffset + 6);
    int lastCode = firstCode + getuint16 (stOffset + 8) - 1;
    for (int i = firstCode; i &lt;= lastCode; i++) {
      int glyphID = getuint16 (stOffset + 10 + 2*(i - firstCode));
      at = new AttributesImpl ();
      at.addAttribute ("", "code", "code", "CDATA",
                       "0x" + Integer.toHexString (i));
      at.addAttribute ("", "glyph", "glyph", "CDATA", "" + glyphID);
      conf.ch.element ("map", at); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='cmap_format6'>
  <code-title>Return glyph for 'charCode', using format 6 subtable at 'stOffset'</code-title>
  { int firstCode = getuint16 (stOffset + 6);
    int entryCount = getuint16 (stOffset + 8);

    if (firstCode &lt;= charCode &amp;&amp; charCode &lt; firstCode + entryCount) {
      return getuint16 (stOffset + 10 + (charCode-firstCode)*2); }
    else {
      return 0; }}
</code-fragment>

<code-fragment id='cmap_format6_iterator'>
  <code-title>Enumerate mappings in format 6 subtable at 'stOffset'</code-title>
  { java.util.TreeMap&lt;Integer, Integer> m
      = new java.util.TreeMap&lt;Integer, Integer> ();

    int firstCode = getuint16 (stOffset + 6);
    int entryCount = getuint16 (stOffset + 8);

    for (int i = 0; i &lt; entryCount; i++) {
      int code = firstCode + i;
      if (from &lt;= code &amp;&amp; (code &lt;= to || to == -1)) {
        m.put (code, getuint16 (stOffset + 10 + i*2)); }}

    return m; }
</code-fragment>

<code-fragment id='cmap_format6_inv'>
  <code-title>Return character for 'glyphID', using format 6 subtable at stOffset</code-title>
  { int firstCode = getuint16 (stOffset + 6);
    int entryCount = getuint16 (stOffset + 8);

    for (int i = 0; i &lt; entryCount; i++) {
      if (getuint16 (stOffset + 6 + 2*i) == glyphID) {
        return firstCode + i; }}

    return -1; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap6_font1: basic test</title>

          <para>Let's start with a simple case:</para>

<aots:test-font id='cmap6_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='6'>
      <map code="34" glyph="17"/>
      <map code="35" glyph="56"/>
      <map code="36" glyph="12"/>
    </mapping>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap6_test1' font='cmap6_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 33, 34, 35, 36, 37, 0xffff'
            outputs='0,  0,  0, 17, 56, 12,  0,      0'/>
        </section>


        <section>
          <title>cmap6_font2: boundary case entrycount=0 test</title>

          <para>Here we test the case where entryCount is 0:</para>

<aots:test-font id='cmap6_font2'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='6'/>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap6_test2' font='cmap6_font2'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 33, 34, 35, 36, 37, 0xffff'
            outputs='0,  0,  0,  0,  0,  0,  0,      0'/>
        </section>
      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

<code-fragment id='validate_cmap_format6'>
  <code-title>Validate cmap 6 subtable at stOffset</code-title>
  if (! claim (stPrefix + " header", stOffset + 2, 8)) {
    break; }

  int stVersion = getuint16 (stOffset + 4);
  if (stVersion > 0) {
    reportError ("cmap@" + stOffset + " table version (" + stVersion
                 + ") not part of the specification"); }

  int length = getuint16 (stOffset + 2);

  int firstCode = getuint16 (stOffset + 6);
  int entryCount = getuint16 (stOffset + 8);

  if (length != 2*entryCount + 10) {
    reportError ("cmap subtable at " + stOffset + " has wrong length"); }

  claim (stPrefix + " glyphIdArray", stOffset + 10, 2*entryCount);
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Supporting 4-byte character codes</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>While the four existing <ottable>cmap</ottable> subtable formats which
          currently exist have served us well, the introduction of the
          Surrogates Area in Unicode 2.0 has stressed them past the
          point of utility. This section specifies three formats,
          format 8, 10 and 12; which directly support 4-byte character
          codes. A major change introduced with these three formats is
          a more pure 32-bit orientation. The <ottable>cmap</ottable> table version
          number will continue to be 0x0000, for those fonts that make
          use of these formats.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>A better formulation in the first sentence could be
        "... the introduction of supplemental characters in Unicode
        2.0..."</para>

        <para>The semicolon after "12" should be changed to a
        comma.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 8: mixed 16-bit and 32-bit coverage</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 8 is a bit like format 2, in that it provides for
          mixed-length character codes. If a font contains characters
          from the Unicode Surrogates Area (U+D800-U+DFFF), which are
          UCS-4 characters; it's likely that it will also include
          other, regular 16-bit Unicodes as well. We therefore need a
          format to map a mixture of 16-bit and 32-bit character
          codes, just as format 2 allows a mixture of 8-bit and 16-bit
          codes. A simplifying assumption is made: namely, that there
          are no 32-bit character codes which share the same first 16
          bits as any 16-bit character code. This means that the
          determination as to whether a particular 16-bit value is a
          standalone character code or the start of a 32-bit character
          code can be made by looking at the 16-bit value directly,
          with no further information required.</para>

        <para>Here's the format 8 subtable format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Subtable format; set to 8.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Reserved; set to 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>Byte length of this subtable (including the
              header)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>is32 [8192]</otfieldname>
            <otfielddesc>Tightly packed array of bits (8K bytes total)
              indicating whether the particular 16-bit (index) value
              is the start of a 32-bit character code
                </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8204</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname> nGroups</otfieldname>
            <otfielddesc> Number of groupings which follow
            </otfielddesc>
          </otfield>
        </otformat>

        <para>Here follow the individual groups. Each group has the
          following format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname> startCharCode</otfieldname>
            <otfielddesc> First character code in this group; note
              that if this group is for one or more 16-bit character
              codes (which is determined from the is32 array), this
              32-bit value will have the high 16-bits set to zero
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname> endCharCode</otfieldname>
            <otfielddesc> Last character code in this group; same
              condition as listed above for the startCharCode
                </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname> startGlyphID</otfieldname>
            <otfielddesc> Glyph index corresponding to the starting
              character code </otfielddesc>
          </otfield>
        </otformat>

        <para>A few notes here. The endCharCode is used, rather than a
          count, because comparisons for group matching are usually
          done on an existing character code, and having the
          endCharCode be there explicitly saves the necessity of an
          addition per group. Groups must be sorted by increasing
          startCharCode. A group's endCharCode must be less than the
          startCharCode of the following group, if any.</para>

        <para>To determine if a particular word (cp) is the first half
          of 32-bit code points, one can use an expression such as (
          is32[ cp / 8 ] &amp; ( 1 &lt;&lt; ( 7 - ( cp % 8 ) ) ) ). If this is
          non-zero, then the word is the first half of a 32-bit code
          point.</para>

        <para>0 is not a special value for the high word of a 32-bit
          code point. A font may not have both a glyph for the code
          point 0x0000 and glyphs for code points with a high word of
          0x0000.</para>

        <para>The presence of the packed array of bits indicating
          whether a particular 16-bit value is the start of a 32-bit
          character code is useful even when the font contains no
          glyphs for a particular 16-bit start value. This is because
          the system software often needs to know how many bytes ahead
          the next character begins, even if the current character
          maps to the missing glyph. By including this information
          explicitly in this table, no "secret" knowledge needs to be
          encoded into the OS.</para>

        <para>Although this format might work advantageously on some
          platforms for non-Unicode encodings, Microsoft does not
          support it for Unicode encoded UCS-4 characters.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>First paragraph, second sentence, should be: "If a font
          maps Unicode supplemental characters, it's likely to map
          Unicode BMP characters as well."</para>

        <para>For coherence with the other formats, the description of
          the format field should be "Format number is set to 8" and
          the description of the length field should be "This is the
          length in bytes of the subtable."</para>

        <para>This format is dubious and would probably best be
          deprecated. If For Unicode encodings, it is useful only for
          UTF-16 (the only version that has 16 bit code units), so
          spending 8K bytes to is

If the intent is really for a Unicode encodings,
          then it is known </para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  cmapsubtable |=
    attribute format { "8" },
    attribute singleWords { text },

    ((element group {
        attribute firstCode { text },
        attribute lastCode { text },
        attribute firstGlyph { text }}*)
    |
     (element map {
        attribute code { text },
        attribute glyph { text }}*))
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  private static class Format8Range implements Comparable&lt;Format8Range> {
    int firstCode;
    int lastCode;
    int firstGlyph;

    public int compareTo (Format8Range o) {
      if (firstCode &lt; o.firstCode) {
        return -1; }
      else if (firstCode &lt; o.firstCode) {
        return 0; }
      else {
        return +1; }
    }
  }

  private Block format8FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();

    if (children.getLength () == 0) {
      int blockSize = 12 + 8192 + 4;
      Block me = new Block (blockSize, 0);
      me.setuint16 (0, 8);
      me.setuint16 (2, 0);
      me.setuint32 (4, blockSize);
      me.setuint32 (8, language);
      // TODO deal with is32
      me.setuint32 (12 + 8192, 0);
      return me; }

    else if ("group".equals (((Element) children.item (0)).getTagName ())) {
      Format8Range[] ranges = new Format8Range [children.getLength ()];
      for (int i = 0; i &lt; children.getLength (); i++) {
        Element e = (Element) children.item (i);
	Format8Range range = new Format8Range ();
        range.firstCode = Integer.decode (e.getAttribute ("firstCode")).intValue ();
	range.lastCode = Integer.decode (e.getAttribute ("lastCode")).intValue ();
	range.firstGlyph = Integer.decode (e.getAttribute ("firstGlyph")).intValue ();
	// should verify if there is already a range that overlap with this one
	ranges [i] = range; }
      Arrays.sort (ranges);

      int blockSize = 12 + 8192 + 4 + 12*ranges.length;
      Block me = new Block (blockSize, 0);
      me.setuint16 (0, 8);
      me.setuint16 (2, 0);
      me.setuint32 (4, blockSize);
      me.setuint32 (8, language);
      // TODO deal with is32
      me.setuint32 (12 + 8192, ranges.length);

      int o = 12 + 8192 + 4;
      for (int i = 0; i &lt; ranges.length; i++) {
	me.setuint32 (o, ranges [i].firstCode);
        o += 4;
	me.setuint32 (o, ranges [i].lastCode);
        o += 4;
	me.setuint32 (o, ranges [i].firstGlyph);
        o += 4; }

      return me; }

    else {
      Vector&lt;Format8Range> vRanges = new Vector&lt;Format8Range> ();

      for (int i = 0; i &lt; children.getLength (); i++) {
        Element e = (Element) children.item (i);
	int mapFrom = Integer.decode (e.getAttribute ("code")).intValue ();
	int mapTo = Integer.decode (e.getAttribute ("glyph")).intValue ();

	boolean inserted = false;
	for (Format8Range r : vRanges) {
          if (r.lastCode + 1 == mapFrom
              &amp;&amp; r.firstGlyph + (r.lastCode - r.firstCode) + 1 == mapTo) {
	    r.lastCode++;
	    inserted = true;
	    break; }}

	if (! inserted) {
	  Format8Range r = new Format8Range ();
	  r.firstCode = mapFrom;
	  r.lastCode = mapFrom;
	  r.firstGlyph = mapTo;
	  vRanges.add (r); }}

      Format8Range[] aRanges = vRanges.toArray (new Format8Range [0]);
      Arrays.sort (aRanges);

      int blockSize = 12 + 8192 + 4 + 12*aRanges.length;
      Block me = new Block (blockSize, 0);
      me.setuint16 (0, 8);
      me.setuint16 (2, 0);
      me.setuint32 (4, blockSize);
      me.setuint32 (8, language);
      // TODO deal with is32
      me.setuint32 (12 + 8192, aRanges.length);

      int o = 12 + 8192 + 4;
      for (int i = 0; i &lt; aRanges.length; i++) {
	me.setuint32 (o, aRanges [i].firstCode);
        o += 4;
	me.setuint32 (o, aRanges [i].lastCode);
        o += 4;
	me.setuint32 (o, aRanges [i].firstGlyph);
        o += 4; }

      return me; }
  }
</code-fragment>
      </section>


      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.decompile.format8.att'>
  <code-title>Generate attributes for the format 8 cmap subtable at 'stOffset'</code-title>
  { StringBuilder sb = new StringBuilder ();
    // TODO deal with is32
    at.addAttribute ("", "singleWords", "singleWords", "CDATA", sb.toString ()); }
</code-fragment>

<code-fragment id='cmap.decompile.format8.elt'>
  <code-title>Generate elements for the format 8 cmap subtable at 'stOffset'</code-title>
  if (conf.preciseCmap) {
    int nGroups = getuint32asint (stOffset + 8204,
                                  "cmap subtable, format 8, nGroups is big");

    for (int g = 0; g &lt; nGroups; g++) {

      int startCharCode = getuint32asint (stOffset + 8208 + 12*g,
                                          "cmap subtable, format 8, startCharCode is big");
      int endCharCode = getuint32asint (stOffset + 8208 + 12*g + 4,
                                        "cmap subtable, format 8, endCharCode is big");
      int startGlyphID = getuint32asint (stOffset + 8208 + 12*g + 8,
                                         "cmap subtable, format 8, startGlyphID is big");
      at = new AttributesImpl ();
      at.addAttribute ("", "firstCode", "firstCode", "CDATA",
                       "0x" + Integer.toHexString (startCharCode));
      at.addAttribute ("", "lastCode", "lastCode", "CDATA",
                       "0x" + Integer.toHexString (endCharCode));
      at.addAttribute ("", "firstGlyph", "firstGlyph", "CDATA", "" + startGlyphID);
      conf.ch.element ("group", at); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='cmap_format8'>
  <code-title>Return glyph for 'charCode', using format 8 subtable at 'stOffset'</code-title>
  { int nGroups = getuint32asint (stOffset + 8204,
                                  "cmap subtable, format 8, nGroups is big");
    int min = 0;
    int max = nGroups - 1;

    while (min &lt;= max) {
      int s = (min + max) / 2;
      int startCharCode = getuint32asint (stOffset + 8208 + 12*s,
                                          "cmap subtable, format 8, startCharCode is big");
      int endCharCode = getuint32asint (stOffset + 8208 + 12*s + 4,
                                        "cmap subtable, format 8, endCharCode is big");

      if (charCode &lt; startCharCode) {
        max = s - 1; }
      else if (endCharCode &lt; charCode) {
        min = s + 1; }
      else {
        int startGlyphID = getuint32asint (stOffset + 8208 + 12*s + 8,
                                           "cmap subtable, format 8, startGlyphID is big");
        return charCode - startCharCode + startGlyphID; }}

    return 0; }
</code-fragment>

<code-fragment id='cmap_format8_iterator'>
  <code-title>Enumerate mappings in format 8 subtable at 'stOffset'</code-title>
  { java.util.TreeMap&lt;Integer, Integer> m
        = new java.util.TreeMap&lt;Integer, Integer> ();

    int nGroups = getuint32asint (stOffset + 8204,
                                  "cmap subtable, format 8, nGroups is big");

    for (int g = 0; g &lt; nGroups; g++) {

      int startCharCode = getuint32asint (stOffset + 8208 + 12*g,
                                          "cmap subtable, format 8, startCharCode is big");
      int endCharCode = getuint32asint (stOffset + 8208 + 12*g + 4,
                                        "cmap subtable, format 8, endCharCode is big");
        int startGlyphID = getuint32asint (stOffset + 8208 + 12*g + 8,
                                           "cmap subtable, format 8, startGlyphID is big");

      for (int c = startCharCode; c &lt;= endCharCode; c++) {
        if (from &lt;= c &amp;&amp; (c &lt;= to || to == -1)) {
          m.put (c, startGlyphID + (endCharCode - startCharCode)); }}}

     return m; }

</code-fragment>

<code-fragment id='cmap_format8_inv'>
  <code-title>Return character for 'glyphID', using format 8 subtable at stOffset</code-title>
  { return -1; /* TODO */ }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap8_font1: basic test</title>

          <para>Let's start with a simple case:</para>

<aots:test-font id='cmap8_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='8'
             singleWords='0x000x34 0x35 0x36'>
      <map code="0x34" glyph="17"/>
      <map code="0x35" glyph="56"/>
      <map code="0x36" glyph="12"/>

      <map code='0x8432' glyph='20'/>
      <map code='0x8433' glyph='21'/>
      <map code='0x8434' glyph='22'/>

      <map code='0x9232' glyph='23'/>
      <map code='0x9233' glyph='24'/>
      <map code='0x9234' glyph='25'/>

      <map code='0x109423' glyph='26'/>
      <map code='0x109424' glyph='27'/>
      <map code='0x109425' glyph='32'/>
    </mapping>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap8_test1' font='cmap8_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 0x33, 0x34, 0x35, 0x36, 0x37, 0x8431, 0x8432, 0x8434, 0x9232, 0x109422, 0x109423, 0x109424, 0x109425, 0xffff'
            outputs='0,  0,    0,   17,   56,   12,    0,      0,     20,     22,     23,        0,       26,       27,       32,      0'/>
        </section>

      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 10: Trimmed array</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 10 is a bit like format 6, in that it defines a
        trimmed array for a tight range of 32-bit character
        codes:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Subtable format; set to 10.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Reserved; set to 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>Byte length of this subtable (including the
              header) </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname> startCharCode</otfieldname>
            <otfielddesc> First character code covered </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname> numChars</otfieldname>
            <otfielddesc> Number of character codes covered
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname> glyphs []</otfieldname>
            <otfielddesc> Array of glyph indices for the character
              codes covered </otfielddesc>
          </otfield>
        </otformat>

        <para>This format is not supported by Microsoft.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>For coherence with the other formats, the description of
        the format field should be "Format number is set to 10" and the
        description of the length field should be "This is the length
        in bytes of the subtable."</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  cmapsubtable |=
    attribute format { "10" },

    element map {
      attribute code { text },
      attribute glyph { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  private Block format10FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();
    int firstCharCode = 0xffff;
    int lastCharCode = 0;
    java.util.Map&lt;Integer, Integer> m
          = new java.util.HashMap&lt;Integer, Integer> ();

    if (children.getLength () == 0) {
      firstCharCode = 0;
      lastCharCode = -1; }

    else {
      for (int i = 0; i &lt; children.getLength (); i++) {
        Element map = (Element) children.item (i);
        int charcode = Integer.decode (map.getAttribute ("code")).intValue ();
        int glyphid = Integer.decode (map.getAttribute ("glyph")).intValue ();

        if (i == 0) {
          firstCharCode = charcode;
          lastCharCode = charcode; }
        else {
          firstCharCode = Math.min (charcode, firstCharCode);
          lastCharCode = Math.max (charcode, lastCharCode); }

        if (m.put (charcode, glyphid) != null) {
          warning ("duplicate charcode in cmap format6 (0x"
                    + Integer.toHexString (charcode) + ")"); }}

      for (int i = firstCharCode; i &lt;= lastCharCode; i++) {
        if (! m.containsKey (i)) {
          //warning ("no entry for charcode " + i + " in cmap format 6");
          m.put (i, 0); }}}

    int length = 20 + 2*(lastCharCode - firstCharCode + 1);
    Block b = new Block (length, 0);

    b.setuint16 (0, 10);
    b.setuint16 (2, 0);
    b.setuint32 (4, length);
    b.setuint32 (8, language);
    b.setuint32 (12, firstCharCode);
    b.setuint32 (16, lastCharCode - firstCharCode + 1);
    int offset = 20;
    for (int i = firstCharCode; i &lt;= lastCharCode; i++) {
      int glyphid = m.get (i);
       b.setuint16 (offset, glyphid);
       offset += 2; }

    return b;
  }
</code-fragment>

      </section>
      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.decompile.format10.elt'>
  <code-title>Generate elements for the format 10 cmap subtable at 'stOffset'</code-title>
  if (conf.preciseCmap) {

    int firstCode = getuint32asint (stOffset + 12,
                          "cmap subtable, format 10, firstCode too big");
    int lastCode = firstCode + getuint32asint (stOffset + 16,
                              "cmap subtable, format 10, entryCount too big") - 1;
    for (int i = firstCode; i &lt;= lastCode; i++) {
      int glyphID = getuint16 (stOffset + 20 + 2*(i - firstCode));
      at = new AttributesImpl ();
      at.addAttribute ("", "code", "code", "CDATA",
                       "0x" + Integer.toHexString (i));
      at.addAttribute ("", "glyph", "glyph", "CDATA", "" + glyphID);
      conf.ch.element ("map", at); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='cmap_format10'>
  <code-title>Return glyph for 'charCode', using format 10 subtable at 'stOffset'</code-title>
  { int firstCode = getuint32asint (stOffset + 12,
                             "cmap subtable, format 10, firstCode too big");
    int entryCount = getuint32asint (stOffset + 16,
                             "cmap subtable, format 10, entryCount too big");

    if (firstCode &lt;= charCode &amp;&amp; charCode &lt; firstCode + entryCount) {
      return getuint16 (stOffset + 20 + 2*(charCode-firstCode)); }
    else {
      return 0; }}
</code-fragment>

<code-fragment id='cmap_format10_iterator'>
  <code-title>Enumerate mappings in format 10 subtable at 'stOffset'</code-title>
  { java.util.TreeMap&lt;Integer, Integer> m
      = new java.util.TreeMap&lt;Integer, Integer> ();

    int firstCode = getuint32asint (stOffset + 12,
                            "cmap subtable, format 10, firstCode too big");
    int entryCount = getuint32asint (stOffset + 16,
                            "cmap subtable, format 10, entryCount too big");

    for (int i = 0; i &lt; entryCount; i++) {
      int code = firstCode + i;
      if (from &lt;= code &amp;&amp; (code &lt;= to || to == -1)) {
        m.put (code, getuint16 (stOffset + 20 + 2*i)); }}

    return m; }
</code-fragment>


<code-fragment id='cmap_format10_inv'>
  <code-title>Return character for 'glyphID', using format 10 subtable at stOffset</code-title>
  { int firstCode = getuint32asint (stOffset + 12,
                            "cmap subtable, format 10, firstCode too big");
    int entryCount = getuint32asint (stOffset + 16,
                            "cmap subtable, format 10, entryCount too big");

    for (int i = 0; i &lt; entryCount; i++) {
      if (getuint16 (stOffset + 20 + 2*i) == glyphID) {
        return firstCode + i; }}

    return -1; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap10_font1: basic test</title>

          <para>Let's start with a simple case:</para>

<aots:test-font id='cmap10_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='10'>
      <map code='0x109423' glyph='26'/>
      <map code='0x109424' glyph='27'/>
      <map code='0x109425' glyph='32'/>
    </mapping>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap10_test1' font='cmap10_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 0x9232, 0x109422, 0x109423, 0x109424, 0x109425, 0xffff'
            outputs='0,  0,      0,        0,       26,       27,       32,      0'/>
        </section>


        <section>
          <title>cmap10_font2: boundary case entrycount=0 test</title>

          <para>Here we test the case where entryCount is 0:</para>

<aots:test-font id='cmap10_font2'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format='10'/>
  </cmap>
</aots:test-font>

          <aots:cmap-test id='cmap10_test2' font='cmap10_font2'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 33, 34, 35, 36, 37, 0xffff'
            outputs='0,  0,  0,  0,  0,  0,  0,      0'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 12: Segmented coverage</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This is the Microsoft standard character to glyph index
          mapping table for fonts supporting the UCS-4 characters in
          the Unicode Surrogates Area (U+D800 - U+DFFF). It is a bit
          like format 4, in that it defines segments for sparse
          representation in 4-byte character space. Here's the
          subtable format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Subtable format; set to 12.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Reserved; set to 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>Byte length of this subtable (including the
              header) </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>language</otfieldname>
            <otfielddesc>Please see <link linkend='language_note'>Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>nGroups</otfieldname>
            <otfielddesc>Number of groupings which follow
            </otfielddesc>
          </otfield>
        </otformat>

        <para>Fonts providing Unicode encoded UCS-4 character support
          for Windows 2000 and later, need to have a subtable with
          platform ID 3, platform specific encoding ID 1 in format 4;
          and in addition, need to have a subtable for platform ID 3,
          platform specific encoding ID 10 in format 12. Please note,
          that the content of format 12 subtable, needs to be a super
          set of the content in the format 4 subtable. The format 4
          subtable needs to be in the cmap table to enable backward
          compatibility needs.</para>

        <para>Here follow the individual groups, each of which has the
          following format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>startCharCode</otfieldname>
            <otfielddesc>First character code in this group
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>endCharCode</otfieldname>
            <otfielddesc>Last character code in this group
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>startGlyphID</otfieldname>
            <otfielddesc>Glyph index corresponding to the starting
              character code </otfielddesc>
          </otfield>
        </otformat>

        <para>Groups must be sorted by increasing startCharCode. A
          group's endCharCode must be less than the startCharCode of
          the following group, if any. The endCharCode is used, rather
          than a count, because comparisons for group matching are
          usually done on an existing character code, and having the
          endCharCode be there explicitly saves the necessity of an
          addition per group.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>First paragraph, first sentence should be reworded: "...
          for fonts supporting Unicode supplemental characters."
          Similarly, second paragraph, first sentence should be
          reworded: "Fonts providing support for Unicode supplemental
          characters..."</para>

        <para>For coherence with the other formats, the description of
          the format field should be "Format number is set to 12" and
          the description of the length field should be "This is the
          length in bytes of the subtable."</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  cmapsubtable |=
    attribute format { "12" },

    ((element map {
        attribute code { text },
        attribute glyph { text },
        attribute count { text }}*)

    |(element map {
        attribute code { text },
        attribute glyph { text }}*))
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  private Block format12FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();
    java.util.SortedMap&lt;Integer, Integer> m
          = new java.util.TreeMap&lt;Integer, Integer> ();

    for (int i = 0; i &lt; children.getLength (); i++) {
      Element map = (Element) children.item (i);
      int charcode = Integer.decode (map.getAttribute ("code")).intValue ();
      int glyphid = Integer.decode (map.getAttribute ("glyph")).intValue ();
      String c = map.getAttribute ("count");
      int count;
      if (c.equals ("")) {
         count = 1; }
      else {
         count = Integer.decode (c).intValue (); }

      while (count > 0) {
        if (glyphid != 0) {
          if (m.put (charcode, glyphid) != null) {
            warning ("duplicate charcode in cmap format12 (0x"
                       + Integer.toHexString (charcode) + ")"); }}
        count--;
        charcode++;
        glyphid++; }}

    // count the number of segments
    int groups = 0;
    int previousCp = -1;
    int previousGid = -1;

    for (Integer x : m.keySet ()) {
      int cp = x.intValue ();
      int gid = m.get (x);
      if (previousCp + 1 != cp || previousGid + 1 != gid) {
        groups++; }
      previousCp = cp;
      previousGid = gid; }


    int length = 16 + 12*groups;
    Block b = new Block (length, 0);

    b.setuint16 (0, 12);
    b.setuint16 (2, 0);
    b.setuint32 (4, length);
    b.setuint32 (8, language);
    b.setuint32 (12, groups);

    int offset = 16 - 12;
    previousCp = -1;
    previousGid = -1;

    for (Integer x : m.keySet ()) {
      int cp = x.intValue ();
      int gid = m.get (x);
      if (previousCp + 1 != cp || previousGid + 1 != gid) {
        offset += 12;
        b.setuint32 (offset, cp);
        b.setuint32 (offset + 8, gid); }
      b.setuint32 (offset + 4, cp);
      previousCp = cp;
      previousGid = gid; }

    return b;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.decompile.format12.elt'>
  <code-title>Generate elements for the format 12 cmap subtable at 'stOffset'</code-title>
  if (conf.preciseCmap) {

    long nGroups = getuint32 (stOffset + 12);

    for (int g = 0; g &lt; nGroups; g++) {
      long startCharCode = getuint32 (stOffset + 16 + 12*g);
      long endCharCode = getuint32 (stOffset + 16 + 12*g + 4);
      long startGlyphID = getuint32 (stOffset + 16 + 12*g + 8);

      at = new AttributesImpl ();
      at.addAttribute ("", "code", "code", "CDATA",
                       "0x" + Long.toHexString (startCharCode));
      at.addAttribute ("", "glyph", "glyph", "CDATA",
                       "" + startGlyphID);
      at.addAttribute ("", "count", "count", "CDATA",
                       "" + (endCharCode - startCharCode + 1));
      conf.ch.element ("map", at); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='cmap_format12'>
  <code-title>Return glyph for 'charCode', using format 12 subtable at
     'stOffset'</code-title>
{ int nGroups = (int)getuint32 (stOffset + 12);
  int min = 0;
  int max = nGroups - 1;
  while (min &lt;= max) {
    int s = (min + max) / 2;
    int startCharCode = (int) getuint32 (stOffset + 16 + 12*s);
    int endCharCode = (int) getuint32 (stOffset + 16 + 12*s + 4);

    if (charCode &lt; startCharCode) {
      max = s - 1; }
    else if (endCharCode &lt; charCode) {
      min = s + 1; }
    else {
      int startGlyphID = (int) getuint32 (stOffset + 16 + 12*s + 8);
      return (startGlyphID + (charCode - startCharCode)); }}
  return 0;
}
</code-fragment>

<code-fragment id='cmap_format12_iterator'>
  <code-title>Enumerate mappings in format 12 subtable at stOffset</code-title>
  { java.util.TreeMap&lt;Integer, Integer> m
        = new java.util.TreeMap&lt;Integer, Integer> ();

    int nGroups = (int)getuint32 (stOffset + 12);

    for (int g = 0; g &lt; nGroups; g++) {

      int startCode = (int)getuint32 (stOffset + 16 + 12*g);
      int endCode = (int)getuint32 (stOffset + 16 + 12*g + 4);
      int glyphID = (int)getuint32 (stOffset + 16 + 12*g + 8);

      for (int c = startCode; c &lt;= endCode; c++) {
        if (from &lt;= c &amp;&amp; (c &lt;= to || to == -1)) {
          m.put (c, glyphID); }
        glyphID++; }}

     return m; }
</code-fragment>

<code-fragment id='cmap_format12_inv'>
  <code-title>Return character for 'glyphID', using format 12 subtable
  at stOffset</code-title>
{ int nGroups = (int) getuint32 (stOffset + 12);
  for (int i = 0; i &lt; nGroups; i++) {
    int startCharCode = (int) getuint32 (stOffset + 16 + 12*i);
    int endCharCode = (int) getuint32 (stOffset + 16 + 12*i + 4);
    int startGlyphID = (int) getuint32 (stOffset + 16 + 12*i + 8);

    if (   glyphID >= startGlyphID
        &amp;&amp; (glyphID - startGlyphID) &lt;= (endCharCode - startCharCode)) {
      return (startCharCode + (glyphID - startGlyphID)); }}

  return -1;
}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap12_font1: basic test</title>

          <para>Let&#x2019;s start with a simple case:</para>

<aots:test-font id='cmap12_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format="12">
      <map code='0x101723' glyph='23' count='5'/>
      <map code='0x102523' glyph='53' count='5'/>
    </mapping>
  </cmap>
</aots:test-font>

	  <aots:cmap-test id='cmap12_test1' font='cmap12_font1'
			  platformID='3' encodingID='1'
            inputs ='0,  1, 16, 0x101723, 0x101724, 0x101727, 0x101728, 0x102522, 0x102523, 0x102527, 0x102528, 0xffff'
            outputs='0,  0,  0,       23,       24,       27,        0,        0,       53,       57,        0,      0'/>
        </section>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 14: Unicode Variation Sequences</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Subtable format 14 specifies the Unicode Variation
        Sequences (UVSes) supported by the font. A Variation Sequence,
        according to the Unicode Standard, comprises a base character
        followed by a variation selector; e.g. &lt;U+82A6,
        U+E0101>.</para>

        <para>The subtable partitions the UVSes supported by the font
        into two categories: &#x201C;default&#x201D; and
        &#x201C;non-default&#x201D; UVSes. Given a UVS, if the glyph
        obtained by looking up the base character of that sequence in
        the Unicode cmap subtable (i.e. the UCS-4 or the BMP cmap
        subtable) is the glyph to use for that sequence, then the
        sequence is a &#x201C;default&#x201D; UVS; otherwise it is a
        &#x201C;non-defaultJ=f UVS, and the glyph to use for that
        sequence is specified in the format 14 subtable itself.</para>

        <para>The example below shows how a font vendor can use format
        14 for a JIS-2004-aware font.</para>

        <otformat>
          <title>Format 14 header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Subtable format; set to 14.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>Byte length of this subtable (including the
              header) </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numVarSelectorRecords</otfieldname>
            <otfielddesc>Number of Variation Selector Records</otfielddesc>
          </otfield>
        </otformat>

        <para>This is immediately followed by 'numVarSelectorRecords'
        Variation Selector Records.</para>


        <otformat>
          <title>Variation Selector Record</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>UINT24</otfieldtype>
            <otfieldname>varSelector</otfieldname>
            <otfielddesc>Variation selector</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>3</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>defaultUVSOffset</otfieldname>
            <otfielddesc>Offset to Default UVS Table. May be 0. </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>nonDefaultUVSOffset</otfieldname>
            <otfielddesc>Offset to Non-Default UVS Table. May be 0.</otfielddesc>
          </otfield>
        </otformat>

        <para>The Variation Selector Records are sorted in increasing
        order of 'varSelector'. No two records may have the same
        'varSelector'. All offsets in a record are relative to the
        beginning of the format 14 cmap subtable.</para>

        <para>A Variation Selector Record and the data its offsets
        point to specify those UVSes supported by the font for which
        the variation selector is the 'varSelector' value of the
        record. The base characters of the UVSes are stored in the
        tables pointed to by the offsets. The UVSes are partitioned by
        whether they are default or non-default UVSes.</para>

        <para>Glyph IDs to be used for non-default UVSes are specified
        in the Non-Default UVS table.</para>

        <para>Default UVS Table</para>

        <para>A Default UVS Table is simply a range-compressed list of
        Unicode scalar values, representing the base characters of the
        default UVSes which use the 'varSelector' of the associated
        Variation Selector Record.</para>

        <otformat>
          <title>Default UVS Table header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numUnicodeValueRanges</otfieldname>
            <otfielddesc>Number of ranges that follow</otfielddesc>
          </otfield>
        </otformat>

        <para>This is immediately followed by 'numUnicodeValueRanges'
        Unicode Value Ranges, each of which represents a contiguous
        range of Unicode values.</para>

        <otformat>
          <title>Unicode Value Range</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>UINT24</otfieldtype>
            <otfieldname>startUnicodeValue</otfieldname>
            <otfielddesc>First value in this range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>3</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>additionalCount</otfieldname>
            <otfielddesc>Number of <emphasis>additional</emphasis>
            values in this range</otfielddesc>
          </otfield>
        </otformat>

        <para>For example, the range U+4E4D...U+4E4F (3 values) will
        set 'startUnicodeValue' to 0x004E4D and 'additionalCount' to
        2. A singleton range will set 'additionalCount' to 0.</para>

        <para>('startUnicodeValue' + 'additionalCount') must not
        exceed 0xFFFFFF.</para>

        <para>The Unicode Value Ranges are sorted in increasing order
        of 'startUnicodeValue'. The ranges must not overlap; i.e.,
        ('startUnicodeValue' + 'additionalCount') must be less than
        the 'startUnicodeValue' of the following range (if
        any).</para>

        <para>Non-Default UVS Table</para>

        <para>A Non-Default UVS Table is a list of pairs of Unicode
        scalar values and glyph IDs. The Unicode values represent the
        base characters of all non-default UVSes which use the
        'varSelector' of the associated Variation Selector Record, and
        the glyph IDs specify the glyph IDs to use for the
        UVSes.</para>

        <otformat>
          <title>Non-Default UVS Table header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numUVSMappings</otfieldname>
            <otfielddesc>Number of UVS Mappings that follow</otfielddesc>
          </otfield>
        </otformat>

        <para>This is immediately followed by 'numUVSMappings' UVS
        Mappings.</para>

        <otformat>
          <title>UVS Mapping</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>UINT24</otfieldtype>
            <otfieldname>unicodeValue</otfieldname>
            <otfielddesc>Base Unicode value of the UVS</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>3</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphID</otfieldname>
            <otfielddesc>Glyph ID of the UVS</otfielddesc>
          </otfield>
        </otformat>

        <para>The UVS Mappings are sorted in increasing order of
        'unicodeValue'. No two mappings in this table may have the
        same 'unicodeValue' values.</para>


        <para>Example</para>

        <para>Here is an example of how a format 14 cmap subtable may
        be used in a font that is aware of JIS-2004 variant
        glyphs. The CIDs (character IDs) in this example refer to
        those in the Adobe Character Collection 'Adobe-Japan1', and
        may be assumed to be identical to the glyph IDs in the font in
        our example.</para>

        <para>JIS-2004 changed the default glyph variants for some of
        its code points. For example:</para>

        <para>JIS-90: U+82A6 -> CID 1142</para>
        <para>JIS-2004: U+82A6 -> CID 7961</para>

        <para>Both of these glyph variants are supported through the
        use of UVSes, as the following examples from Unicode's UVS
        registry show:</para>

        <para>U+82A6 U+E0100 -> CID 1142</para>
        <para>U+82A6 U+E0101 -> CID 7961</para>

        <para>If the font wants to support the JIS-2004 variants by
        default, it will:</para>

        <itemizedlist>
          <listitem>
            <para>encode glyph ID 7961 at U+82A6 in the Unicode cmap
            subtable,</para>
          </listitem>
          <listitem>
            <para>specify &lt;U+82A6, U+E0101> in the UVS cmap
            subtable's Default UVS Table ('varSelector' will be
            0x0E0101 and 'defaultUVSOffset' will point to data
            containing a 0x0082A6 Unicode value)</para>
          </listitem>
          <listitem>
            <para>specify &lt;U+82A6, U+E0100> -> glyph ID 1142 in the
            UVS cmap subtable's Non-Default UVS Table ('varSelector'
            will be 0x0E0100 and 'nonDefaultBaseUVOffset' will point
            to data containing a 'unicodeValue' 0x82A6 and 'glyphID'
            1142). </para>
          </listitem>
        </itemizedlist>

        <para>If, however, the font wants to support the JIS-90
        variants by default, it will:</para>

        <itemizedlist>
          <listitem>
            <para>encode glyph ID 1142 at U+82A6 in the Unicode cmap
            subtable,</para> <para>specify &lt;U+82A6, U+E0100> in the
            UVS cmap subtable's Default UVS Table</para>
          </listitem>
          <listitem>
            <para>specify &lt;U+82A6, U+E0101> -> glyph ID 7961 in the
            UVS cmap subtables Non-Default UVS Table </para>
          </listitem>
        </itemizedlist>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>

  defaultUVSTable =
    element defaultMappings {
      element range {
        attribute start { text },
        attribute additionalCount { text }}* }

  standaloneDefaultUVS =
    element defaultUVSTable { attribute id { text }, defaultUVSTable }

  defaultUVSOffset = attribute defaultUVSTable { text } | defaultUVSTable


  nonDefaultUVSTable =
    element nonDefaultMappings {
      element map {
        attribute usv { text },
        attribute gid  { text }}* }

  standaloneNonDefaultUVS =
    element nonDefaultUVSSubtable { attribute id { text }, nonDefaultUVSTable }

  nonDefaultUVSOffset = attribute nonDefaultUVSTable { text } | nonDefaultUVSTable

  cmapsubtable |=
    attribute format { "14" },

    element variation-selector {
      attribute vs { text },
      defaultUVSOffset,
      nonDefaultUVSOffset }*

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cmap.methods'>
  private Block format14FromXML (Element t, int language)
      throws InvalidFontException, UnsupportedFontException {

    NodeList children = t.getChildNodes ();
    int nbSelectors = children.getLength ();
    int length = 10 + nbSelectors * 11;
    java.util.SortedMap&lt;Integer, Integer> m
          = new java.util.TreeMap&lt;Integer, Integer> ();


    Block me = new Block (length, nbSelectors * 2);
    me.setuint16 (0, 14);
    me.setuint32 (6, nbSelectors);
    int totalLength = length;

    for (int i = 0; i &lt; nbSelectors; i++) {
      Element selector = (Element) children.item (i);
      int vs = Integer.decode (selector.getAttribute ("vs")).intValue ();
      int childPosition = 0;
      NodeList c2 = selector.getChildNodes ();

      me.setuint24 (10 + 11*i, vs);

      if (   c2.getLength () > childPosition
          &amp;&amp; "defaultMappings".equals (((Element) c2.item (childPosition)).getTagName ())) {
        NodeList ranges = ((Element) c2.item (0)).getChildNodes ();
        int nbRanges = ranges.getLength ();
        Block defaultUvsBlock = new Block (4 + 4 * nbRanges, 0);
        totalLength += 4 + 4*nbRanges;
        int o = 0;
        defaultUvsBlock.setuint32 (o, nbRanges);
        o += 4;
        for (int r = 0; r &lt; nbRanges; r++) {
          Element range = (Element) ranges.item (r);
          defaultUvsBlock.setuint24 (o,
            Integer.decode (range.getAttribute ("start")).intValue ());
          o += 3;
          defaultUvsBlock.setuint8 (o,
            Integer.decode (range.getAttribute ("additionalCount")).intValue ());
          o += 1; }
        me.setBigOffset (10 + 11*i + 3, defaultUvsBlock);
        childPosition = 1; }
      else {
        me.setBigOffset (10 + 11*i + 3, null); }

      if (c2.getLength () > childPosition) { /* nonDefaultUVS */
        NodeList maps = ((Element) c2.item (childPosition)).getChildNodes ();
        int nbMaps = maps.getLength ();
        Block nonDefaultUvsBlock = new Block (4 + 5 * nbMaps, 0);
        totalLength += 4 + 5*nbMaps;
        int o = 0;
        nonDefaultUvsBlock.setuint32 (o, nbMaps);
        o += 4;
        for (int mapping = 0; mapping &lt; nbMaps; mapping++) {
          Element map = (Element) maps.item (mapping);
          nonDefaultUvsBlock.setuint24 (o,
            Integer.decode (map.getAttribute ("usv")).intValue ());
          o += 3;
          nonDefaultUvsBlock.setuint16 (o,
            Integer.decode (map.getAttribute ("gid")).intValue ());
          o += 2; }
        me.setBigOffset (10 + 11*i + 7, nonDefaultUvsBlock); }
      else {
        me.setBigOffset (10 + 11*i + 7, null); }}

   me.setuint32 (2, totalLength);
   return me;
}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cmap.methods'>
  public void defaultUVSTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void defaultUVSTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (false &amp;&amp; counts [offset] != 1) {
      at.addAttribute ("", "defaultUsvTable", "defaultUsvTable", "CDATA",
                       "defaultUsvTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      defaultUVSTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void defaultUSVTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (false &amp;&amp;  counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "defaultUsvTable_" + Integer.toHexString (offset));
      defaultUVSTableToXMLEmit (conf, offset, counts, "defaultUVSTable", at);
      counts [offset] = 0; }
  }

  protected void defaultUVSTableToXMLEmit (DecompilerConfig conf, int offset,
                                           int[] counts,
                                           String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {
      long nbRanges = getuint32 (offset);
      for (int i = 0; i &lt; nbRanges; i++) {
        int start = getuint24 (offset + 4 + i * 4);
        int additionalCount = getuint8 (offset + 4 + i * 4 + 3);
        at = new AttributesImpl ();
        at.addAttribute ("", "start", "start", "CDATA",
                         "0x" + Integer.toHexString (start));
        at.addAttribute ("", "additionalCount", "additionalCount", "CDATA",
                         "" + additionalCount);
        conf.ch.element ("range", at); }
      conf.ch.endElement (element); }
  }

  public void nonDefaultUVSTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void nonDefaultUVSTableOffsetToXML (DecompilerConfig conf, int offset,
                                             int [] counts,
                                             String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "nonDefaultUsv", "nonDefaultUsv", "CDATA",
                       "nonDefaultUsvTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      nonDefaultUVSTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void nonDefaultUSVTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "nonDefaultUsvTable_" + Integer.toHexString (offset));
      nonDefaultUVSTableToXMLEmit (conf, offset, counts,
                                   "nonDefaultUVSTable", at);
      counts [offset] = 0; }
  }

  protected void nonDefaultUVSTableToXMLEmit (DecompilerConfig conf, int offset,
                                              int[] counts,
                                              String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {


    conf.ch.startElement (element, at); {
      long nbMappings = getuint32 (offset);
      for (int i = 0; i &lt; nbMappings; i++) {
        int usv = getuint24 (offset + 4 + i * 5);
        int gid = getuint16 (offset + 4 + i * 5 + 3);

        at = new AttributesImpl ();
        at.addAttribute ("", "usv", "usv", "CDATA",
                         "0x" + Integer.toHexString (usv));
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        conf.ch.element ("map", at); }
      conf.ch.endElement (element); }
  }
</code-fragment>

<code-fragment id='cmap.decompile.format14.elt'>
  <code-title>Generate elements for the format 14 cmap subtable at 'stOffset'</code-title>

  long numVarSelectorRecords = getuint32 (stOffset + 6);

  if (true || conf.preciseCmap) {
    for (int i = 0; i &lt; numVarSelectorRecords; i++) {
      int vs = getuint24 (stOffset + 10 + i * 11);
      int defaultOffset = getLOffset (stOffset, 10 + i * 11 + 3);
      int nonDefOffset = getLOffset (stOffset, + 10 + i * 11 + 7);
      at = new AttributesImpl ();
      at.addAttribute ("", "vs", "vs", "CDATA", "0x" + Integer.toHexString (vs));
      conf.ch.startElement ("variation-selector", at); {
        if (defaultOffset != 0) {
          at = new AttributesImpl ();
          defaultUVSTableOffsetToXML (conf, defaultOffset, counts, "defaultMappings", at);  }
        if (nonDefOffset != 0) {
          at = new AttributesImpl ();
          nonDefaultUVSTableOffsetToXML (conf, nonDefOffset, counts, "nonDefaultMappings", at); }
        conf.ch.endElement ("variation-selector"); }}}

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='cmap.methods'>
  <code-title>UVS to glyph method</code-title>
  public int uvs2glyph (int charCode, int variationSelector)
    throws UnsupportedFontException {

    int numTables = getuint16 (2);

    for (int st = 0; st &lt; numTables; st++) {
      if (   0 == getuint16 (4 + 8*st)
          &amp;&amp; 5 == getuint16 (4 + 8*st + 2)) {
        int stOffset = getLOffset (0, 4 + 8*st + 4);

        long numVarSelectorRecords = getuint32 (stOffset + 6);

        for (int i = 0; i &lt; numVarSelectorRecords; i++) {
          if (variationSelector == getuint24 (stOffset + 10 + 11*i)) {

            int dOffset = getLOffset (stOffset, 10 + 11*i + 3);

            if (dOffset != 0) {
              long numUnicodeValueRanges = getuint32 (dOffset);

              for (int j = 0; j &lt; numUnicodeValueRanges; j++) {
                int start = getuint24 (dOffset + 4 + 4*j);
                int additionalCount = getuint8 (dOffset + 4 + 4*j + 3);

                if (   start &lt;= charCode
                    &amp;&amp; charCode &lt;= start + additionalCount) {

                  return unicodechar2glyph (charCode); }}}

            int nOffset = getLOffset (stOffset, 10 + 11*i + 7);

            if (nOffset != 0) {
              long numMappings = getuint32 (nOffset);

              for (int j = 0; j &lt; numMappings; j++) {
                if (charCode == getuint24 (nOffset + 4 + 5*j)) {
                  return getuint16 (nOffset + 4 + 5*j + 3); }}}}}}}

    return 0;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>cmap14_font1: basic test</title>

          <para>Let&#x2019;s start with a simple case:</para>

<aots:test-font id='cmap14_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="0" encodingid="5" language="0" format="14">
      <variation-selector vs='0xe0100'>
        <defaultMappings>
          <range start="0x4e00" additionalCount="0"/>
          <range start="0x4e03" additionalCount="3"/>
        </defaultMappings>
        <nonDefaultMappings>
          <map usv="0x4e10" gid="25"/>
          <map usv="0x4e11" gid="26"/>
        </nonDefaultMappings>
      </variation-selector>
    </mapping>
    <mapping platformid="3" encodingid="1" language="0" format="4">
      <map code="0x4e00" glyph="10"/>
      <map code="0x4e01" glyph="11"/>
      <map code="0x4e02" glyph="12"/>
      <map code="0x4e03" glyph="13"/>
      <map code="0x4e04" glyph="14"/>
      <map code="0x4e05" glyph="15"/>
      <map code="0x4e06" glyph="16"/>
      <map code="0x4e07" glyph="17"/>
      <map code="0x4e08" glyph="18"/>
      <map code="0x4e09" glyph="19"/>
    </mapping>
  </cmap>
</aots:test-font>

           <para>Default mappings:</para>

<aots:cmap-uvs-test id='cmap14_test1a' font='cmap14_font1'
   inputs='0x4e00, 0xe0100, 0x4e03, 0xe0100, 0x4e04, 0xe0100'
   outputs='            10,              13,              14'/>

          <para>Non default mappings:</para>

<aots:cmap-uvs-test id='cmap14_test1b' font='cmap14_font1'
   inputs='0x4e10, 0xe0100, 0x4e11, 0xe0100'
   outputs='            25,              26'/>

          <para>Not supported:</para>

<aots:cmap-uvs-test id='cmap14_test1c' font='cmap14_font1'
   inputs='0x4e00, 0xe0101, 0x4e01, 0xe0100'
   outputs='             0,               0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Various test fonts</title>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

	<para>When using a font, a layout system can select to use one or
	another cmap subtable. Here are some fonts to test that process, by
	having various combinations of subtables.</para>

<aots:test-font id='cmap_subtableselection_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="10" language="0" format="0">
      <map code='0x30' glyph='1'/>
    </mapping>
    <mapping platformid="0" encodingid="4" language="0" format="0">
      <map code='0x30' glyph='2'/>
    </mapping>
    <mapping platformid="3" encodingid="1" language="0" format="0">
      <map code='0x30' glyph='3'/>
    </mapping>
    <mapping platformid="0" encodingid="3" language="0" format="0">
      <map code='0x30' glyph='4'/>
    </mapping>
    <mapping platformid="1" encodingid="0" language="0" format="0">
      <map code='0x30' glyph='5'/>
    </mapping>
  </cmap>
</aots:test-font>

<aots:test-font id='cmap_subtableselection_font2'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="0" encodingid="4" language="0" format="0">
      <map code='0x30' glyph='2'/>
    </mapping>
    <mapping platformid="3" encodingid="1" language="0" format="0">
      <map code='0x30' glyph='3'/>
    </mapping>
    <mapping platformid="0" encodingid="3" language="0" format="0">
      <map code='0x30' glyph='4'/>
    </mapping>
    <mapping platformid="1" encodingid="0" language="0" format="0">
      <map code='0x30' glyph='5'/>
    </mapping>
  </cmap>
</aots:test-font>

<aots:test-font id='cmap_subtableselection_font3'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="1" language="0" format="0">
      <map code='0x30' glyph='3'/>
    </mapping>
    <mapping platformid="0" encodingid="3" language="0" format="0">
      <map code='0x30' glyph='4'/>
    </mapping>
    <mapping platformid="1" encodingid="0" language="0" format="0">
      <map code='0x30' glyph='5'/>
    </mapping>
  </cmap>
</aots:test-font>

<aots:test-font id='cmap_subtableselection_font4'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="0" encodingid="3" language="0" format="0">
      <map code='0x30' glyph='4'/>
    </mapping>
    <mapping platformid="1" encodingid="0" language="0" format="0">
      <map code='0x30' glyph='5'/>
    </mapping>
  </cmap>
</aots:test-font>

<aots:test-font id='cmap_subtableselection_font5'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="1" encodingid="0" language="0" format="0">
      <map code='0x30' glyph='5'/>
    </mapping>
  </cmap>
</aots:test-font>

          <para>Another interesting area is composition: when given
          a combining sequence and one of the characters in it cannot
          be mapped, layout engines are supposed to find a precomposed
          character equivalent to that sequence and see if it is mapped.
	  This font maps a few characters which are interesting to test
	  that area.</para>

<aots:test-font id='cmap_composition_font1'>
  <base-font name='base.otf'/>
  <cmap version="0">
    <mapping platformid="3" encodingid="10" language="0" format="12">
      <map code='0x00e9' glyph='5' count='1'/>
      <map code='0x1ec3' glyph='6' count='1'/>
      <map code='0x1fad' glyph='7' count='1'/>
      <map code='0x2adc' glyph='8' count='1'/>
      <map code='0x1d163' glyph='9' count='1'/>
    </mapping>
  </cmap>
</aots:test-font>

        </section>
      </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.head'>
    <title>head - Font Header</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table gives global information about the font. The
          bounding box values should be computed using
          <emphasis>only</emphasis> glyphs that have contours. Glyphs
          with no contours should be ignored for the purposes of these
          calculations.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Table version number</otfieldname>
            <otfielddesc>0x00010000 for version 1.0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>fontRevision</otfieldname>
            <otfielddesc>Set by font manufacturer.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>checkSumAdjustment</otfieldname>
            <otfielddesc>To compute: set it to 0, sum the entire font
              as ULONG, then store 0xB1B0AFBA - sum.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>magicNumber</otfieldname>
            <otfielddesc>Set to 0x5F0F3CF5.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>flags</otfieldname>
            <otfielddesc><simplelist>
                <member>Bit 0: baseline for font at y=0;</member>
                <member>Bit 1: left sidebearing at x=0;</member>
                <member>Bit 2: instructions may depend on point
                  size;</member>
                <member>Bit 3: force ppem to integer values for all internal
                  scaler math; may use fractional ppem sizes if this bit is
                  clear;</member>
                <member>Bit 4: instructions may alter advance width (the
                  advance widths might not scale linearly);</member>
                <member>Bits 5-10: These should be set according to
                  <ulink
                    url="http://developer.apple.com/fonts/TTRefMan/RM06/Chap6head.html">Apple's specification</ulink>. However, they are not
                  implemented in OpenType.</member>
                <member>Bit 11: font data is 'lossless,' as a result of
                  having been compressed and decompressed with the Agfa
                  MicroType Express engine.</member>
                <member>Bit 12: font converted (produce compatible
                  metrics).</member>
                <member>Bit 13: Font optimized for ClearType.</member>
                <member>Bit 14: Reserved, set to 0.</member>
                <member>Bit 15: Reserved, set to 0.</member>
              </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>unitsPerEm</otfieldname>
            <otfielddesc>Valid range is from 16 to
              16384. This value should be a power of 2 for fonts that
            have TrueType outlines.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>LONGDATETIME</otfieldtype>
            <otfieldname>created</otfieldname>
            <otfielddesc>Number of seconds since 12:00 midnight,
              January 1, 1904. 64-bit integer.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>LONGDATETIME</otfieldtype>
            <otfieldname>modified</otfieldname>
            <otfielddesc>Number of seconds since 12:00 midnight,
              January 1, 1904. 64-bit integer.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>40</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xMin</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>42</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMin</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>44</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xMax</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>46</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMax</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>48</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>macStyle</otfieldname>
            <otfielddesc>
	      <simplelist>
		<member>Bit 0: Bold (if set to 1);</member>
		<member>Bit 1: Italic (if set to 1)</member>
		<member>Bit 2: Underline (if set to 1)</member>
		<member>Bit 3: Outline (if set to 1)</member>
		<member>Bit 4: Shadow (if set to 1)</member>
		<member>Bit 5: Condensed (if set to 1)</member>
		<member>Bit 6: Extended (if set to 1)</member>
		<member>Bits 7-15: Reserved (set to 0)</member>
	      </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>50</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>lowestRecPPEM</otfieldname>
            <otfielddesc>Smallest readable size in
              pixels.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>52</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>fontDirectionHint</otfieldname>
            <otfielddesc>
                  <simplelist>
                    <member>0: Fully mixed directional
                      glyphs;</member>
                    <member>1: Only strongly left to right;</member>
                    <member>2: Like 1 but also contains
                      neutrals;</member>
                    <member>-1: Only strongly right to left;</member>
                    <member>-2: Like -1 but also contains
                      neutrals<footnote>
                        <para>A neutral character has no inherent
                          directionality; it is not a character with
                          zero (0) width. Spaces and punctuation are
                          examples of neutral characters. Non-neutral
                          characters are those with inherent
                          directionality. For example, Roman letters
                          (left-to-right) and Arabic
                          letters(right-to-left) have directionality.
                          In a "normal" Roman font where spaces and
                          punctuation are present, the font direction
                          hints should be set to two (2).</para>
                      </footnote>.</member>
                  </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>54</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>indexToLocFormat</otfieldname>
            <otfielddesc>0 for short offsets, 1 for
              long.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>56</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>glyphDataFormat</otfieldname>
            <otfielddesc>0 for current format.</otfielddesc>
          </otfield>
        </otformat>

        <para></para>


        <para>Note that macStyle bits must agree with the
          <ottable>OS/2</ottable> table fsSelection bits. The
          fsSelection bits are used over the macStyle bits in
          Microsoft Windows. The PANOSE values and
          <ottable>post</ottable> table values are ignored for
          determining bold or italic fonts.</para>

        <para>For historical reasons, the fontRevision value contained
          in this table is not used by Windows to determine the
          version of a font. Instead, Windows evaluates the version
          string (id 5) in the <ottable>name</ottable> table.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>It seems that Table version number is set to 'OTTO' for
          CFF based fonts.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
head =
  element head {
    attribute major { text },
    attribute minor { text },
    element fontRevision {
      attribute major { text },
      attribute minor { text }
    },
    element flags {
      attribute baseline_at_0 { yesOrNo },
      attribute lsb_at_0 { yesOrNo },
      attribute instructions_vary_with_point_size { yesOrNo },
      attribute use_integral_ppem { yesOrNo },
      attribute instructions_alter_advance_width { yesOrNo },
      attribute lossless { yesOrNo },
      attribute converted { yesOrNo },
      attribute optimized_for_cleartype { yesOrNo }
    },
    element unitsPerEm {
      attribute v { text }
    },
    element dates {
      attribute created { text },
      attribute modified { text }
    },
    element bbox {
      attribute xMin { text },
      attribute yMin { text },
      attribute xMax { text },
      attribute yMax { text }
    },
    element macStyle {
      attribute bold { yesOrNo },
      attribute italic { yesOrNo }
    },
    element lowestRecPPEM {
      attribute v { text }
    },
    element fontDirectionHint {
      attribute v { text }
    },
    element indexToLocFormat {
      attribute v { text }
    }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='head.methods'>
  public void fromXML (Element head)
      throws InvalidFontException, UnsupportedFontException {

    data = new byte [54];

    { int major = Integer.decode (head.getAttribute ("major")).intValue ();
      int minor = Integer.decode (head.getAttribute ("minor")).intValue ();
      setTableVersion (major, minor); }

    NodeList children = head.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if ("fontRevision".equals (e.getTagName ())) {
        int major = Integer.decode (e.getAttribute ("major")).intValue ();
        int minor = Integer.decode (e.getAttribute ("minor")).intValue ();
        setFontRevision (major, minor); }

      else if ("flags".equals (e.getTagName ())) {
        Flags flags = new Flags ();
        flags.baseline_at_0
           = "yes".equals (e.getAttribute ("baseline_at_0"));
        flags.lsb_at_0
           = "yes".equals (e.getAttribute ("lsb_at_0"));
        flags.instructions_vary_with_point_size
           = "yes".equals (e.getAttribute ("instructions_vary_with_point_size"));
        flags.use_integral_ppem
           = "yes".equals (e.getAttribute ("use_integral_ppem"));
        flags.instructions_alter_advance_width
           = "yes".equals (e.getAttribute ("instructions_alter_advance_width"));
        flags.lossless
           = "yes".equals (e.getAttribute ("lossless"));
        flags.converted
           = "yes".equals (e.getAttribute ("converted"));
        flags.optimized_for_cleartype
           = "yes".equals (e.getAttribute ("optimized_for_cleartype"));
        setFlags (flags); }

      else if ("unitsPerEm".equals (e.getTagName ())) {
        int upem = Integer.decode (e.getAttribute ("v")).intValue ();
        setUnitsPerEm (upem); }

      else if ("dates".equals (e.getTagName ())) {
        java.text.DateFormat df
          = java.text.DateFormat.getDateTimeInstance (java.text.DateFormat.LONG,
                                                      java.text.DateFormat.LONG);
        try {
          java.util.Date created = df.parse (e.getAttribute ("created"));
          setCreated (created); }
        catch (java.text.ParseException ex) {
          throw new InvalidFontException ("incorrect date/time for head.created"); }

        try {
	  java.util.Date modified = df.parse (e.getAttribute ("modified"));
	  setModified (modified); }
        catch (java.text.ParseException ex) {
          throw new InvalidFontException ("incorrect date/time for head.modified"); }}


      else if ("bbox".equals (e.getTagName ())) {
        Bbox b = new Bbox ();
        b.xMin = Integer.decode (e.getAttribute ("xMin")).intValue ();
        b.yMin = Integer.decode (e.getAttribute ("yMin")).intValue ();
        b.xMax = Integer.decode (e.getAttribute ("xMax")).intValue ();
        b.yMax = Integer.decode (e.getAttribute ("yMax")).intValue ();
        setBbox (b); }

      else if ("macStyle".equals (e.getTagName ())) {
        MacStyle macStyle = new MacStyle ();
        macStyle.bold = "yes".equals (e.getAttribute ("bold"));
        macStyle.italic = "yes".equals (e.getAttribute ("italic"));
        setMacStyle (macStyle); }

      else if ("lowestRecPPEM".equals (e.getTagName ())) {
        int rpem = Integer.decode (e.getAttribute ("v")).intValue ();
        setLowestRecPPEM (rpem); }

      else if ("fontDirectionHint".equals (e.getTagName ())) {
        int hint = Integer.decode (e.getAttribute ("v")).intValue ();
        setFontDirectionHint (hint); }

      else if ("indexToLocFormat".equals (e.getTagName ())) {
        int o = Integer.decode (e.getAttribute ("v")).intValue ();
        setIndexToLocFormat (o); }}

      setuint32 (12, 0x5f0f3cf5); // magicNumber
//    setint16 (52, 0); // glyphDataFormat
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='head.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);
    conf.ch.startElement ("head", at); {

      int [] fontRevision = getFontRevision ();
      at = new AttributesImpl ();
      at.addAttribute ("", "major", "major", "CDATA", "" + fontRevision [0]);
      at.addAttribute ("", "minor", "minor", "CDATA", "" + fontRevision [1]);
      conf.ch.element ("fontRevision", at);

      Flags flags = getFlags ();
      at = new AttributesImpl ();
      at.addAttribute ("", "baseline_at_0", "baseline_at_0", "CDATA",
                       flags.baseline_at_0 ? "yes" : "no");
      at.addAttribute ("", "lsb_at_0", "lsb_at_0", "CDATA",
                       flags.lsb_at_0 ? "yes" : "no");
      at.addAttribute ("", "instructions_vary_with_point_size", "instructions_vary_with_point_size", "CDATA",
                       flags.instructions_vary_with_point_size ? "yes" : "no");
      at.addAttribute ("", "use_integral_ppem", "use_integral_ppem", "CDATA",
                       flags.use_integral_ppem ? "yes" : "no");
      at.addAttribute ("", "instructions_alter_advance_width", "instructions_alter_advance_width", "CDATA",
                       flags.instructions_alter_advance_width ? "yes" : "no");
      at.addAttribute ("", "lossless", "lossless", "CDATA",
                       flags.lossless ? "yes" : "no");
      at.addAttribute ("", "converted", "converted", "CDATA",
                       flags.converted ? "yes" : "no");
      at.addAttribute ("", "optimized_for_cleartype", "optimized_for_cleartype", "CDATA",
                       flags.optimized_for_cleartype? "yes" : "no");
      conf.ch.element ("flags", at);


      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getUnitsPerEm ());
      conf.ch.element  ("unitsPerEm", at);

      at = new AttributesImpl ();
      java.text.DateFormat df
         = java.text.DateFormat.getDateTimeInstance (java.text.DateFormat.LONG,
                                                     java.text.DateFormat.LONG);
      at.addAttribute ("", "created", "created", "CDATA",
                       df.format (getCreated ()));
      at.addAttribute ("", "modified", "modified", "CDATA",
                       df.format (getModified ()));
      conf.ch.element ("dates", at);

      at = new AttributesImpl ();
      Bbox b = getBbox ();
      at.addAttribute ("", "xMin", "xMin", "CDATA", "" + b.xMin);
      at.addAttribute ("", "yMin", "yMin", "CDATA", "" + b.yMin);
      at.addAttribute ("", "xMax", "xMax", "CDATA", "" + b.xMax);
      at.addAttribute ("", "yMax", "yMax", "CDATA", "" + b.yMax);
      conf.ch.element ("bbox", at);

      MacStyle macStyle = getMacStyle ();
      at = new AttributesImpl ();
      at.addAttribute ("", "bold", "bold", "CDATA",
                       macStyle.bold ? "yes" : "no");
      at.addAttribute ("", "italic", "italic", "CDATA",
                       macStyle.italic ? "yes" : "no");
      conf.ch.element ("macStyle", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getLowestRecPPEM ());
      conf.ch.element ("lowestRecPPEM", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getFontDirectionHint ());
      conf.ch.element ("fontDirectionHint", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getIndexToLocFormat ());
      conf.ch.element ("indexToLocFormat", at);

// TODO
//      at = new AttributesImpl ();
//      at.addAttribute ("", "v", "v", "CDATA", "" + getGlyphDataFormat ());
//      conf.ch.element ("glyphDataFormat", at);

      conf.ch.endElement ("head"); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Here is the class that represents the head
          table:</para>

<code-fragment package='com.adobe.aots.opentype' class='Head'>
  <code-title>Head class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.Attributes;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Head extends Table {

  public Head () {
    super (Tag.head, null);
  }

  public Head (Font font) {
    super (Tag.head, font);
  }

  static public final long Version_OTTO = 0x4f54544f;
  static public final long Version_1_0  = 0x00010000;

  static public final long magicNumber = 0x5F0F3CF5;

  public class Flags {
    boolean baseline_at_0;
    boolean lsb_at_0;
    boolean instructions_vary_with_point_size;
    boolean use_integral_ppem;
    boolean instructions_alter_advance_width;
    boolean lossless;
    boolean converted;
    boolean optimized_for_cleartype;

    public void fromBinary (int n) {
      baseline_at_0                        = ((n &amp; 0x0001) != 0);
      lsb_at_0                             = ((n &amp; 0x0002) != 0);
      instructions_vary_with_point_size    = ((n &amp; 0x0004) != 0);
      use_integral_ppem                    = ((n &amp; 0x0008) != 0);
      instructions_alter_advance_width     = ((n &amp; 0x0010) != 0);
      lossless                             = ((n &amp; 0x0800) != 0);
      converted                            = ((n &amp; 0x1000) != 0);
      optimized_for_cleartype              = ((n &amp; 0x2000) != 0);
    }

    public int toBinary () {
      int bin = 0;
      if (baseline_at_0)                          { bin |= 0x0001; }
      if (lsb_at_0)                               { bin |= 0x0002; }
      if (instructions_vary_with_point_size)      { bin |= 0x0004; }
      if (use_integral_ppem)                      { bin |= 0x0008; }
      if (instructions_alter_advance_width)       { bin |= 0x0010; }
      if (lossless)                               { bin |= 0x0800; }
      if (converted)                              { bin |= 0x1000; }
      if (optimized_for_cleartype)                { bin |= 0x2000; }
      return bin;
    }

    public Attributes toXML () {
      org.xml.sax.helpers.AttributesImpl at;
      at = new org.xml.sax.helpers.AttributesImpl ();
      if (baseline_at_0) {
        at.addAttribute ("head",
                         "baseline_at_0",
                         "baseline_at_0",
                         "CDATA", "yes"); }
      if (lsb_at_0) {
        at.addAttribute ("",
                         "lsb_at_0",
                         "lsb_at_0",
                         "CDATA", "yes"); }
      if (instructions_vary_with_point_size) {
        at.addAttribute ("",
                         "instructions_vary_with_point_size",
                         "instructions_vary_with_point_size",
                         "CDATA", "yes"); }
      if (use_integral_ppem) {
        at.addAttribute ("",
                         "use_integral_ppem",
                         "use_integral_ppem",
                         "CDATA", "yes"); }
      if (instructions_alter_advance_width) {
        at.addAttribute ("",
                         "instructions_alter_advance_width",
                         "instructions_alter_advance_width",
                         "CDATA", "yes"); }
      if (lossless) {
        at.addAttribute ("",
                         "lossless",
                         "lossless",
                         "CDATA", "yes"); }
      if (converted) {
        at.addAttribute ("",
                         "converted",
                         "converted",
                         "CDATA", "yes"); }
      if (optimized_for_cleartype) {
        at.addAttribute ("",
                         "optimized_for_cleartype",
                         "optimized_for_cleartype",
                         "CDATA", "yes"); }
      return at;
    }
  }

  public class MacStyle {
    boolean bold;
    boolean italic;

    public void fromBinary (int n) {
      bold                        = ((n &amp; 0x0001) != 0);
      italic                      = ((n &amp; 0x0002) != 0);
    }

    public int toBinary () {
      int bin = 0;
      if (bold)                           { bin |= 0x0001; }
      if (italic)                         { bin |= 0x0002; }
      return bin;
    }

    public Attributes toXML () {
      org.xml.sax.helpers.AttributesImpl at;
      at = new org.xml.sax.helpers.AttributesImpl ();
      if (bold) {
        at.addAttribute ("",
                         "bold",
                         "bold",
                         "CDATA", "yes"); }
      if (italic) {
        at.addAttribute ("",
                         "italic",
                         "italic",
                         "CDATA", "yes"); }
      return at;
    }
  }

  <code-include linkend='head.methods'/>

  public int[] getTableVersion () {
    return getFixed (0);
  }

  public void setTableVersion (int major, int minor) {
    setFixed (0, major, minor);
  }

  public int[] getFontRevision () {
    return getFixed (4);
  }

  public void setFontRevision (int major, int minor) {
    setFixed (4, major, minor);
  }

  public void clearChecksumAdjust () {
    setuint32 (8, 0);
  }

  public void setChecksumAdjust (long l) {
    setuint32 (8, (int)l);
  }

  public Flags getFlags () {
    Flags result = new Flags ();
    result.fromBinary (getuint16 (16));
    return result;
  }

  public void setFlags (Flags flags) {
    setuint16 (16, flags.toBinary ());
  }

  public int getUnitsPerEm () {
    return getuint16 (18);
  }

  public void setUnitsPerEm (int u) {
    setuint16 (18, u);
  }

  static final java.util.GregorianCalendar baseForDates
       = new java.util.GregorianCalendar (1904, 0, 1, 0, 0, 0);

  public java.util.Date getCreated () {
    return new java.util.Date (baseForDates.getTime ().getTime ()
                               +  getLONGDATETIME (20) * 1000);
  }

  public void setCreated (java.util.Date d) {
   setLONGDATETIME (20, (d.getTime () - baseForDates.getTime ().getTime ()) / 1000);
  }

  public java.util.Date getModified () {
    return new java.util.Date (baseForDates.getTime ().getTime ()
                               +  getLONGDATETIME (28) * 1000);
  }

  public void setModified (java.util.Date d) {
    setLONGDATETIME (28, (d.getTime () - baseForDates.getTime ().getTime ()) / 1000);
  }

  static public class Bbox {
    public int xMin;
    public int yMin;
    public int xMax;
    public int yMax; };

  public Bbox getBbox () {
    Bbox b = new Bbox ();
    b.xMin = getint16 (36);
    b.yMin = getint16 (38);
    b.xMax = getint16 (40);
    b.yMax = getint16 (42);
    return b;
  }

  public void setBbox (Bbox b) {
    setint16 (36, b.xMin);
    setint16 (38, b.yMin);
    setint16 (40, b.xMax);
    setint16 (42, b.yMax);
  }

  public MacStyle getMacStyle () {
    MacStyle result = new MacStyle ();
    result.fromBinary (getuint16 (44));
    return result;
  }

  public void setMacStyle (MacStyle flags) {
    setuint16 (44, flags.toBinary ());
  }

  public int getLowestRecPPEM () {
    return getuint16 (46);
  }

  public void setLowestRecPPEM (int n) {
    setuint16 (46, n);
  }

  public int getFontDirectionHint () {
    return getint16 (48);
  }

  public void setFontDirectionHint (int n) {
    setint16 (48, n);
  }

  public int getIndexToLocFormat () {
    return getint16 (50);
  }

  public void setIndexToLocFormat (int n) {
    setint16 (50, n);
  }

  public int getGlyphDataFormat () {
    return getint16 (52);
  }

  public void setGlyphDataFormat (int n) {
    setint16 (52, n);
  }
}
</code-fragment>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.hhea'>
    <title>hhea - Horizontal Header</title>

    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table contains information for horizontal layout.
          The values in the minRightSidebearing, minLeftSideBearing
          and xMaxExtent should be computed using
          <emphasis>only</emphasis> glyphs that have contours. Glyphs
          with no contours should be ignored for the purposes of these
          calculations. All reserved areas must be set to 0.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Table</otfieldname>
            <otfielddesc>version number 0x00010000 for version
              1.0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>Ascender</otfieldname>
            <otfielddesc>Typographic ascent (<ulink
            url='http://developer.apple.com/fonts/TTRefMan/RM06/Chap6hhea.html'>Distance
            from baseline to highest ascender</ulink>)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>Descender</otfieldname>
            <otfielddesc>Typographic descent(<ulink
            url='http://developer.apple.com/fonts/TTRefMan/RM06/Chap6hhea.html'>Distance
            from baseline to highest ascender</ulink>)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>LineGap</otfieldname>
            <otfielddesc>Typographic line gap. Negative LineGap values are
              treated as zero in Windows 3.1, System 6, and System
              7.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>UFWORD</otfieldtype>
            <otfieldname>advanceWidthMax</otfieldname>
            <otfielddesc>Maximum advance width value in
              <ottable>hmtx</ottable> table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>minLeftSideBearing</otfieldname>
            <otfielddesc>Minimum left sidebearing value in
              <ottable>hmtx</ottable> table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>minRightSideBearing</otfieldname>
            <otfielddesc>Minimum right sidebearing value; calculated
              as Min(aw - lsb - (xMax - xMin)).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>xMaxExtent</otfieldname>
            <otfielddesc>Max(lsb + (xMax - xMin)).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretSlopeRise</otfieldname>
            <otfielddesc>Used to calculate the slope of the cursor
              (rise/run); 1 for vertical.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretSlopeRun</otfieldname>
            <otfielddesc>0 for vertical.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretOffset</otfieldname>
            <otfielddesc>The amount by which a slanted highlight on a
              glyph needs to be shifted to produce the best
              appearance. Set to 0 for non-slanted
              fonts.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>(reserved)</otfieldname>
            <otfielddesc>set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>(reserved)</otfieldname>
            <otfielddesc>set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>(reserved)</otfieldname>
            <otfielddesc>set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>(reserved)</otfieldname>
            <otfielddesc>set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>metricDataFormat</otfieldname>
            <otfielddesc>0 for current format.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>34</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numberOfHMetrics</otfieldname>
            <otfielddesc>Number of hMetric entries in
              <ottable>hmtx</ottable> table.</otfielddesc>
          </otfield>
        </otformat>

	<para>Note: The ascender, descender and linegap values in this
	  table are Apple specific. Also, see information in the
	  <ottable>OS/2</ottable> table.</para>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
hhea =
  element hhea {
    attribute major { text },
    attribute minor { text },
    element macLineMetrics {
      attribute ascent { text },
      attribute descent { text },
      attribute lineGap { text }
    },
    element advanceWidthMax {
      attribute v { text }
    },
    element minLeftSideBearing {
      attribute v { text }
    },
    element minRightSideBearing {
      attribute v { text }
    },
    element xMaxExtent {
      attribute v { text }
    },
    element caret {
      attribute slopeRise { text },
      attribute slopeRun { text },
      attribute offset { text }
    },
    element numberOfHMetrics {
      attribute v { text }
    }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='hhea.methods'>
  public void fromXML (Element hhea)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (36, 0);

    me.setFixed (0,
                 Integer.decode (hhea.getAttribute ("major")).intValue (),
                 Integer.decode (hhea.getAttribute ("minor")).intValue ());

    NodeList children = hhea.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if ("macLineMetrics".equals (e.getTagName ())) {
        me.setFWord (4, Integer.decode (e.getAttribute ("ascent")).intValue());
        me.setFWord (6, Integer.decode (e.getAttribute ("descent")).intValue());
        me.setFWord (8, Integer.decode (e.getAttribute ("lineGap")).intValue()); }

      if ("advanceWidthMax".equals (e.getTagName ())) {
        me.setuFWord (10, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("minLeftSideBearing".equals (e.getTagName ())) {
        me.setFWord (12, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("minRightSideBearing".equals (e.getTagName ())) {
        me.setFWord (14, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("xMaxExtent".equals (e.getTagName ())) {
        me.setFWord (16, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("caret".equals (e.getTagName ())) {
        me.setint16 (18, Integer.decode (e.getAttribute ("slopeRise")).intValue());
        me.setint16 (20, Integer.decode (e.getAttribute ("slopeRun")).intValue());
        me.setint16 (22, Integer.decode (e.getAttribute ("offset")).intValue()); }

      if ("numberOfHMetrics".equals (e.getTagName ())) {
        me.setint16 (34, Integer.decode (e.getAttribute ("v")).intValue()); }}

    me.setint16 (24, 0);
    me.setint16 (26, 0);
    me.setint16 (28, 0);
    me.setint16 (30, 0);
    me.setint16 (32, 0);

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='hhea.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    int [] version = getFixed (0);
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);
    conf.ch.startElement ("hhea", at); {

      at = new AttributesImpl ();
      at.addAttribute ("", "ascent", "ascent", "CDATA", "" + getFWord (4));
      at.addAttribute ("", "descent", "descent", "CDATA", "" + getFWord (6));
      at.addAttribute ("", "lineGap", "lineGap", "CDATA", "" +  getFWord (8));
      conf.ch.element ("macLineMetrics", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getuFWord (10) );
      conf.ch.element ("advanceWidthMax", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getFWord (12) );
      conf.ch.element ("minLeftSideBearing", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getFWord (14) );
      conf.ch.element ("minRightSideBearing", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getFWord (16) );
      conf.ch.element ("xMaxExtent", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "slopeRise", "slopeRise", "CDATA", "" +  getint16 (18) );
      at.addAttribute ("", "slopeRun", "slopeRun", "CDATA", "" +  getint16 (20) );
      at.addAttribute ("", "offset", "offset", "CDATA", "" +  getint16 (22) );
      conf.ch.element ("caret", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getNumberOfHMetrics ());
      conf.ch.element ("numberOfHMetrics", at);

      conf.ch.endElement ("hhea"); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Here is the class definition for <ottable>hhea</ottable>
          tables:</para>

<code-fragment package='com.adobe.aots.opentype' class='Hhea'>
  <code-title>Hhea class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Hhea extends Table {

  public Hhea () {
    super (Tag.hhea, null);
  }

  public Hhea (Font font) {
    super (Tag.hhea, font);
  }

  <code-include linkend='hhea.methods'/>
}
</code-fragment>


        <para>We have simple accessor functions:</para>

<code-fragment id='hhea.methods'>
  <code-title>Hhea class</code-title>
  public int getNumberOfHMetrics () {
    return getuint16 (34);
  }

  public void setNumberOfHMetrics (int n) {
    setuint16 (34, n);
  }
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.hmtx'>
    <title>hmtx - Horizontal Metrics</title>

    <section role='fragment'>
      <title>Introduction</title>

      <!--________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The type longHorMetric is defined as an array where each
          element has two parts: the advance width, which is of type
          USHORT, and the left side bearing, which is of type SHORT.
          Or, more formally:</para>

<literallayout>
typedef struct  _longHorMetric {
     USHORT advanceWidth;
     SHORT  lsb;
}  longHorMetric;
</literallayout>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>longHorMetric [numberOfHMetrics]</otfieldtype>
            <otfieldname>hMetrics</otfieldname>
            <otfielddesc>Paired advance width and left side bearing
              values for each glyph. The value numOfHMetrics comes
              from the <ottable>hhea</ottable> table. If the font is
              monospaced, only one entry need be in the array, but
              that entry is required. The last entry applies to all
              subsequent glyphs.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>??</otfieldoffs>
            <otfieldtype>FWord [ ]</otfieldtype>
            <otfieldname>leftSideBearing</otfieldname>
            <otfielddesc>Here the advanceWidth is assumed to be the
              same as the advanceWidth for the last entry above. The
              number of entries in this array is derived from
              numGlyphs (from <ottable>maxp</ottable> table) minus
              numberOfHMetrics. This generally is used with a run of
              monospaced glyphs (e.g., Kanji fonts or Courier fonts).
              Only one run is allowed and it must be at the end. This
              allows a monospaced font to vary the left side bearing
              values for each glyph.</otfielddesc>
          </otfield>
        </otformat>

        <para>In CFF OpenType fonts, every glyph's advanceWidth as
          recorded in the <ottable>hmtx</ottable> table must be identical to its x
          width in the <ottable>CFF</ottable> table.</para>

        <para>For any glyph, xmax and xmin are given in
          <ottable>glyf</ottable> table, lsb and aw are given in
          <ottable>hmtx</ottable> table. rsb is calculated as
          follows:</para>

<literallayout>
rsb = aw - (lsb + xmax - xmin)
</literallayout>

        <para>If pp1 and pp2 are phantom points used to control lsb
          and rsb, their initial position in x is calculated as
          follows:</para>

<literallayout>
pp1 = xmin - lsb
pp2 = pp1 + aw
</literallayout>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

        <para>In the XML representation, the various entries can occur in any order, and the long and short metrics can even be interleaved. However, the entries must have distinct gid attribute values, and collectively cover exactly the range [0, n-1]. In a fully valid font, n must of course be equal to the maxp.numGlyphs.</para>

<code-fragment id='schema'>
  <code-title>??</code-title>
hmtx =
  element hmtx {
    element hMetric {
      attribute gid { text },
      attribute lsb { text },
      attribute adv { text }
    }*,
    element lsb {
      attribute gid { text },
      attribute lsb { text }
    }*
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='hmtx.methods'>
  private class HMetric {
    int lsb;
    int adv;
    boolean hasAdvance;

    public HMetric (int adv, int lsb) {
      this.adv = adv;
      this.lsb = lsb;
      this.hasAdvance = true;
    }

    public HMetric (int lsb) {
      this.lsb = lsb;
      this.hasAdvance = false;
    }
  }

  public void fromXML (Element hmtx)
    throws InvalidFontException, UnsupportedFontException {

    NodeList metrics = hmtx.getChildNodes ();

    HMetric m [] = new HMetric [metrics.getLength ()];

    int hmetrics = 0;
    int lsbs = 0;

    for (int i = 0; i &lt; m.length; i++) {
      Element metric = (Element) metrics.item (i);

      int gid = Integer.decode (metric.getAttribute ("gid"));

      if (m.length &lt;= gid) {
         throw new InvalidFontException ("htmx: gid " + gid + " is too large"); }

      if (m [gid] != null) {
        throw new InvalidFontException ("duplicate gid " + gid + " in hmtx"); }

      if ("hMetric".equals (metric.getTagName ())) {
        m [gid] = new HMetric (Integer.decode (metric.getAttribute ("adv")).intValue (),
                               Integer.decode (metric.getAttribute ("lsb")).intValue ());
        hmetrics++; }

      else if ("lsb".equals (metric.getTagName ())) {
        m [gid] = new HMetric (Integer.decode (metric.getAttribute ("lsb")).intValue ());
        lsbs++; }}

    // verify that all lsbs are after all hmetric
    for (int gid = hmetrics; gid &lt; hmetrics + lsbs; gid++) {
      if (m [gid].hasAdvance) {
        throw new InvalidFontException ("htmx: gid " + gid + " has advance and is larger that first gid without advance " + hmetrics); }}

    Block me = new Block (hmetrics*4 + lsbs*2, 0);

    int offset = 0;

    for (int gid = 0; gid &lt; hmetrics; gid++) {
      me.setuint16 (offset, m [gid].adv);
      me.setuint16 (offset + 2, m [gid].lsb);
      offset += 4; }

    for (int gid = hmetrics; gid &lt; hmetrics + lsbs; gid++) {
      me.setuint16 (offset, m [gid].lsb);
      offset += 2; }

    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='hmtx.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    conf.ch.startElement ("hmtx"); {
      int offset = 0;
      int gid = 0;
      int numberOfHMetrics = font.hhea.getNumberOfHMetrics ();
      int numLsb = font.maxp.getNumGlyphs () - numberOfHMetrics;

      for (int i = 0; i &lt; numberOfHMetrics; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        gid++;
        at.addAttribute ("", "adv", "adv", "CDATA", "" + getint16 (offset));
        offset += 2;
        at.addAttribute ("", "lsb", "lsb", "CDATA", "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("hMetric", at); }

      for (int i = 0; i &lt; numLsb; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        gid++;
        at.addAttribute ("", "lsb", "lsb", "CDATA", "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("lsb", at); }

      conf.ch.endElement ("hmtx"); }
  }
</code-fragment>
      </section>


      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Hmtx'>
  <code-title>Hmtx class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Hmtx extends Table {

  public Hmtx () {
    super (Tag.hmtx, null);
  }

  public Hmtx (Font font) {
    super (Tag.hmtx, font);
  }

  public int getLeftSideBearing (int glyphID) {
    int numberOfHMetrics = font.hhea.getNumberOfHMetrics ();
    if (glyphID &lt; numberOfHMetrics) {
      return getFWord (4*glyphID + 2); }
    else {
      return getFWord (4*numberOfHMetrics + 2*(glyphID - numberOfHMetrics)); }
  }

  public int getHorizontalAdvance (int glyphID) {
    int numberOfHMetrics = font.hhea.getNumberOfHMetrics ();
    if (glyphID &lt; numberOfHMetrics) {
      return getuFWord (4*glyphID); }
    else {
      return getuFWord (4*(numberOfHMetrics - 1)); }
  }

  <code-include linkend='hmtx.methods'/>
}
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.maxp'>
    <title>maxp - Maximum Profile</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table establishes the memory requirements for this
          font. Fonts with CFF data must use Version 0.5 of this
          table, specifying only the numGlyphs field. Fonts with
          TrueType outlines must use Version 1.0 of this table, where
          all data is required. Both formats of OpenType require a
          <ottable>maxp</ottable> table because a number of
          applications call the Windows GetFontData( ) API on the
          <ottable>maxp</ottable> table to determine the number of
          glyphs in the font.</para>

        <otformat>
          <title>Version 0.5</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Table</otfieldname>
            <otfielddesc>version number 0x00005000 for version 0.5
              (Note the difference in the representation of a non-zero
              fractional part, in Fixed numbers.) </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numGlyphs</otfieldname>
            <otfielddesc>The number of glyphs in the
              font.</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>Version 1.0</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Table</otfieldname>
            <otfielddesc>version number 0x00010000 for version
              1.0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numGlyphs</otfieldname>
            <otfielddesc>The number of glyphs in the
              font.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxPoints</otfieldname>
            <otfielddesc>Maximum points in a non-composite
              glyph.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxContours</otfieldname>
            <otfielddesc>Maximum contours in a non-composite
              glyph.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxCompositePoints</otfieldname>
            <otfielddesc>Maximum points in a composite
              glyph.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxCompositeContours</otfieldname>
            <otfielddesc>Maximum contours in a composite
              glyph.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxZones</otfieldname>
            <otfielddesc>1 if instructions do not use the twilight
              zone (Z0), or 2 if instructions do use Z0; should be set
              to 2 in most cases.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxTwilightPoints</otfieldname>
            <otfielddesc>Maximum points used in Z0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxStorage</otfieldname>
            <otfielddesc>Number of Storage Area locations.
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxFunctionDefs</otfieldname>
            <otfielddesc>Number of FDEFs.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxInstructionDefs</otfieldname>
            <otfielddesc>Number of IDEFs.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxStackElements</otfieldname>
            <otfielddesc>Maximum stack depth<footnote>
                <para>This includes Font and CVT Programs, as well as
                  the instructions for each glyph.</para>
                  </footnote>.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxSizeOfInstructions</otfieldname>
            <otfielddesc>Maximum byte count for glyph
              instructions.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxComponentElements</otfieldname>
            <otfielddesc>Maximum number of components referenced at
              "top level" for any composite glyph.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>maxComponentDepth</otfieldname>
            <otfielddesc>Maximum levels of recursion; 1 for simple
              components.</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
maxp |=
  element maxp {
    attribute major { "0" },
    attribute minor { "5" },
    element numGlyphs {
      attribute v { text }
    }
  }
maxp |=
  element maxp {
    attribute major { "1" },
    attribute minor { "0" },
    element numGlyphs {
      attribute v { text }
    },
    element maxPoints {
      attribute v { text }
    },
    element maxContours {
      attribute v { text }
    },
    element maxCompositePoints {
      attribute v { text }
    },
    element maxCompositeContours {
      attribute v { text }
    },
    element maxZones {
      attribute v { text }
    },
    element maxTwilightPoints {
      attribute v { text }
    },
    element maxStorage {
      attribute v { text }
    },
    element maxFunctionDefs {
      attribute v { text }
    },
    element maxInstructionDefs {
      attribute v { text }
    },
    element maxStackElements {
      attribute v { text }
    },
    element maxSizeOfInstructions {
      attribute v { text }
    },
    element maxComponentElements {
      attribute v { text }
    },
    element maxComponentDepth {
      attribute v { text }
    }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='maxp.methods'>
  public void fromXML (Element maxp)
    throws InvalidFontException, UnsupportedFontException {

    int major = Integer.decode (maxp.getAttribute ("major")).intValue ();
    int minor = Integer.decode (maxp.getAttribute ("minor")).intValue ();
    Block me;

    if (major == 0 &amp;&amp; minor == 5) {
      me = new Block (6, 0);
      me.setFixed (0, 0, 0x5000); }
    else if (major == 1 &amp;&amp; minor == 0) {
      me = new Block (32, 0);
      me.setFixed (0, 1, 0); }
    else {
      throw new InvalidFontException
                   ("invalid maxp version (" + major + "." + minor + ")"); }


    NodeList children = maxp.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if ("numGlyphs".equals (e.getTagName ())) {
        me.setuint16(4, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxPoints".equals (e.getTagName ())) {
        me.setuint16(6, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxContours".equals (e.getTagName ())) {
        me.setuint16(8, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxCompositePoints".equals (e.getTagName ())) {
        me.setuint16(10, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxCompositeContours".equals (e.getTagName ())) {
        me.setuint16(12, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxZones".equals (e.getTagName ())) {
        me.setuint16(14, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxTwilightPoints".equals (e.getTagName ())) {
        me.setuint16(16, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxStorage".equals (e.getTagName ())) {
        me.setuint16(18, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxFunctionDefs".equals (e.getTagName ())) {
        me.setuint16(20, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxInstructionDefs".equals (e.getTagName ())) {
        me.setuint16(22, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxStackElements".equals (e.getTagName ())) {
        me.setuint16(24, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxSizeOfInstructions".equals (e.getTagName ())) {
        me.setuint16(26, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxComponentElements".equals (e.getTagName ())) {
        me.setuint16(28, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("maxComponentDepth".equals (e.getTagName ())) {
        me.setuint16(30, Integer.decode (e.getAttribute ("v")).intValue()); }}

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='maxp.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] version = getFixed (0);
    if (! (   (version [0] == 0 &amp;&amp; version [1] == 0x5000)
           || (version [0] == 1 &amp;&amp; version [1] == 0))) {
      throw new InvalidFontException ("unsupported maxp table version ("
                                      + version [0] + "." + version [1]
                                      + ") for decompilation"); }

    AttributesImpl at;
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA",
                     version [1] == 0x5000 ? "5" : "0");
    conf.ch.startElement ("maxp", at); {

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (4));
      conf.ch.element ("numGlyphs", at);

      if (version [0] == 1 &amp;&amp; version [1] == 0) {
        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (6));
	conf.ch.element ("maxPoints", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (8));
        conf.ch.element ("maxContours", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (10));
        conf.ch.element ("maxCompositePoints", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (12));
        conf.ch.element ("maxCompositeContours", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (14));
        conf.ch.element ("maxZones", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (16));
        conf.ch.element ("maxTwilightPoints", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (18));
        conf.ch.element ("maxStorage", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (20));
        conf.ch.element ("maxFunctionDefs", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (22));
        conf.ch.element ("maxInstructionDefs", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (24));
        conf.ch.element ("maxStackElements", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (26));
        conf.ch.element ("maxSizeOfInstructions", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (28));
        conf.ch.element ("maxComponentElements", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (30));
        conf.ch.element ("maxComponentDepth", at); }

      conf.ch.endElement ("maxp"); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Maxp'>
  <code-title>Maxp class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Maxp extends Table {

  public Maxp () {
    super (Tag.maxp, null);
  }

  public Maxp (Font font) {
    super (Tag.maxp, font);
  }

  public int getNumGlyphs () {
    return getuint16 (4);
  }

  public void setNumGlyphs (int n) {
    setuint16 (4, n);
  }

  public int getMaxPoints () {
    return getuint16 (6);
  }

  public void setMaxPoints (int n) {
    setuint16 (6, n);
  }

  public int getMaxCountours () {
    return getuint16 (8);
  }

  public void setMaxContours (int n) {
    setuint16 (8, n);
  }

  public int getMaxCompositePoints () {
    return getuint16 (10);
  }

  public void setMaxCompositePoints (int n) {
    setuint16 (10, n);
  }

  public int getMaxCompositeContours () {
    return getuint16 (12);
  }

  public void setMaxCompositeContours (int n) {
    setuint16 (12, n);
  }

  public int getMaxZones () {
    return getuint16 (14);
  }

  public void setMaxZones (int n) {
    setuint16 (14, n);
  }

  public int getMaxComponentElements () {
    return getuint16 (28);
  }

  public void setMaxComponentElements (int n) {
    setuint16 (28, n);
  }

  public int getMaxComponentDepth () {
    return getuint16 (30);
  }

  public void setMaxComponentDepth (int n) {
    setuint16 (30, n);
  }

  public void fixValuesDerivedFromGlyf () {
    if (font.glyf != null) {
      int maxPoints = 0;
      int maxCompositePoints = 0;
      int maxContours = 0;
      int maxCompositeContours = 0;
      int maxComponentElements = 0;
      int maxComponentDepth = 0;

      for (int gid = 0; gid &lt; getNumGlyphs (); gid++) {
        Glyf.MaxpValues values = font.glyf.getMaxpValues (gid);

        maxPoints = Math.max (maxPoints, values.numPoints);
        maxCompositePoints = Math.max (maxCompositePoints,
                                       values.numCompositePoints);
        maxContours = Math.max (maxContours, values.numContours);
        maxCompositeContours = Math.max (maxCompositeContours,
                                         values.numCompositeContours);

        maxComponentElements = Math.max (maxComponentElements,
                                         values.numComponentElements);
        maxComponentDepth = Math.max (maxComponentDepth, values.componentDepth); }

      setMaxPoints  (maxPoints);
      setMaxContours (maxContours);
      setMaxCompositePoints  (maxCompositePoints);
      setMaxCompositeContours (maxCompositeContours);
      setMaxComponentElements (maxComponentElements);
      setMaxComponentDepth (Math.min (1, maxComponentDepth)); }
  }

  <code-include linkend='maxp.methods'/>
}
</code-fragment>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.name'>
    <title>name - Naming Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The naming table allows multilingual strings to be
          associated with the OpenType font file. These strings can
          represent copyright notices, font names, family names, style
          names, and so on. To keep this table short, the font
          manufacturer may wish to make a limited set of entries in
          some small set of languages; later, the font can be
          "localized" and the strings translated or added. Other parts
          of the OpenType font file that require these strings can
          then refer to them simply by their index number. Clients
          that need a particular string can look it up by its platform
          ID, character encoding ID, language ID and name ID. Note
          that some platforms may require single byte character
          strings, while others may require double byte
          strings.</para>

        <para>For historical reasons, some applications which install
          fonts perform version control using Macintosh platform
          (platform ID 1) strings from the <ottable>name</ottable>
          table. Because of this, we strongly recommend that the
          <ottable>name</ottable> table of all fonts include Macintosh
          platform strings and that the syntax of the version number
          (name id 5) follows the guidelines given in this
          document.</para>

        <para>The Naming Table is organized as follows:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>format</otfieldname>
            <otfielddesc>Format selector (=0).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>count</otfieldname>
            <otfielddesc>Number of name records.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>stringOffset</otfieldname>
            <otfielddesc>Offset to start of string storage (from start
                  of table).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>n NameRecords</otfieldtype>
            <otfieldname>nameRecord [count]</otfieldname>
            <otfielddesc>The name records where count is the number of
	      records.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12n + 6</otfieldoffs>
            <otfieldtype>(Variable)</otfieldtype>
            <otfieldname></otfieldname>
            <otfielddesc>Storage for the actual string data.</otfielddesc>
          </otfield>
        </otformat>

        <para>Each NameRecord looks like this:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>platformID</otfieldname>
            <otfielddesc>Platform ID.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>encodingID</otfieldname>
            <otfielddesc>Platform-specific encoding ID.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>languageID</otfieldname>
            <otfielddesc>Language ID.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>nameID</otfieldname>
            <otfielddesc>Name ID.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>String length (in bytes).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>offset</otfieldname>
            <otfielddesc>String offset from start of storage area (in
                  bytes).</otfielddesc>
          </otfield>
        </otformat>

        <para>Following are the descriptions of the four kinds of ID.
          Note that the specific values listed here are the only ones
          that are predefined; new ones may be added by registry with
          Apple Developer Technical Support. Similar to the character
          encoding table, the NameRecords is sorted by platform ID,
          then platform-specific ID, then language ID, and then by
          name ID.</para>

        <table>
          <title>Platform IDs, Platform-specific encoding IDs and
            Language IDs</title>
          <tgroup cols='4'>
            <colspec colwidth="3pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="11pc"/>
            <colspec colwidth="8pc"/>
            <thead>
              <row>
                <entry>PlatformID</entry>
                <entry>Platform name</entry>
                <entry>Platform-specific encoding IDs</entry>
                <entry>Language IDs</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Unicode</entry>
                <entry><link
                    linkend='name_enc0'>Various</link></entry>
                <entry>None</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Macintosh</entry>
                <entry><link linkend='name_enc1'>Script manager
                    code</link></entry>
                <entry><link
                    linkend='name_lang1'>Various</link></entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>ISO [deprecated]</entry>
                <entry><link linkend='name_enc2'>ISO
                    encoding</link> [deprecated]</entry>
                <entry>None</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Microsoft</entry>
                <entry><link linkend='name_enc3'>Microsoft
                    encoding</link></entry>
                <entry><link
                    linkend='name_lang3'>Various</link></entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Custom</entry>
                <entry><link
                    linkend='name_enc4'>Custom</link></entry>
                <entry>None</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Note that platform ID 2 (ISO) has been deprecated as of
          OpenType Specification v1.3. It was intended to represent
          ISO/IEC 10646, as opposed to Unicode; both standards have
          identical character code assignments.</para>

        <para>PlatformID values 240 through 255 are reserved for
          user-defined platforms. The DTS registry will never assign
          these values to a registered platform.</para>

        <table id='name_enc0'>
          <title>Unicode platform-specific encoding IDs (platform ID =
            0)</title>
          <tgroup cols='2'>
            <colspec colwidth="3pc"/>
            <colspec colwidth="27pc"/>
            <thead>
              <row>
                <entry>EncodingID</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Unicode 1.0 semantics</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Unicode 1.1 semantics</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>ISO 10646:1993 semantics</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Unicode 2.0 and onwards semantics, Unicode BMP only</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Unicode 2.0 and onwards semantics, Unicode
		  full repertoire</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Unicode Variation Sequences</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>A new encoding ID for the Unicode platform will be
          assigned if a new version of Unicode moves characters, in
          order to properly specify character code semantics. The
          distinction between Unicode platform-specific encoding IDs 1
          and 2 is for historical reasons only; Unicode 1.1 is in fact
          identical in repertoire and encoding to ISO 10646:1993
          (before any amendments).</para>

        <para>Unicode platform encoding ID 5 can be used for encodings
        in the 'cmap' table but not for strings in the 'name' table.</para>

        <para>There are currently no language IDs defined for the
          Unicode platform. This means that it can be used for
          encodings in the <ottable>cmap</ottable> table but not for
          strings in the <ottable>name</ottable> table.</para>

        <table id='name_enc3'>
          <title>Microsoft platform-specific encoding IDs (platform
            ID= 3)</title>
          <tgroup cols='3'>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>Platform ID</entry>
                <entry>Encoding ID</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>3</entry>
                <entry>0</entry>
                <entry>Symbol</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>1</entry>
                <entry>Unicode BMP only</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>2</entry>
                <entry>ShiftJIS</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>3</entry>
                <entry>PRC</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>4</entry>
                <entry>Big5</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>5</entry>
                <entry>Wansung</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>6</entry>
                <entry>Johab</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>7</entry>
                <entry>Reserved</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>8</entry>
                <entry>Reserved</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>9</entry>
                <entry>Reserved</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>10</entry>
                <entry>Unicode full repertoire</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>When building a Unicode font for Windows, the platform
          ID should be 3 and the encoding ID should be 1. When
          building a symbol font for Windows, the platform ID should
          be 3 and the encoding ID should be 0. When building a font
          that will be used on the Macintosh, the platform ID should
          be 1 and the encoding ID should be 0.</para>

        <para>Microsoft Language IDs (platform ID = 3)</para>

        <para>The language ID (LCID in the table below) refers to a
          value which identifies the language in which a particular
          string is written. Fifty of the language ID's assigned by
          Microsoft are listed below, along with their corresponding
          code pages. There are 85 additional language ID's assigned.
          corresponding code pages. There are 85 additional language
          ID's assigned.  For a full list, please see the <ulink
          url="http://www.microsoft.com/globaldev/reference/loclanghome.asp">Microsoft
          Global Development</ulink> site or <ulink
          url="http://support.microsoft.com/default.aspx?scid=kb;EN-US;q224804">Knowledge
          Base article Q224804</ulink>.</para>


        <informaltable id='name_lang3'>
          <tgroup cols='5'>
            <colspec colwidth="8pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="6pc"/>
            <colspec colwidth="4pc"/>
            <colspec colwidth="4pc"/>
            <thead>
              <row>
                <entry>Primary Language</entry>
                <entry>Locale Name</entry>
                <entry>LCID</entry>
                <entry>Win CP</entry>
                <entry>OEM CP</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Albanian</entry>
                <entry>Albania</entry>
                <entry>(041c; SQI)</entry>
                <entry></entry>
                <entry></entry>
              </row>
              <row>
                <entry>Basque</entry>
                <entry>Basque</entry>
                <entry>(042D; EUQ)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Byelorussian</entry>
                <entry>Byelorussia</entry>
                <entry>(0423, BEL)</entry>
                <entry>1251</entry>
                <entry>866</entry>
              </row>
              <row>
                <entry>Bulgarian</entry>
                <entry>Bulgaria</entry>
                <entry>(0402, BGR)</entry>
                <entry>1251</entry>
                <entry>866</entry>
              </row>
              <row>
                <entry>Catalan</entry>
                <entry>Catalan</entry>
                <entry>(0403; CAT)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Croatian</entry>
                <entry>Croatian</entry>
                <entry>(041a, SHL)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Czech</entry>
                <entry>Czech</entry>
                <entry>(0405; CSY)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Danish</entry>
                <entry>Danish</entry>
                <entry>(0406; DAN)</entry>
                <entry>1252</entry>
                <entry>865</entry>
              </row>
              <row>
                <entry>Dutch (2):</entry>
                <entry>Dutch (Standard)</entry>
                <entry>(0413; NLD)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Dutch (2):</entry>
                <entry>Belgian (Flemish)</entry>
                <entry>(0813; NLB)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>English (6):</entry>
                <entry>American</entry>
                <entry>(0409; ENU)</entry>
                <entry>1252</entry>
                <entry>437</entry>
              </row>
              <row>
                <entry>English (6):</entry>
                <entry>British</entry>
                <entry>(0809; ENG)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>English (6):</entry>
                <entry>Australian</entry>
                <entry>(0c09; ENA)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>English (6):</entry>
                <entry>Canadian</entry>
                <entry>(1009; ENC)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>English (6):</entry>
                <entry>New Zealand</entry>
                <entry>(1409; ENZ)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>English (6):</entry>
                <entry>Ireland</entry>
                <entry>(1809; ENI)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Estonian</entry>
                <entry>Estonia</entry>
                <entry>(0425, ETI)</entry>
                <entry>1257</entry>
                <entry>775</entry>
              </row>
              <row>
                <entry>Finnish</entry>
                <entry>Finnish</entry>
                <entry>(040b; FIN)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>French</entry>
                <entry>French (Standard)</entry>
                <entry>(040c; FRA)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>French</entry>
                <entry>Belgian</entry>
                <entry>(080c; FRB)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>French</entry>
                <entry>Canadian</entry>
                <entry>(0c0c; FRC)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>French</entry>
                <entry>Swiss</entry>
                <entry>(100c; FRS)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>French</entry>
                <entry>Luxembourg</entry>
                <entry>(140c; FRL)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>German</entry>
                <entry>German (Standard)</entry>
                <entry>(0407; DEU)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>German</entry>
                <entry>Swiss</entry>
                <entry>(0807; DES)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>German</entry>
                <entry>Austrian</entry>
                <entry>(0c07; DEA)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>German</entry>
                <entry>Luxembourg</entry>
                <entry>(1007; DEL)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>German</entry>
                <entry>Liechtenstein</entry>
                <entry>(1407; DEC)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Greek</entry>
                <entry>Greek</entry>
                <entry>(0408; ELL)</entry>
                <entry>1253</entry>
                <entry>737 or 869<footnote>
                    <para>737 is default, but 869 (IBM Greek) will be
                      available at setup time through the selection of
                      a bogus Greek locale in Custom Setup.</para>
                  </footnote></entry>
              </row>
              <row>
                <entry>Hungarian</entry>
                <entry>Hungarian</entry>
                <entry>(040e; HUN)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Icelandic</entry>
                <entry>Icelandic</entry>
                <entry>(040F; ISL)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Italian (2):</entry>
                <entry>Italian (Standard)</entry>
                <entry>(0410; ITA)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Italian (2):</entry>
                <entry>Swiss</entry>
                <entry>(0810; ITS)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Latvian</entry>
                <entry>Latvia</entry>
                <entry>(0426, LVI)</entry>
                <entry>1257</entry>
                <entry>775</entry>
              </row>
              <row>
                <entry>Lithuanian</entry>
                <entry>Lithuania</entry>
                <entry>(0427, LTH)</entry>
                <entry>1257</entry>
                <entry>775</entry>
              </row>
              <row>
                <entry>Norwegian (2):</entry>
                <entry>Norwegian (Bokmal)</entry>
                <entry>(0414; NOR)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Norwegian (2):</entry>
                <entry>Norwegian (Nynorsk)</entry>
                <entry>(0814; NON)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Polish</entry>
                <entry>Polish</entry>
                <entry>(0415; PLK)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Portuguese (2):</entry>
                <entry>Portuguese (Brazilian)</entry>
                <entry>(0416; PTB)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Portuguese (2):</entry>
                <entry>Portuguese (Standard)</entry>
                <entry>(0816; PTG)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Romanian (2):</entry>
                <entry>Romania</entry>
                <entry>(0418, ROM)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Russian</entry>
                <entry>Russian</entry>
                <entry>(0419; RUS)</entry>
                <entry>1251</entry>
                <entry>866</entry>
              </row>
              <row>
                <entry>Slovak</entry>
                <entry>Slovak</entry>
                <entry>(041b; SKY)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Slovenian</entry>
                <entry>Slovenia</entry>
                <entry>(0424, SLV)</entry>
                <entry>1250</entry>
                <entry>852</entry>
              </row>
              <row>
                <entry>Spanish (3):</entry>
                <entry>Spanish (Traditional Sort)</entry>
                <entry>(040a; ESP)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Spanish (3):</entry>
                <entry>Mexican</entry>
                <entry>(080a; ESM)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Spanish (3):</entry>
                <entry>Spanish (Modern Sort)</entry>
                <entry>(0c0a; ESN)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Swedish</entry>
                <entry>Swedish</entry>
                <entry>(041D; SVE)</entry>
                <entry>1252</entry>
                <entry>850</entry>
              </row>
              <row>
                <entry>Turkish</entry>
                <entry>Turkish</entry>
                <entry>(041f; TRK)</entry>
                <entry>1254</entry>
                <entry>857</entry>
              </row>
              <row>
                <entry>Ukrainian</entry>
                <entry>Ukraine</entry>
                <entry>(0422, UKR)</entry>
                <entry>1251</entry>
                <entry>866 </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <table id='name_enc1'>
          <title>Macintosh platform-specific encoding IDs (script
            manager codes), (platform ID = 1)</title>

          <tgroup cols='2'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>Code</entry>
                <entry>Script</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Roman</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Japanese</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Chinese (Traditional)</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Korean</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Greek</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Russian</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>RSymbol</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Devanagari</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Gurmukhi</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>Gujarati</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>Oriya</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>Bengali</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>Tamil</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>Telugu</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>Kannada</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>Malayalam</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>Sinhalese</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>Burmese</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry>Khmer</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry>Thai</entry>
              </row>
              <row>
                <entry>22</entry>
                <entry>Laotian</entry>
              </row>
              <row>
                <entry>23</entry>
                <entry>Georgian</entry>
              </row>
              <row>
                <entry>24</entry>
                <entry>Armenian</entry>
              </row>
              <row>
                <entry>25</entry>
                <entry>Chinese (Simplified)</entry>
              </row>
              <row>
                <entry>26</entry>
                <entry>Tibetan</entry>
              </row>
              <row>
                <entry>27</entry>
                <entry>Mongolian</entry>
              </row>
              <row>
                <entry>28</entry>
                <entry>Geez</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry>Slavic</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry>Vietnamese</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry>Sindhi</entry>
              </row>
              <row>
                <entry>32</entry>
                <entry>Uninterpreted</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id='name_lang1'>
          <title>Macintosh language IDs (platform ID = 1)</title>
          <tgroup cols='2'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>Code</entry>
                <entry>Language</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>English</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>French</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>German</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Italian</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Dutch</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Swedish</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Spanish</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Danish</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Portuguese</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Norwegian</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>Japanese</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>Finnish</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>Greek</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>Icelandic</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>Maltese</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>Turkish</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>Yugoslavian</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>Chinese (Traditional)</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry>Urdu</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry>Hindi</entry>
              </row>
              <row>
                <entry>22</entry>
                <entry>Thai</entry>
              </row>
              <row>
                <entry>23</entry>
                <entry>Korean</entry>
              </row>
              <row>
                <entry>24</entry>
                <entry>Lithuanian</entry>
              </row>
              <row>
                <entry>25</entry>
                <entry>Polish</entry>
              </row>
              <row>
                <entry>26</entry>
                <entry>Hungarian</entry>
              </row>
              <row>
                <entry>27</entry>
                <entry>Estonian</entry>
              </row>
              <row>
                <entry>28</entry>
                <entry>Latvian</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry>Sami</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry>Faroese</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry>Farsi/Persian</entry>
              </row>
              <row>
                <entry>32</entry>
                <entry>Russian</entry>
              </row>
              <row>
                <entry>33</entry>
                <entry>Chinese (Simplified)</entry>
              </row>
              <row>
                <entry>34</entry>
                <entry>Flemish</entry>
              </row>
              <row>
                <entry>35</entry>
                <entry>Irish Gaelic</entry>
              </row>
              <row>
                <entry>36</entry>
                <entry>Albanian</entry>
              </row>
              <row>
                <entry>37</entry>
                <entry>Romanian</entry>
              </row>
              <row>
                <entry>38</entry>
                <entry>Czech</entry>
              </row>
              <row>
                <entry>39</entry>
                <entry>Slovak</entry>
              </row>
              <row>
                <entry>40</entry>
                <entry>Slovenian</entry>
              </row>
              <row>
                <entry>41</entry>
                <entry>Yiddish</entry>
              </row>
              <row>
                <entry>42</entry>
                <entry>Serbian</entry>
              </row>
              <row>
                <entry>43</entry>
                <entry>Macedonian</entry>
              </row>
              <row>
                <entry>44</entry>
                <entry>Bulgarian</entry>
              </row>
              <row>
                <entry>45</entry>
                <entry>Ukrainian</entry>
              </row>
              <row>
                <entry>46</entry>
                <entry>Byelorussian </entry>
              </row>
              <row>
                <entry>47</entry>
                <entry>Uzbek </entry>
              </row>
              <row>
                <entry>48</entry>
                <entry>Kazakh </entry>
              </row>
              <row>
                <entry>49</entry>
                <entry>Azerbaijani (Cyrillic script) </entry>
              </row>
              <row>
                <entry>50</entry>
                <entry>Azerbaijani (Arabic script) </entry>
              </row>
              <row>
                <entry>51</entry>
                <entry>Armenian </entry>
              </row>
              <row>
                <entry>52</entry>
                <entry>Georgian </entry>
              </row>
              <row>
                <entry>53</entry>
                <entry>Moldavian</entry>
              </row>
              <row>
                <entry>54</entry>
                <entry>Kirghiz</entry>
              </row>
              <row>
                <entry>55</entry>
                <entry>Tajiki</entry>
              </row>
              <row>
                <entry>56</entry>
                <entry>Turkmen</entry>
              </row>
              <row>
                <entry>57</entry>
                <entry>Mongolian (Mongolian script)</entry>
              </row>
              <row>
                <entry>58</entry>
                <entry>Mongolian (Cyrillic script)</entry>
              </row>
              <row>
                <entry>59</entry>
                <entry>Pashto</entry>
              </row>
              <row>
                <entry>60</entry>
                <entry>Kurdish</entry>
              </row>
              <row>
                <entry>61</entry>
                <entry>Kashmiri</entry>
              </row>
              <row>
                <entry>62</entry>
                <entry>Sindhi</entry>
              </row>
              <row>
                <entry>63</entry>
                <entry>Tibetan</entry>
              </row>
              <row>
                <entry>64</entry>
                <entry>Nepali</entry>
              </row>
              <row>
                <entry>65</entry>
                <entry>Sanskrit</entry>
              </row>
              <row>
                <entry>66</entry>
                <entry>Marathi</entry>
              </row>
              <row>
                <entry>67</entry>
                <entry>Bengali</entry>
              </row>
              <row>
                <entry>68</entry>
                <entry>Assamese</entry>
              </row>
              <row>
                <entry>69</entry>
                <entry>Gujarati</entry>
              </row>
              <row>
                <entry>70</entry>
                <entry>Punjabi</entry>
              </row>
              <row>
                <entry>71</entry>
                <entry>Oriya</entry>
              </row>
              <row>
                <entry>72</entry>
                <entry>Malayalam</entry>
              </row>
              <row>
                <entry>73</entry>
                <entry>Kannada</entry>
              </row>
              <row>
                <entry>74</entry>
                <entry>Tamil</entry>
              </row>
              <row>
                <entry>75</entry>
                <entry>Telugu </entry>
              </row>
              <row>
                <entry>76</entry>
                <entry>Sinhalese </entry>
              </row>
              <row>
                <entry>77</entry>
                <entry>Burmese </entry>
              </row>
              <row>
                <entry>78</entry>
                <entry>Khmer </entry>
              </row>
              <row>
                <entry>79</entry>
                <entry>Lao </entry>
              </row>
              <row>
                <entry>80</entry>
                <entry>Vietnamese </entry>
              </row>
              <row>
                <entry>81</entry>
                <entry>Indonesian </entry>
              </row>
              <row>
                <entry>82</entry>
                <entry>Tagalong </entry>
              </row>
              <row>
                <entry>83</entry>
                <entry>Malay (Roman script) </entry>
              </row>
              <row>
                <entry>84</entry>
                <entry>Malay (Arabic script) </entry>
              </row>
              <row>
                <entry>85</entry>
                <entry>Amharic </entry>
              </row>
              <row>
                <entry>86</entry>
                <entry>Tigrinya </entry>
              </row>
              <row>
                <entry>87</entry>
                <entry>Galla </entry>
              </row>
              <row>
                <entry>88</entry>
                <entry>Somali </entry>
              </row>
              <row>
                <entry>89</entry>
                <entry>Swahili </entry>
              </row>
              <row>
                <entry>90</entry>
                <entry>Kinyarwanda/Ruanda </entry>
              </row>
              <row>
                <entry>91</entry>
                <entry>Rundi </entry>
              </row>
              <row>
                <entry>92</entry>
                <entry>Nyanja/Chewa </entry>
              </row>
              <row>
                <entry>93</entry>
                <entry>Malagasy </entry>
              </row>
              <row>
                <entry>94</entry>
                <entry>Esperanto </entry>
              </row>
              <row>
                <entry>128</entry>
                <entry>Welsh </entry>
              </row>
              <row>
                <entry>129</entry>
                <entry>Basque </entry>
              </row>
              <row>
                <entry>130</entry>
                <entry>Catalan </entry>
              </row>
              <row>
                <entry>131</entry>
                <entry>Latin </entry>
              </row>
              <row>
                <entry>132</entry>
                <entry>Quenchua </entry>
              </row>
              <row>
                <entry>133</entry>
                <entry>Guarani </entry>
              </row>
              <row>
                <entry>134</entry>
                <entry>Aymara </entry>
              </row>
              <row>
                <entry>135</entry>
                <entry>Tatar </entry>
              </row>
              <row>
                <entry>136</entry>
                <entry>Uighur </entry>
              </row>
              <row>
                <entry>137</entry>
                <entry>Dzongkha </entry>
              </row>
              <row>
                <entry>138</entry>
                <entry>Javanese (Roman script) </entry>
              </row>
              <row>
                <entry>139</entry>
                <entry>Sundanese (Roman script) </entry>
              </row>
              <row>
                <entry>140</entry>
                <entry>Galician </entry>
              </row>
              <row>
                <entry>141</entry>
                <entry>Afrikaans </entry>
              </row>
              <row>
                <entry>142</entry>
                <entry>Breton </entry>
              </row>
              <row>
                <entry>143</entry>
                <entry>Inuktitut [!!fixed] </entry>
              </row>
              <row>
                <entry>144</entry>
                <entry>Scottish Gaelic </entry>
              </row>
              <row>
                <entry>145</entry>
                <entry>Manx Gaelic </entry>
              </row>
              <row>
                <entry>146</entry>
                <entry>Irish Gaelic (with dot above) </entry>
              </row>
              <row>
                <entry>147</entry>
                <entry>Tongan </entry>
              </row>
              <row>
                <entry>148</entry>
                <entry>Greek (polytonic) </entry>
              </row>
              <row>
                <entry>149</entry>
                <entry>Greenlandic </entry>
              </row>
              <row>
                <entry>150</entry>
                <entry>Azerbaijani (Roman script) </entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id='name_enc2'>
          <title>ISO specific encodings (platform ID=2)
            [Deprecated]</title>
          <tgroup cols='2'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>Code</entry>
                <entry>ISO encoding</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>7-bit ASCII</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>ISO 10646</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>ISO 8859-1</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>There are no ISO-specific language IDs.</para>

        <table id='name_enc4'>
          <title>Custom platform-specific encoding IDs (platform
            ID=4)</title>
          <tgroup cols='2'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>ID</entry>
                <entry>Custom encoding</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0-255</entry>
                <entry>OTF Windows NT compatibility mapping</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>In cases where a custom platform <ottable>cmap</ottable>
          is present for OTF Windows NT compatibility, the encoding ID
          must be set to the Windows charset value (in the range 0 to
          255, inclusive) present in the .PFM file of the original
          Type 1 font. See the <ottable>cmap</ottable> table for more
          details on the <link linkend="cmap_cust">OTF Windows NT
            compatibility cmap</link>.</para>

        <para>There are currently no language IDs defined for the
          Custom platform. This means that it can be used for
          encodings in the <ottable>cmap</ottable> table but not for
          strings in the <ottable>name</ottable> table.</para>

        <para>Name IDs</para>

        <para>The following name IDs are pre-defined, and they apply to
          all platforms unless indicated otherwise. Name IDs 21 to
          255, inclusive, are reserved for future standard names. Name
          IDs 256 to 32767, inclusive, are reserved for font-specific
          names such as those referenced by a font's layout feature.</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth='3pc'/>
            <colspec colwidth='27pc'/>
            <thead>
              <row>
                <entry>Code</entry>
                <entry>Meaning</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Copyright notice.</entry>
              </row>
              <row>
                <entry>1</entry> <entry>Font Family nam. Up to four
		  fonts can share the Font Family name, forming a font
		  style linking group (regular, italic, bold, bold
		  italic - as defined by OS/2.fsSelection bit
		  settings).</entry>
              </row>
              <row>
                <entry>2</entry> <entry>Font Subfamily name. The Font
		  Subfamily name distiguishes the font in a group with
		  the same Font Family name (name ID 1). This is
		  assumed to address style (italic, oblique) and !
		  weight (light, bold, black, etc.). A font with no
		  particular differences in weight or style (e.g.
		  medium weight, not italic and fsSelection bit 6 set)
		  should have the string "Regular" stored in this
		  position.</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Unique font identifier</entry>
              </row>
              <row>
                <entry>4</entry> <entry>Full font name; this should be
		  a combination of strings 1 and 2. Exception: if the
		  font is "Regular" as indicated in string 2, then use
		  only the family name contained in string 1. An
		  exception to the above definition of Full font name
		  is for Microsoft platform strings for CFF OpenType
		  fonts: in this case, the Full font name string must
		  be identical to the PostScript FontName in the CFF
		  Name INDEX. </entry>
              </row>
              <row>
                <entry>5</entry> <entry>Version string. Should begin
		  with the syntax 'Version &lt;number>.&lt;number>'
		  (upper case, lower case, or mixed, with a space
		  between "Version" and the number).  The string must
		  contain a version number of the following form: one
		  or more digits (0-9) of value less than 65,535,
		  followed by a period, followed by one or more digits
		  of value less than 65,535. Any character other than
		  a digit will terminate the minor number. A character
		  such as ";" is helpful to separate different pieces
		  of version information. The first such match in
		  the string can be used by installation software to
		  compare font versions. Note that some installers may
		  require the string to start with "Version ",
		  followed by a version number as above.</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>
		  <para>Postscript name for the font; Name ID 6
                    specifies a string which is used to invoke a
                    PostScript language font that corresponds to this
                    OpenType font. If no name ID 6 is present, then
                    there is no defined method for invoking this font
                    on a PostScript interpreter.</para> <para>OpenType
                    fonts which include a name with name ID of 6 shall
                    include these two names with name ID 6, and
                    characteristics as follows:</para> <para>a.
                    Platform: 1 [Macintosh]; Platform-specific
                    encoding: 0 [Roman]; Language: 0 [English].</para>
                  <para>b Platform: 3 [Microsoft]; Platform-specific
                    encoding: 1 [Unicode]; Language: 0x409 [English
                    (American)]. </para> <para>Names with name ID 6
                    other than the above two, if present, must be
                    ignored.</para> <para>When translated to ASCII,
                    these two name strings must be identical; no
                    longer than 63 characters; and restricted to the
                    printable ASCII subset, codes 33 through 126,
                    except for the 10 characters: '[', ']', '(', ')',
                    '{', '}', '&lt;', '>', '/', '%'.</para> <para>In
                    CFF OpenType fonts, these two name strings, when
                    translated to ASCII, must also be identical to the
                    font name as stored in the CFF's Name
                    INDEX.</para> <para>The term "PostScript Name"
                    here means a string identical to the two identical
                    name ID 6 strings described above.</para>
                  <para>Depending on the particular font format that
                    PostScript language font uses, the invocation
                    method for the PostScript font differs, and the
                    semantics of the resulting PostScript language
                    font differ. The method used to invoke this font
                    depends on the presence of name ID 20.</para>
                  <para>If a name ID 20 is present in this font, then
                    the default assumption should be that the
                    PostScript Name defined by name ID 6 should be
                    used with the "composefont" invocation. This
                    PostScript Name is then the name of a PostScript
                    language CIDFont resource which corresponds to the
                    glyphs of the OpenType font. This name is valid to
                    pass, with an appropriate PostScript language CMap
                    reference, and an instance name, to the PostScript
                    language "composefont" operator.</para> <para>If
                    no name ID 20 is present in this font, then the
                    default assumption should be that the PostScript
                    Name defined by name ID 6 should be used with the
                    "findfont" invocation, for locating the font in
                    the context of a PostScript interpreter. This
                    PostScript Name is then the name of a PostScript
                    language Font resource which corresponds to the
                    glyphs of the OpenType font. This name is valid to
                    pass to the PostScript language "findfont"
                    operator. Note that this does
                    <emphasis>not</emphasis> necessarily imply that
                    the resulting font dictionary accepts an /Encoding
                    array, such as when the font referenced is a Type
                    0 PostScript font.</para> <para>Note that this
                    specification applies only to data fork OpenType
                    fonts. Macintosh resource-fork TrueType and other
                    Macintosh sfnt-wrapped fonts supply the PostScript
                    font name to be used with the "findfont"
                    invocation, in order to invoke the font in a
                    PostScript interpreter, in the FOND resource
                    style-mapping table.</para> <para>Developers may
                    choose to ignore the default usage when
                    appropriate. For example, PostScript printers
                    whose version is earlier than 2015 cannot process
                    CID font resources, and a CJK OpenType/CFF-CID
                    font can be downloaded only as a set of Type 1
                    PostScript fonts. Legacy CJK TrueType fonts, which
                    do not have a name ID 20, may still be most
                    effectively downloaded as a CID font resource.
                    Definition of the full set of situations in which
                    the defaults should not be followed is outside the
                    scope of this document.</para>
                </entry>
              </row>
              <row>
                <entry>7</entry> <entry>Trademark; this is used to
                save any trademark notice/information for this
                font. Such information should be based on legal
                advice. This is <emphasis>distinctly</emphasis>
                separate from the copyright. </entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Manufacturer Name.</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Designer; name of the designer of the
                  typeface.</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Description; description of the typeface. Can
                  contain revision information, usage recommendations,
                  history, features, etc.</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>URL Vendor; URL of font vendor (with protocol,
                  e.g., http://, ftp://). If a unique serial number is
                  embedded in the URL, it can be used to register the
                  font.</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>URL Designer; URL of typeface designer (with
                  protocol, e.g., http://, ftp://).</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>License Description; description of how the
                  font may be legally used, or different example
                  scenarios for licensed use. This field should be
                  written in plain language, not legalese.</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>License Info URL; URL where additional
                  licensing information can be found.</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>Reserved; Set to zero.</entry>
              </row>
              <row>
                <entry>16</entry> <entry>For historical reasons, font
		  families have contained a maximum of four styles,
		  but font designers may group more than four fonts to
		  a single family.  The Preferred Family allows font
		  designers to include the preferred family grouping
		  which contains more than four fonts. This ID is only
		  present if it is different from ID 1. </entry>
              </row>
              <row>
                <entry>17</entry> <entry>Preferred Subfamily allows
		  font designers to include the preferred subfamily
		  grouping that is more descriptive than ID 2. This ID
		  is only present if it is different from ID 2 and
		  must be unique for the the Preferred Family.</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>Compatible Full (Macintosh only); On the
                  Macintosh, the menu name is constructed using the
                  FOND resource. This usually matches the Full Name.
                  If you want the name of the font to appear
                  differently than the Full Name, you can insert the
                  Compatible Full Name in ID 18. </entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>Sample text; This can be the font name, or any
                  other text that the designer thinks is the best
                  sample to display the font in.</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry><para>PostScript CID findfont name; Its
                    presence in a font means that the nameID 6 holds a
                    PostScript font name that is meant to be used with
                    the "composefont" invocation in order to invoke
                    the font in a PostScript interpreter. See the
                    definition of name ID 6.</para> <para>The value
                    held in the name ID 20 string is interpreted as a
                    PostScript font name that is meant to be used with
                    the "findfont" invocation, in order to invoke the
                    font in a PostScript interpreter.</para> <para>If
                    the name ID 20 is present in a font, there must be
                    one name ID 20 record for every Macintosh platform
                    cmap subtable in that font. A particular name ID
                    20 record is associated with the encoding
                    specified by the matching cmap subtable. A name ID
                    20 record is matched to a cmap subtable when they
                    have the same platform and platform-specific
                    encoding IDs, and corresponding language/version
                    IDs. Name ID 20 records are meant to be used only
                    with Macintosh cmap subtables. The version field
                    for a cmap subtable is one more than the language
                    ID value for the corresponding name ID 20 record,
                    with the exception of the cmap subtable version
                    field 0. This version field, meaning "not
                    language-specific", corresponds to the language ID
                    value 0xFFFF, or decimal 65535, for the
                    corresponding name ID 20 record.</para> <para>When
                    translated to ASCII, this name string must be
                    restricted to the printable ASCII subset, codes 33
                    through 126, except for the 10 characters: '[',
                    ']', '(', ')', '{', '}', '&lt;', '>', '/',
                    '%'.</para> <para>Note that this specification
                    applies only to data fork OpenType fonts.
                    Macintosh resource-fork TrueType and other
                    Macintosh sfnt-wrapped fonts supply the PostScript
                    font name to be used with the "findfont"
                    invocation, in order to invoke the font in a
                    PostScript interpreter, in the FOND resource
                    style-mapping table.</para> <para>Note that a
                    particular Name ID 20 string always corresponds to
                    a particular Macintosh cmap subtable. However,
                    some host OpenType/TTF fonts also contain a post
                    table, format 4, which provides a mapping from
                    glyph ID to encoding value, and also corresponds
                    to a particular Macintosh cmap subtable.
                    Unfortunately, the <ottable>post</ottable> table
                    format 4 contains no provision for identifying
                    which Macintosh cmap subtable it matches, nor for
                    providing more than one mapping. Host fonts which
                    contain a <ottable>post</ottable> table format 4,
                    should also contain only a single Macintosh cmap
                    subtable, and a single Name ID 20 string. In the
                    case where there is more than one Macintosh cmap
                    subtable and more than one Name ID 20 string,
                    there is no definition of which one matches the
                    <ottable>post</ottable> table format
                    4.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Note that while both Apple and Microsoft support the
          same set of name strings, the interpretations may be
          somewhat different. But since name strings are stored by
          platform, encoding and language (placing separate strings in
          for both Apple and MS platforms), this should not present a
          problem.</para>

        <para>The key information for this table for MS fonts relates
          to the use of strings 1, 2 and 4. To better help understand,
          here are some examples of name usage, weight class and style
          flags:</para>

	<informaltable>
	  <tgroup cols='5'>
	    <thead>
	      <row>
		<entry>Font</entry>
		<entry>Name ID 1</entry>
		<entry>Name ID 2</entry>
		<entry>Name ID 4</entry>
		<entry>Name ID 16</entry>
		<entry>Name ID 17</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Arial Narrow</entry>
		<entry>Arial Narrow</entry>
		<entry>Regular</entry>
		<entry>Arial Narrow</entry>
		<entry>Arial</entry>
		<entry>Narrow</entry>
	      </row>
	      <row>
		<entry>Arial Narrow Italic</entry>
		<entry>Arial Narrow</entry>
		<entry>Italic</entry>
		<entry>Arial Narrow Italic</entry>
		<entry>Arial</entry>
		<entry>Narrow Italic</entry>
	      </row>
	      <row>
		<entry>Arial Narrow Bold</entry>
		<entry>Arial Narrow</entry>
		<entry>Bold</entry>
		<entry>Arial Narrow Bold</entry>
		<entry>Arial</entry>
		<entry>Narrow Bold</entry>
	      </row>
	      <row>
		<entry>Arial Narrow Bold Italic</entry>
		<entry>Arial Narrow</entry>
		<entry>Bold Italic</entry>
		<entry>Arial Narrow Bold Italic</entry>
		<entry>Arial</entry>
		<entry>Narrow Bold Italic</entry>
	      </row>
	      <row>
		<entry>Arial</entry>
		<entry>Arial</entry>
		<entry>Regular</entry>
		<entry>Arial</entry>
		<entry>Arial</entry>
	      </row>
	      <row>
		<entry>Arial Italic</entry>
		<entry>Arial</entry>
		<entry>Italic</entry>
		<entry>Arial Italic</entry>
		<entry>Arial</entry>
		<entry>Italic</entry>
	      </row>
	      <row>
		<entry>Arial Bold</entry>
		<entry>Arial</entry>
		<entry>Bold</entry>
		<entry>Arial Bold</entry>
		<entry>Arial</entry>
		<entry>Bold</entry>
	      </row>
	      <row>
		<entry>Arial Bold Italic</entry>
		<entry>Arial</entry>
		<entry>Bold Italic</entry>
		<entry>Arial Bold Italic</entry>
		<entry>Arial</entry>
		<entry>Bold Italic</entry>
	      </row>
	      <row>
		<entry>Arial Black</entry>
		<entry>Arial Black</entry>
		<entry>Regular</entry>
		<entry>Arial Black</entry>
		<entry>Arial</entry>
		<entry>Black</entry>
	      </row>
	      <row>
		<entry>Arial Black Italic</entry>
		<entry>Arial Black</entry>
		<entry>Italic</entry>
		<entry>Arial Black Italic</entry>
		<entry>Arial</entry>
		<entry>Black Italic</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>In addition to name strings, OS/2.usWeightClass,
	  OS/2.usWidthClass, OS/2.fsSelection style bits, and
	  head.macStyle bits are shown. These settings allow the fonts
	  to fit together into a single family of varying weight and
	  compression/expansion.</para>

	<informaltable>
	  <tgroup cols='9'>
	    <thead>
	      <row>
		<entry>Font</entry>
		<entry>OS/2 usWeightClass</entry>
		<entry>OS/2 usWidthClass</entry>
		<entry>OS/2 fsSelection Italic</entry>
		<entry>OS/2 fsSelection Bold</entry>
		<entry>OS/2 fsSelection Regular</entry>
		<entry>head macStyle Bold</entry>
		<entry>head macStyle Italic</entry>
		<entry>head macStyle Condensed</entry>
		<entry>head macStyle Extended</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Arial Narrow</entry>
		<entry>400</entry>
		<entry>3</entry>
		<entry></entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Narrow Italic</entry>
		<entry>400</entry>
		<entry>3</entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
		<entry></entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Narrow Bold</entry>
		<entry>700</entry>
		<entry>3</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Narrow Bold Italic</entry>
		<entry>700</entry>
		<entry>3</entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial</entry>
		<entry>400</entry>
		<entry>5</entry>
		<entry></entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
		<entry></entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Italic</entry>
		<entry>400</entry>
		<entry>5</entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Bold</entry>
		<entry>700</entry>
		<entry>5</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Bold Italic</entry>
		<entry>700</entry>
		<entry>5</entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Black</entry>
		<entry>900</entry>
		<entry>5</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
		<entry></entry>
	      </row>
	      <row>
		<entry>Arial Black Italic</entry>
		<entry>900</entry>
		<entry>5</entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
		<entry>x</entry>
		<entry>x</entry>
		<entry></entry>
		<entry></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Note that OS/2 and Windows both require that all name
          strings be defined in Unicode. Thus all 'name' table strings
          for platform ID = 3 (Microsoft) will require two bytes per
          character. Macintosh fonts require single byte
          strings.</para>

        <para>Examples of how these strings might be defined:</para>

        <para>0. The copyright string from the font vendor. <emphasis>&#x00a9;
          Copyright the Monotype Corporation plc, 1990</emphasis></para>

        <para>1. The name the user sees. <emphasis>Times New
            Roman</emphasis></para>

        <para>2. The name of the style. <emphasis>Bold</emphasis></para>

        <para>3. A unique identifier that applications can store to
          identify the font being used. Monotype: <emphasis>Times New Roman
          Bold:1990</emphasis></para>

        <para>4. The complete, hopefully unique, human readable name
          of the font. This name is used by Windows. <emphasis>Times
          New Roman Bold</emphasis>. (If this were the Microsoft
          platform string for a CFF OpenType font, then the value
          would be <emphasis>TimesNewRoman-Bold</emphasis>, as
          described in the definition of name ID 4 above.)</para>

        <para>5. Release and version information from the font vendor.
          <emphasis>Version 1.00 June 1, 1990, initial release</emphasis></para>

        <para>6. The name the font will be known by on a PostScript
          printer. <emphasis>TimesNewRoman-Bold</emphasis></para>

        <para>7. Trademark string. <emphasis>Times New Roman is a registered
          trademark of the Monotype Corporation.</emphasis></para>

        <para>8. Manufacturer. <emphasis>Monotype Corporation
        plc</emphasis></para>

        <para>9. Designer. <emphasis>Stanley Morison</emphasis></para>

        <para>10. Description. <emphasis>Designed in 1932 for the Times of
          London newspaper. Excellent readability and a narrow overall
          width, allowing more words per line than most fonts.</emphasis></para>

        <para>11. URL of Vendor.
          <emphasis>http://www.monotype.com</emphasis></para>

        <para>12. URL of Designer.
          <emphasis>http://www.monotype.com</emphasis></para>

        <para>13. License Description. <emphasis>This font may be installed on
          all of your machines and printers, but you may not sell or
          give these fonts to anyone else.</emphasis></para>

        <para>14. License Info URL.
          <emphasis>http://www.monotype.com/license/</emphasis></para>

        <para>15. Reserved. Set to zero.</para>

        <para>16. Preferred Family. No name string
          present, since it is the same as name ID 1 (Font Family
          name).</para>

        <para>17. Preferred Subfamily. No name string
          present, since it is the same as name ID 2 (Font Subfamily
          name).</para>

        <para>18. Compatible Full (Macintosh only). No name string
          present, since it is the same as name ID 4 (Full
          name).</para>

        <para>19. Sample text. <emphasis>The quick brown fox jumps over the lazy
          dog.</emphasis></para>

        <para>20. PostScript CID findfont name. No name string
          present. Thus, the PostScript Name defined by name ID 6
          should be used with the "findfont" invocation for locating
          the font in the context of a PostScript interpreter.</para>

        <para>The following is an example of only name IDs 6 and 20 in
          the CFF OpenType Japanese font Kozuka Mincho Std Regular
          (other name IDs are also present in this font):</para>

        <para>6. PostScript name:
          <emphasis>KozMinStd-Regular</emphasis>. Since a name ID 20
          is present in the font (see below), then the PostScript name
          defined by name ID 6 should be used with the "composefont"
          invocation for locating the font in the context of a
          PostScript interpreter.</para>

        <para>20. PostScript CID findfont name:
          <emphasis>KozMinStd-Regular-83pv-RKSJ-H</emphasis>, in a
          name record of Platform 1 [Macintosh], Platform-specific
          script 1 [Japanese], Language: 0xFFFF [English]. This name
          string is a PostScript name that should be used with the
          "findfont" invocation for locating the font in the context
          of a PostScript interpreter, and is associated with the
          encoding specified by the following cmap subtable, which
          must be present in the font: Platform: 1 [Macintosh];
          Platform-specific encoding: 1 [Japanese]; Language: 0 [not
          language-specific].</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>In the example, string 19 is not set in italic like the
        other strings.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>name table</code-title>
name =
  element name {
    element name-record {
      attribute platformID { text },
      attribute encodingID { text },
      attribute languageID { text },
      attribute nameID { text },
      attribute v { text }
    }*
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='name.methods'>
  static private void enterName (Block b, int offset, int nameID,
                                int stringSize, int stringOffset) {
    b.setuint16 (offset,    3);
    b.setuint16 (offset+2,  1);
    b.setuint16 (offset+4,  1033);
    b.setuint16 (offset+6,  nameID);
    b.setuint16 (offset+8,  stringSize*2);
    b.setuint16 (offset+10, stringOffset*2);
  }

  static public byte[] buildNameTable (String s)
      throws Exception {
    int nbEntries = 6;
    String storage = s + "-RegularVersion1.0";
    int blockSize = 6 + 12*nbEntries + 2*storage.length ();
    if (blockSize % 4 != 0) {
      blockSize = ((blockSize / 4) + 1) * 4; }
    Block b = new Block (blockSize, 0);

    b.setuint16 (0, 0);
    b.setuint16 (2, nbEntries);
    b.setuint16 (4, 6 + 12*nbEntries);

    enterName (b,  6, 1, s.length (), 0);
    enterName (b, 18, 2, 7, s.length () + 1);
    enterName (b, 30, 3, s.length (), 0);
    enterName (b, 42, 4, s.length () + 8, 0);
    enterName (b, 54, 5, 10, s.length () + 8);
    enterName (b, 66, 6, s.length () + 8, 0);

    for (int i = 0; i &lt; storage.length(); i++) {
      b.setuint16 (78 + 2*i, storage.charAt (i)); }

    return b.serialize ();
  }


  public void fromXML (Element name)
      throws InvalidFontException, UnsupportedFontException {
    NodeList nl = name.getChildNodes ();

    entries = new java.util.ArrayList &lt;Entry> ();

    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element oneName = (Element) nl.item (i);

      Entry e = new Entry ();
      e.platformID = Integer.decode (oneName.getAttribute ("platformID")).intValue ();
      e.encodingID = Integer.decode (oneName.getAttribute ("encodingID")).intValue ();
      e.languageID = Integer.decode (oneName.getAttribute ("languageID")).intValue ();
      e.nameID = Integer.decode (oneName.getAttribute ("nameID")).intValue ();

      String charset = getCharset (e.platformID, e.encodingID);

      try {
        e.s = oneName.getAttribute ("v").getBytes (charset); }

      catch (java.io.UnsupportedEncodingException ex) {
        System.err.println ("cannot convert name entry '"
                            + oneName.getAttribute ("v") + "' to charset '"
                            + charset + "'");
        e.s = new byte[] {}; }

      entries.add (e); }

    dataReady = false;
    expandedReady = true;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='name.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, UnsupportedFontException {

    AttributesImpl at;

    at = new AttributesImpl ();
    conf.ch.startElement ("name", at); {
      int stringOffset = getuint16 (4);
      for (int i = 0; i &lt; getuint16 (2); i++) {
        int platformID = getuint16 (6 + 12*i);
        int encodingID = getuint16 (6 + 12*i + 2);
        int languageID = getuint16 (6 + 12*i + 4);
        int nameID     = getuint16 (6 + 12*i + 6);
        int length     = getuint16 (6 + 12*i + 8);
        int offset     = getuint16 (6 + 12*i + 10);

        at = new AttributesImpl ();
        at.addAttribute ("", "platformID", "platformID", "CDATA",
	                 "" + platformID);
        at.addAttribute ("", "encodingID", "encodingID", "CDATA",
	                 "" + encodingID);
        at.addAttribute ("", "languageID", "languageID", "CDATA",
	                 "" + languageID);
        at.addAttribute ("", "nameID", "nameID", "CDATA",
	                 "" + nameID);

        String charset = getCharset (platformID, encodingID);
	if (charset == null) {
          throw new UnsupportedFontException ("name: unsupported encoding ("
                                + platformID + "/" + encodingID + ")"); }

        try {
          String v = new String (data, stringOffset + offset, length, charset);
          at.addAttribute ("", "v", "v", "CDATA", v); }
        catch (java.io.UnsupportedEncodingException e) {
          throw new UnsupportedFontException ("name: unsupported encoding ("
                                + platformID + "/" + encodingID + ")"); }

        conf.ch.element ("name-record", at); }
      conf.ch.endElement ("name"); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Name'>
  <code-title>Name class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Name extends Table {

  public Name () {
    super (Tag.name, null);
  }

  public Name (Font font) {
    super (Tag.name, font);
  }

  private boolean dataReady = false;
  private boolean expandedReady = false;

  public class Entry {
    public int platformID;
    public int encodingID;
    public int languageID;
    public int nameID;
    public byte[] s; }

  public java.util.ArrayList &lt;Entry> entries = null;

  public int fromBinary (java.io.InputStream in, int length)
      throws java.io.IOException, InvalidFontException {
    super.fromBinary (in, length);
    dataReady = true;
    expandedReady = false;
    return length;
  }

  public byte[] toBinary () {
    makeDataReady ();
    return data;
  }

  public void makeDataReady () {
    if (dataReady) {
      return; }

    int nbRecords = entries.size ();
    int storageSize = 0;
    for (int i = 0; i &lt; nbRecords; i++) {
      storageSize += entries.get (i).s.length; }

    Block b = new Block (6 + 12 * nbRecords + storageSize, 0);
    b.setuint16 (0, 0);
    b.setuint16 (2, nbRecords);
    b.setuint16 (4, 6 + 12 * nbRecords);

    int offset = 6;
    int storageOffset = 0;
    for (int i = 0; i &lt; nbRecords; i++) {
      Entry e = entries.get (i);
      b.setuint16 (offset, e.platformID);
      b.setuint16 (offset + 2, e.encodingID);
      b.setuint16 (offset + 4, e.languageID);
      b.setuint16 (offset + 6, e.nameID);
      b.setuint16 (offset + 8, e.s.length);
      b.setuint16 (offset + 10, storageOffset);
      offset += 12;
      storageOffset += e.s.length; }

    for (int i = 0; i &lt; nbRecords; i++) {
      Entry e = entries.get (i);
      for (int j = 0; j &lt; e.s.length; j++) {
        b.setuint8 (offset++, e.s[j]); }}

    data = b.serialize ();
    dataReady = true;
  }

  public void makeExpandedReady () {
  }




  public String getCharset (int platformID, int encodingID) {
         if (platformID == 3 &amp;&amp; encodingID ==  1) { return "UTF-16BE"; }
    else if (platformID == 3 &amp;&amp; encodingID ==  0) { return "UTF-16BE"; }
    else if (platformID == 3 &amp;&amp; encodingID == 10) { return "UTF-16BE"; }
    else if (platformID == 1 &amp;&amp; encodingID ==  0) { return "MacRoman"; }
    else if (platformID == 1 &amp;&amp; encodingID ==  1) { return "Shift_JIS"; }
    else if (platformID == 1 )                            { return "MacRoman"; }
    else if (platformID == 0)                             { return "UTF-16BE"; }
    else {                                                  return null; }
  }

  public String getName (int languageID, int nameID) {

    try {
      return getName (3, 1, languageID, nameID); }
    catch (java.io.UnsupportedEncodingException e) {
      // 3, 1 -> UTF-16BE, which must be supported
      return null; }
  }

  public String getName (int platformID, int encodingID,
                         int languageID, int nameID)
      throws java.io.UnsupportedEncodingException {
    String charset = getCharset (platformID, encodingID);

    if (charset == null) {
      throw new java.io.UnsupportedEncodingException (); }

    int nameRecordsNumber = getuint16 (2);
    int stringStorageOffset = getuint16 (4);

    for (int i = 0; i &lt; nameRecordsNumber; i++) {
       if (   getuint16 (6 + 12*i + 0) == platformID
           &amp;&amp; getuint16 (6 + 12*i + 2) == encodingID
           &amp;&amp; (   -1 == languageID
                       || getuint16 (6 + 12*i + 4) == languageID)
           &amp;&amp; getuint16 (6 + 12*i + 6) == nameID) {
         int stringLength = getuint16 (6 + 12*i + 8);
         int stringOffset = stringStorageOffset + getuint16 (6 + 12*i + 10);

         return new String (data, stringOffset, stringLength, charset); }}

    return null;
  }



  public class Representation {
    public int platformID;
    public int encodingID;
    public int languageID;

    public Representation (int platformID, int encodingID, int languageID) {
      this.platformID = platformID;
      this.encodingID = encodingID;
      this.languageID = languageID;
    }
  }

  public Representation[] getRepresentations (int nameID) {
   int nameRecordsNumber = getuint16 (2);

   int reps = 0;
   for (int i = 0; i &lt; nameRecordsNumber; i++) {
      if (getuint16 (6 + 12*i + 6) == nameID) {
        reps++; }}

   Representation[] r = new Representation [reps];
   reps = 0;

   for (int i = 0; i &lt; nameRecordsNumber; i++) {
      if (getuint16 (6 + 12*i + 6) == nameID) {
        r [reps++] = new Representation (getuint16 (6 + 12*i + 0),
                                         getuint16 (6 + 12*i + 2),
                                         getuint16 (6 + 12*i + 4)); }}

   return r;
  }

  public boolean checkOrder () {
    int nameRecordsNumber = getuint16 (2);

    int platformID = -1;
    int encodingID = -1;
    int languageID = -1;
    int nameID = -1;

    for (int i = 0; i &lt; nameRecordsNumber; i++) {
      int k;
      k = getuint16 (6 + 12*i + 0);
      if (k > platformID) {
        platformID = getuint16 (6 + 12*i + 0);
        encodingID = getuint16 (6 + 12*i + 2);
        languageID = getuint16 (6 + 12*i + 4);
        nameID     = getuint16 (6 + 12*i + 6); }
      else if (k &lt; platformID) {
        // System.out.println ("-- platformID " + k);
        return false; }
      else {
        k = getuint16 (6 + 12*i + 2);
        if (k > encodingID) {
          encodingID = getuint16 (6 + 12*i + 2);
          languageID = getuint16 (6 + 12*i + 4);
          nameID     = getuint16 (6 + 12*i + 6); }
        else if (k &lt; encodingID) {
          // System.out.println ("-- encodingID " + platformID + " " + k);
          return false; }
        else {
          k = getuint16 (6 + 12*i + 4);
          if (k > languageID) {
            languageID = getuint16 (6 + 12*i + 4);
            nameID     = getuint16 (6 + 12*i + 6); }
          else if (k &lt; languageID) {
            //System.out.println ("-- languageID " + platformID + " " + encodingID + " " + k);
            return false; }
          else {
            k = getuint16 (6 + 12*i + 6);
            if (k > nameID) {
              nameID = getuint16 (6 + 12*i + 6); }
            else {
              // System.out.println ("-- nameID " + platformID + " " + encodingID + " " + languageID + "  " + k);
              return false; }}}}}

    return true;
  }

  <code-include linkend='name.methods'/>
}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <para>The following piece of code creates a very basic name
        table. We use it for our test fonts.</para>

<code-fragment package='com.adobe.aots.opentype' class='NameBuilder'>
  <code-title>NameBuilder class</code-title>
  package com.adobe.aots.opentype;

  public class NameBuilder {
    private static void writeUSHORT (int n)
        throws java.io.IOException {
      byte[] data = new byte[2];
      data [1] =  (byte)( n       &amp; 0xff);
      data [0] =  (byte)((n >> 8) &amp; 0xff);
      System.out.write (data);
    }

    private static String storage = "";


    private static void writeNameRecord (int nameID, String s)
        throws java.io.IOException {
      writeUSHORT (3);
      writeUSHORT (1);
      writeUSHORT (1033);
      writeUSHORT (nameID);
      writeUSHORT (s.length () * 2);
      writeUSHORT (storage.length () * 2);
      storage = storage + s;
    }

    public static void main (String[] args) {
      try {
        int entries = 6;
        writeUSHORT (0);
        writeUSHORT (entries);
        writeUSHORT (6 + 12*entries);

        writeNameRecord (1, args[0]);
        writeNameRecord (2, "Regular");
        writeNameRecord (3, args[0]);
        writeNameRecord (4, args[0] + "-Regular");
        writeNameRecord (5, "Version 1.00");
        writeNameRecord (6, args[0] + "-Regular");

        for (int i = 0; i &lt; storage.length(); i++) {
          writeUSHORT (storage.charAt (i)); }}

      catch (Exception e) {
       System.out.println ("Exception: " + e.getMessage ());
       e.printStackTrace (); }
    }
  }
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.OS2'>
    <title>OS/2 - OS/2 and Windows Metrics</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The OS/2 table consists of a set of metrics that are
          required in OpenType fonts. The fourth version of the OS/2
          table (version 3) follows:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>0x0003</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xAvgCharWidth</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWeightClass</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWidthClass</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>fsType</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptXSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptYSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptXOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptYOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptXSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptYSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptXOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptYOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yStrikeoutSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yStrikeoutPosition</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sFamilyClass</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>panose[10]</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>42</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange1</otfieldname>
            <otfielddesc>Bits 0-31</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>46</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange2</otfieldname>
            <otfielddesc>Bits 32-63</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>50</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange3</otfieldname>
            <otfielddesc>Bits 64-95</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>54</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange4</otfieldname>
            <otfielddesc>Bits 96-127</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>60</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>achVendID[4]</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>64</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>fsSelection</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>66</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usFirstCharIndex</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>68</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usLastCharIndex</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>70</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sTypoAscender</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>72</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sTypoDescender</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>74</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sTypoLineGap</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>76</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWinAscent</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>78</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWinDescent</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>80</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulCodePageRange1</otfieldname>
            <otfielddesc>Bits 0-31</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>84</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulCodePageRange2</otfieldname>
            <otfielddesc>Bits 32-63</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>88</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sxHeight</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>90</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sCapHeight</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>92</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usDefaultChar</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>94</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usBreakChar</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>96</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usMaxContext</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
        </otformat>

        <bridgehead>version</bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Units: n/a</para>
        <para>Title: OS/2 table version number.</para>
        <para>Description: The version number for this OS/2
          table.</para>
        <para>Comments: The version number allows for identification
          of the precise contents and layout for the OS/2 table. The
          version number for this layout is three (3). Versions zero
          (0, TrueType rev 1.5), one (1, TrueType rev 1.66) and two
          (2, OpenType rev 1.2) have been used previously.</para>

        <bridgehead>xAvgCharWidth</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Pels / em units</para>
        <para>Title: Average weighted escapement.</para>

        <para>Description: The Average Character Width parameter
          specifies the arithmetic average of the escapement (width)
          of all non-zero width glyphs in the font.</para>
        <para>Comments: The value of xAvgCharWidth is calculated by
	  obtaining the arithmetic average of the width of all
	  non-zero width glyphs in the font. Furthermore, it is
	  strongly recommended that implementers do not rely on this
	  value for computing layout for lines of text. Especially,
	  for cases where complex scripts are used.</para>

        <bridgehead>usWeightClass</bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Title: Weight class. </para>
        <para>Description: Indicates the visual weight (degree of
          blackness or thickness of strokes) of the characters in the
          font. </para>
        <para>Comments:</para>


        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="4pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="18pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
                <entry>C Definition (from windows.h)</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>100</entry>
                <entry>Thin</entry>
                <entry>FW_THIN</entry>
              </row>
              <row>
                <entry>200</entry>
                <entry>Extra-light (Ultra-light)</entry>
                <entry>FW_EXTRALIGHT</entry>
              </row>
              <row>
                <entry>300</entry>
                <entry>Light</entry>
                <entry>FW_LIGHT</entry>
              </row>
              <row>
                <entry>400</entry>
                <entry>Normal (Regular)</entry>
                <entry>FW_NORMAL</entry>
              </row>
              <row>
                <entry>500</entry>
                <entry>Medium</entry>
                <entry>FW_MEDIUM</entry>
              </row>
              <row>
                <entry>600</entry>
                <entry>Semi-bold (Demi-bold)</entry>
                <entry>FW_SEMIBOLD</entry>
              </row>
              <row>
                <entry>700</entry>
                <entry>Bold</entry>
                <entry>FW_BOLD</entry>
              </row>
              <row>
                <entry>800</entry>
                <entry>Extra-bold (Ultra-bold)</entry>
                <entry>FW_EXTRABOLD</entry>
              </row>
              <row>
                <entry>900</entry>
                <entry>Black (Heavy)</entry>
                <entry>FW_BLACK</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>usWidthClass </bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Title: Width class. </para>
        <para>Description: Indicates a relative change from the normal
          aspect ratio (width to height ratio) as specified by a font
          designer for the glyphs in a font. </para>
        <para>Comments:  Although every character in a font may have a
          different numeric aspect ratio, each character in a font of
          normal width has a relative aspect ratio of one. When a new
          type style is created of a different width class (either by
          a font designer or by some automated means) the relative
          aspect ratio of the characters in the new font is some
          percentage greater or less than those same characters in the
          normal font -- it is this difference that this parameter
          specifies. </para>


        <informaltable>
          <tgroup cols='4'>
            <colspec colwidth="4pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="14pc"/>
            <colspec colwidth="4pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
                <entry>C Definition</entry>
                <entry>% of normal</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>Ultra-condensed</entry>
                <entry>FWIDTH_ULTRA_CONDENSED</entry>
                <entry>50</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Extra-condensed</entry>
                <entry>FWIDTH_EXTRA_CONDENSED</entry>
                <entry>62.5</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Condensed</entry>
                <entry>FWIDTH_CONDENSED</entry>
                <entry>75</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Semi-condensed</entry>
                <entry>FWIDTH_SEMI_CONDENSED</entry>
                <entry>87.5</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Medium (normal)</entry>
                <entry>FWIDTH_NORMAL</entry>
                <entry>100</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Semi-expanded</entry>
                <entry>FWIDTH_SEMI_EXPANDED</entry>
                <entry>112.5</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Expanded</entry>
                <entry>FWIDTH_EXPANDED</entry>
                <entry>125</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Extra-expanded</entry>
                <entry>FWIDTH_EXTRA_EXPANDED</entry>
                <entry>150</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Ultra-expanded</entry>
                <entry>FWIDTH_ULTRA_EXPANDED</entry>
                <entry>200</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>fsType</bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Title: Type flags. </para>
        <para>Description: Indicates font embedding licensing rights
          for the font. Embeddable fonts may be stored in a document.
          When a document with embedded fonts is opened on a system
          that does not have the font installed (the remote system),
          the embedded font may be loaded for temporary (and in some
          cases, permanent) use on that system by an embedding-aware
          application. Embedding licensing rights are granted by the
          vendor of the font.</para>

        <para>The OpenType Font Embedding DLL Specification and DLL
          release notes describe the APIs used to implement support
          for OpenType font embedding and loading.
          <emphasis>Applications that implement support for font
            embedding, either through use of the Font Embedding DLL or
            through other means, must not embed fonts which are not
            licensed to permit embedding. Further, applications
            loading embedded fonts for temporary use (see Preview
            &amp; Print and Editable embedding below) must delete the
            fonts when the document containing the embedded font is
            closed.</emphasis></para>

	<para>This version of the OS/2 table makes bits 0 - 3 a set of
	  exclusive bits. In other words, at most one bit in this
	  range may be set at a time. The purpose is to remove
	  misunderstandings caused by previous behavior of using the
	  least restrictive of the bits that are set.</para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="1cm"/>
            <colspec colwidth="2cm"/>
            <colspec colwidth="10cm"/>
            <thead>
              <row>
                <entry>Bit</entry>
                <entry>BitMask</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry></entry>
                <entry>0x0000</entry>
                <entry>Installable Embedding: No fsType bit is set.
                  Thus fsType is zero. Fonts with this setting
                  indicate that they may be embedded and permanently
                  installed on the remote system by an application.
                  The user of the remote system acquires the identical
                  rights, obligations and licenses for that font as
                  the original purchaser of the font, and is subject
                  to the same end-user license agreement, copyright,
                  design patent, and/or trademark as was the original
                  purchaser.</entry>
              </row>
              <row>
                <entry>0</entry>
                <entry>0x0001</entry>
                <entry>Reserved, must be zero.</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>0x0002</entry>
                <entry>Restricted License embedding: Fonts that have
                  <emphasis>only</emphasis> this bit set must not be
                  <emphasis>modified, embedded or exchanged in any
                    manner</emphasis> without first obtaining
                  permission of the legal owner. Caution: For
                  Restricted License embedding to take effect, it must
                  be the only level of embedding selected.</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>0x0004</entry>
                <entry>Preview &amp; Print embedding: When this bit is
                  set, the font may be embedded, and temporarily
                  loaded on the remote system. Documents containing
                  Preview &amp; Print fonts must be opened "read-only;" no
                  edits can be applied to the document.</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>0x0008</entry>
                <entry>Editable embedding: When this bit is set, the
                  font may be embedded but must only be installed
                  <emphasis>temporarily</emphasis> on other systems.
                  In contrast to Preview &amp; Print fonts, documents
                  containing Editable fonts <emphasis>may</emphasis>
                  be opened for reading, editing is permitted, and
                  changes may be saved.</entry>
              </row>
              <row>
                <entry>4-7</entry>
                <entry></entry>
                <entry>Reserved, must be zero.</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>0x0100</entry>
                <entry>No subsetting: When this bit is set, the font
                  may not be subsetted prior to embedding. Other
                  embedding restrictions specified in bits 0-3 and 9
                  also apply.</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>0x0200</entry>
                <entry>Bitmap embedding only: When this bit is set,
                  only bitmaps contained in the font may be embedded.
                  No outline data may be embedded. If there are no
                  bitmaps available in the font, then the font is
                  considered unembeddable and the embedding services
                  will fail. Other embedding restrictions specified in
                  bits 0-3 and 8 also apply.</entry>
              </row>
              <row>
                <entry>10-15</entry>
                <entry></entry>
                <entry>Reserved, must be zero.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>



        <bridgehead>ySubscriptXSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript horizontal font size. </para>
        <para>Description: The recommended horizontal size in font
          design units for subscripts for this font.  </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g., numerics and other, the numeric sizes
          should be stressed. This size field maps to the em square
          size of the font being used for a subscript. The horizontal
          font size specifies a font designer's recommended horizontal
          font size for subscript characters associated with this
          font. If a font does not include all of the required
          subscript characters for an application, and the application
          can substitute characters by scaling the character of a font
          or by substituting characters from another font, this
          parameter specifies the recommended em square for those
          subscript characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySubScriptXSize is set to 205, then the horizontal size for
          a simulated subscript character would be 1/10th the size of
          the normal character.</para>



        <bridgehead>ySubscriptYSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript vertical font size. </para>
        <para>Description: The recommended vertical size in font
          design units for subscripts for this font.  </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g. numerics and other, the numeric sizes
          should be stressed. This size field maps to the emHeight of
          the font being used for a subscript. The horizontal font
          size specifies a font designer's recommendation for
          horizontal font size of subscript characters associated with
          this font. If a font does not include all of the required
          subscript characters for an application, and the application
          can substitute characters by scaling the characters in a
          font or by substituting characters from another font, this
          parameter specifies the recommended horizontal EmInc for
          those subscript characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySubScriptYSize is set to 205, then the vertical size for a
          simulated subscript character would be 1/10th the size of
          the normal character.</para>



        <bridgehead>ySubscriptXOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript x offset.</para>
        <para>Description: The recommended horizontal offset in font
          design untis for subscripts for this font. </para>
        <para>Comments: The Subscript X Offset parameter specifies a
          font designer's recommended horizontal offset -- from the
          character origin of the font to the character origin of the
          subscript's character -- for subscript characters associated
          with this font. If a font does not include all of the
          required subscript characters for an application, and the
          application can substitute characters, this parameter
          specifies the recommended horizontal position from the
          character escapement point of the last character before the
          first subscript character. For upright characters, this
          value is usually zero; however, if the characters of a font
          have an incline (italic characters) the reference point for
          subscript characters is usually adjusted to compensate for
          the angle of incline.</para>



        <bridgehead>ySubscriptYOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript y offset. </para>
        <para>Description: The recommended vertical offset in font
          design units from the baseline for subscripts for this font.
        </para>
        <para>Comments: The Subscript Y Offset parameter specifies a
          font designer's recommended vertical offset from the
          character baseline to the character baseline for subscript
          characters associated with this font. Values are expressed
          as a positive offset below the character baseline. If a font
          does not include all of the required subscript for an
          application, this parameter specifies the recommended
          vertical distance below the character baseline for those
          subscript characters.</para>


        <bridgehead>ySuperscriptXSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript horizontal font size.</para>
        <para>Description: The recommended horizontal size in font
          design units for superscripts for this font. </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g., numerics and other, the numeric sizes
          should be stressed. This size field maps to the em square
          size of the font being used for a subscript. The horizontal
          font size specifies a font designer's recommended horizontal
          font size for superscript characters associated with this
          font. If a font does not include all of the required
          superscript characters for an application, and the
          application can substitute characters by scaling the
          character of a font or by substituting characters from
          another font, this parameter specifies the recommended em
          square for those superscript characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySuperScriptXSize is set to 205, then the horizontal size
          for a simulated superscript character would be 1/10th the
          size of the normal character.</para>



        <bridgehead>ySuperscriptYSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript vertical font size.</para>
        <para>Description: The recommended vertical size in font
          design units for superscripts for this font. </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g., numerics and other, the numeric sizes
          should be stressed. This size field maps to the emHeight of
          the font being used for a subscript. The vertical font size
          specifies a font designer's recommended vertical font size
          for superscript characters associated with this font. If a
          font does not include all of the required superscript
          characters for an application, and the application can
          substitute characters by scaling the character of a font or
          by substituting characters from another font, this parameter
          specifies the recommended EmHeight for those superscript
          characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySuperScriptYSize is set to 205, then the vertical size for
          a simulated superscript character would be 1/10th the size
          of the normal character.</para>



        <bridgehead>ySuperscriptXOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript x offset.</para>
        <para>Description: The recommended horizontal offset in font
          design units for superscripts for this font. </para>
        <para>Comments: The Superscript X Offset parameter specifies a
          font designer's recommended horizontal offset -- from the
          character origin to the superscript character's origin for
          the superscript characters associated with this font. If a
          font does not include all of the required superscript
          characters for an application, this parameter specifies the
          recommended horizontal position from the escapement point of
          the character before the first superscript character. For
          upright characters, this value is usually zero; however, if
          the characters of a font have an incline (italic characters)
          the reference point for superscript characters is usually
          adjusted to compensate for the angle of incline.</para>



        <bridgehead>ySuperscriptYOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript y offset.</para>
        <para>Description: The recommended vertical offset in font
          design units from the baseline for superscripts for this
          font. </para>
        <para>Comments: The Superscript Y Offset parameter specifies a
          font designer's recommended vertical offset -- from the
          character baseline to the superscript character's baseline
          associated with this font. Values for this parameter are
          expressed as a positive offset above the character baseline.
          If a font does not include all of the required superscript
          characters for an application, this parameter specifies the
          recommended vertical distance above the character baseline
          for those superscript characters.</para>



        <bridgehead>yStrikeoutSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Strikeout size.</para>
        <para>Description: Width of the strikeout stroke in font
          design units. </para>
        <para>Comments: This field should normally be the width of the
          em dash for the current font. If the size is one, the
          strikeout line will be the line represented by the strikeout
          position field. If the value is two, the strikeout line will
          be the line represented by the strikeout position and the
          line immediately above the strikeout position. For a Roman
          font with a 2048 em square, 102 is suggested.</para>



        <bridgehead>yStrikeoutPosition</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Strikeout position.</para>
        <para>Description: The position of the top of the strikeout
          stroke relative to the baseline in font design units.
        </para>
        <para>Comments: Positive values represent distances above the
          baseline, while negative values represent distances below
          the baseline. A value of zero falls directly on the
          baseline, while a value of one falls one pel above the
          baseline. The value of strikeout position should not
          interfere with the recognition of standard characters, and
          therefore should not line up with crossbars in the font. For
          a Roman font with a 2048 em square, 460 is suggested.</para>



        <bridgehead>sFamilyClass</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Title: Font-family class and subclass.</para>
        <para>Description: This parameter is a classification of
          font-family design. </para>
        <para>Comments: The font class and font subclass are
          registered values assigned by IBM to each font family. This
          parameter is intended for use in selecting an alternate font
          when the requested font is not available. The font class is
          the most general and the font subclass is the most specific.
          The high byte of this field contains the family class, while
          the low byte contains the family subclass. More information
          about this field.  </para>



        <bridgehead>Panose</bridgehead>

        <para>Format: 10 byte array</para>
        <para>Title: PANOSE classification number</para>
        <para>International: Additional specifications are required
          for PANOSE to classify non-Latin character sets.</para>
        <para>Description: This 10 byte series of numbers is used to
          describe the visual characteristics of a given typeface.
          These characteristics are then used to associate the font
          with other fonts of similar appearance having different
          names. The variables for each digit are listed below. The
          Panose values are fully described in the Panose "greybook"
          reference, currently owned by Agfa-Monotype. </para>
        <para>Comments: The PANOSE definition contains ten digits each
          of which currently describes up to sixteen variations.
          Windows uses bFamilyType, bSerifStyle and bProportion in the
          font mapper to determine family type. It also uses
          bProportion to determine if the font is monospaced. If the
          font is a symbol font, the first byte of the PANOSE number
          (bFamilyType) must be set to "pictorial." Good PANOSE values
          in fonts are very valuable to users of the Windows fonts
          folder. The specification for assigning PANOSE values is
          located at <ulink
        url='http://www.panose.com/hardware/pan2.asp'>http://www.panose.com/hardware/pan2.asp</ulink>.</para>


        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>BYTE</entry>
                <entry>bFamilyType</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bSerifStyle</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bWeight</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bProportion;</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bContrast</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bStrokeVariation</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bArmStyle</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bLetterform</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bMidline</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bXHeight</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <bridgehead>ulUnicodeRange1 (Bits 0-31)</bridgehead>
        <bridgehead>ulUnicodeRange2 (Bits 32-63)</bridgehead>
        <bridgehead>ulUnicodeRange3 (Bits 64-95)</bridgehead>
        <bridgehead>ulUnicodeRange4 (Bits 96-127)</bridgehead>

        <para>Format: 32-bit unsigned long(4 copies) totaling 128
          bits.</para>
        <para>Title: Unicode Character Range</para>
        <para>Description: This field is used to specify the Unicode
          blocks or ranges encompassed by the font file in the <ottable>cmap</ottable>
          subtable for platform 3, encoding ID 1 (Microsoft platform).
          If the bit is set (1) then the Unicode range is considered
          functional. If the bit is clear (0) then the range is not
          considered functional. Each of the bits is treated as an
          independent flag and the bits can be set in any combination.
          The determination of "functional" is left up to the font
          designer, although character set selection should attempt to
          be functional by ranges if at all possible.</para>

        <para>All reserved fields must be zero. Each long is in Big-Endian
          form. See the Basic Multilingual Plane of ISO/IEC 10646-1 or
          the Unicode Standard v.3.0 for the list of Unicode ranges
          and characters.  </para>


        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>Bit</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Basic Latin</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Latin-1 Supplement</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Latin Extended-A</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Latin Extended-B</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>IPA Extensions</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Spacing Modifier Letters</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Combining Diacritical Marks</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Greek and Coptic</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Cyrillic</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Cyrillic Supplementary</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Armenian</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>Devanagari</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>Bengali</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>Gurmukhi</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>Gujarati</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>Oriya</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry>Tamil</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry>Telugu</entry>
              </row>
              <row>
                <entry>22</entry>
                <entry>Kannada</entry>
              </row>
              <row>
                <entry>23</entry>
                <entry>Malayalam</entry>
              </row>
              <row>
                <entry>24</entry>
                <entry>Thai</entry>
              </row>
              <row>
                <entry>25</entry>
                <entry>Lao</entry>
              </row>
              <row>
                <entry>26</entry>
                <entry>Georgian</entry>
              </row>
              <row>
                <entry>27</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>28</entry>
                <entry>Hangul Jamo</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry>Latin Extended Additional</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry>Greek Extended</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry>General Punctuation</entry>
              </row>
              <row>
                <entry>32</entry>
                <entry>Superscripts And Subscripts</entry>
              </row>
              <row>
                <entry>33</entry>
                <entry>Currency Symbols</entry>
              </row>
              <row>
                <entry>34</entry>
                <entry>Combining Diacritical Marks For Symbols</entry>
              </row>
              <row>
                <entry>35</entry>
                <entry>Letterlike Symbols</entry>
              </row>
              <row>
                <entry>36</entry>
                <entry>Number Forms</entry>
              </row>
              <row>
                <entry>37</entry>
                <entry>Arrows</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Supplemental Arrows-A</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Supplemental Arrows-B</entry>
              </row>
              <row>
                <entry>38</entry>
                <entry>Mathematical Operators</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Supplemental Mathematical Operators</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Miscellaneous Mathematical Symbols-A</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Miscellaneous Mathematical Symbols-B</entry>
              </row>
              <row>
                <entry>39</entry>
                <entry>Miscellaneous Technical</entry>
              </row>
              <row>
                <entry>40</entry>
                <entry>Control Pictures</entry>
              </row>
              <row>
                <entry>41</entry>
                <entry>Optical Character Recognition</entry>
              </row>
              <row>
                <entry>42</entry>
                <entry>Enclosed Alphanumerics</entry>
              </row>
              <row>
                <entry>43</entry>
                <entry>Box Drawing</entry>
              </row>
              <row>
                <entry>44</entry>
                <entry>Block Elements</entry>
              </row>
              <row>
                <entry>45</entry>
                <entry>Geometric Shapes</entry>
              </row>
              <row>
                <entry>46</entry>
                <entry>Miscellaneous Symbols</entry>
              </row>
              <row>
                <entry>47</entry>
                <entry>Dingbats</entry>
              </row>
              <row>
                <entry>48</entry>
                <entry>CJK Symbols And Punctuation</entry>
              </row>
              <row>
                <entry>49</entry>
                <entry>Hiragana</entry>
              </row>
              <row>
                <entry>50</entry>
                <entry>Katakana</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Katakana Phonetic Extensions</entry>
              </row>
              <row>
                <entry>51</entry>
                <entry>Bopomofo</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Bopomofo Extended</entry>
              </row>
              <row>
                <entry></entry>
                <entry>  Extended Bopomofo</entry>
              </row>
              <row>
                <entry>52</entry>
                <entry>Hangul Compatibility Jamo</entry>
              </row>
              <row>
                <entry>53</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>54</entry>
                <entry>Enclosed CJK Letters And Months</entry>
              </row>
              <row>
                <entry>55</entry>
                <entry>CJK Compatibility</entry>
              </row>
              <row>
                <entry>56</entry>
                <entry>Hangul Syllables</entry>
              </row>
              <row>
                <entry>57</entry>
                <entry>Non-Plane 0<footnote>
                        <para>Setting bit 57 implies that there is
                      at least one codepoint beyond the Basic
                      Multilingual Plane that is supported by this
                      font.</para>
                  </footnote></entry>
              </row>
              <row>
                <entry>58</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>59</entry>
                <entry>CJK Unified Ideographs</entry>
              </row>
              <row>
                <entry></entry>
                <entry>CJK Radicals Supplement</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Kangxi Radicals</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Ideographic Description Characters</entry>
              </row>
              <row>
                <entry></entry>
                <entry>CJK Unified Ideograph Extension A</entry>
              </row>
              <row>
                <entry></entry>
                <entry>CJK Unified Ideograph Extension B</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Kanbun</entry>
              </row>
              <row>
                <entry>60</entry>
                <entry>Private Use Area</entry>
              </row>
              <row>
                <entry>61</entry>
                <entry>CJK Compatibility Ideographs</entry>
              </row>
              <row>
                <entry></entry>
                <entry>CJK Compatibility Ideographs Supplement</entry>
              </row>
              <row>
                <entry>62</entry>
                <entry>Alphabetic Presentation Forms</entry>
              </row>
              <row>
                <entry>63</entry>
                <entry>Arabic Presentation Forms-A</entry>
              </row>
              <row>
                <entry>64</entry>
                <entry>Combining Half Marks</entry>
              </row>
              <row>
                <entry>65</entry>
                <entry>CJK Compatibility Forms</entry>
              </row>
              <row>
                <entry>66</entry>
                <entry>Small Form Variants</entry>
              </row>
              <row>
                <entry>67</entry>
                <entry>Arabic Presentation Forms-B</entry>
              </row>
              <row>
                <entry>68</entry>
                <entry>Halfwidth And Fullwidth Forms</entry>
              </row>
              <row>
                <entry>69</entry>
                <entry>Specials</entry>
              </row>
              <row>
                <entry>70</entry>
                <entry>Tibetan</entry>
              </row>
              <row>
                <entry>71</entry>
                <entry>Syriac</entry>
              </row>
              <row>
                <entry>72</entry>
                <entry>Thaana</entry>
              </row>
              <row>
                <entry>73</entry>
                <entry>Sinhala</entry>
              </row>
              <row>
                <entry>74</entry>
                <entry>Myanmar</entry>
              </row>
              <row>
                <entry>75</entry>
                <entry>Ethiopic</entry>
              </row>
              <row>
                <entry>76</entry>
                <entry>Cherokee</entry>
              </row>
              <row>
                <entry>77</entry>
                <entry>Unified Canadian Aboriginal Syllabics</entry>
              </row>
              <row>
                <entry>78</entry>
                <entry>Ogham</entry>
              </row>
              <row>
                <entry>79</entry>
                <entry>Runic</entry>
              </row>
              <row>
                <entry>80</entry>
                <entry>Khmer</entry>
              </row>
              <row>
                <entry>81</entry>
                <entry>Mongolian</entry>
              </row>
              <row>
                <entry>82</entry>
                <entry>Braille Patterns</entry>
              </row>
              <row>
                <entry>83</entry>
                <entry>Yi Syllables</entry>
              </row>
              <row>
                <entry></entry>
                <entry>Yi Radicals</entry>
              </row>
	      <row>
		<entry>84</entry>
		<entry>Tagalog</entry>
	      </row>
	      <row>
		<entry></entry>
		<entry>Hanunoo</entry>
	      </row>
	      <row>
		<entry></entry>
		<entry>Buhid</entry>
	      </row>
	      <row>
		<entry></entry>
		<entry>Tagbanwa</entry>
	      </row>
	      <row>
		<entry>85</entry>
		<entry>Old Italic</entry>
	      </row>
	      <row>
		<entry>86</entry>
		<entry>Gothic</entry>
	      </row>
	      <row>
		<entry>87</entry>
		<entry>Deseret</entry>
	      </row>
	      <row>
		<entry>88</entry>
		<entry>Byzantine Musical Symbols</entry>
	      </row>
	      <row>
		<entry></entry>
		<entry>Musical Symbols</entry>
	      </row>
	      <row>
		<entry>89</entry>
		<entry>Mathematical Alphanumeric Symbols</entry>
	      </row>
	      <row>
		<entry>90</entry>
		<entry>Private Use (plane 15)</entry>
	      </row>
	      <row>
		<entry></entry>
		<entry>Private Use (plane 16)</entry>
	      </row>
	      <row>
		<entry>91</entry>
		<entry>Variation Selectors</entry>
	      </row>
	      <row>
		<entry>92</entry>
		<entry>Tags</entry>
	      </row>
              <row>
                <entry>93-127</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>



        <bridgehead>achVendID</bridgehead>

        <para>Format: 4-byte character array</para>
        <para>Title: Font Vendor Identification</para>
        <para>Description: The four character identifier for the
          vendor of the given type face.</para>
        <para>Comments: This is not the royalty owner of the original
          artwork. This is the company responsible for the marketing
          and distribution of the typeface that is being classified.
          It is reasonable to assume that there will be 6 vendors of
          ITC Zapf Dingbats for use on desktop platforms in the near
          future (if not already). It is also likely that the vendors
          will have other inherent benefits in their fonts (more kern
          pairs, unregularized data, hand hinted, etc.). This
          identifier will allow for the correct vendor's type to be
          used over another, possibly inferior, font file. The Vendor
          ID value is not required.</para>
        <para>Microsoft has assigned values for some font suppliers as
          listed below. Uppercase vendor ID's are reserved by
          Microsoft. Other suppliers can choose their own mixed case
          or lowercase ID's, or leave the field blank.</para>


        <para>For a list of registered Vendor id's see our <ulink
            url="http://www.microsoft.com/typography/links/vendorlist.asp">Registered
            'vendors'</ulink> links page.</para>


        <bridgehead>fsSelection</bridgehead>

        <para>Format: 2-byte bit field.</para>
        <para>Title: Font selection flags.</para>
        <para>Description: Contains information concerning the nature
          of the font patterns, as follows:</para>


        <informaltable>
          <tgroup cols='4'>
            <colspec colwidth="4pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="10pc"/>
            <thead>
              <row>
                <entry>Bit #</entry>
                <entry>macStyle bit</entry>
                <entry>C Definition</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>bit 1</entry>
                <entry>ITALIC</entry>
                <entry>Font contains Italic characters, otherwise they
                  are upright.</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry></entry>
                <entry>UNDERSCORE</entry>
                <entry>Characters are underscored.</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry></entry>
                <entry>NEGATIVE</entry>
                <entry>Characters have their foreground and background
                  reversed.</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry></entry>
                <entry>OUTLINED</entry>
                <entry>Outline (hollow) characters, otherwise they are
                  solid.</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry></entry>
                <entry>STRIKEOUT</entry>
                <entry>Characters are overstruck</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>bit 0</entry>
                <entry>BOLD</entry>
                <entry>Characters are emboldened.</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry></entry>
                <entry>REGULAR</entry>
                <entry>Characters are in the standard weight/style for
                  the font.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>Comments: All undefined bits must be zero.</para>

        <para>This field contains information on the original design
          of the font. Bits 0 &amp; 5 can be used to determine if the font
          was designed with these features or whether some type of
          machine simulation was performed on the font to achieve this
          appearance. Bits 1-4 are rarely used bits that indicate the
          font is primarily a decorative or special purpose
          font.</para>

        <para>If bit 6 is set, then bits 0 and 5 must be clear, else
          the behavior is undefined. As noted above, the settings of
          bits 0 and 1 must be reflected in the macStyle bits in the
          <ottable>head</ottable> table. While bit 6 on implies that
          bits 0 and 1 of macStyle are clear (along with bits 0 and 5
          of fsSelection), the reverse is not true. Bits 0 and 1 of
          macStyle (and 0 and 5 of fsSelection) may be clear and that
          does not give any indication of whether or not bit 6 of
          fsSelection is clear (e.g., Arial Light would have all bits
          cleared; it is not the regular version of Arial). </para>



        <bridgehead>usFirstCharIndex</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The minimum Unicode index (character code)
          in this font, according to the cmap subtable for platform ID
          3 and platform- specific encoding ID 0 or 1. For most fonts
          supporting Win-ANSI or other character sets, this value
          would be 0x0020. This field cannot represent supplementary
	  character values (codepoints greater than 0xFFFF). Fonts that
	  support supplementary characters should set the value in this
	  field to 0xFFFF if the minimum index value is a supplementary
	  character.</para>



        <bridgehead>usLastCharIndex</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The maximum Unicode index (character code)
          in this font, according to the cmap subtable for platform ID
          3 and encoding ID 0 or 1. This value depends on which
          character sets the font supports. This field cannot
	  represent supplementary character values (codepoints greater
	  than 0xFFFF). Fonts that support supplementary characters
	  should set the value in this field to 0xFFFF. </para>


        <bridgehead>sTypoAscender</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: The typographic ascender for this font.
          Remember that this is not the same as the Ascender value in
          the <ottable>hhea</ottable> table, which Apple defines in a
          far different manner. One good source for sTypoAscender in
          Latin based fonts is the Ascender value from an AFM file.
          For CJK fonts see below.</para>

        <para>The suggested usage for sTypoAscender is that it be used
          in conjunction with unitsPerEm to compute a typographically
          correct default line spacing. The goal is to free
          applications from Macintosh or Windows-specific metrics
          which are constrained by backward compatibility
          requirements. These new metrics, when combined with the
          character design widths, will allow applications to lay out
          documents in a typographically correct and portable fashion.
          These metrics will be exposed through Windows APIs.
          Macintosh applications will need to access the 'sfnt'
          resource and parse it to extract this data from the
          <ottable>OS/2</ottable> table.</para>

        <para>For CJK (Chinese, Japanese, and Korean) fonts that are
          intended to be used for vertical writing (in addition to
          horizontal writing), the required value for sTypoAscender is
          that which describes the top of the of the ideographic
          em-box. For example, if the ideographic em-box of the font
          extends from coordinates 0,-120 to 1000,880 (that is, a
          1000x1000 box set 120 design units below the Latin
          baseline), then the value of sTypoAscender must be set to
          880. Failing to adhere to these requirements will result in
          incorrect vertical layout.</para>

        <para>Also see the Recommendations Section for more on this
          field. </para>



        <bridgehead>sTypoDescender</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: The typographic descender for this font.
          Remember that this is not the same as the Descender value in
          the <ottable>hhea</ottable> table, which Apple defines in a
          far different manner. One good source for sTypoDescender in
          Latin based fonts is the Descender value from an AFM file.
          For CJK fonts see below.</para>

        <para>The suggested usage for sTypoDescender is that it be
          used in conjunction with unitsPerEm to compute a
          typographically correct default line spacing. The goal is to
          free applications from Macintosh or Windows-specific metrics
          which are constrained by backward compatability
          requirements. These new metrics, when combined with the
          character design widths, will allow applications to lay out
          documents in a typographically correct and portable fashion.
          These metrics will be exposed through Windows APIs.
          Macintosh applications will need to access the 'sfnt'
          resource and parse it to extract this data from the
          <ottable>OS/2</ottable> table (unless Apple exposes the
          <ottable>OS/2</ottable> table through a new API).</para>

        <para>For CJK (Chinese, Japanese, and Korean) fonts that are
          intended to be used for vertical writing (in addition to
          horizontal writing), the required value for sTypoDescender
          is that which describes the bottom of the of the ideographic
          em-box. For example, if the ideographic em-box of the font
          extends from coordinates 0,-120 to 1000,880 (that is, a
          1000x1000 box set 120 design units below the Latin
          baseline), then the value of sTypoDescender must be set to
          -120. Failing to adhere to these requirements will result in
          incorrect vertical layout.</para>

        <para>Also see the Recommendations Section for more on this
          field. </para>



        <bridgehead>sTypoLineGap</bridgehead>

        <para>Format: 2-byte SHORT</para>
        <para>Description: The typographic line gap for this font.
          Remember that this is not the same as the LineGap value in
          the <ottable>hhea</ottable> table, which Apple defines in a
          far different manner.</para>

        <para>The suggested usage for usTypoLineGap is that it be used
          in conjunction with unitsPerEm to compute a typographically
          correct default line spacing. Typical values average 7-10%
          of units per em. The goal is to free applications from
          Macintosh or Windows-specific metrics which are constrained
          by backward compatability requirements (see chapter,
          "Recommendations for OpenType Fonts"). These new metrics, when
          combined with the character design widths, will allow
          applications to lay out documents in a typographically
          correct and portable fashion. These metrics will be exposed
          through Windows APIs. Macintosh applications will need to
          access the 'sfnt' resource and parse it to extract this data
          from the <ottable>OS/2</ottable> table (unless Apple exposes
          the <ottable>OS/2</ottable> table through a new API) </para>


        <bridgehead>usWinAscent</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The ascender metric for Windows. This, too,
          is distinct from Apple's Ascender value and from the
          usTypoAscender values. usWinAscent is computed as the yMax
          for all characters in the Windows ANSI character set.
          usWinAscent is used to compute the Windows font height and
          default line spacing. For platform 3 encoding 0 fonts, it is
          the same as yMax. Windows will clip the bitmap of any
          portion of a glyph that appears above this value. Some
          applications use this value to determine default line
          spacing. This is strongly discouraged. The typographic
          ascender, descender and line gap fields in conjunction with
          unitsPerEm should be used for this purpose. Developers
          should set this field keeping the above factors in
          mind.</para>
        <para>If any clipping is unacceptable, then the value should
          be set to yMax.</para>
        <para>However, if a developer desires to provide appropriate
          default line spacing using this field, for those
          applications that continue to use this field for doing so
          (against OpenType recommendations), then the value should be
          set appropriately. In such a case, it may result in some
          glyph bitmaps being clipped.</para>



        <bridgehead>usWinDescent</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The descender metric for Windows. This,
          too, is distinct from Apple's Descender value and from the
          usTypoDescender values. usWinDescent is computed as the
          -yMin for all characters in the Windows ANSI character set.
          usWinDescent is used to compute the Windows font height and
          default line spacing. For platform 3 encoding 0 fonts, it is
          the same as -yMin. Windows will clip the bitmap of any
          portion of a glyph that appears below this value. Some
          applications use this value to determine default line
          spacing. This is strongly discouraged. The typographic
          ascender, descender and line gap fields in conjunction with
          unitsPerEm should be used for this purpose. Developers
          should set this field keeping the above factors in
          mind.</para>
        <para>If any clipping is unacceptable, then the value should
          be set to yMin.</para>
        <para>However, if a developer desires to provide appropriate
          default line spacing using this field, for those
          applications that continue to use this field for doing so
          (against OpenType recommendations), then the value should be
          set appropriately. In such a case, it may result in some
          glyph bitmaps being clipped. </para>



        <bridgehead>ulCodePageRange1 Bits 0-31</bridgehead>
        <bridgehead>ulCodePageRange2 Bits 32-63 </bridgehead>

        <para>Format: 32-bit unsigned long(2 copies) totaling 64
          bits.</para>

        <para>Title: Code Page Character Range</para>

        <para>Description: This field is used to specify the code
        pages encompassed by the font file in the
        <ottable>cmap</ottable> subtable for platform 3, encoding ID 1
        (Microsoft platform). If the font file is encoding ID 0, then
        the Symbol Character Set bit should be set. If the bit is set
        (1) then the code page is considered functional. If the bit is
        clear (0) then the code page is not considered
        functional. Each of the bits is treated as an independent flag
        and the bits can be set in any combination. The determination
        of "functional" is left up to the font designer, although
        character set selection should attempt to be functional by
        code pages if at all possible.</para>

        <para>Symbol character sets have a special meaning. If the
        symbol bit (31) is set, and the font file contains a
        <ottable>cmap</ottable> subtable for platform of 3 and
        encoding ID of 1, then all of the characters in the Unicode
        range 0xF000 - 0xF0FF (inclusive) will be used to enumerate
        the symbol character set. If the bit is not set, any
        characters present in that range will not be enumerated as a
        symbol character set.</para>

        <para>All reserved fields must be zero. Each long is in
          Big-Endian form. </para>


        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="6pc"/>
            <colspec colwidth="18pc"/>
            <thead>
              <row>
                <entry>Bit</entry>
                <entry>Code</entry>
                <entry>Page Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>1252</entry>
                <entry>Latin 1</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>1250</entry>
                <entry>Latin 2: Eastern Europe</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>1251</entry>
                <entry>Cyrillic</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>1253</entry>
                <entry>Greek</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>1254</entry>
                <entry>Turkish</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>1255</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>1256</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>1257</entry>
                <entry>Windows Baltic</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>1258</entry>
                <entry>Vietnamese</entry>
              </row>
              <row>
                <entry>9-15</entry>
                <entry></entry>
                <entry>Reserved for Alternate ANSI</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>874</entry>
                <entry>Thai</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>932</entry>
                <entry>JIS/Japan</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>936</entry>
                <entry>Chinese: Simplified chars--PRC and
                  Singapore</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>949</entry>
                <entry>Korean Wansung</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry>950</entry>
                <entry>Chinese: Traditional chars--Taiwan and Hong
                  Kong</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry>1361</entry>
                <entry>Korean Johab</entry>
              </row>
              <row>
                <entry>22-28</entry>
                <entry></entry>
                <entry>Reserved for Alternate ANSI &amp; OEM</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry></entry>
                <entry>Macintosh Character Set (US Roman)</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry></entry>
                <entry>OEM Character Set</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry></entry>
                <entry>Symbol Character Set</entry>
              </row>
              <row>
                <entry>32-47</entry>
                <entry></entry>
                <entry>Reserved for OEM</entry>
              </row>
              <row>
                <entry>48</entry>
                <entry>869</entry>
                <entry>IBM Greek</entry>
              </row>
              <row>
                <entry>49</entry>
                <entry>866</entry>
                <entry>MS-DOS Russian</entry>
              </row>
              <row>
                <entry>50</entry>
                <entry>865</entry>
                <entry>MS-DOS Nordic</entry>
              </row>
              <row>
                <entry>51</entry>
                <entry>864</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>52</entry>
                <entry>863</entry>
                <entry>MS-DOS Canadian French</entry>
              </row>
              <row>
                <entry>53</entry>
                <entry>862</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>54</entry>
                <entry>861</entry>
                <entry>MS-DOS Icelandic</entry>
              </row>
              <row>
                <entry>55</entry>
                <entry>860</entry>
                <entry>MS-DOS Portuguese</entry>
              </row>
              <row>
                <entry>56</entry>
                <entry>857</entry>
                <entry>IBM Turkish</entry>
              </row>
              <row>
                <entry>57</entry>
                <entry>855</entry>
                <entry>IBM Cyrillic; primarily Russian</entry>
              </row>
              <row>
                <entry>58</entry>
                <entry>852</entry>
                <entry>Latin 2</entry>
              </row>
              <row>
                <entry>59</entry>
                <entry>775</entry>
                <entry>MS-DOS Baltic</entry>
              </row>
              <row>
                <entry>60</entry>
                <entry>737</entry>
                <entry>Greek; former 437 G</entry>
              </row>
              <row>
                <entry>61</entry>
                <entry>708</entry>
                <entry>Arabic; ASMO 708</entry>
              </row>
              <row>
                <entry>62</entry>
                <entry>850</entry>
                <entry>WE/Latin 1</entry>
              </row>
              <row>
                <entry>63</entry>
                <entry>437</entry>
                <entry>US</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>sxHeight</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: This metric specifies the distance between
          the baseline and the approximate height of non-ascending
          lowercase letters measured in FUnits. This value would
          normally be specified by a type designer but in situations
          where that is not possible, for example when a legacy font
          is being converted, the value may be set equal to the top of
          the unscaled and unhinted glyph bounding box of the glyph
          encoded at U+0078 (LATIN SMALL LETTER X). If no glyph is
          encoded in this position the field should be set to
          0.</para>

        <para>This metric, if specified, can be used in font
          substitution: the xHeight value of one font can be scaled to
          approximate the apparent size of another. </para>



        <bridgehead>sCapHeight</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: This metric specifies the distance between
          the baseline and the approximate height of uppercase letters
          measured in FUnits. This value would normally be specified
          by a type designer but in situations where that is not
          possible, for example when a legacy font is being converted,
          the value may be set equal to the top of the unscaled and
          unhinted glyph bounding box of the glyph encoded at U+0048
          (LATIN CAPITAL LETTER H). If no glyph is encoded in this
          position the field should be set to 0.</para>

        <para>This metric, if specified, can be used in systems that
          specify type size by capital height measured in millimeters.
          It can also be used as an alignment metric; the top of a
          drop capital, for instance, can be aligned to the sCapHeight
          metric of the first line of text. </para>



        <bridgehead>usDefaultChar</bridgehead>

        <para>Format: USHORT</para>
        <para>Description: Whenever a request is made for a character
          that is not in the font, Windows provides this default
          character. If the value of this field is zero, glyph ID 0 is
          to be used for the default character otherwise this is the
          Unicode encoding of the glyph that Windows uses as the
          default character. This field cannot represent supplementary
          character values (codepoints greater than 0xFFFF).</para>



        <bridgehead>usBreakChar</bridgehead>

        <para>Format: USHORT</para>
        <para>Description: This is the Unicode encoding of the glyph
          that Windows uses as the break character. The break
          character is used to separate words and justify text. Most
          fonts specify 'space' as the break character. This field
          cannot represent supplementary character values (codepoints
          greater than 0xFFFF).</para>


        <bridgehead>usMaxContext</bridgehead>

        <para>Format: USHORT</para>
        <para>Description: The maximum length of a target glyph
          context for any feature in this font. For example, a font
          which has only a pair kerning feature should set this field
          to 2. If the font also has a ligature feature in which the
          glyph sequence 'f f i' is substituted by the ligature 'ffi',
          then this field should be set to 3. This field could be
          useful to sophisticated line-breaking engines in determining
          how far they should look ahead to test whether something
          could change that effects the line breaking. For chaining
          contextual lookups, the length of the string (covered glyph)
          + (input sequence) + (lookahead sequence) should be
          considered.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The OS/2 table consists of a set of metrics that are
          required in OpenType fonts. The fourth version of the OS/2
          table (version 3) follows:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>0x0003</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xAvgCharWidth</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWeightClass</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWidthClass</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>fsType</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptXSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptYSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptXOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySubscriptYOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptXSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptYSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptXOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ySuperscriptYOffset</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yStrikeoutSize</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yStrikeoutPosition</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sFamilyClass</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>panose[10]</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>42</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange1</otfieldname>
            <otfielddesc>Bits 0-31</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>46</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange2</otfieldname>
            <otfielddesc>Bits 32-63</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>50</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange3</otfieldname>
            <otfielddesc>Bits 64-95</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>54</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulUnicodeRange4</otfieldname>
            <otfielddesc>Bits 96-127</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>60</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>achVendID[4]</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>64</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>fsSelection</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>66</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usFirstCharIndex</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>68</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usLastCharIndex</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>70</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sTypoAscender</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>72</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sTypoDescender</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>74</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sTypoLineGap</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>76</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWinAscent</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>78</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usWinDescent</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>80</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulCodePageRange1</otfieldname>
            <otfielddesc>Bits 0-31</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>84</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulCodePageRange2</otfieldname>
            <otfielddesc>Bits 32-63</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>88</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sxHeight</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>90</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>sCapHeight</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>92</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usDefaultChar</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>94</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usBreakChar</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>96</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usMaxContext</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
        </otformat>

        <bridgehead>version</bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Units: n/a</para>
        <para>Title: OS/2 table version number.</para>
        <para>Description: The version number for this OS/2
          table.</para>
        <para>Comments: The version number allows for identification
          of the precise contents and layout for the OS/2 table. The
          version number for this layout is two (2). Versions one (1)
          and zero (0) have been used previously, in rev.1.66 and 1.5,
          respectively, of the TrueType specification.</para>

        <bridgehead>xAvgCharWidth</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Pels / em units</para>
        <para>Title: Average weighted escapement.</para>
        <para>Description: The Average Character Width parameter
          specifies the arithmetic average of the escapement (width)
          of all of the 26 lowercase letters a through z of the Latin
          alphabet and the space character. If any of the 26 lowercase
          letters are not present, this parameter should equal the
          weighted average of all glyphs in the font. For non-UGL
          (platform 3, encoding 0) fonts, use the unweighted
          average.</para>
        <para>Comments: This parameter is a descriptive attribute of
          the font that specifies the spacing of characters for
          comparing one font to another for selection or substitution.
          For proportionally spaced fonts, this value is useful in
          estimating the length for lines of text. The weighting
          factors provided with this example are only valid for Latin
          lowercase letters. If other character sets, or capital
          letters are used, the corresponding frequency of use values
          should be used. One needs to be careful when comparing fonts
          that use different frequency of use values for font mapping.
          The average character width for the following set of upper
          and lowercase letters only, is calculated according to this
          formula: Sum the individual character widths multiplied by
          the following weighting factors and then divide by 1000. For
          example:</para>

        <informaltable>
          <tgroup cols='4'>
            <colspec colwidth="15pc"/>
            <colspec colwidth="15pc"/>
            <thead>
              <row>
                <entry>Letter</entry>
                <entry>Weight Factor</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>a</entry>
                <entry>64</entry>
              </row>
              <row>
                <entry>b</entry>
                <entry>14</entry>
              </row>
              <row>
                <entry>c</entry>
                <entry>27</entry>
              </row>
              <row>
                <entry>d</entry>
                <entry>35</entry>
              </row>
              <row>
                <entry>e</entry>
                <entry>100</entry>
              </row>
              <row>
                <entry>f</entry>
                <entry>20</entry>
              </row>
              <row>
                <entry>g</entry>
                <entry>14</entry>
              </row>
              <row>
                <entry>h</entry>
                <entry>42</entry>
              </row>
              <row>
                <entry>i</entry>
                <entry>63</entry>
              </row>
              <row>
                <entry>j</entry>
                <entry>3</entry>
              </row>
              <row>
                <entry>k</entry>
                <entry>6</entry>
              </row>
              <row>
                <entry>l</entry>
                <entry>35</entry>
              </row>
              <row>
                <entry>m</entry>
                <entry>20</entry>
              </row>
              <row>
                <entry>n</entry>
                <entry>56</entry>
              </row>
              <row>
                <entry>o</entry>
                <entry>56</entry>
              </row>
              <row>
                <entry>p</entry>
                <entry>17</entry>
              </row>
              <row>
                <entry>q</entry>
                <entry>4</entry>
              </row>
              <row>
                <entry>r</entry>
                <entry>49</entry>
              </row>
              <row>
                <entry>s</entry>
                <entry>56</entry>
              </row>
              <row>
                <entry>t</entry>
                <entry>71</entry>
              </row>
              <row>
                <entry>u</entry>
                <entry>31</entry>
              </row>
              <row>
                <entry>v</entry>
                <entry>10</entry>
              </row>
              <row>
                <entry>w</entry>
                <entry>18</entry>
              </row>
              <row>
                <entry>x</entry>
                <entry>3</entry>
              </row>
              <row>
                <entry>y</entry>
                <entry>18</entry>
              </row>
              <row>
                <entry>z</entry>
                <entry>2</entry>
              </row>
              <row>
                <entry>space</entry>
                <entry>166</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>usWeightClass</bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Title: Weight class. </para>
        <para>Description: Indicates the visual weight (degree of
          blackness or thickness of strokes) of the characters in the
          font. </para>
        <para>Comments:</para>


        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="4pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="18pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
                <entry>C Definition (from windows.h)</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>100</entry>
                <entry>Thin</entry>
                <entry>FW_THIN</entry>
              </row>
              <row>
                <entry>200</entry>
                <entry>Extra-light (Ultra-light)</entry>
                <entry>FW_EXTRALIGHT</entry>
              </row>
              <row>
                <entry>300</entry>
                <entry>Light</entry>
                <entry>FW_LIGHT</entry>
              </row>
              <row>
                <entry>400</entry>
                <entry>Normal (Regular)</entry>
                <entry>FW_NORMAL</entry>
              </row>
              <row>
                <entry>500</entry>
                <entry>Medium</entry>
                <entry>FW_MEDIUM</entry>
              </row>
              <row>
                <entry>600</entry>
                <entry>Semi-bold (Demi-bold)</entry>
                <entry>FW_SEMIBOLD</entry>
              </row>
              <row>
                <entry>700</entry>
                <entry>Bold</entry>
                <entry>FW_BOLD</entry>
              </row>
              <row>
                <entry>800</entry>
                <entry>Extra-bold (Ultra-bold)</entry>
                <entry>FW_EXTRABOLD</entry>
              </row>
              <row>
                <entry>900</entry>
                <entry>Black (Heavy)</entry>
                <entry>FW_BLACK</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>usWidthClass </bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Title: Width class. </para>
        <para>Description: Indicates a relative change from the normal
          aspect ratio (width to height ratio) as specified by a font
          designer for the glyphs in a font. </para>
        <para>Comments:  Although every character in a font may have a
          different numeric aspect ratio, each character in a font of
          normal width has a relative aspect ratio of one. When a new
          type style is created of a different width class (either by
          a font designer or by some automated means) the relative
          aspect ratio of the characters in the new font is some
          percentage greater or less than those same characters in the
          normal font -- it is this difference that this parameter
          specifies. </para>


        <informaltable>
          <tgroup cols='4'>
            <colspec colwidth="4pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="14pc"/>
            <colspec colwidth="4pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
                <entry>C Definition</entry>
                <entry>% of normal</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>Ultra-condensed</entry>
                <entry>FWIDTH_ULTRA_CONDENSED</entry>
                <entry>50</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Extra-condensed</entry>
                <entry>FWIDTH_EXTRA_CONDENSED</entry>
                <entry>62.5</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Condensed</entry>
                <entry>FWIDTH_CONDENSED</entry>
                <entry>75</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Semi-condensed</entry>
                <entry>FWIDTH_SEMI_CONDENSED</entry>
                <entry>87.5</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Medium (normal)</entry>
                <entry>FWIDTH_NORMAL</entry>
                <entry>100</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Semi-expanded</entry>
                <entry>FWIDTH_SEMI_EXPANDED</entry>
                <entry>112.5</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Expanded</entry>
                <entry>FWIDTH_EXPANDED</entry>
                <entry>125</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Extra-expanded</entry>
                <entry>FWIDTH_EXTRA_EXPANDED</entry>
                <entry>150</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Ultra-expanded</entry>
                <entry>FWIDTH_ULTRA_EXPANDED</entry>
                <entry>200</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>fsType</bridgehead>

        <para>Format: 2-byte unsigned short</para>
        <para>Title: Type flags. </para>
        <para>Description: Indicates font embedding licensing rights
          for the font. Embeddable fonts may be stored in a document.
          When a document with embedded fonts is opened on a system
          that does not have the font installed (the remote system),
          the embedded font may be loaded for temporary (and in some
          cases, permanent) use on that system by an embedding-aware
          application. Embedding licensing rights are granted by the
          vendor of the font.</para>

        <para>The OpenType Font Embedding DLL Specification and DLL
          release notes describe the APIs used to implement support
          for OpenType font embedding and loading.
          <emphasis>Applications that implement support for font
            embedding, either through use of the Font Embedding DLL or
            through other means, must not embed fonts which are not
            licensed to permit embedding. Further, applications
            loading embedded fonts for temporary use (see Preview
            &amp; Print and Editable embedding below) must delete the
            fonts when the document containing the embedded font is
            closed.</emphasis></para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="1cm"/>
            <colspec colwidth="2cm"/>
            <colspec colwidth="10cm"/>
            <thead>
              <row>
                <entry>Bit</entry>
                <entry>BitMask</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry></entry>
                <entry>0x0000</entry>
                <entry>Installable Embedding: No fsType bit is set.
                  Thus fsType is zero. Fonts with this setting
                  indicate that they may be embedded and permanently
                  installed on the remote system by an application.
                  The user of the remote system acquires the identical
                  rights, obligations and licenses for that font as
                  the original purchaser of the font, and is subject
                  to the same end-user license agreement, copyright,
                  design patent, and/or trademark as was the original
                  purchaser.</entry>
              </row>
              <row>
                <entry>0</entry>
                <entry>0x0001</entry>
                <entry>Reserved, must be zero.</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>0x0002</entry>
                <entry>Restricted License embedding: Fonts that have
                  <emphasis>only</emphasis> this bit set must not be
                  <emphasis>modified, embedded or exchanged in any
                    manner</emphasis> without first obtaining
                  permission of the legal owner. Caution: For
                  Restricted License embedding to take effect, it must
                  be the only level of embedding selected.</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>0x0004</entry>
                <entry>Preview &amp; Print embedding: When this bit is
                  set, the font may be embedded, and temporarily
                  loaded on the remote system. Documents containing
                  Preview &amp; Print fonts must be opened "read-only;" no
                  edits can be applied to the document.</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>0x0008</entry>
                <entry>Editable embedding: When this bit is set, the
                  font may be embedded but must only be installed
                  <emphasis>temporarily</emphasis> on other systems.
                  In contrast to Preview &amp; Print fonts, documents
                  containing Editable fonts <emphasis>may</emphasis>
                  be opened for reading, editing is permitted, and
                  changes may be saved.</entry>
              </row>
              <row>
                <entry>4-7</entry>
                <entry></entry>
                <entry>Reserved, must be zero.</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>0x0100</entry>
                <entry>No subsetting: When this bit is set, the font
                  may not be subsetted prior to embedding. Other
                  embedding restrictions specified in the lower byte
                  also apply.</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>0x0200</entry>
                <entry>Bitmap embedding only: When this bit is set,
                  only bitmaps contained in the font may be embedded.
                  No outline data may be embedded. If there are no
                  bitmaps available in the font, then the font is
                  considered unembeddable and the embedding services
                  will fail. Other embedding restrictions specified in
                  the lower byte also apply.</entry>
              </row>
              <row>
                <entry>10-15</entry>
                <entry></entry>
                <entry>Reserved, must be zero.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>Comments: If multiple embedding bits are set, the least
          restrictive license granted takes precedence. For example,
          if bits 1 and 3 are set, bit 3 takes precedence over bit
          1 and the font may be embedded with Editable rights. For
          compatibility purposes, most vendors granting Editable
          embedding rights are also setting the Preview &amp; Print bit
          (0x000C). This will permit an application that only supports
          Preview &amp; Print embedding to detect that font embedding is
          allowed.</para>



        <bridgehead>ySubscriptXSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript horizontal font size. </para>
        <para>Description: The recommended horizontal size in font
          design units for subscripts for this font.  </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g., numerics and other, the numeric sizes
          should be stressed. This size field maps to the em square
          size of the font being used for a subscript. The horizontal
          font size specifies a font designer's recommended horizontal
          font size for subscript characters associated with this
          font. If a font does not include all of the required
          subscript characters for an application, and the application
          can substitute characters by scaling the character of a font
          or by substituting characters from another font, this
          parameter specifies the recommended em square for those
          subscript characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySubScriptXSize is set to 205, then the horizontal size for
          a simulated subscript character would be 1/10th the size of
          the normal character.</para>



        <bridgehead>ySubscriptYSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript vertical font size. </para>
        <para>Description: The recommended vertical size in font
          design units for subscripts for this font.  </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g. numerics and other, the numeric sizes
          should be stressed. This size field maps to the emHeight of
          the font being used for a subscript. The horizontal font
          size specifies a font designer's recommendation for
          horizontal font size of subscript characters associated with
          this font. If a font does not include all of the required
          subscript characters for an application, and the application
          can substitute characters by scaling the characters in a
          font or by substituting characters from another font, this
          parameter specifies the recommended horizontal EmInc for
          those subscript characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySubScriptYSize is set to 205, then the vertical size for a
          simulated subscript character would be 1/10th the size of
          the normal character.</para>



        <bridgehead>ySubscriptXOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript x offset.</para>
        <para>Description: The recommended horizontal offset in font
          design untis for subscripts for this font. </para>
        <para>Comments: The Subscript X Offset parameter specifies a
          font designer's recommended horizontal offset -- from the
          character origin of the font to the character origin of the
          subscript's character -- for subscript characters associated
          with this font. If a font does not include all of the
          required subscript characters for an application, and the
          application can substitute characters, this parameter
          specifies the recommended horizontal position from the
          character escapement point of the last character before the
          first subscript character. For upright characters, this
          value is usually zero; however, if the characters of a font
          have an incline (italic characters) the reference point for
          subscript characters is usually adjusted to compensate for
          the angle of incline.</para>



        <bridgehead>ySubscriptYOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Subscript y offset. </para>
        <para>Description: The recommended vertical offset in font
          design units from the baseline for subscripts for this font.
        </para>
        <para>Comments: The Subscript Y Offset parameter specifies a
          font designer's recommended vertical offset from the
          character baseline to the character baseline for subscript
          characters associated with this font. Values are expressed
          as a positive offset below the character baseline. If a font
          does not include all of the required subscript for an
          application, this parameter specifies the recommended
          vertical distance below the character baseline for those
          subscript characters.</para>


        <bridgehead>ySuperscriptXSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript horizontal font size.</para>
        <para>Description: The recommended horizontal size in font
          design units for superscripts for this font. </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g., numerics and other, the numeric sizes
          should be stressed. This size field maps to the em square
          size of the font being used for a subscript. The horizontal
          font size specifies a font designer's recommended horizontal
          font size for superscript characters associated with this
          font. If a font does not include all of the required
          superscript characters for an application, and the
          application can substitute characters by scaling the
          character of a font or by substituting characters from
          another font, this parameter specifies the recommended em
          square for those superscript characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySuperScriptXSize is set to 205, then the horizontal size
          for a simulated superscript character would be 1/10th the
          size of the normal character.</para>



        <bridgehead>ySuperscriptYSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript vertical font size.</para>
        <para>Description: The recommended vertical size in font
          design units for superscripts for this font. </para>
        <para>Comments: If a font has two recommended sizes for
          subscripts, e.g., numerics and other, the numeric sizes
          should be stressed. This size field maps to the emHeight of
          the font being used for a subscript. The vertical font size
          specifies a font designer's recommended vertical font size
          for superscript characters associated with this font. If a
          font does not include all of the required superscript
          characters for an application, and the application can
          substitute characters by scaling the character of a font or
          by substituting characters from another font, this parameter
          specifies the recommended EmHeight for those superscript
          characters.</para>

        <para>For example, if the em square for a font is 2048 and
          ySuperScriptYSize is set to 205, then the vertical size for
          a simulated superscript character would be 1/10th the size
          of the normal character.</para>



        <bridgehead>ySuperscriptXOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript x offset.</para>
        <para>Description: The recommended horizontal offset in font
          design units for superscripts for this font. </para>
        <para>Comments: The Superscript X Offset parameter specifies a
          font designer's recommended horizontal offset -- from the
          character origin to the superscript character's origin for
          the superscript characters associated with this font. If a
          font does not include all of the required superscript
          characters for an application, this parameter specifies the
          recommended horizontal position from the escapement point of
          the character before the first superscript character. For
          upright characters, this value is usually zero; however, if
          the characters of a font have an incline (italic characters)
          the reference point for superscript characters is usually
          adjusted to compensate for the angle of incline.</para>



        <bridgehead>ySuperscriptYOffset</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Superscript y offset.</para>
        <para>Description: The recommended vertical offset in font
          design units from the baseline for superscripts for this
          font. </para>
        <para>Comments: The Superscript Y Offset parameter specifies a
          font designer's recommended vertical offset -- from the
          character baseline to the superscript character's baseline
          associated with this font. Values for this parameter are
          expressed as a positive offset above the character baseline.
          If a font does not include all of the required superscript
          characters for an application, this parameter specifies the
          recommended vertical distance above the character baseline
          for those superscript characters.</para>



        <bridgehead>yStrikeoutSize</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Strikeout size.</para>
        <para>Description: Width of the strikeout stroke in font
          design units. </para>
        <para>Comments: This field should normally be the width of the
          em dash for the current font. If the size is one, the
          strikeout line will be the line represented by the strikeout
          position field. If the value is two, the strikeout line will
          be the line represented by the strikeout position and the
          line immediately above the strikeout position. For a Roman
          font with a 2048 em square, 102 is suggested.</para>



        <bridgehead>yStrikeoutPosition</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Units: Font design units</para>
        <para>Title: Strikeout position.</para>
        <para>Description: The position of the top of the strikeout
          stroke relative to the baseline in font design units.
        </para>
        <para>Comments: Positive values represent distances above the
          baseline, while negative values represent distances below
          the baseline. A value of zero falls directly on the
          baseline, while a value of one falls one pel above the
          baseline. The value of strikeout position should not
          interfere with the recognition of standard characters, and
          therefore should not line up with crossbars in the font. For
          a Roman font with a 2048 em square, 460 is suggested.</para>



        <bridgehead>sFamilyClass</bridgehead>

        <para>Format: 2-byte signed short</para>
        <para>Title: Font-family class and subclass.</para>
        <para>Description: This parameter is a classification of
          font-family design. </para>
        <para>Comments: The font class and font subclass are
          registered values assigned by IBM to each font family. This
          parameter is intended for use in selecting an alternate font
          when the requested font is not available. The font class is
          the most general and the font subclass is the most specific.
          The high byte of this field contains the family class, while
          the low byte contains the family subclass. More information
          about this field.  </para>



        <bridgehead>Panose</bridgehead>

        <para>Format: 10 byte array</para>
        <para>Title: PANOSE classification number</para>
        <para>International: Additional specifications are required
          for PANOSE to classify non-Latin character sets.</para>
        <para>Description: This 10 byte series of numbers is used to
          describe the visual characteristics of a given typeface.
          These characteristics are then used to associate the font
          with other fonts of similar appearance having different
          names. The variables for each digit are listed below. The
          Panose values are fully described in the Panose "greybook"
          reference, currently owned by Agfa-Monotype. </para>
        <para>Comments: The PANOSE definition contains ten digits each
          of which currently describes up to sixteen variations.
          Windows uses bFamilyType, bSerifStyle and bProportion in the
          font mapper to determine family type. It also uses
          bProportion to determine if the font is monospaced. If the
          font is a symbol font, the first byte of the PANOSE number
          (bFamilyType) must be set to "pictorial." Good PANOSE values
          in fonts are very valuable to users of the Windows fonts
          folder. The specification for assigning PANOSE values is
          located at http://www.fonts.com/hp/panose/greybook/</para>


        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>BYTE</entry>
                <entry>bFamilyType</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bSerifStyle</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bWeight</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bProportion</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bContrast</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bStrokeVariation</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bArmStyle</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bLetterform</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bMidline</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>bXHeight</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <bridgehead>ulUnicodeRange1 (Bits 0-31)</bridgehead>
        <bridgehead>ulUnicodeRange2 (Bits 32-63)</bridgehead>
        <bridgehead>ulUnicodeRange3 (Bits 64-95)</bridgehead>
        <bridgehead>ulUnicodeRange4 (Bits 96-127)</bridgehead>

        <para>Format: 32-bit unsigned long(4 copies) totaling 128
          bits.</para>
        <para>Title: Unicode Character Range</para>
        <para>Description: This field is used to specify the Unicode
          blocks or ranges encompassed by the font file in the <ottable>cmap</ottable>
          subtable for platform 3, encoding ID 1 (Microsoft platform).
          If the bit is set (1) then the Unicode range is considered
          functional. If the bit is clear (0) then the range is not
          considered functional. Each of the bits is treated as an
          independent flag and the bits can be set in any combination.
          The determination of "functional" is left up to the font
          designer, although character set selection should attempt to
          be functional by ranges if at all possible.</para>
        <para>
          All reserved fields must be zero. Each long is in Big-Endian
          form. See the Basic Multilingual Plane of ISO/IEC 10646-1 or
          the Unicode Standard v.3.0 for the list of Unicode ranges
          and characters.  </para>


        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="20pc"/>
            <thead>
              <row>
                <entry>Bit</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Basic Latin</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Latin-1 Supplement</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Latin Extended-A</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Latin Extended-B</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>IPA Extensions</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Spacing Modifier Letters</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Combining Diacritical Marks</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Greek</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Cyrillic</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Armenian</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>Devanagari</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>Bengali</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>Gurmukhi</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>Gujarati</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>Oriya</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry>Tamil</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry>Telugu</entry>
              </row>
              <row>
                <entry>22</entry>
                <entry>Kannada</entry>
              </row>
              <row>
                <entry>23</entry>
                <entry>Malayalam</entry>
              </row>
              <row>
                <entry>24</entry>
                <entry>Thai</entry>
              </row>
              <row>
                <entry>25</entry>
                <entry>Lao</entry>
              </row>
              <row>
                <entry>26</entry>
                <entry>Georgian</entry>
              </row>
              <row>
                <entry>27</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>28</entry>
                <entry>Hangul Jamo</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry>Latin Extended Additional</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry>Greek Extended</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry>General Punctuation</entry>
              </row>
              <row>
                <entry>32</entry>
                <entry>Superscripts And Subscripts</entry>
              </row>
              <row>
                <entry>33</entry>
                <entry>Currency Symbols</entry>
              </row>
              <row>
                <entry>34</entry>
                <entry>Combining Diacritical Marks For Symbols</entry>
              </row>
              <row>
                <entry>35</entry>
                <entry>Letterlike Symbols</entry>
              </row>
              <row>
                <entry>36</entry>
                <entry>Number Forms</entry>
              </row>
              <row>
                <entry>37</entry>
                <entry>Arrows</entry>
              </row>
              <row>
                <entry>38</entry>
                <entry>Mathematical Operators</entry>
              </row>
              <row>
                <entry>39</entry>
                <entry>Miscellaneous Technical</entry>
              </row>
              <row>
                <entry>40</entry>
                <entry>Control Pictures</entry>
              </row>
              <row>
                <entry>41</entry>
                <entry>Optical Character Recognition</entry>
              </row>
              <row>
                <entry>42</entry>
                <entry>Enclosed Alphanumerics</entry>
              </row>
              <row>
                <entry>43</entry>
                <entry>Box Drawing</entry>
              </row>
              <row>
                <entry>44</entry>
                <entry>Block Elements</entry>
              </row>
              <row>
                <entry>45</entry>
                <entry>Geometric Shapes</entry>
              </row>
              <row>
                <entry>46</entry>
                <entry>Miscellaneous Symbols</entry>
              </row>
              <row>
                <entry>47</entry>
                <entry>Dingbats</entry>
              </row>
              <row>
                <entry>48</entry>
                <entry>CJK Symbols And Punctuation</entry>
              </row>
              <row>
                <entry>49</entry>
                <entry>Hiragana</entry>
              </row>
              <row>
                <entry>50</entry>
                <entry>Katakana</entry>
              </row>
              <row>
                <entry>51</entry>
                <entry>Bopomofo</entry>
              </row>
              <row>
                <entry></entry>
                <entry>  Extended Bopomofo</entry>
              </row>
              <row>
                <entry>52</entry>
                <entry>Hangul Compatibility Jamo</entry>
              </row>
              <row>
                <entry>53</entry>
                <entry>CJK Miscellaneous</entry>
              </row>
              <row>
                <entry>54</entry>
                <entry>Enclosed CJK Letters And Months</entry>
              </row>
              <row>
                <entry>55</entry>
                <entry>CJK Compatibility</entry>
              </row>
              <row>
                <entry>56</entry>
                <entry>Hangul</entry>
              </row>
              <row>
                <entry>57</entry>
                <entry>Surrogates<footnote>
                        <para>Setting bit 57 implies that there is
                      at least one codepoint beyond the Basic
                      Multilingual Plane that is supported by this
                      font.</para>
                  </footnote></entry>
              </row>
              <row>
                <entry>58</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
              <row>
                <entry>59</entry>
                <entry>CJK Unified Ideographs</entry>
              </row>
              <row>
                <entry></entry>
                <entry> CJK Radicals Supplement</entry>
              </row>
              <row>
                <entry></entry>
                <entry>  Kangxi Radicals</entry>
              </row>
              <row>
                <entry></entry>
                <entry>  Ideographic Description</entry>
              </row>
              <row>
                <entry></entry>
                <entry>  CJK Unified Ideograph Extension A</entry>
              </row>
              <row>
                <entry>60</entry>
                <entry>Private Use Area</entry>
              </row>
              <row>
                <entry>61</entry>
                <entry>CJK Compatibility Ideographs</entry>
              </row>
              <row>
                <entry>62</entry>
                <entry>Alphabetic Presentation Forms</entry>
              </row>
              <row>
                <entry>63</entry>
                <entry>Arabic Presentation Forms-A</entry>
              </row>
              <row>
                <entry>64</entry>
                <entry>Combining Half Marks</entry>
              </row>
              <row>
                <entry>65</entry>
                <entry>CJK Compatibility Forms</entry>
              </row>
              <row>
                <entry>66</entry>
                <entry>Small Form Variants</entry>
              </row>
              <row>
                <entry>67</entry>
                <entry>Arabic Presentation Forms-B</entry>
              </row>
              <row>
                <entry>68</entry>
                <entry>Halfwidth And Fullwidth Forms</entry>
              </row>
              <row>
                <entry>69</entry>
                <entry>Specials</entry>
              </row>
              <row>
                <entry>70</entry>
                <entry>Tibetan</entry>
              </row>
              <row>
                <entry>71</entry>
                <entry>Syriac</entry>
              </row>
              <row>
                <entry>72</entry>
                <entry>Thaana</entry>
              </row>
              <row>
                <entry>73</entry>
                <entry>Sinhala</entry>
              </row>
              <row>
                <entry>74</entry>
                <entry>Myanmar</entry>
              </row>
              <row>
                <entry>75</entry>
                <entry>Ethiopic</entry>
              </row>
              <row>
                <entry>76</entry>
                <entry>Cherokee</entry>
              </row>
              <row>
                <entry>77</entry>
                <entry>Unified Canadian Syllabics</entry>
              </row>
              <row>
                <entry>78</entry>
                <entry>Ogham</entry>
              </row>
              <row>
                <entry>79</entry>
                <entry>Runic</entry>
              </row>
              <row>
                <entry>80</entry>
                <entry>Khmer</entry>
              </row>
              <row>
                <entry>81</entry>
                <entry>Mongolian</entry>
              </row>
              <row>
                <entry>82</entry>
                <entry>Braille</entry>
              </row>
              <row>
                <entry>83</entry>
                <entry>Yi</entry>
              </row>
              <row>
                <entry></entry>
                <entry>  Yi Radicals</entry>
              </row>
              <row>
                <entry>84-127</entry>
                <entry>Reserved for Unicode SubRanges</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>





        <bridgehead>achVendID</bridgehead>

        <para>Format: 4-byte character array</para>
        <para>Title: Font Vendor Identification</para>
        <para>Description: The four character identifier for the
          vendor of the given type face.</para>
        <para>Comments: This is not the royalty owner of the original
          artwork. This is the company responsible for the marketing
          and distribution of the typeface that is being classified.
          It is reasonable to assume that there will be 6 vendors of
          ITC Zapf Dingbats for use on desktop platforms in the near
          future (if not already). It is also likely that the vendors
          will have other inherent benefits in their fonts (more kern
          pairs, unregularized data, hand hinted, etc.). This
          identifier will allow for the correct vendor's type to be
          used over another, possibly inferior, font file. The Vendor
          ID value is not required.</para>
        <para>Microsoft has assigned values for some font suppliers as
          listed below. Uppercase vendor ID's are reserved by
          Microsoft. Other suppliers can choose their own mixed case
          or lowercase ID's, or leave the field blank.</para>


        <para>For a list of registered Vendor id's see our <ulink
            url="http://www.microsoft.com/typography/links/vendorlist.asp">Registered
            'vendors'</ulink> links page.</para>


        <bridgehead>fsSelection</bridgehead>

        <para>Format: 2-byte bit field.</para>
        <para>Title: Font selection flags.</para>
        <para>Description: Contains information concerning the nature
          of the font patterns, as follows:</para>


        <informaltable>
          <tgroup cols='4'>
            <colspec colwidth="4pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="10pc"/>
            <thead>
              <row>
                <entry>Bit #</entry>
                <entry>macStyle bit</entry>
                <entry>C Definition</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>bit 1</entry>
                <entry>ITALIC</entry>
                <entry>Font contains Italic characters, otherwise they
                  are upright.</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry></entry>
                <entry>UNDERSCORE</entry>
                <entry>Characters are underscored.</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry></entry>
                <entry>NEGATIVE</entry>
                <entry>Characters have their foreground and background
                  reversed.</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry></entry>
                <entry>OUTLINED</entry>
                <entry>Outline (hollow) characters, otherwise they are
                  solid.</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry></entry>
                <entry>STRIKEOUT</entry>
                <entry>Characters are overstruck</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>bit 0</entry>
                <entry>BOLD</entry>
                <entry>Characters are emboldened.</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry></entry>
                <entry>REGULAR</entry>
                <entry>Characters are in the standard weight/style for
                  the font.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>Comments: All undefined bits must be zero.</para>

        <para>This field contains information on the original design
          of the font. Bits 0 &amp; 5 can be used to determine if the font
          was designed with these features or whether some type of
          machine simulation was performed on the font to achieve this
          appearance. Bits 1-4 are rarely used bits that indicate the
          font is primarily a decorative or special purpose
          font.</para>

        <para>If bit 6 is set, then bits 0 and 5 must be clear, else
          the behavior is undefined. As noted above, the settings of
          bits 0 and 1 must be reflected in the macStyle bits in the
          <ottable>head</ottable> table. While bit 6 on implies that
          bits 0 and 1 of macStyle are clear (along with bits 0 and 5
          of fsSelection), the reverse is not true. Bits 0 and 1 of
          macStyle (and 0 and 5 of fsSelection) may be clear and that
          does not give any indication of whether or not bit 6 of
          fsSelection is clear (e.g., Arial Light would have all bits
          cleared; it is not the regular version of Arial). </para>



        <bridgehead>usFirstCharIndex</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The minimum Unicode index (character code)
          in this font, according to the cmap subtable for platform ID
          3 and platform- specific encoding ID 0 or 1. For most fonts
          supporting Win-ANSI or other character sets, this value
          would be 0x0020. </para>



        <bridgehead>usLastCharIndex</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The maximum Unicode index (character code)
          in this font, according to the cmap subtable for platform ID
          3 and encoding ID 0 or 1. This value depends on which
          character sets the font supports. </para>



        <bridgehead>sTypoAscender</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: The typographic ascender for this font.
          Remember that this is not the same as the Ascender value in
          the <ottable>hhea</ottable> table, which Apple defines in a
          far different manner. One good source for sTypoAscender in
          Latin based fonts is the Ascender value from an AFM file.
          For CJK fonts see below.</para>

        <para>The suggested usage for sTypoAscender is that it be used
          in conjunction with unitsPerEm to compute a typographically
          correct default line spacing. The goal is to free
          applications from Macintosh or Windows-specific metrics
          which are constrained by backward compatibility
          requirements. These new metrics, when combined with the
          character design widths, will allow applications to lay out
          documents in a typographically correct and portable fashion.
          These metrics will be exposed through Windows APIs.
          Macintosh applications will need to access the 'sfnt'
          resource and parse it to extract this data from the
          <ottable>OS/2</ottable> table.</para>

        <para>For CJK (Chinese, Japanese, and Korean) fonts that are
          intended to be used for vertical writing (in addition to
          horizontal writing), the required value for sTypoAscender is
          that which describes the top of the of the ideographic
          em-box. For example, if the ideographic em-box of the font
          extends from coordinates 0,-120 to 1000,880 (that is, a
          1000x1000 box set 120 design units below the Latin
          baseline), then the value of sTypoAscender must be set to
          880. Failing to adhere to these requirements will result in
          incorrect vertical layout.</para>

        <para>Also see the Recommendations Section for more on this
          field. </para>



        <bridgehead>sTypoDescender</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: The typographic descender for this font.
          Remember that this is not the same as the Descender value in
          the <ottable>hhea</ottable> table, which Apple defines in a
          far different manner. One good source for sTypoDescender in
          Latin based fonts is the Descender value from an AFM file.
          For CJK fonts see below.</para>

        <para>The suggested usage for sTypoDescender is that it be
          used in conjunction with unitsPerEm to compute a
          typographically correct default line spacing. The goal is to
          free applications from Macintosh or Windows-specific metrics
          which are constrained by backward compatability
          requirements. These new metrics, when combined with the
          character design widths, will allow applications to lay out
          documents in a typographically correct and portable fashion.
          These metrics will be exposed through Windows APIs.
          Macintosh applications will need to access the 'sfnt'
          resource and parse it to extract this data from the
          <ottable>OS/2</ottable> table (unless Apple exposes the
          <ottable>OS/2</ottable> table through a new API).</para>

        <para>For CJK (Chinese, Japanese, and Korean) fonts that are
          intended to be used for vertical writing (in addition to
          horizontal writing), the required value for sTypoDescender
          is that which describes the bottom of the of the ideographic
          em-box. For example, if the ideographic em-box of the font
          extends from coordinates 0,-120 to 1000,880 (that is, a
          1000x1000 box set 120 design units below the Latin
          baseline), then the value of sTypoDescender must be set to
          -120. Failing to adhere to these requirements will result in
          incorrect vertical layout.</para>

        <para>Also see the Recommendations Section for more on this
          field. </para>



        <bridgehead>sTypoLineGap</bridgehead>

        <para>Format: 2-byte SHORT</para>
        <para>Description: The typographic line gap for this font.
          Remember that this is not the same as the LineGap value in
          the <ottable>hhea</ottable> table, which Apple defines in a
          far different manner.</para>

        <para>The suggested usage for usTypoLineGap is that it be used
          in conjunction with unitsPerEm to compute a typographically
          correct default line spacing. Typical values average 7-10%
          of units per em. The goal is to free applications from
          Macintosh or Windows-specific metrics which are constrained
          by backward compatability requirements (see chapter,
          "Recommendations for Windows Fonts). These new metrics, when
          combined with the character design widths, will allow
          applications to lay out documents in a typographically
          correct and portable fashion. These metrics will be exposed
          through Windows APIs. Macintosh applications will need to
          access the 'sfnt' resource and parse it to extract this data
          from the <ottable>OS/2</ottable> table (unless Apple exposes
          the <ottable>OS/2</ottable> table through a new API) </para>


        <bridgehead>usWinAscent</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The ascender metric for Windows. This, too,
          is distinct from Apple's Ascender value and from the
          usTypoAscender values. usWinAscent is computed as the yMax
          for all characters in the Windows ANSI character set.
          usWinAscent is used to compute the Windows font height and
          default line spacing. For platform 3 encoding 0 fonts, it is
          the same as yMax. Windows will clip the bitmap of any
          portion of a glyph that appears above this value. Some
          applications use this value to determine default line
          spacing. This is strongly discouraged. The typographic
          ascender, descender and line gap fields in conjunction with
          unitsPerEm should be used for this purpose. Developers
          should set this field keeping the above factors in
          mind.</para>
        <para>If any clipping is unacceptable, then the value should
          be set to yMax.</para>
        <para>However, if a developer desires to provide appropriate
          default line spacing using this field, for those
          applications that continue to use this field for doing so
          (against OpenType recommendations), then the value should be
          set appropriately. In such a case, it may result in some
          glyph bitmaps being clipped.</para>



        <bridgehead>usWinDescent</bridgehead>

        <para>Format: 2-byte USHORT</para>
        <para>Description: The descender metric for Windows. This,
          too, is distinct from Apple's Descender value and from the
          usTypoDescender values. usWinDescent is computed as the
          -yMin for all characters in the Windows ANSI character set.
          usWinDescent is used to compute the Windows font height and
          default line spacing. For platform 3 encoding 0 fonts, it is
          the same as -yMin. Windows will clip the bitmap of any
          portion of a glyph that appears below this value. Some
          applications use this value to determine default line
          spacing. This is strongly discouraged. The typographic
          ascender, descender and line gap fields in conjunction with
          unitsPerEm should be used for this purpose. Developers
          should set this field keeping the above factors in
          mind.</para>
        <para>If any clipping is unacceptable, then the value should
          be set to yMin.</para>
        <para>However, if a developer desires to provide appropriate
          default line spacing using this field, for those
          applications that continue to use this field for doing so
          (against OpenType recommendations), then the value should be
          set appropriately. In such a case, it may result in some
          glyph bitmaps being clipped. </para>



        <bridgehead>ulCodePageRange1 Bits 0-31</bridgehead>
        <bridgehead>ulCodePageRange2 Bits 32-63 </bridgehead>

        <para>Format: 32-bit unsigned long(2 copies) totaling 64
          bits.</para>
        <para>Title: Code Page Character Range</para>
        <para>Description: This field is used to specify the code
          pages encompassed by the font file in the <ottable>cmap</ottable> subtable
          for platform 3, encoding ID 1 (Microsoft platform). If the
          font file is encoding ID 0, then the Symbol Character Set
          bit should be set. If the bit is set (1) then the code page
          is considered functional. If the bit is clear (0) then the
          code page is not considered functional. Each of the bits is
          treated as an independent flag and the bits can be set in
          any combination. The determination of "functional" is left
          up to the font designer, although character set selection
          should attempt to be functional by code pages if at all
          possible.</para>

        <para>Symbol character sets have a special meaning. If the
          symbol bit (31) is set, and the font file contains a <ottable>cmap</ottable>
          subtable for platform of 3 and encoding ID of 1, then all of
          the characters in the Unicode range 0xF000 - 0xF0FF
          (inclusive) will be used to enumerate the symbol character
          set. If the bit is not set, any characters present in that
          range will not be enumerated as a symbol character
          set.</para>

        <para>All reserved fields must be zero. Each long is in
          Big-Endian form. </para>


        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="6pc"/>
            <colspec colwidth="18pc"/>
            <thead>
              <row>
                <entry>Bit</entry>
                <entry>Code</entry>
                <entry>Page Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>1252</entry>
                <entry>Latin 1</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>1250</entry>
                <entry>Latin 2: Eastern Europe</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>1251</entry>
                <entry>Cyrillic</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>1253</entry>
                <entry>Greek</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>1254</entry>
                <entry>Turkish</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>1255</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>1256</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>1257</entry>
                <entry>Windows Baltic</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>1258</entry>
                <entry>Vietnamese</entry>
              </row>
              <row>
                <entry>9-15</entry>
                <entry></entry>
                <entry>Reserved for Alternate ANSI</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>874</entry>
                <entry>Thai</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>932</entry>
                <entry>JIS/Japan</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>936</entry>
                <entry>Chinese: Simplified chars--PRC and
                  Singapore</entry>
              </row>
              <row>
                <entry>19</entry>
                <entry>949</entry>
                <entry>Korean Wansung</entry>
              </row>
              <row>
                <entry>20</entry>
                <entry>950</entry>
                <entry>Chinese: Traditional chars--Taiwan and Hong
                  Kong</entry>
              </row>
              <row>
                <entry>21</entry>
                <entry>1361</entry>
                <entry>Korean Johab</entry>
              </row>
              <row>
                <entry>22-28</entry>
                <entry></entry>
                <entry>Reserved for Alternate ANSI &amp; OEM</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry></entry>
                <entry>Macintosh Character Set (US Roman)</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry></entry>
                <entry>OEM Character Set</entry>
              </row>
              <row>
                <entry>31</entry>
                <entry></entry>
                <entry>Symbol Character Set</entry>
              </row>
              <row>
                <entry>32-47</entry>
                <entry></entry>
                <entry>Reserved for OEM</entry>
              </row>
              <row>
                <entry>48</entry>
                <entry>869</entry>
                <entry>IBM Greek</entry>
              </row>
              <row>
                <entry>49</entry>
                <entry>866</entry>
                <entry>MS-DOS Russian</entry>
              </row>
              <row>
                <entry>50</entry>
                <entry>865</entry>
                <entry>MS-DOS Nordic</entry>
              </row>
              <row>
                <entry>51</entry>
                <entry>864</entry>
                <entry>Arabic</entry>
              </row>
              <row>
                <entry>52</entry>
                <entry>863</entry>
                <entry>MS-DOS Canadian French</entry>
              </row>
              <row>
                <entry>53</entry>
                <entry>862</entry>
                <entry>Hebrew</entry>
              </row>
              <row>
                <entry>54</entry>
                <entry>861</entry>
                <entry>MS-DOS Icelandic</entry>
              </row>
              <row>
                <entry>55</entry>
                <entry>860</entry>
                <entry>MS-DOS Portuguese</entry>
              </row>
              <row>
                <entry>56</entry>
                <entry>857</entry>
                <entry>IBM Turkish</entry>
              </row>
              <row>
                <entry>57</entry>
                <entry>855</entry>
                <entry>IBM Cyrillic; primarily Russian</entry>
              </row>
              <row>
                <entry>58</entry>
                <entry>852</entry>
                <entry>Latin 2</entry>
              </row>
              <row>
                <entry>59</entry>
                <entry>775</entry>
                <entry>MS-DOS Baltic</entry>
              </row>
              <row>
                <entry>60</entry>
                <entry>737</entry>
                <entry>Greek; former 437 G</entry>
              </row>
              <row>
                <entry>61</entry>
                <entry>708</entry>
                <entry>Arabic; ASMO 708</entry>
              </row>
              <row>
                <entry>62</entry>
                <entry>850</entry>
                <entry>WE/Latin 1</entry>
              </row>
              <row>
                <entry>63</entry>
                <entry>437</entry>
                <entry>US</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>sxHeight</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: This metric specifies the distance between
          the baseline and the approximate height of non-ascending
          lowercase letters measured in FUnits. This value would
          normally be specified by a type designer but in situations
          where that is not possible, for example when a legacy font
          is being converted, the value may be set equal to the top of
          the unscaled and unhinted glyph bounding box of the glyph
          encoded at U+0078 (LATIN SMALL LETTER X). If no glyph is
          encoded in this position the field should be set to
          0.</para>

        <para>This metric, if specified, can be used in font
          substitution: the xHeight value of one font can be scaled to
          approximate the apparent size of another. </para>



        <bridgehead>sCapHeight</bridgehead>

        <para>Format: SHORT</para>
        <para>Description: This metric specifies the distance between
          the baseline and the approximate height of uppercase letters
          measured in FUnits. This value would normally be specified
          by a type designer but in situations where that is not
          possible, for example when a legacy font is being converted,
          the value may be set equal to the top of the unscaled and
          unhinted glyph bounding box of the glyph encoded at U+0048
          (LATIN CAPITAL LETTER H). If no glyph is encoded in this
          position the field should be set to 0.</para>

        <para>This metric, if specified, can be used in systems that
          specify type size by capital height measured in millimeters.
          It can also be used as an alignment metric; the top of a
          drop capital, for instance, can be aligned to the sCapHeight
          metric of the first line of text. </para>



        <bridgehead>usDefaultChar</bridgehead>

        <para>Format: USHORT</para>
        <para>Description: Whenever a request is made for a character
          that is not in the font, Windows provides this default
          character. If the value of this field is zero, glyph ID 0 is
          to be used for the default character otherwise this is the
          Unicode encoding of the glyph that Windows uses as the
          default character. </para>



        <bridgehead>usBreakChar</bridgehead>

        <para>Format: USHORT</para>
        <para>Description: This is the Unicode encoding of the glyph
          that Windows uses as the break character. The break
          character is used to separate words and justify text. Most
          fonts specify 'space' as the break character.</para>



        <bridgehead>usMaxContext</bridgehead>

        <para>Format: USHORT</para>
        <para>Description: The maximum length of a target glyph
          context for any feature in this font. For example, a font
          which has only a pair kerning feature should set this field
          to 2. If the font also has a ligature feature in which the
          glyph sequence 'f f i' is substituted by the ligature 'ffi',
          then this field should be set to 3. This field could be
          useful to sophisticated line-breaking engines in determining
          how far they should look ahead to test whether something
          could change that effects the line breaking. For chaining
          contextual lookups, the length of the string (covered glyph)
          + (input sequence) + (lookahead sequence) should be
          considered.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>Note that the usFirstCharIndex and usLastCharIndex are
        no longer very useful, since these fields are not big enough
        to represent Unicode supplemental characters.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Relax Schema for OS/2 table</code-title>
OS2 |=
  element OS2 {
    attribute version { "0" },
    os2_avgCharWidth,
    os2_weightClass,
    os2_widthClass,
    os2_fsType_v0,
    os2_subscript,
    os2_superscript,
    os2_strikeout,
    os2_familyClass,
    os2_panose,
    os2_vendID,
    os2_fsSelection,
    os2_charIndex,
    os2_typo,
    os2_win
  }
OS2 |=
  element OS2 {
    attribute version { "1" },
    os2_avgCharWidth,
    os2_weightClass,
    os2_widthClass,
    os2_fsType_v0,
    os2_subscript,
    os2_superscript,
    os2_strikeout,
    os2_familyClass,
    os2_panose,
    os2_unicodeRange_v1,
    os2_vendID,
    os2_fsSelection,
    os2_charIndex,
    os2_typo,
    os2_win,
    os2_codePageRange_v1
  }
OS2 |=
  element OS2 {
    attribute version { "2" },
    os2_avgCharWidth,
    os2_weightClass,
    os2_widthClass,
    os2_fsType_v2,
    os2_subscript,
    os2_superscript,
    os2_strikeout,
    os2_familyClass,
    os2_panose,
    os2_unicodeRange_v2,
    os2_vendID,
    os2_fsSelection,
    os2_charIndex,
    os2_typo,
    os2_win,
    os2_codePageRange_v2,
    os2_height,
    os2_capHeight,
    os2_defaultChar,
    os2_breakChar,
    os2_maxContext
  }
OS2 |=
  element OS2 {
    attribute version { "3" },
    os2_avgCharWidth,
    os2_weightClass,
    os2_widthClass,
    os2_fsType_v2,
    os2_subscript,
    os2_superscript,
    os2_strikeout,
    os2_familyClass,
    os2_panose,
    os2_unicodeRange_v3,
    os2_vendID,
    os2_fsSelection,
    os2_charIndex,
    os2_typo,
    os2_win,
    os2_codePageRange_v2,
    os2_height,
    os2_capHeight,
    os2_defaultChar,
    os2_breakChar,
    os2_maxContext
  }
OS2 |=
  element OS2 {
    attribute version { "4" },
    os2_avgCharWidth,
    os2_weightClass,
    os2_widthClass,
    os2_fsType_v2,
    os2_subscript,
    os2_superscript,
    os2_strikeout,
    os2_familyClass,
    os2_panose,
    os2_unicodeRange_v4,
    os2_vendID,
    os2_fsSelection_v4,
    os2_charIndex,
    os2_typo,
    os2_win,
    os2_codePageRange_v2,
    os2_height,
    os2_capHeight,
    os2_defaultChar,
    os2_breakChar,
    os2_maxContext
  }
OS2 |=
  element OS2 {
    attribute version { "5" },
    os2_avgCharWidth,
    os2_weightClass,
    os2_widthClass,
    os2_fsType_v2,
    os2_subscript,
    os2_superscript,
    os2_strikeout,
    os2_familyClass,
    os2_panose,
    os2_unicodeRange_v5,
    os2_vendID,
    os2_fsSelection_v4,
    os2_charIndex,
    os2_typo,
    os2_win,
    os2_codePageRange_v2,
    os2_height,
    os2_capHeight,
    os2_defaultChar,
    os2_breakChar,
    os2_maxContext,
    os2_lowerOpticalPointSize,
    os2_upperOpticalPointSize
  }
os2_avgCharWidth =
  element avgCharWidth {
    attribute v { text }
  }
os2_weightClass =
  element weightClass {
    attribute v { text }
  }
os2_widthClass =
  element widthClass {
    attribute v { text }
  }
os2_fsType_v0 =
  element fsType {
    attribute Restricted { yesOrNo },
    attribute Preview_and_print { yesOrNo },
    attribute Editable_embedding { yesOrNo }
  }
os2_fsType_v2 =
  element fsType {
    attribute Restricted { yesOrNo },
    attribute Preview_and_print { yesOrNo },
    attribute Editable_embedding { yesOrNo },
    attribute No_subsetting { yesOrNo },
    attribute Bitmap_embedding_only { yesOrNo }
  }
os2_subscript =
  element subscript {
    attribute xsize { text },
    attribute ysize { text },
    attribute xoffset { text },
    attribute yoffset { text }
  }
os2_superscript =
  element superscript {
    attribute xsize { text },
    attribute ysize { text },
    attribute xoffset { text },
    attribute yoffset { text }
  }
os2_strikeout =
  element strikeout {
    attribute size { text },
    attribute position { text }
  }
os2_familyClass =
  element familyClass {
    attribute v { text }
  }
os2_panose =
  element panose {
    attribute familyType { text },
    attribute serifStyle { text },
    attribute weight { text },
    attribute proportion { text },
    attribute contrast { text },
    attribute strokeVariation { text },
    attribute armStyle { text },
    attribute letterform { text },
    attribute midline { text },
    attribute xHeight { text }
  }
os2_unicodeRange_v1 =
  element unicodeRange {
    attribute Basic_Latin { yesOrNo },
    attribute Latin_1_Supplement { yesOrNo },
    attribute Latin_Extended_A { yesOrNo },
    attribute Latin_Extended_B { yesOrNo },
    attribute IPA_Extensions { yesOrNo },
    attribute Spacing_Modifier_Letters { yesOrNo },
    attribute Combining_Diacritical_Marks { yesOrNo },
    attribute Greek { yesOrNo },
    attribute Greek_Symbols_And_Coptic { yesOrNo },
    attribute Cyrillic { yesOrNo },
    attribute Armenian { yesOrNo },
    attribute Hebrew { yesOrNo },
    attribute Hebrew_Extended { yesOrNo },
    attribute Arabic { yesOrNo },
    attribute Arabic_Extended { yesOrNo },
    attribute Devanagari { yesOrNo },
    attribute Bengali { yesOrNo },
    attribute Gurmukhi { yesOrNo },
    attribute Gujarati { yesOrNo },
    attribute Oriya { yesOrNo },
    attribute Tamil { yesOrNo },
    attribute Telugu { yesOrNo },
    attribute Kannada { yesOrNo },
    attribute Malayalam { yesOrNo },
    attribute Thai { yesOrNo },
    attribute Lao { yesOrNo },
    attribute Georgian { yesOrNo },
    attribute Georgian_Extended { yesOrNo },
    attribute Hangul_Jamo { yesOrNo },
    attribute Latin_Extended_Additional { yesOrNo },
    attribute Greek_Extended { yesOrNo },
    attribute General_Punctuation { yesOrNo },
    attribute Superscripts_And_Subscripts { yesOrNo },
    attribute Currency_Symbols { yesOrNo },
    attribute Combining_Diacritical_Marks_For_Symbols { yesOrNo },
    attribute Letterlike_Symbols { yesOrNo },
    attribute Number_Forms { yesOrNo },
    attribute Arrows { yesOrNo },
    attribute Mathematical_Operators { yesOrNo },
    attribute Miscellaneous_Technical { yesOrNo },
    attribute Control_Pictures { yesOrNo },
    attribute Optical_Character_Recognition { yesOrNo },
    attribute Enclosed_Alphanumerics { yesOrNo },
    attribute Box_Drawing { yesOrNo },
    attribute Block_Elements { yesOrNo },
    attribute Geometric_Shapes { yesOrNo },
    attribute Miscellaneous_Symbols { yesOrNo },
    attribute Dingbats { yesOrNo },
    attribute CJK_Symbols_And_Punctuation { yesOrNo },
    attribute Hiragana { yesOrNo },
    attribute Katakana { yesOrNo },
    attribute Bopomofo { yesOrNo },
    attribute Hangul_Compatibility_Jamo { yesOrNo },
    attribute CJK_Miscellaneous { yesOrNo },
    attribute Enclosed_CJK_Letters_And_Months { yesOrNo },
    attribute CJK_Compatibility { yesOrNo },
    attribute Hangul { yesOrNo },
    attribute CJK_Unified_Ideographs { yesOrNo },
    attribute Private_Use_Area { yesOrNo },
    attribute CJK_Compatibility_Ideographs { yesOrNo },
    attribute Alphabetic_Presentation_Forms { yesOrNo },
    attribute Arabic_Presentation_Forms_A { yesOrNo },
    attribute Combining_Half_Marks { yesOrNo },
    attribute CJK_Compatibility_Forms { yesOrNo },
    attribute Small_Form_Variants { yesOrNo },
    attribute Arabic_Presentation_Forms_B { yesOrNo },
    attribute Halfwidth_And_Fullwidth_Forms { yesOrNo },
    attribute Specials { yesOrNo }
  }
os2_unicodeRange_v2 =
  element unicodeRange {
    attribute Basic_Latin { yesOrNo },
    attribute Latin_1_Supplement { yesOrNo },
    attribute Latin_Extended_A { yesOrNo },
    attribute Latin_Extended_B { yesOrNo },
    attribute IPA_Extensions { yesOrNo },
    attribute Spacing_Modifier_Letters { yesOrNo },
    attribute Combining_Diacritical_Marks { yesOrNo },
    attribute Greek { yesOrNo },
    attribute Cyrillic { yesOrNo },
    attribute Armenian { yesOrNo },
    attribute Hebrew { yesOrNo },
    attribute Arabic { yesOrNo },
    attribute Devanagari { yesOrNo },
    attribute Bengali { yesOrNo },
    attribute Gurmukhi { yesOrNo },
    attribute Gujarati { yesOrNo },
    attribute Oriya { yesOrNo },
    attribute Tamil { yesOrNo },
    attribute Telugu { yesOrNo },
    attribute Kannada { yesOrNo },
    attribute Malayalam { yesOrNo },
    attribute Thai { yesOrNo },
    attribute Lao { yesOrNo },
    attribute Georgian { yesOrNo },
    attribute Hangul_Jamo { yesOrNo },
    attribute Latin_Extended_Additional { yesOrNo },
    attribute Greek_Extended { yesOrNo },
    attribute General_Punctuation { yesOrNo },
    attribute Superscripts_And_Subscripts { yesOrNo },
    attribute Currency_Symbols { yesOrNo },
    attribute Combining_Diacritical_Marks_For_Symbols { yesOrNo },
    attribute Letterlike_Symbols { yesOrNo },
    attribute Number_Forms { yesOrNo },
    attribute Arrows { yesOrNo },
    attribute Mathematical_Operators { yesOrNo },
    attribute Miscellaneous_Technical { yesOrNo },
    attribute Control_Pictures { yesOrNo },
    attribute Optical_Character_Recognition { yesOrNo },
    attribute Enclosed_Alphanumerics { yesOrNo },
    attribute Box_Drawing { yesOrNo },
    attribute Block_Elements { yesOrNo },
    attribute Geometric_Shapes { yesOrNo },
    attribute Miscellaneous_Symbols { yesOrNo },
    attribute Dingbats { yesOrNo },
    attribute CJK_Symbols_And_Punctuation { yesOrNo },
    attribute Hiragana { yesOrNo },
    attribute Katakana { yesOrNo },
    attribute Bopomofo { yesOrNo },
    attribute Hangul_Compatibility_Jamo { yesOrNo },
    attribute CJK_Miscellaneous { yesOrNo },
    attribute Enclosed_CJK_Letters_And_Months { yesOrNo },
    attribute CJK_Compatibility { yesOrNo },
    attribute Hangul { yesOrNo },
    attribute Surrogates { yesOrNo },
    attribute CJK_Unified_Ideographs { yesOrNo },
    attribute Private_Use_Area { yesOrNo },
    attribute CJK_Compatibility_Ideographs { yesOrNo },
    attribute Alphabetic_Presentation_Forms { yesOrNo },
    attribute Arabic_Presentation_Forms_A { yesOrNo },
    attribute Combining_Half_Marks { yesOrNo },
    attribute CJK_Compatibility_Forms { yesOrNo },
    attribute Small_Form_Variants { yesOrNo },
    attribute Arabic_Presentation_Forms_B { yesOrNo },
    attribute Halfwidth_And_Fullwidth_Forms { yesOrNo },
    attribute Specials { yesOrNo },
    attribute Tibetan { yesOrNo },
    attribute Syriac { yesOrNo },
    attribute Thaana { yesOrNo },
    attribute Sinhala { yesOrNo },
    attribute Myanmar { yesOrNo },
    attribute Ethiopic { yesOrNo },
    attribute Cherokee { yesOrNo },
    attribute Unified_Canadian_Syllabics { yesOrNo },
    attribute Ogham { yesOrNo },
    attribute Runic { yesOrNo },
    attribute Khmer { yesOrNo },
    attribute Mongolian { yesOrNo },
    attribute Braille { yesOrNo },
    attribute Yi { yesOrNo }
  }
os2_unicodeRange_v3 =
  element unicodeRange {
    attribute Basic_Latin { yesOrNo },
    attribute Latin_1_Supplement { yesOrNo },
    attribute Latin_Extended_A { yesOrNo },
    attribute Latin_Extended_B { yesOrNo },
    attribute IPA_Extensions { yesOrNo },
    attribute Spacing_Modifier_Letters { yesOrNo },
    attribute Combining_Diacritical_Marks { yesOrNo },
    attribute Greek { yesOrNo },
    attribute Cyrillic { yesOrNo },
    attribute Armenian { yesOrNo },
    attribute Hebrew { yesOrNo },
    attribute Arabic { yesOrNo },
    attribute Devanagari { yesOrNo },
    attribute Bengali { yesOrNo },
    attribute Gurmukhi { yesOrNo },
    attribute Gujarati { yesOrNo },
    attribute Oriya { yesOrNo },
    attribute Tamil { yesOrNo },
    attribute Telugu { yesOrNo },
    attribute Kannada { yesOrNo },
    attribute Malayalam { yesOrNo },
    attribute Thai { yesOrNo },
    attribute Lao { yesOrNo },
    attribute Georgian { yesOrNo },
    attribute Hangul_Jamo { yesOrNo },
    attribute Latin_Extended_Additional { yesOrNo },
    attribute Greek_Extended { yesOrNo },
    attribute General_Punctuation { yesOrNo },
    attribute Superscripts_And_Subscripts { yesOrNo },
    attribute Currency_Symbols { yesOrNo },
    attribute Combining_Diacritical_Marks_For_Symbols { yesOrNo },
    attribute Letterlike_Symbols { yesOrNo },
    attribute Number_Forms { yesOrNo },
    attribute Arrows { yesOrNo },
    attribute Mathematical_Operators { yesOrNo },
    attribute Miscellaneous_Technical { yesOrNo },
    attribute Control_Pictures { yesOrNo },
    attribute Optical_Character_Recognition { yesOrNo },
    attribute Enclosed_Alphanumerics { yesOrNo },
    attribute Box_Drawing { yesOrNo },
    attribute Block_Elements { yesOrNo },
    attribute Geometric_Shapes { yesOrNo },
    attribute Miscellaneous_Symbols { yesOrNo },
    attribute Dingbats { yesOrNo },
    attribute CJK_Symbols_And_Punctuation { yesOrNo },
    attribute Hiragana { yesOrNo },
    attribute Katakana { yesOrNo },
    attribute Bopomofo { yesOrNo },
    attribute Hangul_Compatibility_Jamo { yesOrNo },
    attribute Enclosed_CJK_Letters_And_Months { yesOrNo },
    attribute CJK_Compatibility { yesOrNo },
    attribute Hangul { yesOrNo },
    attribute Surrogates { yesOrNo },
    attribute CJK_Unified_Ideographs { yesOrNo },
    attribute Private_Use_Area { yesOrNo },
    attribute CJK_Compatibility_Ideographs { yesOrNo },
    attribute Alphabetic_Presentation_Forms { yesOrNo },
    attribute Arabic_Presentation_Forms_A { yesOrNo },
    attribute Combining_Half_Marks { yesOrNo },
    attribute CJK_Compatibility_Forms { yesOrNo },
    attribute Small_Form_Variants { yesOrNo },
    attribute Arabic_Presentation_Forms_B { yesOrNo },
    attribute Halfwidth_And_Fullwidth_Forms { yesOrNo },
    attribute Specials { yesOrNo },
    attribute Tibetan { yesOrNo },
    attribute Syriac { yesOrNo },
    attribute Thaana { yesOrNo },
    attribute Sinhala { yesOrNo },
    attribute Myanmar { yesOrNo },
    attribute Ethiopic { yesOrNo },
    attribute Cherokee { yesOrNo },
    attribute Unified_Canadian_Syllabics { yesOrNo },
    attribute Ogham { yesOrNo },
    attribute Runic { yesOrNo },
    attribute Khmer { yesOrNo },
    attribute Mongolian { yesOrNo },
    attribute Braille { yesOrNo },
    attribute Yi { yesOrNo },
    attribute Tagalog_Hanunoo_Buhid_Tagbanwa { yesOrNo },
    attribute Old_Italic { yesOrNo },
    attribute Gothic { yesOrNo },
    attribute Deseret { yesOrNo },
    attribute Musical_Symbols { yesOrNo },
    attribute Mathematical_Alphanumeric_Symbols { yesOrNo },
    attribute Private_Use_Supplementary { yesOrNo },
    attribute Variation_Selectors { yesOrNo },
    attribute Tags { yesOrNo }
  }
os2_unicodeRange_v4 =
  element unicodeRange {
    attribute Basic_Latin { yesOrNo },
    attribute Latin_1_Supplement { yesOrNo },
    attribute Latin_Extended_A { yesOrNo },
    attribute Latin_Extended_B { yesOrNo },
    attribute IPA_Extensions { yesOrNo },
    attribute Spacing_Modifier_Letters { yesOrNo },
    attribute Combining_Diacritical_Marks { yesOrNo },
    attribute Greek { yesOrNo },
    attribute Coptic { yesOrNo },
    attribute Cyrillic { yesOrNo },
    attribute Armenian { yesOrNo },
    attribute Hebrew { yesOrNo },
    attribute Vai { yesOrNo },
    attribute Arabic { yesOrNo },
    attribute NKo { yesOrNo },
    attribute Devanagari { yesOrNo },
    attribute Bengali { yesOrNo },
    attribute Gurmukhi { yesOrNo },
    attribute Gujarati { yesOrNo },
    attribute Oriya { yesOrNo },
    attribute Tamil { yesOrNo },
    attribute Telugu { yesOrNo },
    attribute Kannada { yesOrNo },
    attribute Malayalam { yesOrNo },
    attribute Thai { yesOrNo },
    attribute Lao { yesOrNo },
    attribute Georgian { yesOrNo },
    attribute Balinese { yesOrNo },
    attribute Hangul_Jamo { yesOrNo },
    attribute Latin_Extended_Additional { yesOrNo },
    attribute Greek_Extended { yesOrNo },
    attribute General_Punctuation { yesOrNo },
    attribute Superscripts_And_Subscripts { yesOrNo },
    attribute Currency_Symbols { yesOrNo },
    attribute Combining_Diacritical_Marks_For_Symbols { yesOrNo },
    attribute Letterlike_Symbols { yesOrNo },
    attribute Number_Forms { yesOrNo },
    attribute Arrows { yesOrNo },
    attribute Mathematical_Operators { yesOrNo },
    attribute Miscellaneous_Technical { yesOrNo },
    attribute Control_Pictures { yesOrNo },
    attribute Optical_Character_Recognition { yesOrNo },
    attribute Enclosed_Alphanumerics { yesOrNo },
    attribute Box_Drawing { yesOrNo },
    attribute Block_Elements { yesOrNo },
    attribute Geometric_Shapes { yesOrNo },
    attribute Miscellaneous_Symbols { yesOrNo },
    attribute Dingbats { yesOrNo },
    attribute CJK_Symbols_And_Punctuation { yesOrNo },
    attribute Hiragana { yesOrNo },
    attribute Katakana { yesOrNo },
    attribute Bopomofo { yesOrNo },
    attribute Hangul_Compatibility_Jamo { yesOrNo },
    attribute Phags_pa { yesOrNo },
    attribute Enclosed_CJK_Letters_And_Months { yesOrNo },
    attribute CJK_Compatibility { yesOrNo },
    attribute Hangul { yesOrNo },
    attribute Surrogates { yesOrNo },
    attribute Phoenician { yesOrNo },
    attribute CJK_Unified_Ideographs { yesOrNo },
    attribute Private_Use_Area { yesOrNo },
    attribute CJK_Compatibility_Ideographs { yesOrNo },
    attribute Alphabetic_Presentation_Forms { yesOrNo },
    attribute Arabic_Presentation_Forms_A { yesOrNo },
    attribute Combining_Half_Marks { yesOrNo },
    attribute CJK_Compatibility_Forms { yesOrNo },
    attribute Small_Form_Variants { yesOrNo },
    attribute Arabic_Presentation_Forms_B { yesOrNo },
    attribute Halfwidth_And_Fullwidth_Forms { yesOrNo },
    attribute Specials { yesOrNo },
    attribute Tibetan { yesOrNo },
    attribute Syriac { yesOrNo },
    attribute Thaana { yesOrNo },
    attribute Sinhala { yesOrNo },
    attribute Myanmar { yesOrNo },
    attribute Ethiopic { yesOrNo },
    attribute Cherokee { yesOrNo },
    attribute Unified_Canadian_Syllabics { yesOrNo },
    attribute Ogham { yesOrNo },
    attribute Runic { yesOrNo },
    attribute Khmer { yesOrNo },
    attribute Mongolian { yesOrNo },
    attribute Braille { yesOrNo },
    attribute Yi { yesOrNo },
    attribute Tagalog_Hanunoo_Buhid_Tagbanwa { yesOrNo },
    attribute Old_Italic { yesOrNo },
    attribute Gothic { yesOrNo },
    attribute Deseret { yesOrNo },
    attribute Musical_Symbols { yesOrNo },
    attribute Mathematical_Alphanumeric_Symbols { yesOrNo },
    attribute Private_Use_Supplementary { yesOrNo },
    attribute Variation_Selectors { yesOrNo },
    attribute Tags { yesOrNo },
    attribute Limbu { yesOrNo },
    attribute Tai_Le { yesOrNo },
    attribute New_Tai_Lue { yesOrNo },
    attribute Buginese { yesOrNo },
    attribute Glagolitic { yesOrNo },
    attribute Tifinagh { yesOrNo },
    attribute Yijing_Hexagram_Symbols { yesOrNo },
    attribute Syloti_Nagri { yesOrNo },
    attribute Linear_B { yesOrNo },
    attribute Ancient_Greek_Numbers { yesOrNo },
    attribute Ugaritic { yesOrNo },
    attribute Old_Persian { yesOrNo },
    attribute Shavian { yesOrNo },
    attribute Osmanya { yesOrNo },
    attribute Cypriot_Syllabary { yesOrNo },
    attribute Kharoshthi { yesOrNo },
    attribute Tai_Xuan_Jing_Symbols { yesOrNo },
    attribute Cuneiform { yesOrNo },
    attribute Counting_Rod_Numerals { yesOrNo },
    attribute Sundanese { yesOrNo },
    attribute Lepcha { yesOrNo },
    attribute Ol_Chiki { yesOrNo },
    attribute Saurashtra { yesOrNo },
    attribute Kayah_Li { yesOrNo },
    attribute Rejang { yesOrNo },
    attribute Cham { yesOrNo },
    attribute Ancient_Symbols { yesOrNo },
    attribute Phaistos_Disc { yesOrNo },
    attribute Carian_Lycian_Lydian { yesOrNo },
    attribute Domino_And_Mahjong_Tiles { yesOrNo }
  }
os2_unicodeRange_v5 =
  element unicodeRange {
    attribute Basic_Latin { yesOrNo },
    attribute Latin_1_Supplement { yesOrNo },
    attribute Latin_Extended_A { yesOrNo },
    attribute Latin_Extended_B { yesOrNo },
    attribute IPA_Extensions { yesOrNo },
    attribute Spacing_Modifier_Letters { yesOrNo },
    attribute Combining_Diacritical_Marks { yesOrNo },
    attribute Greek { yesOrNo },
    attribute Coptic { yesOrNo },
    attribute Cyrillic { yesOrNo },
    attribute Armenian { yesOrNo },
    attribute Hebrew { yesOrNo },
    attribute Vai { yesOrNo },
    attribute Arabic { yesOrNo },
    attribute NKo { yesOrNo },
    attribute Devanagari { yesOrNo },
    attribute Bengali { yesOrNo },
    attribute Gurmukhi { yesOrNo },
    attribute Gujarati { yesOrNo },
    attribute Oriya { yesOrNo },
    attribute Tamil { yesOrNo },
    attribute Telugu { yesOrNo },
    attribute Kannada { yesOrNo },
    attribute Malayalam { yesOrNo },
    attribute Thai { yesOrNo },
    attribute Lao { yesOrNo },
    attribute Georgian { yesOrNo },
    attribute Balinese { yesOrNo },
    attribute Hangul_Jamo { yesOrNo },
    attribute Latin_Extended_Additional { yesOrNo },
    attribute Greek_Extended { yesOrNo },
    attribute General_Punctuation { yesOrNo },
    attribute Superscripts_And_Subscripts { yesOrNo },
    attribute Currency_Symbols { yesOrNo },
    attribute Combining_Diacritical_Marks_For_Symbols { yesOrNo },
    attribute Letterlike_Symbols { yesOrNo },
    attribute Number_Forms { yesOrNo },
    attribute Arrows { yesOrNo },
    attribute Mathematical_Operators { yesOrNo },
    attribute Miscellaneous_Technical { yesOrNo },
    attribute Control_Pictures { yesOrNo },
    attribute Optical_Character_Recognition { yesOrNo },
    attribute Enclosed_Alphanumerics { yesOrNo },
    attribute Box_Drawing { yesOrNo },
    attribute Block_Elements { yesOrNo },
    attribute Geometric_Shapes { yesOrNo },
    attribute Miscellaneous_Symbols { yesOrNo },
    attribute Dingbats { yesOrNo },
    attribute CJK_Symbols_And_Punctuation { yesOrNo },
    attribute Hiragana { yesOrNo },
    attribute Katakana { yesOrNo },
    attribute Bopomofo { yesOrNo },
    attribute Hangul_Compatibility_Jamo { yesOrNo },
    attribute Phags_pa { yesOrNo },
    attribute Enclosed_CJK_Letters_And_Months { yesOrNo },
    attribute CJK_Compatibility { yesOrNo },
    attribute Hangul { yesOrNo },
    attribute Surrogates { yesOrNo },
    attribute Phoenician { yesOrNo },
    attribute CJK_Unified_Ideographs { yesOrNo },
    attribute Private_Use_Area { yesOrNo },
    attribute CJK_Compatibility_Ideographs { yesOrNo },
    attribute Alphabetic_Presentation_Forms { yesOrNo },
    attribute Arabic_Presentation_Forms_A { yesOrNo },
    attribute Combining_Half_Marks { yesOrNo },
    attribute CJK_Compatibility_Forms { yesOrNo },
    attribute Small_Form_Variants { yesOrNo },
    attribute Arabic_Presentation_Forms_B { yesOrNo },
    attribute Halfwidth_And_Fullwidth_Forms { yesOrNo },
    attribute Specials { yesOrNo },
    attribute Tibetan { yesOrNo },
    attribute Syriac { yesOrNo },
    attribute Thaana { yesOrNo },
    attribute Sinhala { yesOrNo },
    attribute Myanmar { yesOrNo },
    attribute Ethiopic { yesOrNo },
    attribute Cherokee { yesOrNo },
    attribute Unified_Canadian_Syllabics { yesOrNo },
    attribute Ogham { yesOrNo },
    attribute Runic { yesOrNo },
    attribute Khmer { yesOrNo },
    attribute Mongolian { yesOrNo },
    attribute Braille { yesOrNo },
    attribute Yi { yesOrNo },
    attribute Tagalog_Hanunoo_Buhid_Tagbanwa { yesOrNo },
    attribute Old_Italic { yesOrNo },
    attribute Gothic { yesOrNo },
    attribute Deseret { yesOrNo },
    attribute Musical_Symbols { yesOrNo },
    attribute Mathematical_Alphanumeric_Symbols { yesOrNo },
    attribute Private_Use_Supplementary { yesOrNo },
    attribute Variation_Selectors { yesOrNo },
    attribute Tags { yesOrNo },
    attribute Limbu { yesOrNo },
    attribute Tai_Le { yesOrNo },
    attribute New_Tai_Lue { yesOrNo },
    attribute Buginese { yesOrNo },
    attribute Glagolitic { yesOrNo },
    attribute Tifinagh { yesOrNo },
    attribute Yijing_Hexagram_Symbols { yesOrNo },
    attribute Syloti_Nagri { yesOrNo },
    attribute Linear_B { yesOrNo },
    attribute Ancient_Greek_Numbers { yesOrNo },
    attribute Ugaritic { yesOrNo },
    attribute Old_Persian { yesOrNo },
    attribute Shavian { yesOrNo },
    attribute Osmanya { yesOrNo },
    attribute Cypriot_Syllabary { yesOrNo },
    attribute Kharoshthi { yesOrNo },
    attribute Tai_Xuan_Jing_Symbols { yesOrNo },
    attribute Cuneiform { yesOrNo },
    attribute Counting_Rod_Numerals { yesOrNo },
    attribute Sundanese { yesOrNo },
    attribute Lepcha { yesOrNo },
    attribute Ol_Chiki { yesOrNo },
    attribute Saurashtra { yesOrNo },
    attribute Kayah_aLi { yesOrNo },
    attribute Rejang { yesOrNo },
    attribute Cham { yesOrNo },
    attribute Ancient_Symbols { yesOrNo },
    attribute Phaistos_Disc { yesOrNo },
    attribute Carian_Lycian_Lydian { yesOrNo },
    attribute Domino_And_Mahjong_Tiles { yesOrNo }
  }
os2_vendID =
  element vendID {
    attribute v { text }
  }
os2_fsSelection =
  element fsSelection {
    attribute ITALIC { text },
    attribute UNDERSCORE { text },
    attribute NEGATIVE { text },
    attribute OUTLINED { text },
    attribute STRIKEOUT { text },
    attribute BOLD { text },
    attribute REGULAR { text }
  }
os2_fsSelection_v4 =
  element fsSelection {
    attribute ITALIC { text },
    attribute UNDERSCORE { text },
    attribute NEGATIVE { text },
    attribute OUTLINED { text },
    attribute STRIKEOUT { text },
    attribute BOLD { text },
    attribute REGULAR { text },
    attribute USE_TYPO_METRICS { text },
    attribute WWS { text },
    attribute OBLIQUE { text }
  }
os2_charIndex =
  element charIndex {
    attribute first { text },
    attribute last { text }
  }
os2_typo =
  element typo {
    attribute ascender { text },
    attribute descender { text },
    attribute linegap { text }
  }
os2_win =
  element win {
    attribute ascent { text },
    attribute descent { text }
  }
os2_codePageRange_v1 =
  element codePageRange {
    attribute CP_1252 { yesOrNo },
    attribute CP_1250 { yesOrNo },
    attribute CP_1251 { yesOrNo },
    attribute CP_1253 { yesOrNo },
    attribute CP_1254 { yesOrNo },
    attribute CP_1255 { yesOrNo },
    attribute CP_1256 { yesOrNo },
    attribute CP_1257 { yesOrNo },
    attribute CP_874 { yesOrNo },
    attribute CP_932 { yesOrNo },
    attribute CP_936 { yesOrNo },
    attribute CP_949 { yesOrNo },
    attribute CP_950 { yesOrNo },
    attribute CP_1361 { yesOrNo },
    attribute OEM { yesOrNo },
    attribute Symbol { yesOrNo },
    attribute CP_869 { yesOrNo },
    attribute CP_866 { yesOrNo },
    attribute CP_865 { yesOrNo },
    attribute CP_864 { yesOrNo },
    attribute CP_863 { yesOrNo },
    attribute CP_862 { yesOrNo },
    attribute CP_861 { yesOrNo },
    attribute CP_860 { yesOrNo },
    attribute CP_857 { yesOrNo },
    attribute CP_855 { yesOrNo },
    attribute CP_852 { yesOrNo },
    attribute CP_775 { yesOrNo },
    attribute CP_737 { yesOrNo },
    attribute CP_708 { yesOrNo },
    attribute CP_850 { yesOrNo },
    attribute CP_437 { yesOrNo }
  }
os2_codePageRange_v2 =
  element codePageRange {
    attribute CP_1252 { yesOrNo },
    attribute CP_1250 { yesOrNo },
    attribute CP_1251 { yesOrNo },
    attribute CP_1253 { yesOrNo },
    attribute CP_1254 { yesOrNo },
    attribute CP_1255 { yesOrNo },
    attribute CP_1256 { yesOrNo },
    attribute CP_1257 { yesOrNo },
    attribute CP_1258 { yesOrNo },
    attribute CP_874 { yesOrNo },
    attribute CP_932 { yesOrNo },
    attribute CP_936 { yesOrNo },
    attribute CP_949 { yesOrNo },
    attribute CP_950 { yesOrNo },
    attribute CP_1361 { yesOrNo },
    attribute Macintosh { yesOrNo },
    attribute OEM { yesOrNo },
    attribute Symbol { yesOrNo },
    attribute CP_869 { yesOrNo },
    attribute CP_866 { yesOrNo },
    attribute CP_865 { yesOrNo },
    attribute CP_864 { yesOrNo },
    attribute CP_863 { yesOrNo },
    attribute CP_862 { yesOrNo },
    attribute CP_861 { yesOrNo },
    attribute CP_860 { yesOrNo },
    attribute CP_857 { yesOrNo },
    attribute CP_855 { yesOrNo },
    attribute CP_852 { yesOrNo },
    attribute CP_775 { yesOrNo },
    attribute CP_737 { yesOrNo },
    attribute CP_708 { yesOrNo },
    attribute CP_850 { yesOrNo },
    attribute CP_437 { yesOrNo }
  }
os2_height =
  element height {
    attribute v { text }
  }
os2_capHeight =
  element capHeight {
    attribute v { text }
  }
os2_defaultChar =
  element defaultChar {
    attribute v { text }
  }
os2_breakChar =
  element breakChar {
    attribute v { text }
  }
os2_maxContext =
  element maxContext {
    attribute v { text }
  }
os2_lowerOpticalPointSize =
  element lowerOpticalPointSize {
    attribute v { text }
  }
os2_upperOpticalPointSize =
  element upperOpticalPointSize {
    attribute v { text }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='os2.methods'>
  <code-title>?</code-title>
  public static final int[] tableSize = {78, 86, 96, 96, 96, 100 };

  public void fromXML (Element os2)
      throws InvalidFontException, UnsupportedFontException {

    int version = Integer.decode (os2.getAttribute ("version")).intValue ();

    if (version &lt; 0 || 5 &lt; version) {
      throw new InvalidFontException ("invalid OS/2 version"); }

    Block me = new Block (tableSize [version], 0);

    me.setuint16 (0, version);

    NodeList children = os2.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);
      int j, mask;

      if ("avgCharWidth".equals (e.getTagName ())) {
        int avgCharWidth = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (2, avgCharWidth); }

      else if ("weightClass".equals (e.getTagName ())) {
        int weightClass = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (4, weightClass); }

      else if ("widthClass".equals (e.getTagName ())) {
        int widthClass = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (6, widthClass); }

      else if ("fsType".equals (e.getTagName ())) {
        int format = fsType_version2format [version];
        int fsType = 0;
        for (j = 0; j &lt; fsTypeNames.length; j++) {
          if (fsTypeNames [j][format] != null) {
            if ("yes".equals (e.getAttribute (fsTypeNames [j][format]))) {
              fsType |= 1 &lt;&lt; j; }}}
        me.setint16 (8, fsType); }

      else if ("subscript".equals (e.getTagName ())) {
        int xsize = Integer.decode (e.getAttribute ("xsize")).intValue();
        int ysize = Integer.decode (e.getAttribute ("ysize")).intValue();
        int xoffset = Integer.decode (e.getAttribute ("xoffset")).intValue();
        int yoffset = Integer.decode (e.getAttribute ("yoffset")).intValue();
        me.setint16 (10, xsize);
        me.setint16 (12, ysize);
        me.setint16 (14, xoffset);
        me.setint16 (16, yoffset); }

      else if ("superscript".equals (e.getTagName ())) {
        int xsize = Integer.decode (e.getAttribute ("xsize")).intValue();
        int ysize = Integer.decode (e.getAttribute ("ysize")).intValue();
        int xoffset = Integer.decode (e.getAttribute ("xoffset")).intValue();
        int yoffset = Integer.decode (e.getAttribute ("yoffset")).intValue();
        me.setint16 (18, xsize);
        me.setint16 (20, ysize);
        me.setint16 (22, xoffset);
        me.setint16 (24, yoffset); }

      else if ("strikeout".equals (e.getTagName ())) {
        int size = Integer.decode (e.getAttribute ("size")).intValue();
        int position = Integer.decode (e.getAttribute ("position")).intValue();
        me.setint16 (26, size);
        me.setint16 (28, position); }

      else if ("familyClass".equals (e.getTagName ())) {
        int cl = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (30, cl); }

      else if ("panose".equals (e.getTagName ())) {
        int familyType = Integer.decode (e.getAttribute ("familyType")).intValue();
        int serifStyle = Integer.decode (e.getAttribute ("serifStyle")).intValue();
        int weight     = Integer.decode (e.getAttribute ("weight")).intValue();
        int proportion = Integer.decode (e.getAttribute ("proportion")).intValue();
        int contrast  = Integer.decode (e.getAttribute ("contrast")).intValue();
        int strokeVariation = Integer.decode (e.getAttribute ("strokeVariation")).intValue();
        int armStyle   = Integer.decode (e.getAttribute ("armStyle")).intValue();
        int letterform = Integer.decode (e.getAttribute ("letterform")).intValue();
        int midline    = Integer.decode (e.getAttribute ("midline")).intValue();
        int xHeight    = Integer.decode (e.getAttribute ("xHeight")).intValue();

        me.setuint8 (32, familyType);
        me.setuint8 (33, serifStyle);
        me.setuint8 (34, weight);
        me.setuint8 (35, proportion);
        me.setuint8 (36, contrast);
        me.setuint8 (37, strokeVariation);
        me.setuint8 (38, armStyle);
        me.setuint8 (39, letterform);
        me.setuint8 (40, midline);
        me.setuint8 (41, xHeight); }

      else if ("unicodeRange".equals (e.getTagName ())) {
        int[] range = {0, 0, 0, 0};
        for (int r = 0; r &lt; unicodeRangeNames.length; r++) {
          if (unicodeRangeNames [r][version] != null) {
	    if ("yes".equals (e.getAttribute (unicodeRangeNames [r][version]))) {
              range [r / 32] |= (1 &lt;&lt; (r % 32)); }}}
        me.setuint32 (42, range [0]);
        me.setuint32 (46, range [1]);
        me.setuint32 (50, range [2]);
        me.setuint32 (54, range [3]); }

      else if ("vendID".equals (e.getTagName ())) {
        String id = e.getAttribute ("v");
        me.setTag (58, id); }

      else if ("fsSelection".equals (e.getTagName ())) {
        int format = fsSelectionNames_version2format [version];
        int fsSelection = 0;
        for (j = 0; j &lt; fsSelectionNames.length; j++) {
          if (fsSelectionNames [j][format] != null) {
            if ("yes".equals (e.getAttribute (fsSelectionNames [j][format]))) {
              fsSelection |= 1 &lt;&lt; j; }}}
        me.setuint16 (62, fsSelection); }

      else if ("charIndex".equals (e.getTagName ())) {
        int first = Integer.decode (e.getAttribute ("first")).intValue();
        int last  = Integer.decode (e.getAttribute ("last")).intValue();
        me.setuint16 (64, first);
        me.setuint16 (66, last); }

      else if ("typo".equals (e.getTagName ())) {
        int ascender = Integer.decode (e.getAttribute ("ascender")).intValue();
        int descender = Integer.decode (e.getAttribute ("descender")).intValue();
        int linegap = Integer.decode (e.getAttribute ("linegap")).intValue();
        me.setint16 (68, ascender);
        me.setint16 (70, descender);
        me.setint16 (72, linegap); }

      else if ("win".equals (e.getTagName ())) {
        int ascent = Integer.decode (e.getAttribute ("ascent")).intValue();
        int descent = Integer.decode (e.getAttribute ("descent")).intValue();
        me.setint16 (74, ascent);
        me.setint16 (76, descent); }

      else if ("codePageRange".equals (e.getTagName ())) {
        int format = cpNames_version2format [version];
        int[] cp = {0, 0};
        for (int r = 0; r &lt; cpNames.length; r++) {
          if (cpNames [r][format] != null) {
            if ("yes".equals (e.getAttribute (cpNames [r][format]))) {
              cp [r / 32] |= (1 &lt;&lt; (r %32)); }}}
        me.setuint32 (78, cp [0]);
        me.setuint32 (82, cp [1]); }

      else if ("height".equals (e.getTagName ())) {
        int h = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (86, h); }

      else if ("capHeight".equals (e.getTagName ())) {
        int h = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (88, h); }

      else if ("defaultChar".equals (e.getTagName ())) {
        int c = Integer.decode (e.getAttribute ("v")).intValue();
        me.setuint16 (90, c); }

      else if ("breakChar".equals (e.getTagName ())) {
        int c = Integer.decode (e.getAttribute ("v")).intValue();
        me.setint16 (92, c); }

      else if ("maxContext".equals (e.getTagName ())) {
        int m = Integer.decode (e.getAttribute ("v")).intValue();
        me.setuint16 (94, m); }

      else if ("lowerOpticalPointSize".equals (e.getTagName ())) {
        int v = Integer.decode (e.getAttribute ("v")).intValue();
        me.setuint16 (96, v); }

      else if ("upperOpticalPointSize".equals (e.getTagName ())) {
        int v = Integer.decode (e.getAttribute ("v")).intValue();
        me.setuint16 (98, v); }}

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='os2.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int version = getuint16 (0);
    if (version &lt; 0 || 5 &lt; version) {
      throw new InvalidFontException ("unsupported OS/2 table version ("
                                      + version + ") for decompilation"); }

    AttributesImpl at;
    int mask, j;

    at = new AttributesImpl ();
    at.addAttribute ("", "version", "version", "CDATA", "" + version);
    conf.ch.startElement ("OS2", at); {

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getint16 (2) );
      conf.ch.element ("avgCharWidth", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getuint16 (4) );
      conf.ch.element ("weightClass", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getuint16 (6) );
      conf.ch.element ("widthClass", at);

      at = new AttributesImpl ();
      int fsType = getuint16 (8);
      int fsTypeFormat = fsType_version2format [version];
      for (mask = 1, j = 0; j &lt; fsTypeNames.length; mask &lt;&lt;= 1, j++) {
        if (fsTypeNames [j][fsTypeFormat] != null) {
          at.addAttribute ("", fsTypeNames [j][fsTypeFormat],
                           fsTypeNames [j][fsTypeFormat], "CDATA",
                           (fsType &amp; mask) == 0 ? "no" : "yes"); }}
      conf.ch.element ("fsType", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "xsize", "xsize", "CDATA", "" +  getint16 (10));
      at.addAttribute ("", "ysize", "ysize", "CDATA", "" +  getint16 (12));
      at.addAttribute ("", "xoffset", "xoffset", "CDATA", "" +  getint16 (14));
      at.addAttribute ("", "yoffset", "yoffset", "CDATA", "" +  getint16 (16));
      conf.ch.element ("subscript", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "xsize", "xsize", "CDATA", "" +  getint16 (18));
      at.addAttribute ("", "ysize", "ysize", "CDATA", "" +  getint16 (20));
      at.addAttribute ("", "xoffset", "xoffset", "CDATA", "" +  getint16 (22));
      at.addAttribute ("", "yoffset", "yoffset", "CDATA", "" +  getint16 (24));
      conf.ch.element ("superscript", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "size", "size", "CDATA", "" +  getint16 (26));
      at.addAttribute ("", "position", "position", "CDATA", "" +  getint16 (28));
      conf.ch.element ("strikeout", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getint16 (30) );
      conf.ch.element ("familyClass", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "familyType", "familyType", "CDATA",
                       "" +  getuint8 (32));
      at.addAttribute ("", "serifStyle", "serifStyle", "CDATA",
                       "" +  getuint8 (33));
      at.addAttribute ("", "weight", "weight", "CDATA",
                       "" +  getuint8 (34));
      at.addAttribute ("", "proportion", "proportion", "CDATA",
                       "" +  getuint8 (35));
      at.addAttribute ("", "contrast", "contrast", "CDATA",
                       "" +  getuint8 (36));
      at.addAttribute ("", "strokeVariation", "strokeVariation", "CDATA",
                       "" +  getuint8 (37));
      at.addAttribute ("", "armStyle", "armStyle", "CDATA",
                       "" +  getuint8 (38));
      at.addAttribute ("", "letterform", "letterform", "CDATA",
                       "" +  getuint8 (39));
      at.addAttribute ("", "midline", "midline", "CDATA",
                       "" +  getuint8 (40));
      at.addAttribute ("", "xHeight", "xHeight", "CDATA",
                       "" +  getuint8 (41));
      conf.ch.element ("panose", at);

      if (version > 0) {
        at = new AttributesImpl ();
	long[] range = {getuint32 (42), getuint32 (46),
                        getuint32 (50),  getuint32 (54)};
        for (int r = 0; r &lt; unicodeRangeNames.length; r++) {
          if (unicodeRangeNames [r][version] != null) {
            at.addAttribute ("", unicodeRangeNames [r][version],
                             unicodeRangeNames [r][version], "CDATA",
                             ((range [r / 32] &amp; (1 &lt;&lt; (r % 32))) == 0) ? "no" : "yes"); }}
        conf.ch.element ("unicodeRange", at); }

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", Tag.tag2string (getuint32 (58)));
      conf.ch.element ("vendID", at);

      at = new AttributesImpl ();
      int fsSelectionFormat = fsSelectionNames_version2format [version];
      int fsSelection = getuint16 (62);
      for (j = 0; j &lt; fsSelectionNames.length; j++) {
        if (fsSelectionNames [j][fsSelectionFormat] != null) {
          at.addAttribute ("", fsSelectionNames [j][fsSelectionFormat],
                           fsSelectionNames [j][fsSelectionFormat], "CDATA",
                           ((fsSelection &amp; (1 &lt;&lt; j)) == 0) ? "no" : "yes"); }}
      conf.ch.element ("fsSelection", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "first", "first", "CDATA", "" +  getuint16 (64) );
      at.addAttribute ("", "last", "last", "CDATA", "" +  getuint16 (66) );
      conf.ch.element ("charIndex", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "ascender", "ascender", "CDATA", "" +  getint16 (68) );
      at.addAttribute ("", "descender", "descender", "CDATA", "" +  getint16 (70) );
      at.addAttribute ("", "linegap", "linegap", "CDATA", "" +  getint16 (72) );
      conf.ch.element ("typo", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "ascent", "ascent", "CDATA", "" +  getint16 (74) );
      at.addAttribute ("", "descent", "descent", "CDATA", "" +  getint16 (76) );
      conf.ch.element ("win", at);

      if (version > 0) {
        at = new AttributesImpl ();
        int format = cpNames_version2format [version];
        long[] cp = {getuint32 (78), getuint32 (82)};
        for (int r = 0; r &lt; cpNames.length; r++) {
          if (cpNames [r][format] != null) {
            at.addAttribute ("", cpNames[r][format], cpNames[r][format], "CDATA",
                 ((cp [r/32] &amp; (1 &lt;&lt; (r %32))) == 0) ? "no" : "yes"); }}
        conf.ch.element ("codePageRange", at); }

      if (version >= 2) {
	at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" +  getint16 (86) );
        conf.ch.element ("height", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" +  getint16 (88) );
        conf.ch.element ("capHeight", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" +  getuint16 (90) );
        conf.ch.element ("defaultChar", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" +  getuint16 (92) );
        conf.ch.element ("breakChar", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" +  getuint16 (94) );
        conf.ch.element ("maxContext", at); }

      if (version >= 5) {
        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (96) );
        conf.ch.element ("lowerOpticalPointSize", at);

        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA", "" + getuint16 (98) );
        conf.ch.element ("upperOpticalPointSize", at); }

      conf.ch.endElement ("OS2"); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='OS2'>
  <code-title>OS2 class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class OS2 extends Table {

  public OS2 () {
    super (Tag.os2, null);
  }

  public OS2 (Font font) {
    super (Tag.os2, font);
  }

  public int getTypoAscender () {
    return getint16 (68);
  }

  public int getTypoDescender () {
    return getint16 (70);
  }

  public int getTypoLineGap () {
    return getint16 (72);
  }

  public int getXHeight () {
    return getint16 (86);
  }

  public int getCapHeight () {
    return getint16 (88);
  }

  <code-include linkend='os2.methods'/>
}
</code-fragment>


   <para>Here are strings for the names of the various bitfields.</para>

<code-fragment id='os2.methods'>
  <code-title></code-title>

  public static final int[] fsType_version2format = {0, 0, 1, 1, 1, 1};
  public static final String[][] fsTypeNames =
    {{null,                 null},
     {"Restricted",         "Restricted"},
     {"Preview_and_print",  "Preview_and_print"},
     {"Editable_embedding", "Editable_embedding"},
     {null,                 null},
     {null,                 null},
     {null,                 null},
     {null,                 null},
     {null,                 "No_subsetting"},
     {null,                 "Bitmap_embedding_only"},
     {null,                 null},
     {null,                 null},
     {null,                 null},
     {null,                 null},
     {null,                 null},
     {null,                 null}};


  public static final String[/*bit*/][/*version*/] unicodeRangeNames = {
    {null,                                        /* bit 0 */
     "Basic_Latin",
     "Basic_Latin",
     "Basic_Latin",
     "Basic_Latin",
     "Basic_Latin"},
    {null,                                        /* bit 1 */
     "Latin_1_Supplement",
     "Latin_1_Supplement",
     "Latin_1_Supplement",
     "Latin_1_Supplement",
     "Latin_1_Supplement"},
    {null,                                        /* bit 2 */
     "Latin_Extended_A",
     "Latin_Extended_A",
     "Latin_Extended_A",
     "Latin_Extended_A",
     "Latin_Extended_A"},
    {null,                                        /* bit 3 */
     "Latin_Extended_B",
     "Latin_Extended_B",
     "Latin_Extended_B",
     "Latin_Extended_B",
     "Latin_Extended_B"},
    {null,                                        /* bit 4 */
     "IPA_Extensions",
     "IPA_Extensions",
     "IPA_Extensions",
     "IPA_Extensions",
     "IPA_Extensions"},
    {null,                                        /* bit 5 */
     "Spacing_Modifier_Letters",
     "Spacing_Modifier_Letters",
     "Spacing_Modifier_Letters",
     "Spacing_Modifier_Letters",
     "Spacing_Modifier_Letters"},
    {null,                                        /* bit 6 */
     "Combining_Diacritical_Marks",
     "Combining_Diacritical_Marks",
     "Combining_Diacritical_Marks",
     "Combining_Diacritical_Marks",
     "Combining_Diacritical_Marks"},
    {null,                                        /* bit 7 */
     "Greek",
     "Greek",
     "Greek",
     "Greek",
     "Greek"},
    {null,                                        /* bit 8 */
     "Greek_Symbols_And_Coptic",
     null,
     null,
     "Coptic",
     "Coptic"},
    {null,                                        /* bit 9 */
     "Cyrillic",
     "Cyrillic",
     "Cyrillic",
     "Cyrillic",
     "Cyrillic"},
    {null,                                        /* bit 10 */
     "Armenian",
     "Armenian",
     "Armenian",
     "Armenian",
     "Armenian"},
    {null,                                        /* bit 11 */
     "Hebrew",
     "Hebrew",
     "Hebrew",
     "Hebrew",
     "Hebrew"},
    {null,                                        /* bit 12 */
     "Hebrew_Extended",
     null,
     null,
     "Vai",
     "Vai"},
    {null,                                        /* bit 13 */
     "Arabic",
     "Arabic",
     "Arabic",
     "Arabic",
     "Arabic"},
    {null,                                        /* bit 14 */
     "Arabic_Extended",
     null,
     null,
     "NKo",
     "NKo"},
    {null,                                        /* bit 15 */
     "Devanagari",
     "Devanagari",
     "Devanagari",
     "Devanagari",
     "Devanagari"},
    {null,                                        /* bit 16 */
     "Bengali",
     "Bengali",
     "Bengali",
     "Bengali",
     "Bengali"},
    {null,                                        /* bit 17 */
     "Gurmukhi",
     "Gurmukhi",
     "Gurmukhi",
     "Gurmukhi",
     "Gurmukhi"},
    {null,                                        /* bit 18 */
     "Gujarati",
     "Gujarati",
     "Gujarati",
     "Gujarati",
     "Gujarati"},
    {null,                                        /* bit 19 */
     "Oriya",
     "Oriya",
     "Oriya",
     "Oriya",
     "Oriya"},
    {null,                                        /* bit 20 */
     "Tamil",
     "Tamil",
     "Tamil",
     "Tamil",
     "Tamil"},
    {null,                                        /* bit 21 */
     "Telugu",
     "Telugu",
     "Telugu",
     "Telugu",
     "Telugu"},
    {null,                                        /* bit 22 */
     "Kannada",
     "Kannada",
     "Kannada",
     "Kannada",
     "Kannada"},
    {null,                                        /* bit 23 */
     "Malayalam",
     "Malayalam",
     "Malayalam",
     "Malayalam",
     "Malayalam"},
    {null,                                        /* bit 24 */
     "Thai",
     "Thai",
     "Thai",
     "Thai",
     "Thai"},
    {null,                                        /* bit 25 */
     "Lao",
     "Lao",
     "Lao",
     "Lao",
     "Lao"},
    {null,                                        /* bit 26 */
     "Georgian",
     "Georgian",
     "Georgian",
     "Georgian",
     "Georgian"},
    {null,                                        /* bit 27 */
     "Georgian_Extended",
     null,
     null,
     "Balinese",
     "Balinese"},
    {null,                                        /* bit 28 */
     "Hangul_Jamo",
     "Hangul_Jamo",
     "Hangul_Jamo",
     "Hangul_Jamo",
     "Hangul_Jamo"},
    {null,                                        /* bit 29 */
     "Latin_Extended_Additional",
     "Latin_Extended_Additional",
     "Latin_Extended_Additional",
     "Latin_Extended_Additional",
     "Latin_Extended_Additional"},
    {null,                                        /* bit 30 */
     "Greek_Extended",
     "Greek_Extended",
     "Greek_Extended",
     "Greek_Extended",
     "Greek_Extended"},
    {null,                                        /* bit 31 */
     "General_Punctuation",
     "General_Punctuation",
     "General_Punctuation",
     "General_Punctuation",
     "General_Punctuation"},
    {null,                                        /* bit 32 */
     "Superscripts_And_Subscripts",
     "Superscripts_And_Subscripts",
     "Superscripts_And_Subscripts",
     "Superscripts_And_Subscripts",
     "Superscripts_And_Subscripts"},
    {null,                                        /* bit 33 */
     "Currency_Symbols",
     "Currency_Symbols",
     "Currency_Symbols",
     "Currency_Symbols",
     "Currency_Symbols"},
    {null,                                        /* bit 34 */
     "Combining_Diacritical_Marks_For_Symbols",
     "Combining_Diacritical_Marks_For_Symbols",
     "Combining_Diacritical_Marks_For_Symbols",
     "Combining_Diacritical_Marks_For_Symbols",
     "Combining_Diacritical_Marks_For_Symbols"},
    {null,                                        /* bit 35 */
     "Letterlike_Symbols",
     "Letterlike_Symbols",
     "Letterlike_Symbols",
     "Letterlike_Symbols",
     "Letterlike_Symbols"},
    {null,                                        /* bit 36 */
     "Number_Forms",
     "Number_Forms",
     "Number_Forms",
     "Number_Forms",
     "Number_Forms"},
    {null,                                        /* bit 37 */
     "Arrows",
     "Arrows",
     "Arrows",
     "Arrows",
     "Arrows"},
    {null,                                        /* bit 38 */
     "Mathematical_Operators",
     "Mathematical_Operators",
     "Mathematical_Operators",
     "Mathematical_Operators",
     "Mathematical_Operators"},
    {null,                                        /* bit 39 */
     "Miscellaneous_Technical",
     "Miscellaneous_Technical",
     "Miscellaneous_Technical",
     "Miscellaneous_Technical",
     "Miscellaneous_Technical"},
    {null,                                        /* bit 40 */
     "Control_Pictures",
     "Control_Pictures",
     "Control_Pictures",
     "Control_Pictures",
     "Control_Pictures"},
    {null,                                        /* bit 41 */
     "Optical_Character_Recognition",
     "Optical_Character_Recognition",
     "Optical_Character_Recognition",
     "Optical_Character_Recognition",
     "Optical_Character_Recognition"},
    {null,                                        /* bit 42 */
     "Enclosed_Alphanumerics",
     "Enclosed_Alphanumerics",
     "Enclosed_Alphanumerics",
     "Enclosed_Alphanumerics",
     "Enclosed_Alphanumerics"},
    {null,                                        /* bit 43 */
     "Box_Drawing",
     "Box_Drawing",
     "Box_Drawing",
     "Box_Drawing",
     "Box_Drawing"},
    {null,                                        /* bit 44 */
     "Block_Elements",
     "Block_Elements",
     "Block_Elements",
     "Block_Elements",
     "Block_Elements"},
    {null,                                        /* bit 45 */
     "Geometric_Shapes",
     "Geometric_Shapes",
     "Geometric_Shapes",
     "Geometric_Shapes",
     "Geometric_Shapes"},
    {null,                                        /* bit 46 */
     "Miscellaneous_Symbols",
     "Miscellaneous_Symbols",
     "Miscellaneous_Symbols",
     "Miscellaneous_Symbols",
     "Miscellaneous_Symbols"},
    {null,                                        /* bit 47 */
     "Dingbats",
     "Dingbats",
     "Dingbats",
     "Dingbats",
     "Dingbats"},
    {null,                                        /* bit 48 */
     "CJK_Symbols_And_Punctuation",
     "CJK_Symbols_And_Punctuation",
     "CJK_Symbols_And_Punctuation",
     "CJK_Symbols_And_Punctuation",
     "CJK_Symbols_And_Punctuation"},
    {null,                                        /* bit 49 */
     "Hiragana",
     "Hiragana",
     "Hiragana",
     "Hiragana",
     "Hiragana"},
    {null,                                        /* bit 50 */
     "Katakana",
     "Katakana",
     "Katakana",
     "Katakana",
     "Katakana"},
    {null,                                        /* bit 51 */
     "Bopomofo",
     "Bopomofo",
     "Bopomofo",
     "Bopomofo",
     "Bopomofo"},
    {null,                                        /* bit 52 */
     "Hangul_Compatibility_Jamo",
     "Hangul_Compatibility_Jamo",
     "Hangul_Compatibility_Jamo",
     "Hangul_Compatibility_Jamo",
     "Hangul_Compatibility_Jamo"},
    {null,                                        /* bit 53 */
     "CJK_Miscellaneous",
     "CJK_Miscellaneous",
     null,
     "Phags_pa",
     "Phags_pa"},
    {null,                                        /* bit 54 */
     "Enclosed_CJK_Letters_And_Months",
     "Enclosed_CJK_Letters_And_Months",
     "Enclosed_CJK_Letters_And_Months",
     "Enclosed_CJK_Letters_And_Months",
     "Enclosed_CJK_Letters_And_Months"},
    {null,                                        /* bit 55 */
     "CJK_Compatibility",
     "CJK_Compatibility",
     "CJK_Compatibility",
     "CJK_Compatibility",
     "CJK_Compatibility"},
    {null,                                        /* bit 56 */
     "Hangul",
     "Hangul",
     "Hangul",
     "Hangul",
     "Hangul"},
    {null,                                        /* bit 57 */
     null,
     "Surrogates",
     "Surrogates",
     "Surrogates",
     "Surrogates"},
    {null,                                        /* bit 58 */
     null,
     null,
     null,
     "Phoenician",
     "Phoenician" },
    {null,                                        /* bit 59 */
     "CJK_Unified_Ideographs",
     "CJK_Unified_Ideographs",
     "CJK_Unified_Ideographs",
     "CJK_Unified_Ideographs",
     "CJK_Unified_Ideographs"},
    {null,                                        /* bit 60 */
     "Private_Use_Area",
     "Private_Use_Area",
     "Private_Use_Area",
     "Private_Use_Area",
     "Private_Use_Area"},
    {null,                                        /* bit 61 */
     "CJK_Compatibility_Ideographs",
     "CJK_Compatibility_Ideographs",
     "CJK_Compatibility_Ideographs",
     "CJK_Compatibility_Ideographs",
     "CJK_Compatibility_Ideographs"},
    {null,                                        /* bit 62 */
     "Alphabetic_Presentation_Forms",
     "Alphabetic_Presentation_Forms",
     "Alphabetic_Presentation_Forms",
     "Alphabetic_Presentation_Forms",
     "Alphabetic_Presentation_Forms"},
    {null,                                        /* bit 63 */
     "Arabic_Presentation_Forms_A",
     "Arabic_Presentation_Forms_A",
     "Arabic_Presentation_Forms_A",
     "Arabic_Presentation_Forms_A",
     "Arabic_Presentation_Forms_A"},
    {null,                                        /* bit 64 */
     "Combining_Half_Marks",
     "Combining_Half_Marks",
     "Combining_Half_Marks",
     "Combining_Half_Marks",
     "Combining_Half_Marks"},
    {null,                                        /* bit 65 */
     "CJK_Compatibility_Forms",
     "CJK_Compatibility_Forms",
     "CJK_Compatibility_Forms",
     "CJK_Compatibility_Forms",
     "CJK_Compatibility_Forms"},
    {null,                                        /* bit 66 */
     "Small_Form_Variants",
     "Small_Form_Variants",
     "Small_Form_Variants",
     "Small_Form_Variants",
     "Small_Form_Variants"},
    {null,                                        /* bit 67 */
     "Arabic_Presentation_Forms_B",
     "Arabic_Presentation_Forms_B",
     "Arabic_Presentation_Forms_B",
     "Arabic_Presentation_Forms_B",
     "Arabic_Presentation_Forms_B"},
    {null,                                        /* bit 68 */
     "Halfwidth_And_Fullwidth_Forms",
     "Halfwidth_And_Fullwidth_Forms",
     "Halfwidth_And_Fullwidth_Forms",
     "Halfwidth_And_Fullwidth_Forms",
     "Halfwidth_And_Fullwidth_Forms"},
    {null,                                        /* bit 69 */
     "Specials",
     "Specials",
     "Specials",
     "Specials",
     "Specials"},
    {null,                                        /* bit 70 */
     null,
     "Tibetan",
     "Tibetan",
     "Tibetan",
     "Tibetan"},
    {null,                                        /* bit 71 */
     null,
     "Syriac",
     "Syriac",
     "Syriac",
     "Syriac"},
    {null,                                        /* bit 72 */
     null,
     "Thaana",
     "Thaana",
     "Thaana",
     "Thaana"},
    {null,                                        /* bit 73 */
     null,
     "Sinhala",
     "Sinhala",
     "Sinhala",
     "Sinhala"},
    {null,                                        /* bit 74 */
     null,
     "Myanmar",
     "Myanmar",
     "Myanmar",
     "Myanmar"},
    {null,                                        /* bit 75 */
     null,
     "Ethiopic",
     "Ethiopic",
     "Ethiopic",
     "Ethiopic"},
    {null,                                        /* bit 76 */
     null,
     "Cherokee",
     "Cherokee",
     "Cherokee",
     "Cherokee"},
    {null,                                        /* bit 77 */
     null,
     "Unified_Canadian_Syllabics",
     "Unified_Canadian_Syllabics",
     "Unified_Canadian_Syllabics",
     "Unified_Canadian_Syllabics"},
    {null,                                        /* bit 78 */
     null,
     "Ogham",
     "Ogham",
     "Ogham",
     "Ogham"},
    {null,                                        /* bit 79 */
     null,
     "Runic",
     "Runic",
     "Runic",
     "Runic"},
    {null,                                        /* bit 80 */
     null,
     "Khmer",
     "Khmer",
     "Khmer",
     "Khmer"},
    {null,                                        /* bit 81 */
     null,
     "Mongolian",
     "Mongolian",
     "Mongolian",
     "Mongolian"},
    {null,                                        /* bit 82 */
     null,
     "Braille",
     "Braille",
     "Braille",
     "Braille"},
    {null,                                        /* bit 83 */
     null,
     "Yi",
     "Yi",
     "Yi",
     "Yi"},
    {null,                                        /* bit 84 */
     null,
     null,
     "Tagalog_Hanunoo_Buhid_Tagbanwa",
     "Tagalog_Hanunoo_Buhid_Tagbanwa",
     "Tagalog_Hanunoo_Buhid_Tagbanwa"},
    {null,                                        /* bit 85 */
     null,
     null,
     "Old_Italic",
     "Old_Italic",
     "Old_Italic"},
    {null,                                        /* bit 86 */
     null,
     null,
     "Gothic",
     "Gothic",
     "Gothic"},
    {null,                                        /* bit 87 */
     null,
     null,
     "Deseret",
     "Deseret",
     "Deseret"},
    {null,                                        /* bit 88 */
     null,
     null,
     "Musical_Symbols",
     "Musical_Symbols",
     "Musical_Symbols"},
    {null,                                        /* bit 89 */
     null,
     null,
     "Mathematical_Alphanumeric_Symbols",
     "Mathematical_Alphanumeric_Symbols",
     "Mathematical_Alphanumeric_Symbols"},
    {null,                                        /* bit 90 */
     null,
     null,
     "Private_Use_Supplementary",
     "Private_Use_Supplementary",
     "Private_Use_Supplementary"},
    {null,                                        /* bit 91 */
     null,
     null,
     "Variation_Selectors",
     "Variation_Selectors",
     "Variation_Selectors"},
    {null,                                        /* bit 92 */
     null,
     null,
     "Tags",
     "Tags",
     "Tags"},
    {null,                                        /* bit 93 */
     null,
     null,
     null,
     "Limbu",
     "Limbu"},
    {null,                                        /* bit 94 */
     null,
     null,
     null,
     "Tai_Le",
     "Tai_Le"},
    {null,                                        /* bit 95 */
     null,
     null,
     null,
     "New_Tai_Lue",
     "New_Tai_Lue"},
    {null,                                        /* bit 96 */
     null,
     null,
     null,
     "Buginese",
     "Buginese"},
    {null,                                        /* bit 97 */
     null,
     null,
     null,
     "Glagolitic",
     "Glagolitic"},
    {null,                                        /* bit 98 */
     null,
     null,
     null,
     "Tifinagh",
     "Tifinagh"},
    {null,                                        /* bit 99 */
     null,
     null,
     null,
     "Yijing_Hexagram_Symbols" ,
     "Yijing_Hexagram_Symbols" },
    {null,                                        /* bit 100 */
     null,
     null,
     null,
     "Syloti_Nagri",
     "Syloti_Nagri"},
    {null,                                        /* bit 101 */
     null,
     null,
     null,
     "Linear_B",
     "Linear_B"},
    {null,                                        /* bit 102 */
     null,
     null,
     null,
     "Ancient_Greek_Numbers",
     "Ancient_Greek_Numbers"},
    {null,                                        /* bit 103 */
     null,
     null,
     null,
     "Ugaritic",
     "Ugaritic"},
    {null,                                        /* bit 104 */
     null,
     null,
     null,
     "Old_Persian",
     "Old_Persian"},
    {null,                                        /* bit 105 */
     null,
     null,
     null,
     "Shavian",
     "Shavian"},
    {null,                                        /* bit 106 */
     null,
     null,
     null,
     "Osmanya",
     "Osmanya"},
    {null,                                        /* bit 107 */
     null,
     null,
     null,
     "Cypriot_Syllabary",
     "Cypriot_Syllabary"},
    {null,                                        /* bit 108 */
     null,
     null,
     null,
     "Kharoshthi",
     "Kharoshthi"},
    {null,                                        /* bit 109 */
     null,
     null,
     null,
     "Tai_Xuan_Jing_Symbols",
     "Tai_Xuan_Jing_Symbols"},
    {null,                                        /* bit 110 */
     null,
     null,
     null,
     "Cuneiform",
     "Cuneiform"},
    {null,                                        /* bit 111 */
     null,
     null,
     null,
     "Counting_Rod_Numerals",
     "Counting_Rod_Numerals"},
    {null,                                        /* bit 112 */
     null,
     null,
     null,
     "Sundanese",
     "Sundanese"},
    {null,                                        /* bit 113 */
     null,
     null,
     null,
     "Lepcha",
     "Lepcha"},
    {null,                                        /* bit 114 */
     null,
     null,
     null,
     "Ol_Chiki",
     "Ol_Chiki"},
    {null,                                        /* bit 115 */
     null,
     null,
     null,
     "Saurashtra",
     "Saurashtra"},
    {null,                                        /* bit 116 */
     null,
     null,
     null,
     "Kayah_Li",
     "Kayah_Li"},
    {null,                                        /* bit 117 */
     null,
     null,
     null,
     "Rejang",
     "Rejang"},
    {null,                                        /* bit 118 */
     null,
     null,
     null,
     "Cham",
     "Cham"},
    {null,                                        /* bit 119 */
     null,
     null,
     null,
     "Ancient_Symbols",
     "Ancient_Symbols"},
    {null,                                        /* bit 120 */
     null,
     null,
     null,
     "Phaistos_Disc",
     "Phaistos_Disc"},
    {null,                                        /* bit 121 */
     null,
     null,
     null,
     "Carian_Lycian_Lydian",
     "Carian_Lycian_Lydian"},
    {null,                                        /* bit 122 */
     null,
     null,
     null,
     "Domino_And_Mahjong_Tiles",
     "Domino_And_Mahjong_Tiles"},
    {null,                                        /* bit 123 */
     null,
     null,
     null,
     null,
     null},
    {null,                                        /* bit 124 */
     null,
     null,
     null,
     null,
     null},
    {null,                                        /* bit 125 */
     null,
     null,
     null,
     null,
     null},
    {null,                                        /* bit 126 */
     null,
     null,
     null,
     null,
     null},
    {null,                                        /* bit 127 */
     null,
     null,
     null,
     null,
     null}};

  public static final int[] fsSelectionNames_version2format = {0, 0, 0, 0, 1, 1};
  public static final String[][] fsSelectionNames = {
    {"ITALIC",      "ITALIC"},
    {"UNDERSCORE",  "UNDERSCORE"},
    {"NEGATIVE",    "NEGATIVE"},
    {"OUTLINED",    "OUTLINED"},
    {"STRIKEOUT",   "STRIKEOUT"},
    {"BOLD",        "BOLD"},
    {"REGULAR",     "REGULAR"},
    {null,          "USE_TYPO_METRICS"},
    {null,          "WWS"},
    {null,          "OBLIQUE"}};

  public static final int[] cpNames_version2format = {-1, 0, 1, 1, 1};
  public static final String[][] cpNames = {
    {"CP_1252",     "CP_1252"},
    {"CP_1250",     "CP_1250"},
    {"CP_1251",     "CP_1251"},
    {"CP_1253",     "CP_1253"},
    {"CP_1254",     "CP_1254"},
    {"CP_1255",     "CP_1255"},
    {"CP_1256",     "CP_1256"},
    {"CP_1257",     "CP_1257"},
    {null,          "CP_1258"},
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {"CP_874",      "CP_874"},
    {"CP_932",      "CP_932"},
    {"CP_936",      "CP_936"},
    {"CP_949",      "CP_949"},
    {"CP_950",      "CP_950"},
    {"CP_1361",     "CP_1361"},
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          "Macintosh"},
    {"OEM",         "OEM"},
    {"Symbol",      "Symbol"},

    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {null,          null} ,
    {"CP_869",     "CP_869"},
    {"CP_866",     "CP_866"},
    {"CP_865",     "CP_865"},
    {"CP_864",     "CP_864"},
    {"CP_863",     "CP_863"},
    {"CP_862",     "CP_862"},
    {"CP_861",     "CP_861"},
    {"CP_860",     "CP_860"},
    {"CP_857",     "CP_857"},
    {"CP_855",     "CP_855"},
    {"CP_852",     "CP_852"},
    {"CP_775",     "CP_775"},
    {"CP_737",     "CP_737"},
    {"CP_708",     "CP_708"},
    {"CP_850",     "CP_850"},
    {"CP_437",     "CP_437"}};
</code-fragment>

        <para>The following function returns the bit position in
        ulUnicodeRange (0 through 128) that correspond to a given code
        point, or -1 if the code point is not assigned to a
        block. The set of blocks are those of Unicode 3.2.</para>

<code-fragment id='os2.methods'>
  <code-title>Unicode range to ulUnicodeRange map</code-title>
  private static class UnicodeRange {
    public UnicodeRange (int first, int last, int bit) {
      this.first = first;
      this.last = last;
      this.bit = bit; }
    public int first;
    public int last;
    public int bit; };


  private static UnicodeRange[] unicodeRanges = {
    new UnicodeRange (0x0000, 0x007f, 0), // Basic Latin
    new UnicodeRange (0x0080, 0x00FF, 1), // Latin-1 Supplement
    new UnicodeRange (0x0100, 0x017F, 2), // Latin Extended-A
    new UnicodeRange (0x0180, 0x024F, 3), // Latin Extended-B
    new UnicodeRange (0x0250, 0x02AF, 4), // IPA Extensions
    new UnicodeRange (0x02B0, 0x02FF, 5), // Spacing Modifier Letters
    new UnicodeRange (0x0300, 0x036F, 6), // Combining Diacritical Marks
    new UnicodeRange (0x0370, 0x03FF, 7), // Greek and Coptic
    new UnicodeRange (0x0400, 0x04FF, 9), // Cyrillic
    new UnicodeRange (0x0500, 0x052F, 9), // Cyrillic Supplementary
    new UnicodeRange (0x0530, 0x058F, 10), // Armenian
    new UnicodeRange (0x0590, 0x05FF, 11), // Hebrew
    new UnicodeRange (0x0600, 0x06FF, 13), // Arabic
    new UnicodeRange (0x0700, 0x074F, 71), // Syriac
    new UnicodeRange (0x0780, 0x07BF, 72), // Thaana
    new UnicodeRange (0x0900, 0x097F, 15), // Devanagari
    new UnicodeRange (0x0980, 0x09FF, 16), // Bengali
    new UnicodeRange (0x0A00, 0x0A7F, 17), // Gurmukhi
    new UnicodeRange (0x0A80, 0x0AFF, 18), // Gujarati
    new UnicodeRange (0x0B00, 0x0B7F, 19), // Oriya
    new UnicodeRange (0x0B80, 0x0BFF, 20), // Tamil
    new UnicodeRange (0x0C00, 0x0C7F, 21), // Telugu
    new UnicodeRange (0x0C80, 0x0CFF, 22), // Kannada
    new UnicodeRange (0x0D00, 0x0D7F, 23), // Malayalam
    new UnicodeRange (0x0D80, 0x0DFF, 73), // Sinhala
    new UnicodeRange (0x0E00, 0x0E7F, 24), // Thai
    new UnicodeRange (0x0E80, 0x0EFF, 25), // Lao
    new UnicodeRange (0x0F00, 0x0FFF, 70), // Tibetan
    new UnicodeRange (0x1000, 0x109F, 74), // Myanmar
    new UnicodeRange (0x10A0, 0x10FF, 26), // Georgian
    new UnicodeRange (0x1100, 0x11FF, 28), // Hangul Jamo
    new UnicodeRange (0x1200, 0x137F, 75), // Ethiopic
    new UnicodeRange (0x13A0, 0x13FF, 76), // Cherokee
    new UnicodeRange (0x1400, 0x167F, 77), // Unified Canadian Aboriginal Syllabics
    new UnicodeRange (0x1680, 0x169F, 78), // Ogham
    new UnicodeRange (0x16A0, 0x16FF, 79), // Runic
    new UnicodeRange (0x1700, 0x171F, -1), // Tagalog
    new UnicodeRange (0x1720, 0x173F, -1), // Hanunoo
    new UnicodeRange (0x1740, 0x175F, -1), // Buhid
    new UnicodeRange (0x1760, 0x177F, -1), // Tagbanwa
    new UnicodeRange (0x1780, 0x17FF, 80), // Khmer
    new UnicodeRange (0x1800, 0x18AF, 81), // Mongolian
    new UnicodeRange (0x1E00, 0x1EFF, 29), // Latin Extended Additional
    new UnicodeRange (0x1F00, 0x1FFF, 30), // Greek Extended
    new UnicodeRange (0x2000, 0x206F, 31), // General Punctuation
    new UnicodeRange (0x2070, 0x209F, 32), // Superscripts and Subscripts
    new UnicodeRange (0x20A0, 0x20CF, 33), // Currency Symbols
    new UnicodeRange (0x20D0, 0x20FF, 34), // Combining Diacritical Marks for Symbols
    new UnicodeRange (0x2100, 0x214F, 35), // Letterlike Symbols
    new UnicodeRange (0x2150, 0x218F, 36), // Number Forms
    new UnicodeRange (0x2190, 0x21FF, 37), // Arrows
    new UnicodeRange (0x2200, 0x22FF, 38), // Mathematical Operators
    new UnicodeRange (0x2300, 0x23FF, 39), // Miscellaneous Technical
    new UnicodeRange (0x2400, 0x243F, 40), // Control Pictures
    new UnicodeRange (0x2440, 0x245F, 41), // Optical Character Recognition
    new UnicodeRange (0x2460, 0x24FF, 42), // Enclosed Alphanumerics
    new UnicodeRange (0x2500, 0x257F, 43), // Box Drawing
    new UnicodeRange (0x2580, 0x259F, 44), // Block Elements
    new UnicodeRange (0x25A0, 0x25FF, 45), // Geometric Shapes
    new UnicodeRange (0x2600, 0x26FF, 46), // Miscellaneous Symbols
    new UnicodeRange (0x2700, 0x27BF, 47), // Dingbats
    new UnicodeRange (0x27C0, 0x27EF, -1), // Miscellaneous Mathematical Symbols-A
    new UnicodeRange (0x27F0, 0x27FF, -1), // Supplemental Arrows-A
    new UnicodeRange (0x2800, 0x28FF, 82), // Braille Patterns
    new UnicodeRange (0x2900, 0x297F, -1), // Supplemental Arrows-B
    new UnicodeRange (0x2980, 0x29FF, -1), // Miscellaneous Mathematical Symbols-B
    new UnicodeRange (0x2A00, 0x2AFF, -1), // Supplemental Mathematical Operators
    new UnicodeRange (0x2E80, 0x2EFF, 59), // CJK Radicals Supplement
    new UnicodeRange (0x2F00, 0x2FDF, 59), // Kangxi Radicals
    new UnicodeRange (0x2FF0, 0x2FFF, 59), // Ideographic Description Characters
    new UnicodeRange (0x3000, 0x303F, 48), // CJK Symbols and Punctuation
    new UnicodeRange (0x3040, 0x309F, 49), // Hiragana
    new UnicodeRange (0x30A0, 0x30FF, 50), // Katakana
    new UnicodeRange (0x3100, 0x312F, 51), // Bopomofo
    new UnicodeRange (0x3130, 0x318F, 52), // Hangul Compatibility Jamo
    new UnicodeRange (0x3190, 0x319F, -1), // Kanbun
    new UnicodeRange (0x31A0, 0x31BF, 51), // Bopomofo Extended
    new UnicodeRange (0x31F0, 0x31FF, -1), // Katakana Phonetic Extensions
    new UnicodeRange (0x3200, 0x32FF, 54), // Enclosed CJK Letters and Months
    new UnicodeRange (0x3300, 0x33FF, 55), // CJK Compatibility
    new UnicodeRange (0x3400, 0x4DBF, 59), // CJK Unified Ideographs Extension A
    new UnicodeRange (0x4E00, 0x9FFF, 59), // CJK Unified Ideographs
    new UnicodeRange (0xA000, 0xA48F, 83), // Yi Syllables
    new UnicodeRange (0xA490, 0xA4CF, 83), // Yi Radicals
    new UnicodeRange (0xAC00, 0xD7AF, 56), // Hangul Syllables
    new UnicodeRange (0xD800, 0xDB7F, 57), // High Surrogates
    new UnicodeRange (0xDB80, 0xDBFF, 57), // High Private Use Surrogates
    new UnicodeRange (0xDC00, 0xDFFF, 57), // Low Surrogates
    new UnicodeRange (0xE000, 0xF8FF, 60), // Private Use Area
    new UnicodeRange (0xF900, 0xFAFF, 61), // CJK Compatibility Ideographs
    new UnicodeRange (0xFB00, 0xFB4F, 62), // Alphabetic Presentation Forms
    new UnicodeRange (0xFB50, 0xFDFF, 63), // Arabic Presentation Forms-A
    new UnicodeRange (0xFE00, 0xFE0F, -1), // Variation Selectors
    new UnicodeRange (0xFE20, 0xFE2F, 64), // Combining Half Marks
    new UnicodeRange (0xFE30, 0xFE4F, 65), // CJK Compatibility Forms
    new UnicodeRange (0xFE50, 0xFE6F, 66), // Small Form Variants
    new UnicodeRange (0xFE70, 0xFEFF, 67), // Arabic Presentation Forms-B
    new UnicodeRange (0xFF00, 0xFFEF, 68), // Halfwidth and Fullwidth Forms
    new UnicodeRange (0xFFF0, 0xFFFF, 69), // Specials
    new UnicodeRange (0x10300, 0x1032F, -1), // Old Italic
    new UnicodeRange (0x10330, 0x1034F, -1), // Gothic
    new UnicodeRange (0x10400, 0x1044F, -1), // Deseret
    new UnicodeRange (0x1D000, 0x1D0FF, -1), // Byzantine Musical Symbols
    new UnicodeRange (0x1D100, 0x1D1FF, -1), // Musical Symbols
    new UnicodeRange (0x1D400, 0x1D7FF, -1), // Mathematical Alphanumeric Symbols
    new UnicodeRange (0x20000, 0x2A6DF, -1), // CJK Unified Ideographs Extension B
    new UnicodeRange (0x2F800, 0x2FA1F, -1), // CJK Compatibility Ideographs Supplement
    new UnicodeRange (0xE0000, 0xE007F, -1), // Tags
    new UnicodeRange (0xF0000, 0xFFFFF, -1), //  Supplementary Private Use Area-A
    new UnicodeRange (0x100000, 0x10FFFF, -1), // Supplementary Private Use Area-B
  };

  public static int bitForCodePoint (int cp) {
    int min = 0;
    int max = unicodeRanges.length - 1;

    // invariant: if cp is covered by one of the ranges, then the
    // index of that range is between min and max (both included)

    while (min &lt;= max) {
      int s = (min + max) / 2;
      if (cp &lt; unicodeRanges [s].first) {
        max = s - 1; }
      else if (unicodeRanges [s].last &lt; cp) {
        min = s + 1; }
      else {
        if (   unicodeRanges [s].first &lt;= cp
            &amp;&amp; cp &lt;= unicodeRanges [s].last) {
          return unicodeRanges [s].bit; }
        else {
          return -1; }}}

    return -1;
  }
</code-fragment>


<code-fragment id='os2.methods'>
  <code-title>Test ulUnicodeRange support</code-title>
  public boolean unicodeRangeSupported (int i) {
    int offset = 42 + 4 * (i / 32);
    long range = getuint32 (offset);
    return (range &amp; (1 &lt;&lt; (i % 32))) != 0;
  }

  public boolean codePageSupported (int i) {
    if (data.length &lt; 86) {
      return false; }
    int offset = 78 + 4 * (i / 32);
    long range = getuint32 (offset);
    return (range &amp; (1 &lt;&lt; (i % 32))) != 0;
  }
</code-fragment>

   <para>Warning: this interpertation of fsType is not necessarily
    correct.</para>

<code-fragment id='os2.methods'>
  <code-title>fsType</code-title>
  public int getFsType () {
    return getuint16 (8);
  }

  public boolean allowsSubsettingOutlineEmbedding () {
    int fsType = getFsType ();

    if (fsType == 0) {
      return true; }

    if (   ((fsType &amp; 0x0004) != 0 || (fsType &amp; 0x0008) != 0)
        &amp;&amp; (fsType &amp; 0x0100) == 0
        &amp;&amp; (fsType &amp; 0x0200) == 0) {
      return true; }

    return false;
  }
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.IBM'>
    <title>IBM Font Class Parameters</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This section defines the IBM Font Class and the IBM Font
	  Subclass parameter values to be used in the classification
	  of font designs by the font designer or supplier. This
	  information is stored in the sFamilyClass field of a font's
	  OS/2 table.</para>

	<para>sFamilyClass</para>

	<para>Format: 2-byte signed short</para>

	<para>Title: Font-family class and subclass. Also see section 3.4.</para>

	<para>Description: This parameter is a classification of
	  font-family design.</para>

	<para>Comments: The font class and font subclass are
	  registered values assigned by IBM to each font family. This
	  parameter is intended for use in selecting an alternate font
	  when the requested font is not available. The font class is
	  the most general and the font subclass is the most
	  specific. The high byte of this field contains the family
	  class, while the low byte contains the family
	  subclass.</para>

	<para>These values classify a font design as to its
	  appearance, but do not identify the specific font family,
	  typeface variation, designer, supplier, size, or metric
	  table differences. It should be noted that some font designs
	  may be classified equally well into more than IBM Font Class
	  or Subclass. Such designs should be matched to a
	  classification for which substitution of another font design
	  from the same class or subclass would generally result in a
	  similar appearance of the presented document.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 0 No Classification</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This class ID is used to indicate that the associated
	font has no design classification or that the design
	classification is not of significance to the creator or user
	of the font resource.</para>
      </section>
    </section>


    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 1 Oldstyle Serifs</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style is generally based upon the Latin printing
	style of the 15th to 17th century, with a mild diagonal
	contrast in stroke emphasis (lighter in upper left to lower
	right, heavier in upper right to lower left) and bracketed
	serifs. This IBM Class reflects the ISO Serif Class, Oldstyle
	and Legibility Subclasses as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	subclassification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : IBM Rounded Legibility</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with short ascenders and descenders. Specifically,
	it is distinguished by a medium resolution, hand tuned, bitmap
	rendition of the more general rounded legibility subclass. An
	example of this font style is the IBM Sonoran Serif
	family. This IBM Subclass reflects the ISO Serif Class,
	Legibility Subclass, and Rounded Specific Group as documented
	in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 2 : Garalde</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with tall ascenders. An example of this font style
	is the ITC Garamond family. This IBM Subclass reflects the ISO
	Serif Class, Oldstyle Subclass, and Garalde Specific Group as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 3 : Venetian</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with a relatively monotone appearance and sweeping
	tails based on the designs of the early Venetian printers. An
	example of this font style is the Goudy family. This IBM
	Subclass reflects the ISO Serif Class, Oldstyle Subclass, and
	Venetian Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 4 : Modified Venetian</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with a relatively monotone appearance and sweeping
	tails based on the designs of the early Venetian printers. An
	example of this font style is the Allied Linotype Palatino
	family. This IBM Subclass reflects the ISO Serif Class,
	Transitional Subclass, and Modified Specific Group as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 5 : Dutch Modern</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with wedge shaped serifs and a circular appearance
	to the bowls similar to the Dutch Traditional Subclass below,
	but with lighter stokes. An example of this font style is the
	Monotype Times New Roman family. This IBM Subclass reflects
	the ISO Serif Class, Oldstyle Subclass, and Dutch Specific
	Group as documented in the 12/87 ISO/IEC 9541-5 draft
	standard.</para>


	<bridgehead>Subclass ID = 6 : Dutch Traditional</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with wedge shaped serifs and a circular appearance
	of the bowls. An example of this font style is the IBM Press
	Roman family. This IBM Subclass reflects the ISO Serif Class
	and Legibility Subclass as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 7 : Contemporary</bridgehead>

	<para>This style is generally characterized by a small
	x-height, with light stokes and serifs. An example of this
	font style is the University family. This IBM Subclass
	reflects the ISO Serif Class and Contemporary Subclass as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 8 : Calligraphic</bridgehead>

	<para>This style is generally characterized by the fine hand
	writing style of calligraphy, while retaining the
	characteristic Oldstyle appearance. This IBM Subclass is not
	reflected in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 9-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 2 Transitional Serifs</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style is generally based upon the Latin printing
	style of the 18th to 19th century, with a pronounced vertical
	contrast in stroke emphasis (vertical strokes being heavier
	than the horizontal strokes) and bracketed serifs. This IBM
	Class reflects the ISO Serif Class, Transitional Subclass as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : Direct Line</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with fine serifs, noticeable contrast, and capitol
	letters of approximately the same width. An example of this
	font style is the Monotype Baskerville family. This IBM
	Subclass reflects the ISO Serif Class, Transitional Subclass,
	and Direct Line Specific Group as documented in the 12/87
	ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 2 : Script</bridgehead>

	<para>This style is generally characterized by a hand written
	script appearance while retaining the Transitional Direct Line
	style. An example of this font style is the IBM Nasseem
	(Arabic) family. This IBM Subclass is not specifically
	reflected in the 12/87 ISO/IEC 9541-5 draft standard, though
	the ISO Serif Class, Transitional Subclass, and Direct Line
	Specific Group would be a close approximation.</para>


	<bridgehead>Subclass ID = 3-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 3 Modern Serifs</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


	<para>This style is generally based upon the Latin printing
	style of the 20th century, with an extreme contrast between
	the thick and thin portion of the strokes. This IBM Class
	reflects the ISO Serif Class, Modern Subclass as documented in
	the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : Italian</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with thin hairline serifs. An example of this font
	style is the Monotype Bodoni family. This IBM Subclass
	reflects the ISO Serif Class, Modern Subclass, and Italian
	Specific Group as documented in the 12/87 ISO/IEC 9541-5 draft
	standard.</para>


	<bridgehead>Subclass ID = 2 : Script</bridgehead>

	<para>This style is generally characterized by a hand written
	script appearance while retaining the Modern Italian style. An
	example of this font style is the IBM Narkissim (Hebrew)
	family. This IBM Subclass is not specifically reflected in the
	12/87 ISO/IEC 9541-5 draft standard, though the ISO Serif
	Class, Modern Subclass, and Italian Specific Group would be a
	close approximation.</para>


	<bridgehead>Subclass ID = 3-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 4 Clarendon Serifs</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style is a variation of the Oldstyle Serifs and the
	Transitional Serifs, with a mild vertical stroke contrast and
	bracketed serifs. This IBM Class reflects the ISO Serif Class,
	Square Serif Subclass as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : Clarendon</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs and strokes of equal weight. An example
	of this font style is the Allied Linotype Clarendon
	family. This IBM Subclass reflects the ISO Serif Class, Square
	Serif Subclass, and Clarendon Specific Group as documented in
	the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 2 : Modern</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs of a lighter weight than the strokes and
	the strokes of a lighter weight than the Traditional. An
	example of this font style is the Monotype Century Schoolbook
	family. This IBM Subclass reflects the ISO Serif Class, Square
	Serif Subclass, and Clarendon Specific Group as documented in
	the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 3 : Traditional</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs of a lighter weight than the strokes. An
	example of this font style is the Monotype Century family.This
	IBM Subclass reflects the ISO Serif Class, Square Serif
	Subclass, and Clarendon Specific Group as documented in the
	12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 4 : Newspaper</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with a simpler style of design and serifs of a
	lighter weight than the strokes. An example of this font style
	is the Allied Linotype Excelsior Family. This IBM Subclass
	reflects the ISO Serif Class, Square Serif Subclass, and
	Clarendon Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 5 : Stub Serif</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with short stub serifs and relatively bold stems. An
	example of this font style is the Cheltenham Family. This IBM
	Subclass reflects the ISO Serif Class, Square Serif Subclass,
	and Short Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 6 : Monotone</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with monotone stems. An example of this font style
	is the ITC Korinna Family. This IBM Subclass reflects the ISO
	Serif Class, Square Serif Subclass, and Monotone Specific
	Group as documented in the 12/87 ISO/IEC 9541-5 draft
	standard.</para>


	<bridgehead>Subclass ID = 7 : Typewriter</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with moderate stroke thickness characteristic of a
	typewriter. An example of this font style is the Prestige
	Elite Family. This IBM Subclass reflects the ISO Serif Class,
	Square Serif Subclass, and Typewriter Specific Group as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 8-14: (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 5 Slab Serifs</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style is characterized by serifs with a square
	transition between the strokes and the serifs (no
	brackets). This IBM Class reflects the ISO Serif Class, Square
	Serif Subclass (except the Clarendon Specific Group) as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : Monotone</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs and strokes of equal weight. An example
	of this font style is the ITC Lubalin Family. This IBM
	Subclass reflects the ISO Serif Class, Square Serif Subclass,
	and Monotone Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 2 : Humanist</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with serifs of lighter weight that the strokes. An
	example of this font style is the Candida Family. This IBM
	Subclass reflects the ISO Serif Class, Square Serif Subclass,
	and Monotone Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 3 : Geometric</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs and strokes of equal weight and a
	geometric (circles and lines) design. An example of this font
	style is the Monotype Rockwell Family. This IBM Subclass
	reflects the ISO Serif Class, Square Serif Subclass, and
	Monotone Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 4 : Swiss</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs and strokes of equal weight and an
	emphasis on the white space of the characters. An example of
	this font style is the Allied Linotype Serifa Family. This IBM
	Subclass reflects the ISO Serif Class, Square Serif Subclass,
	and Monotone Specific Group as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 5 : Typewriter</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with serifs and strokes of equal but moderate
	thickness, and a geometric design. An example of this font
	style is the IBM Courier Family. This IBM Subclass reflects
	the ISO Serif Class, Square Serif Subclass, and Monotone
	Specific Group as documented in the 12/87 ISO/IEC 9541-5 draft
	standard.</para>


	<bridgehead>Subclass ID = 6-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 6 (reserved for future use)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This class ID is reserved for future assignment, and
	shall not be used without formal assignment by IBM.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 7 Freeform Serifs</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style includes serifs, but which expresses a design
	freedom that does not generally fit within the other serif
	design classifications. This IBM Class reflects the remaining
	ISO Serif Class subclasses as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : Modern</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with light contrast in the strokes and a round full
	design. An example of this font style is the ITC Souvenir
	Family. This IBM Subclass is not reflected in the 12/87
	ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 2-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 8 Sans Serif</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style includes most basic letter forms (excluding
	Scripts and Ornamentals) that do not have serifs on the
	strokes. This IBM Class reflects the ISO Sans Serif Class as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : IBM Neo-grotesque Gothic</bridgehead>

	<para>This style is generally characterized by a large
	x-height, with uniform stroke width and a simple one story
	design distinguished by a medium resolution, hand tuned,
	bitmap rendition of the more general Neo-grotesque Gothic
	Subclass. An example of this font style is the IBM Sonoran
	Sans Serif family. This IBM Subclass reflects the ISO Sans
	Serif Class, Gothic Subclass, and Neo-grotesque Specific Group
	as documented in the 12/87 ISO/IEC 9541-5 draft
	standard.</para>


	<bridgehead>Subclass ID = 2 : Humanist</bridgehead>

	<para>This style is generally characterized by a medium
	x-height, with light contrast in the strokes and a classic
	Roman letterform. An example of this font style is the Allied
	Linotype Optima family. This IBM Subclass reflects the ISO
	Sans Serif Class, Humanist Subclass as documented in the 12/87
	ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 3 : Low-x Round Geometric</bridgehead>

	<para>This style is generally characterized by a low x-height,
	with monotone stroke weight and a round geometric design. An
	example of this font style is the Fundicion Tipograficia
	Neufville Futura family. This IBM Subclass reflects the ISO
	Sans Serif Class, Geometric Subclass, Round Specific Group as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 4 : High-x Round Geometric</bridgehead>

	<para>This style is generally characterized by a high
	x-height, with uniform stroke weight and a round geometric
	design. An example of this font style is the ITC Avant Garde
	Gothic family. This IBM Subclass reflects the ISO Sans Serif
	Class, Geometric Subclass, Round Specific Group as documented
	in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 5 : Neo-grotesque Gothic</bridgehead>

	<para>This style is generally characterized by a high
	x-height, with uniform stroke width and a simple one story
	design. An example of this font style is the Allied Linotype
	Helvetica family. This IBM Subclass reflects the ISO Sans
	Serif Class, Gothic Subclass, Neo-grotesque Specific Group as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 6 : Modified Neo-grotesque Gothic</bridgehead>

	<para>This style is similar to the Neo-grotesque Gothic style,
	with design variations to the G and Q. An example of this font
	style is the Allied Linotype Univers family. This IBM Subclass
	reflects the ISO Sans Serif Class, Gothic Subclass,
	Neo-grotesque Specific Group as documented in the 12/87
	ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 7-8 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 9 : Typewriter Gothic</bridgehead>

	<para>This style is similar to the Neo-grotesque Gothic style,
	with moderate stroke thickness characteristic of a
	typewriter. An example of this font style is the IBM Letter
	Gothic family. This IBM Subclass reflects the ISO Sans Serif
	Class, Gothic Subclass, Typewriter Specific Group as
	documented in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 10 : Matrix</bridgehead>

	<para>This style is generally a simple design characteristic
	of a dot matrix printer. An example of this font style is the
	IBM Matrix Gothic family. This IBM Subclass is not reflected
	in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 11-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 9 Ornamentals</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style includes highly decorated or stylized
	character shapes that are typically used in headlines. This
	IBM Class reflects the ISO Ornamental Class and the ISO
	Blackletter Class as documented in the 12/87 ISO/IEC 9541-5
	draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1 : Engraver</bridgehead>

	<para>This style is characterized by fine lines or lines
	engraved on the stems. An example of this font style is the
	Copperplate family. This IBM Subclass reflects the ISO
	Ornamental Class and Inline Subclass, or the Serif Class and
	Engraving Subclass as documented in the 12/87 ISO/IEC 9541-5
	draft standard.</para>


	<bridgehead>Subclass ID = 2 : Black Letter</bridgehead>

	<para>This style is generally based upon the printing style of
	the German monasteries and printers of the 12th to 15th
	centuries. An example of this font style is the Old English
	family. This IBM Subclass reflects the ISO Blackletters Class
	as documented in the 12/87 ISO/IEC 9541-5 draft
	standard.</para>


	<bridgehead>Subclass ID = 3 : Decorative</bridgehead>

	<para>This style is characterized by ornamental designs
	(typically from nature, such as leaves, flowers, animals,
	etc.) incorporated into the stems and strokes of the
	characters. An example of this font style is the Saphire
	family. This IBM Subclass reflects the ISO Ornamental Class
	and Decorative Subclass as documented in the 12/87 ISO/IEC
	9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 4 : Three Dimensional</bridgehead>

	<para>This style is characterized by a three dimensional
	(raised) appearance of the characters created by shading or
	geometric effects. An example of this font style is the Thorne
	Shaded family. This IBM Subclass reflects the ISO Ornamental
	Class and Three Dimensional Subclass as documented in the
	12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 5-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 10 Scripts</title>

      <!--____________________________________________________________________-->
	  <section role='specification'>
        <title>Specification</title>

	    <para>This style includes those typefaces that are
	    designed to simulate handwriting. This IBM Class reflects
	    the ISO Script Class and Uncial Class as documented in the
	    12/87 ISO/IEC 9541-5 draft standard.</para>


	    <bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	    <para>This subclass ID is used to indicate that the
	    associated font has no design sub-classification or that
	    the design sub-classification is not of significance to
	    the creator or user of the font resource.</para>


	    <bridgehead>Subclass ID = 1 : Uncial</bridgehead>

	    <para>This style is characterized by unjoined
	    (nonconnecting) characters that are generally based on the
	    hand writing style of Europe in the 6th to 9th
	    centuries. An example of this font style is the Libra
	    family. This IBM Subclass reflects the ISO Uncial Class as
	    documented in the 12/87 ISO/IEC 9541-5 draft
	    standard.</para>


	    <bridgehead>Subclass ID = 2 : Brush Joined</bridgehead>

	    <para>This style is characterized by joined (connecting)
	    characters that have the appearance of being painted with
	    a brush, with moderate contrast between thick and thin
	    strokes. An example of this font style is the Mistral
	    family. This IBM Subclass reflects the ISO Script Class,
	    Joined Subclass, and Informal Specific Group as documented
	    in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	    <bridgehead>Subclass ID = 3 : Formal Joined</bridgehead>

	    <para>This style is characterized by joined (connecting)
	    characters that have a printed (or drawn with a stiff
	    brush) appearance with extreme contrast between the thick
	    and thin strokes. An example of this font style is the
	    Coronet family. This IBM Subclass reflects the ISO Script
	    Class, Joined Subclass, and Formal Specific Group as
	    documented in the 12/87 ISO/IEC 9541-5 draft
	    standard.</para>


	    <bridgehead>Subclass ID = 4 : Monotone Joined</bridgehead>

	    <para>This style is characterized by joined (connecting)
	    characters that have a uniform appearance with little or
	    no contrast in the strokes. An example of this font style
	    is the Kaufmann family. This IBM Subclass reflects the ISO
	    Script Class, Joined Subclass, and Monotone Specific Group
	    as documented in the 12/87 ISO/IEC 9541-5 draft
	    standard.</para>


	    <bridgehead>Subclass ID = 5 : Calligraphic</bridgehead>

	    <para>This style is characterized by beautifully hand
	    drawn, unjoined (non-connecting) characters that have an
	    appearance of being drawn with a broad edge pen. An
	    example of this font style is the Thompson Quillscript
	    family. This IBM Subclass reflects the ISO Script Class,
	    Unjoined Subclass, and Calligraphic Specific Group as
	    documented in the 12/87 ISO/IEC 9541-5 draft
	    standard.</para>


	    <bridgehead>Subclass ID = 6 : Brush Unjoined</bridgehead>

	    <para>This style is characterized by unjoined
	    (non-connecting) characters that have the appearance of
	    being painted with a brush, with moderate contrast between
	    thick and thin strokes. An example of this font style is
	    the Saltino family. This IBM Subclass reflects the ISO
	    Script Class, Unjoined Subclass, and Brush Specific Group
	    as documented in the 12/87 ISO/IEC 9541-5 draft
	    standard.</para>


	    <bridgehead>Subclass ID = 7 : Formal Unjoined</bridgehead>

	    <para>This style is characterized by unjoined
	    (non-connecting) characters that have a printed (or drawn
	    with a stiff brush) appearance with extreme contrast
	    between the thick and thin strokes. An example of this
	    font style is the Virtuosa family. This IBM Subclass
	    reflects the ISO Script Class, Unjoined Subclass, and
	    Formal Specific Group as documented in the 12/87 ISO/IEC
	    9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 8 : Monotone Unjoined</bridgehead>

	<para>This style is characterized by unjoined
	    (non-connecting) characters that have a uniform appearance
	    with little or no contrast in the strokes. An example of
	    this font style is the Gilles Gothic family. This IBM
	    Subclass reflects the ISO Script Class, Unjoined Subclass,
	    and Monotone Specific Group as documented in the 12/87
	    ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 9-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future
	    assignment, and shall not be used without formal
	    assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 : Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	  the associated design class that are not covered by another
	  Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 11 (reserved for future use)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This class ID is reserved for future assignment, and
	shall not be used without formal assignment by IBM.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 12 Symbolic</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This style is generally design independent, making it
	suitable for Pi and special characters (icons, dingbats,
	technical symbols, etc.) that may be used equally well with
	any font. This IBM Class reflects various ISO Specific Groups,
	as noted below and documented in the 12/87 ISO/IEC 9541-5
	draft standard.</para>


	<bridgehead>Subclass ID = 0 : No Classification</bridgehead>

	<para>This subclass ID is used to indicate that the associated
	font has no design sub-classification or that the design
	sub-classification is not of significance to the creator or
	user of the font resource.</para>


	<bridgehead>Subclass ID = 1-2 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 3 : Mixed Serif</bridgehead>

	<para>This style is characterized by either both or a
	combination of serif and sans serif designs on those
	characters of the font for which design is important (e.g.,
	superscript and subscript characters, numbers, copyright or
	trademark symbols, etc.). An example of this font style is
	found in the IBM Symbol family. This IBM Subclass is not
	reflected in the 12/87 ISO/IEC 9541-5 draft standard.</para>


	<bridgehead>Subclass ID = 4-5 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 6 : Oldstyle Serif</bridgehead>

	<para>This style is characterized by a Oldstyle Serif IBM
	Class design on those characters of the font for which design
	is important (e.g., superscript and subscript characters,
	numbers, copyright or trademark symbols, etc.). An example of
	this font style is found in the IBM Sonoran Pi Serif
	family. This IBM Subclass is not directly reflected in the
	12/87 ISO/IEC 9541-5 draft standard, though it is indirectly
	by the ISO Serif Class and Legibility Subclass (implies that
	all characters of the font exhibit the design appearance,
	while only a subset of the characters actually exhibit the
	design).</para>


	<bridgehead>Subclass ID = 7 : Neo-grotesque Sans Serif</bridgehead>

	<para>This style is characterized by a Neo-grotesque Sans
	Serif IBM Font Class and Subclass design on those characters
	of the font for which design is important (e.g., superscript
	and subscript characters, numbers, copyright or trademark
	symbols, etc.). An example of this font style is found in the
	IBM Sonoran Pi Sans Serif family. This IBM Subclass is not
	directly reflected in the 12/87 ISO/IEC 9541-5 draft standard,
	though it is indirectly by the ISO Sans Serif Class and Gothic
	Subclass (implies that all characters of the font exhibit the
	design appearance, while only a subset of the characters
	actually exhibit the design).</para>


	<bridgehead>Subclass ID = 8-14 : (reserved for future use)</bridgehead>

	<para>These subclass IDs are reserved for future assignment,
	and shall not be used without formal assignment by IBM.</para>


	<bridgehead>Subclass ID = 15 :Miscellaneous</bridgehead>

	<para>This subclass ID is used for miscellaneous designs of
	the associated design class that are not covered by another
	Subclass.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 13 Reserved</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This class ID is reserved for future assignment, and
	shall not be used without formal assignment by IBM.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class ID = 14 Reserved</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This class ID is reserved for future assignment, and
	shall not be used without formal assignment by IBM.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.post'>
    <title>post - PostScript</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table contains additional information needed to use
        TrueType or OpenType fonts on PostScript printers.  This
        includes data for the FontInfo dictionary entry and the
        PostScript names of all the glyphs. For more information about
        PostScript names, see the Adobe document <ulink
        url="http://partners.adobe.com/asn/developer/typeforum/unicodegm.html">Unicode
        and Glyph Names</ulink>.</para>

        <para>Versions 1.0, 2.0, and 2.5 refer to TrueType fonts and
          OpenType fonts with TrueType data. OpenType fonts with
          TrueType data may also use Version 3.0. OpenType fonts with
          CFF data use Version 3.0 only.</para>

        <para>The table begins as follows:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>
              <simplelist>
                <member>0x00010000 for version 1.0</member>
                <member>0x00020000 for version 2.0</member>
                <member>0x00025000 for version 2.5
                  (deprecated)</member>
                <member>0x00030000 for version 3.0</member>
              </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>italicAngle</otfieldname>
            <otfielddesc>Italic angle in counter-clockwise degrees
              from the vertical. Zero for upright text, negative for
              text that leans to the right (forward).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>FWord</otfieldtype>
            <otfieldname>underlinePosition</otfieldname>
            <otfielddesc>This is the suggested distance of the top
              of the underline from the baseline (negative
              values indicate below baseline). The
              PostScript definition of this FontInfo dictionary key (the y
              coordinate of the center of the stroke) is not used for
              historical reasons. The value of the PostScript key may be
              calculated by subtracting half the underlineThickness from
              the value of this field.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>FWord</otfieldtype>
            <otfieldname>underlineThickness</otfieldname>
            <otfielddesc>Suggested values for the underline
              thickness.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>isFixedPitch</otfieldname>
            <otfielddesc>Set to 0 if the font is proportionally
              spaced, non-zero if the font is not proportionally
              spaced (i.e. monospaced).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>minMemType42</otfieldname>
            <otfielddesc>Minimum memory usage when an OpenType font is
              downloaded.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>maxMemType42</otfieldname>
            <otfielddesc>Maximum memory usage when an OpenType font is
              downloaded.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>minMemType1</otfieldname>
            <otfielddesc>Minimum memory usage when an OpenType font is
              downloaded as a Type 1 font.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>maxMemType1</otfieldname>
            <otfielddesc>Maximum memory usage when an OpenType font is
              downloaded as a Type 1 font.</otfielddesc>
          </otfield>
        </otformat>

        <para>The last four entries in the table are present because
          PostScript drivers can do better memory management if the
          virtual memory (VM) requirements of a downloadable OpenType
          font are known before the font is downloaded. This
          information should be supplied if known. If it is not known,
          set the value to zero. The driver will still work but will
          be less efficient.</para>

        <para>Maximum memory usage is minimum memory usage plus
          maximum runtime memory use. Maximum runtime memory use
          depends on the maximum band size of any bitmap potentially
          rasterized by the font scaler. Runtime memory usage could be
          calculated by rendering characters at different point sizes
          and comparing memory use.</para>

        <para>If the version is 1.0 or 3.0, the table ends here. The
          additional entries for versions 2.0 and 2.5 are shown below.
          Apple has defined a version 4.0 for use with Apple's AAT
          (Apple Advanced Typography), which is described in their
          documentation.</para>

        <bridgehead>Version 1.0</bridgehead>

        <para>This TrueType-based font file contains exactly the 258
          glyphs in the standard Macintosh TrueType font file (see
          <ulink
            url="http://www.microsoft.com/typography/otspec/WGL4.htm">The
            WGL4.0 Character Set</ulink> chapter for a list of the
          Macintosh glyphs). As a result, the glyph names are taken
          from the system with no storage required by the font.</para>

        <bridgehead>Version 2.0</bridgehead>

        <para>This is the version required by TrueType-based fonts to
          be used on Windows.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numberOfGlyphs</otfieldname>
            <otfielddesc>Number of glyphs (this should be the same as
              numGlyphs in <ottable>maxp</ottable>
              table).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphNameIndex [numGlyphs]</otfieldname>
            <otfielddesc>This is not an offset, but is the ordinal
              number of the glyph in <ottable>post</ottable> string
              tables.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>names [numberNewGlyphs]</otfieldname>
            <otfielddesc>Glyph names with length bytes [variable] (a
              Pascal string).</otfielddesc>
          </otfield>
        </otformat>

        <para>This TrueType-based font file contains glyphs not in the
          standard Macintosh set or the ordering of the glyphs in the
          TrueType font file is non-standard (again, for the
          Macintosh). The glyph name array maps the glyphs in this
          font to name index. If the name index is between 0 and 257,
          treat the name index as a glyph index in the Macintosh
          standard order. If the name index is between 258 and 32767,
          then subtract 258 and use that to index into the list of
          Pascal strings at the end of the table. Thus a given font
          may map some of its glyphs to the standard glyph names, and
          some to its own names.</para>

        <para>Index numbers 32768 through 65535 are reserved for
          future use. If you do not want to associate a PostScript
          name with a particular glyph, use index number 0 which
          points the name .notdef.</para>


        <bridgehead>Version 2.5</bridgehead>

        <para>This version of the <ottable>post</ottable> table has
          been deprecated as of OpenType Specification v1.3.</para>

        <para>This version provides a space saving table for
          TrueType-based fonts which contain a pure subset of, or a
          simple reordering of, the standard Macintosh glyph
          set.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numberOfGlyphs</otfieldname>
            <otfielddesc>Number of glyphs</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>offset [numGlyphs]</otfieldname>
            <otfielddesc>Difference between graphic index and standard
              order of glyph</otfielddesc>
          </otfield>
        </otformat>

        <para>This version is useful for TrueType-based font files
          that contain only glyphs in the standard Macintosh glyph set
          but which have those glyphs arranged in a non-standard order
          or which are missing some glyphs. The table contains one
          byte for each glyph in the font file. The byte is treated as
          a signed offset that maps the glyph index used in this font
          into the standard glyph index. In other words, assuming that
          the font contains the three glyphs A, B, and C which are the
          37th, 38th, and 39th glyphs in the standard ordering, the
          <ottable>post</ottable> table would contain the bytes +36,
          +36, +36. This format has been deprecated by Apple, as of
          February 2000.</para>


        <bridgehead>Version 3.0</bridgehead>

        <para>This version is used by OpenType fonts with TrueType or
          CFF data. The version makes it possible to create a special
          font that is not burdened with a large
          <ottable>post</ottable> table set of glyph names.</para>

        <para>This version specifies that no PostScript name
          information is provided for the glyphs in this font file.
          The printing behavior of this version on PostScript printers
          is unspecified, except that it should not result in a fatal
          or unrecoverable error. Some drivers may print nothing,
          other drivers may attempt to print using a default naming
          scheme.</para>

        <para>Windows makes use of the italic angle value in the
          <ottable>post</ottable> table but does not actually
          <emphasis>require</emphasis> any glyph names to be stored as
          Pascal strings.</para>
      </section>


      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
post |=
  element post {
    attribute major { "1" },
    attribute minor { "0" },
    post_common
  }

post |=
  element post {
    attribute major { "2" },
    attribute minor { "0" },
    post_common,
    element glyph {
      attribute id { text },
      attribute name { text }
    }*
  }

post |=
  element post {
    attribute major { "2" },
    attribute minor { "5" },
    post_common,
    element offset {
      attribute v { text }
    }*
  }

post |=
  element post {
    attribute major { "3" },
    attribute minor { "0" },
    post_common
  }

post_common =
  element italicAngle {
    attribute int { text },
    attribute frac { text }
  },
  element underline {
    attribute position { text },
    attribute thickness { text }
  },
  element isFixedPitch {
    attribute v { yesOrNo }
  },
  element memType42 {
    attribute min { text },
    attribute max { text }
  },
  element memType1 {
    attribute min { text },
    attribute max { text }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='post.methods'>
  public void fromXML (Element post)
      throws InvalidFontException, UnsupportedFontException {

    int highestGid = -1;
    int namesLength = 0;
    NodeList children = post.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if ("glyph".equals (e.getTagName ())) {
        int gid = Integer.decode (e.getAttribute ("id")).intValue ();
        if (gid > highestGid) {
          highestGid = gid; }
        namesLength += 1 + e.getAttribute ("name").length (); }}

    int nbGids = highestGid + 1;

    Block me = new Block (32 + 2 + nbGids * 2 + namesLength, 0);
    String[] names = new String [nbGids];

    me.setFixed (0,
                 Integer.decode (post.getAttribute ("major")).intValue (),
                 Integer.decode (post.getAttribute ("minor")).intValue ());

    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if ("italicAngle".equals (e.getTagName ())) {
        me.setFixed (4,
	             Integer.decode (e.getAttribute ("int")).intValue(),
	             Integer.decode (e.getAttribute ("frac")).intValue()); }

      if ("underline".equals (e.getTagName ())) {
        me.setFWord (8, Integer.decode (e.getAttribute ("position")).intValue());
        me.setFWord (10, Integer.decode (e.getAttribute ("thickness")).intValue()); }

      if ("isFixedPitch".equals (e.getTagName ())) {
        me.setuint32 (12, "yes".equals (e.getAttribute ("v")) ? 1 : 0); }

      if ("memType42".equals (e.getTagName ())) {
        me.setuint32 (16, Integer.decode (e.getAttribute ("min")).intValue());
        me.setuint32 (20, Integer.decode (e.getAttribute ("max")).intValue()); }

      if ("memType1".equals (e.getTagName ())) {
        me.setuint32 (24, Integer.decode (e.getAttribute ("min")).intValue());
        me.setuint32 (28, Integer.decode (e.getAttribute ("max")).intValue()); }

      if ("glyph".equals (e.getTagName ())) {
        int gid = Integer.decode (e.getAttribute ("id")).intValue ();
        names [gid] = e.getAttribute ("name"); }}

    me.setuint16 (32, nbGids);
    int indexOffset = 34;
    int charOffset = indexOffset + nbGids * 2;

    for (int gid = 0; gid &lt; nbGids; gid++) {
      me.setuint16 (indexOffset, 258 + gid);
      indexOffset += 2;

      char[] name = names [gid].toCharArray ();

      me.setuint8 (charOffset, name.length);
      charOffset++;
      for (int i = 0; i &lt; name.length; i++) {
        me.setuint8 (charOffset, name [i]);
        charOffset ++; }}

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='post.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    int [] version = getFixed (0);

    AttributesImpl at;

    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);
    conf.ch.startElement ("post", at); {

      at = new AttributesImpl ();
      at.addAttribute ("", "int", "int", "CDATA", "" + getFixed (4) [0]);
      at.addAttribute ("", "frac", "frac", "CDATA", "" + getFixed (4) [1]);
      conf.ch.element ("italicAngle", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "position", "position", "CDATA", "" +  getFWord (8) );
      at.addAttribute ("", "thickness", "thickness", "CDATA", "" +  getFWord (10) );
      conf.ch.element ("underline", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", getuint32 (12) == 0 ? "no":"yes");
      conf.ch.element ("isFixedPitch", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "min", "min", "CDATA", "" +  getuint32 (16) );
      at.addAttribute ("", "max", "max", "CDATA", "" +  getuint32 (20) );
      conf.ch.element ("memType42", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "min", "min", "CDATA", "" +  getuint32 (24) );
      at.addAttribute ("", "max", "max", "CDATA", "" +  getuint32 (28) );
      conf.ch.element ("memType1", at);

      if (version [0] == 2 &amp;&amp; version [1] == 0) {
        String [] names = getGlyphNames ();
        for (int g = 0; g &lt; names.length; g++) {
	  at = new AttributesImpl ();
	  at.addAttribute ("", "id", "id", "CDATA", "" + g);
          at.addAttribute ("", "name", "name", "CDATA", names [g]);
          conf.ch.element ("glyph", at); }}

      conf.ch.endElement ("post"); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Post'>
  <code-title>Post class</code-title>
package com.adobe.aots.opentype;

import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Post extends Table {

  public Post () {
    super (Tag.post);
  }

  public Post (Font font) {
    super (Tag.post, font);
  }

  <code-include linkend='post.methods'/>
}
</code-fragment>


<code-fragment id='post.methods'>
  <code-title>Glyph names</code-title>

  protected static String [] wellKnownNames = {
     ".notdef", // 0
     ".null", // 1
     "nonmarkingreturn", // 2
     "space", // 3
     "exclam", // 4
     "quotedbl", // 5
     "numbersign", // 6
     "dollar", // 7
     "percent", // 8
     "ampersand", // 9
     "quotesingle", // 10
     "parenleft", // 11
     "parenright", // 12
     "asterisk", // 13
     "plus", // 14
     "comma", // 15
     "hyphen", // 16
     "period", // 17
     "slash", // 18
     "zero", // 19
     "one", // 20
     "two", // 21
     "three", // 22
     "four", // 23
     "five", // 24
     "six", // 25
     "seven", // 26
     "eight", // 27
     "nine", // 28
     "colon", // 29
     "semicolon", // 30
     "less", // 31
     "equal", // 32
     "greater", // 33
     "question", // 34
     "at", // 35
     "A", // 36
     "B", // 37
     "C", // 38
     "D", // 39
     "E", // 40
     "F", // 41
     "G", // 42
     "H", // 43
     "I", // 44
     "J", // 45
     "K", // 46
     "L", // 47
     "M", // 48
     "N", // 49
     "O", // 50
     "P", // 51
     "Q", // 52
     "R", // 53
     "S", // 54
     "T", // 55
     "U", // 56
     "V", // 57
     "W", // 58
     "X", // 59
     "Y", // 60
     "Z", // 61
     "bracketleft", // 62
     "backslash", // 63
     "bracketright", // 64
     "asciicircum", // 65
     "underscore", // 66
     "grave", // 67
     "a", // 68
     "b", // 69
     "c", // 70
     "d", // 71
     "e", // 72
     "f", // 73
     "g", // 74
     "h", // 75
     "i", // 76
     "j", // 77
     "k", // 78
     "l", // 79
     "m", // 80
     "n", // 81
     "o", // 82
     "p", // 83
     "q", // 84
     "r", // 85
     "s", // 86
     "t", // 87
     "u", // 88
     "v", // 89
     "w", // 90
     "x", // 91
     "y", // 92
     "z", // 93
     "braceleft", // 94
     "bar", // 95
     "braceright", // 96
     "asciitilde", // 97
     "Adieresis", // 98
     "Aring", // 99
     "Ccedilla", // 100
     "Eacute", // 101
     "Ntilde", // 102
     "Odieresis", // 103
     "Udieresis", // 104
     "aacute", // 105
     "agrave", // 106
     "acircumflex", // 107
     "adieresis", // 108
     "atilde", // 109
     "aring", // 110
     "ccedilla", // 111
     "eacute", // 112
     "egrave", // 113
     "ecircumflex", // 114
     "edieresis", // 115
     "iacute", // 116
     "igrave", // 117
     "icircumflex", // 118
     "idieresis", // 119
     "ntilde", // 120
     "oacute", // 121
     "ograve", // 122
     "ocircumflex", // 123
     "odieresis", // 124
     "otilde", // 125
     "uacute", // 126
     "ugrave", // 127
     "ucircumflex", // 128
     "udieresis", // 129
     "dagger", // 130
     "degree", // 131
     "cent", // 132
     "sterling", // 133
     "section", // 134
     "bullet", // 135
     "paragraph", // 136
     "germandbls", // 137
     "registered", // 138
     "copyright", // 139
     "trademark", // 140
     "acute", // 141
     "dieresis", // 142
     "notequal", // 143
     "AE", // 144
     "Oslash", // 145
     "infinity", // 146
     "plusminus", // 147
     "lessequal", // 148
     "greaterequal", // 149
     "yen", // 150
     "mu", // 151
     "partialdiff", // 152
     "summation", // 153
     "product", // 154
     "pi", // 155
     "integral", // 156
     "ordfeminine", // 157
     "ordmasculine", // 158
     "Omega", // 159
     "ae", // 160
     "oslash", // 161
     "questiondown", // 162
     "exclamdown", // 163
     "logicalnot", // 164
     "radical", // 165
     "florin", // 166
     "approxequal", // 167
     "Delta", // 168
     "guillemotleft", // 169
     "guillemotright", // 170
     "ellipsis", // 171
     "nonbreakingspace", // 172
     "Agrave", // 173
     "Atilde", // 174
     "Otilde", // 175
     "OE", // 176
     "oe", // 177
     "endash", // 178
     "emdash", // 179
     "quotedblleft", // 180
     "quotedblright", // 181
     "quoteleft", // 182
     "quoteright", // 183
     "divide", // 184
     "lozenge", // 185
     "ydieresis", // 186
     "Ydieresis", // 187
     "fraction", // 188
     "currency", // 189
     "guilsinglleft", // 190
     "guilsinglright", // 191
     "fi", // 192
     "fl", // 193
     "daggerdbl", // 194
     "periodcentered", // 195
     "quotesinglbase", // 196
     "quotedblbase", // 197
     "perthousand", // 198
     "Acircumflex", // 199
     "Ecircumflex", // 200
     "Aacute", // 201
     "Edieresis", // 202
     "Egrave", // 203
     "Iacute", // 204
     "Icircumflex", // 205
     "Idieresis", // 206
     "Igrave", // 207
     "Oacute", // 208
     "Ocircumflex", // 209
     "apple", // 210
     "Ograve", // 211
     "Uacute", // 212
     "Ucircumflex", // 213
     "Ugrave", // 214
     "dotlessi", // 215
     "circumflex", // 216
     "tilde", // 217
     "macron", // 218
     "breve", // 219
     "dotaccent", // 220
     "ring", // 221
     "cedilla", // 222
     "hungarumlaut", // 223
     "ogonek", // 224
     "caron", // 225
     "Lslash", // 226
     "lslash", // 227
     "Scaron", // 228
     "scaron", // 229
     "Zcaron", // 230
     "zcaron", // 231
     "brokenbar", // 232
     "Eth", // 233
     "eth", // 234
     "Yacute", // 235
     "yacute", // 236
     "Thorn", // 237
     "thorn", // 238
     "minus", // 239
     "multiply", // 240
     "onesuperior", // 241
     "twosuperior", // 242
     "threesuperior", // 243
     "onehalf", // 244
     "onequarter", // 245
     "threequarters", // 246
     "franc", // 247
     "Gbreve", // 248
     "gbreve", // 249
     "Idotaccent", // 250
     "Scedilla", // 251
     "scedilla", // 252
     "Cacute", // 253
     "cacute", // 254
     "Ccaron", // 255
     "ccaron", // 256
     "dcroat", // 257
    };


  protected String[] myNames = null;

  public int getGid (String name) {
    if (myNames == null) {
      myNames = getGlyphNames (); }

    if (myNames == null) {
      return -1; }

    for (int gid = 0; gid &lt; myNames.length; gid++) {
      if (name.equals (myNames [gid])) {
         return gid; }}

    return -1;
  }

  public String[] getGlyphNames () {
    int [] version = getFixed (0);

    if (version [0] == 2 &amp;&amp; version [1] == 0) {
      int numGlyphs = getuint16 (32);
      int[] positions = new int [numGlyphs];
      int offset = 34;
      int highestIndex = 0;

      for (int g = 0; g &lt; numGlyphs; g++) {
        positions [g] = getuint16 (offset);
    	if (positions [g] > highestIndex) {
          highestIndex = positions [g]; }
        offset += 2; }

      int numberNewGlyphs = highestIndex > 257 ? highestIndex - 257 : 0;
      String[] newNames = new String [numberNewGlyphs];
      try {
        for (int i = 0; i &lt; numberNewGlyphs; i++) {
          int len = getuint8 (offset);
          offset++;
          newNames [i] = new String (data, offset, len, "ASCII");
          offset += len; }}
      catch (java.io.UnsupportedEncodingException e) {
    	System.err.println ("ASCII encoding not supported in String creation");
        System.exit (1); }

      String[] names = new String [numGlyphs];
      for (int g = 0; g &lt; numGlyphs; g++) {
        names [g] = positions [g] > 257
    	                ? newNames [positions[g]-258]
    			: wellKnownNames [positions[g]]; }
      return names; }

    else {
      return null; }
  }
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.cvt'>
    <title>cvt - Control Value Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table contains a list of values that can be
          referenced by instructions. They can be used, among other
          things, to control characteristics for different glyphs. The
          length of the table must be an integral number of FWORD
          units.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>FWORD [n]</otfieldtype>
            <otfieldname></otfieldname>
            <otfielddesc>List of n values referenceable by
	      instructions. n is the number of FWORD items that
	      fit in the size of the table.</otfielddesc>
          </otfield>
        </otformat>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.fpgm'>
    <title>fpgm - Font Program </title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table is similar to the CVT Program, except that it
          is only run once, when the font is first used. It is used
          only for FDEFs and IDEFs. Thus the CVT Program need not
          contain function definitions. However, the CVT Program may
          redefine existing FDEFs or IDEFs.</para>

        <para>This table is optional.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>BYTE [n]</otfieldtype>
            <otfieldname></otfieldname>
            <otfielddesc>Instructions. n is the number of BYTE items
	      that fit in the size of the table.</otfielddesc>
          </otfield>
        </otformat>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.glyf'>
    <title>glyf - Glyf Data</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table contains information that describes the
          glyphs in the font in the TrueType outline format.
          Information regarding the rasterizer (scaler) refers to the
          TrueType rasterizer.</para>

        <para>Each glyph begins with the following header:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>numberOfContours</otfieldname>
            <otfielddesc>If the number of contours is greater than or
              equal to zero, this is a single glyph; if negative, this
              is a composite glyph.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xMin</otfieldname>
            <otfielddesc>Minimum x for coordinate data.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMin</otfieldname>
            <otfielddesc>Minimum y for coordinate data.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xMax</otfieldname>
            <otfielddesc>Maximum x for coordinate data.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMax</otfieldname>
            <otfielddesc>Maximum y for coordinate data.</otfielddesc>
          </otfield>
        </otformat>

        <para>Note that the bounding rectangle from each character is
          defined as the rectangle with a lower left corner of (xMin,
          yMin) and an upper right corner of (xMax, yMax).</para>

        <para>Note: The scaler will perform better if the glyph
          coordinates have been created such that the xMin is equal to
          the lsb. For example, if the lsb is 123, then xMin for the
          glyph should be 123. If the lsb is -12 then the xMin should
          be -12. If the lsb is 0 then xMin is 0. If all glyphs are
          done like this, set bit 1 of flags field in the
          <ottable>head</ottable> table.</para>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Relax Schema for glyf table</code-title>
glyf =
  element glyf {
    ( simple_glyph | empty_glyph | composite_glyph )*
  }

empty_glyph =
  element empty_glyph {
    attribute gid { text } }

glyph_attributes =
  attribute gid { text },
  attribute xMin { text },
  attribute yMin { text },
  attribute xMax { text },
  attribute yMax { text }

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='glyf.methods'>
  <code-title>Compilation methods</code-title>
  public void fromXML (Element glyf)
      throws InvalidFontException, UnsupportedFontException {

      NodeList l = glyf.getChildNodes ();

      int glyfSize = 0;

      Block glyphs [] = new Block [l.getLength ()];

      for (int gid = 0; gid &lt; l.getLength (); gid++) {
        Element e = (Element) l.item (gid);
        if ("simple_glyph".equals (e.getTagName ())) {
          glyphs [gid] = simpleGlyphFromXML (e); }
        else if ("composite_glyph".equals (e.getTagName ())) {
          glyphs [gid] = compositeGlyphFromXML (e); }
        else if ("empty_glyph".equals (e.getTagName ())) {
          glyphs [gid] = new Block (0, 0); }
        glyfSize += glyphs [gid].content.length; }

      data = new byte [glyfSize];

      boolean shortLoca;

      if (font.loca == null) {
        font.loca = new Loca (font);
        font.tables.put (Tag.loca, font.loca); }

      if (glyfSize / 2 &lt; 65536) {
        shortLoca = true;
        font.head.setIndexToLocFormat (0);
        font.loca.data = new byte [(l.getLength () + 1) * 2]; }
      else {
        shortLoca = false;
        font.head.setIndexToLocFormat (1);
        font.loca.data = new byte [(l.getLength () + 1) * 4]; }

      int offset = 0;

      for (int gid = 0; gid &lt; l.getLength (); gid++) {
        Element e = (Element) l.item (gid);

        if (shortLoca) {
          font.loca.setuint16 (2 * gid, offset / 2); }
        else {
          font.loca.setuint32 (4 * gid, offset); }

        int s = glyphs [gid].content.length;
        System.arraycopy (glyphs [gid].content, 0,
                         data, offset, s);
        offset += s; }

      if (shortLoca) {
        font.loca.setuint16 (2 * l.getLength (), offset / 2); }
      else {
        font.loca.setuint32 (4 * l.getLength (), offset); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='glyf.methods'>
  <code-title>Decompilation methods</code-title>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

      int numGlyphs = font.maxp.getNumGlyphs ();

      conf.ch.startElement ("glyf");

      for (int gid = 0; gid &lt; numGlyphs; gid++) {
        AttributesImpl at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);

        if (isEmpty (gid)) {
          conf.ch.element ("empty_glyph", at);
          continue; }

        int offset = (int) font.loca.getGlyphLocation (gid);
        int nbContours = getint16 (offset);

        at.addAttribute ("", "xMin", "xMin", "CDATA", "" + getint16 (offset + 2));
        at.addAttribute ("", "yMin", "yMin", "CDATA", "" + getint16 (offset + 4));
        at.addAttribute ("", "xMax", "xMax", "CDATA", "" + getint16 (offset + 6));
        at.addAttribute ("", "yMax", "yMax", "CDATA", "" + getint16 (offset + 8));

        offset += 10;

        if (nbContours &lt; 0) {
          conf.ch.startElement ("composite_glyph", at);
          compositeGlyphToXML (conf, offset);
          conf.ch.endElement ("composite_glyph"); }

        else {
          conf.ch.startElement ("simple_glyph", at);
          simpleGlyphToXML (conf, offset, nbContours);
          conf.ch.endElement ("simple_glyph"); }}

      conf.ch.endElement ("glyf");
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Glyf'>
  <code-title>Glyf class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Glyf extends Table {

  public Glyf () {
    super (Tag.glyf);
  }

  public Glyf (Font font) {
    super (Tag.glyf, font);
  }

  <code-include linkend='glyf.methods'/>
}
</code-fragment>

<para>For a given glyph with id g, loca[g] = loca[g+1] indicates
an empty outline. Similarly loca[g] = sizeof(glyph) for the last glyph.
This function identifies those situations.</para>

<code-fragment id='glyf.methods'>
  <code-title>Empty glyf detection</code-title>
  public boolean isEmpty (int gid) {
    int offset = (int) font.loca.getGlyphLocation (gid);

    if (gid == font.maxp.getNumGlyphs ()) {
      return offset >= data.length; }
    else {
      return offset == (int) font.loca.getGlyphLocation (gid + 1); }
  }
</code-fragment>

	<para>Here is a method to return the bounding box of a glyph given the
	  offset to glyph header:</para>

<code-fragment id='glyf.methods'>
  <code-title>Glyf methods</code-title>
  public boolean isComposite (int gid) {
    if (isEmpty (gid)) {
      return false; }

    int offset = (int) font.loca.getGlyphLocation (gid);
    return getint16 (offset) &lt; 0;
  }

  public BoundingBox getGlyphBoundingBox (int gid) {
    BoundingBox b = new BoundingBox ();

    if (isEmpty (gid)) {
      return b; }

    int offset = (int)font.loca.getGlyphLocation (gid);
    b.xmin = getint16 (offset + 2);
    b.ymin = getint16 (offset + 4);
    b.xmax = getint16 (offset + 6);
    b.ymax = getint16 (offset + 8);
    return b;
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Simple Glyph Description</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>This is the table information needed if numberOfContours
          is greater than zero, that is, a glyph is not a
          composite.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>endPtsOfContours [n]</otfieldname>
            <otfielddesc>Array of last points of each contour; n is
              the number of contours.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2n</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>instructionLength</otfieldname>
            <otfielddesc>Total number of bytes for
              instructions.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2n+2</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>instructions [n]</otfieldname>
            <otfielddesc>Array of instructions for each glyph; n is
              the number of instructions.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>3n+2</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>flags [n]</otfieldname>
            <otfielddesc>Array of flags for each coordinate in
              outline; n is the number of flags.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4n+2</otfieldoffs>
            <otfieldtype>BYTE or SHORT</otfieldtype>
            <otfieldname>xCoordinates []</otfieldname>
            <otfielddesc> First coordinates relative to (0,0); others
              are relative to previous point.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>5n+2 or 6n+2</otfieldoffs>
            <otfieldtype>BYTE or SHORT</otfieldtype>
            <otfieldname>yCoordinates []</otfieldname>
            <otfielddesc>First coordinates relative to (0,0); others
              are relative to previous point.</otfielddesc>
          </otfield>
        </otformat>

        <para>Note: In the <ottable>glyf</ottable> table, the position
          of a point is not stored in absolute terms but as a vector
          relative to the previous point. The delta-x and delta-y
          vectors represent these (often small) changes in
          position.</para>
        <para>Each flag is a single byte. Their meanings are shown
          below.</para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="1cm"/>
            <colspec colwidth="10cm"/>
            <thead>
              <row>
                <entry>Flags</entry>
                <entry>Bit</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>On Curve</entry>
                <entry>0</entry>
                <entry>If set, the point is on the curve; otherwise,
                  it is off the curve.</entry>
              </row>
              <row>
                <entry>x-Short Vector</entry>
                <entry>1</entry>
                <entry>If set, the corresponding x-coordinate is 1
                  byte long. If not set, 2 bytes.</entry>
              </row>
              <row>
                <entry>y-Short Vector</entry>
                <entry>2</entry>
                <entry>If set, the corresponding y-coordinate is 1
                  byte long. If not set, 2 bytes.</entry>
              </row>
              <row>
                <entry>Repeat</entry>
                <entry>3</entry>
                <entry>If set, the next byte specifies the number of
                  additional times this set of flags is to be
                  repeated. In this way, the number of flags listed
                  can be smaller than the number of points in a
                  character.</entry>
              </row>
              <row>
                <entry>This x is same (Positive x-Short
                  Vector)</entry>
                <entry>4</entry>
                <entry>This flag has two meanings, depending on how
                  the x-Short Vector flag is set. If x-Short Vector is
                  set, this bit describes the sign of the value, with
                  1 equalling positive and 0 negative. If the x-Short
                  Vector bit is not set and this bit is set, then the
                  current x-coordinate is the same as the previous
                  x-coordinate. If the x-Short Vector bit is not set
                  and this bit is also not set, the current
                  x-coordinate is a signed 16-bit delta
                  vector.</entry>
              </row>
              <row>
                <entry>This y is same (Positive y-Short
                  Vector)</entry>
                <entry>5</entry>
                <entry>This flag has two meanings, depending on how
                  the y-Short Vector flag is set. If y-Short Vector is
                  set, this bit describes the sign of the value, with
                  1 equalling positive and 0 negative. If the y-Short
                  Vector bit is not set and this bit is set, then the
                  current y-coordinate is the same as the previous
                  y-coordinate. If the y-Short Vector bit is not set
                  and this bit is also not set, the current
                  y-coordinate is a signed 16-bit delta
                  vector.</entry>
              </row>
              <row>
                <entry>Reserved</entry>
                <entry>6</entry>
                <entry>This bit is reserved. Set it to zero.</entry>
              </row>
              <row>
                <entry>Reserved</entry>
                <entry>7</entry>
                <entry>This bit is reserved. Set it to zero.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Relax Schema for glyf table</code-title>
simple_glyph =
  element simple_glyph {
    glyph_attributes,
    element contour {
      element point {
        attribute on_curve { yesOrNo },
        attribute x { text },
        attribute y { text } }+ } +,

    element instructions {
      attribute opcodes { text }} ?
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='glyf.methods'>
  public Block simpleGlyphFromXML (Element e) {

    NodeList contours = e.getChildNodes ();
    int nbContours = contours.getLength ();

    Element instructionsElt = (Element) contours.item (nbContours - 1);
    Block instructions;

    if ("instructions".equals (instructionsElt.getTagName())) {
      nbContours--;
      int opcodes [] = parseIntList (instructionsElt.getAttribute ("opcodes"));
      instructions = new Block (opcodes.length, 0);
      for (int i = 0; i &lt; opcodes.length; i++) {
        instructions.setuint8 (i, opcodes [i]); }}
    else {
      instructions = new Block (0, 0); }

    int nbTotalPoints = 0;
    for (int c = 0; c &lt; nbContours; c++) {
       Element contour = (Element) contours.item (c);
       NodeList points = (NodeList) contour.getChildNodes ();
       nbTotalPoints += points.getLength (); }

    int endPts []  = new int [nbContours];

    // pessimistic allocation
    Block flags = new Block (nbTotalPoints, 0);
    int flagsOffset = 0;
    Block x = new Block (nbTotalPoints * 2, 0);
    int xOffset = 0;
    Block y = new Block (nbTotalPoints * 2, 0);
    int yOffset = 0;


    int currentPoint = 0;
    int currentX = 0;
    int currentY = 0;

    int lastFlags = 0;
    boolean lastFlagsRepeat = false;
    int lastFlagsCount = 0;

    for (int c = 0; c &lt; nbContours; c++) {
       Element contour = (Element) contours.item (c);

       NodeList points = (NodeList) contour.getChildNodes ();
       int nbPoints = points.getLength ();

       for (int p = 0; p &lt; nbPoints; p++) {
         Element point = (Element) points.item (p);
         int thisX = Integer.parseInt (point.getAttribute ("x"));
         int thisY = Integer.parseInt (point.getAttribute ("y"));

         int thisFlags = 0;

         if ("yes".equals (point.getAttribute ("on_curve"))) {
           thisFlags |= ON_CURVE_POINT; }

         int delta_x = thisX - currentX;
         if (delta_x == 0) {
           thisFlags |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR; }
         else if (-255 &lt;= delta_x &amp;&amp; delta_x &lt;= 255) {
           thisFlags |= X_SHORT_VECTOR;
           if (0 &lt; delta_x) {
             thisFlags |= X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR; }
           else {
             delta_x = - delta_x; }
           x.setuint8 (xOffset, delta_x);
           xOffset += 1; }
         else {
           x.setint16 (xOffset, delta_x);
           xOffset += 2; }

         currentX = thisX;

         int delta_y = thisY - currentY;
         if (delta_y == 0) {
           thisFlags |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR; }
         else if (-255 &lt;= delta_y &amp;&amp; delta_y &lt;= 255) {
           thisFlags |= Y_SHORT_VECTOR;
           if (0 &lt; delta_y) {
             thisFlags |= Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR; }
           else {
             delta_y = - delta_y; }
           y.setuint8 (yOffset, delta_y);
           yOffset += 1; }
         else {
           y.setint16 (yOffset, delta_y);
           yOffset += 2; }

         currentY = thisY;

         if (0 &lt; flagsOffset  &amp;&amp; thisFlags == lastFlags) {
           if (lastFlagsRepeat) {
             if (lastFlagsCount &lt; 255) {
               lastFlagsCount++;
               flags.setuint8 (flagsOffset - 1, lastFlagsCount); }
             else {
               flags.setuint8 (flagsOffset, thisFlags);
               flagsOffset += 1;
               lastFlagsRepeat = false;
               lastFlagsCount = 0; }}
           else {
             flags.setuint8 (flagsOffset - 1, lastFlags | REPEAT_FLAG);
             flags.setuint8 (flagsOffset, 1);
             flagsOffset += 1;
             lastFlagsRepeat = true;
             lastFlagsCount = 1; }}
         else {
           flags.setuint8 (flagsOffset, thisFlags);
           flagsOffset += 1;
           lastFlagsRepeat = false;
           lastFlagsCount = 0; }

         lastFlags = thisFlags; }

      endPts [c] = ((c == 0) ? -1 : endPts [c - 1]) + nbPoints; }


    int totalSize = 10
                     + endPts.length * 2
                     + 2 + instructions.content.length
                     + flagsOffset + xOffset + yOffset;

    if (totalSize % 2 == 1) {
      totalSize++; }

    Block result = new Block (totalSize, 0);
    int b = 0;

    result.setuint16 (b, nbContours); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("xMin"))); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("yMin"))); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("xMax"))); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("yMax"))); b += 2;

    for (int c = 0; c &lt; nbContours; c++) {
      result.setuint16 (b, endPts [c]); b += 2; }

    if (instructions == null) {
      result.setuint16 (b, 0); b += 2; }
    else {
      result.setuint16 (b, instructions.content.length); b += 2;
      System.arraycopy (instructions.content, 0,
                        result.content, b,
                        instructions.content.length);
      b += instructions.content.length; }

    System.arraycopy (flags.content, 0, result.content, b, flagsOffset);
    b += flagsOffset;

    System.arraycopy (x.content, 0, result.content, b, xOffset);
    b += xOffset;

    System.arraycopy (y.content, 0, result.content, b, yOffset);
    b += yOffset;

    return result;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='glyf.methods'>
  <code-title>Decompiler for simple glyphs</code-title>

  public void simpleGlyphToXML (DecompilerConfig conf,
                                int offset,
                                int nbContours)
      throws org.xml.sax.SAXException, InvalidFontException {

      SimpleGlyphUnpack u = unpackSimpleGlyphContours (offset, nbContours);

      offset += 2 * nbContours;  // skip to the instructions

      int numInstr = getuint16 (offset); offset += 2;
      String opcodes = "";
      String prefix = "";
      for (int i = 0; i &lt; numInstr; i++) {
        opcodes += prefix + "0x" + Integer.toHexString (getuint8 (offset));
        offset += 1;
        prefix = " "; }

      int pt = 0;
      for (int c = 0; c &lt; nbContours; c++) {
        conf.ch.startElement ("contour");

        while (pt &lt;= u.endPts [c]) {

          AttributesImpl at = new AttributesImpl ();
          at.addAttribute ("", "on_curve", "on_curve", "CDATA",
                           u.on [pt] ? "yes" : "no");
          at.addAttribute ("", "x", "x", "CDATA", Integer.toString (u.x [pt]));
          at.addAttribute ("", "y", "y", "CDATA", Integer.toString (u.y [pt]));

          conf.ch.element ("point", at);
          pt++; }

        conf.ch.endElement ("contour"); }

      if (numInstr != 0) {
        AttributesImpl at = new AttributesImpl ();
        at.addAttribute ("", "opcodes", "opcodes", "CDATA", opcodes);
        conf.ch.element ("instructions", at); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='glyf.methods'>
  <code-title>Glyf methods</code-title>
  public static final int ON_CURVE_POINT                       = 0x0001;
  public static final int X_SHORT_VECTOR                       = 0x0002;
  public static final int Y_SHORT_VECTOR                       = 0x0004;
  public static final int REPEAT_FLAG                          = 0x0008;
  public static final int X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR = 0x0010;
  public static final int Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR = 0x0020;
</code-fragment>


<para>This method unpacks the fields of a simple glyph, so that we have the list of coordinates readily available.</para>


<code-fragment id='glyf.methods'>

  public class SimpleGlyphUnpack {
    int offset;
    int endPts [];
    int nbPts;
    int x[];
    int y[];
    boolean on[];
  }

  public SimpleGlyphUnpack unpackSimpleGlyphContours (int offset,
                                                      int nbContours) {

    SimpleGlyphUnpack u = new SimpleGlyphUnpack ();

    u.endPts = new int [nbContours];
    for (int i = 0; i &lt; nbContours; i++) {
      u.endPts [i] = getuint16 (offset); offset += 2; }

    offset += 2 + getuint16 (offset);  // instructionLength

    u.nbPts = u.endPts [nbContours - 1] + 1;
    u.x = new int [u.nbPts];
    u.y = new int [u.nbPts];
    u.on = new boolean [u.nbPts];

    int flags[] = new int [u.nbPts];
    int repeat = 0;
    int f = 0;

    for (int i = 0; i &lt; u.nbPts; i++) {
      if (repeat == 0) {
        f = getuint8 (offset); offset++;
        repeat = 0;
        if ((f &amp; REPEAT_FLAG) != 0) {
          repeat = getuint8 (offset); offset++; }}
      else {
        repeat--; }
      flags [i] = f;
      u.on [i] = ((f &amp; ON_CURVE_POINT) != 0);  }

    int current_x = 0;

    for (int i = 0; i &lt; u.nbPts; i++) {
      if ((flags [i] &amp; X_SHORT_VECTOR) != 0) {
        int xOffset = getuint8 (offset); offset += 1;
        if ((flags [i] &amp; X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) == 0) {
          xOffset = - xOffset; }
        current_x += xOffset; }

      else if ((flags [i] &amp; X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR) != 0) {
        /* same */ }

      else {
        current_x += getint16 (offset); offset += 2; }

      u.x [i] = current_x; }

    int current_y = 0;

    for (int i = 0; i &lt; u.nbPts; i++) {
      if ((flags [i] &amp; Y_SHORT_VECTOR) != 0) {
        int yOffset = getuint8 (offset); offset += 1;
        if ((flags [i] &amp; Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) == 0) {
          yOffset = - yOffset; }
        current_y += yOffset; }

      else if ((flags [i] &amp; Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR) != 0) {
        /* same */ }

      else {
        current_y += getint16 (offset); offset += 2; }

      u.y [i] = current_y; }

    return u;
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Composite Glyph Description</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This is the table information needed for composite
          glyphs (numberOfContours is -1). A composite glyph starts
          with two USHORT values ("flags" and "glyphIndex," i.e. the
          index of the first contour in this composite glyph); the
          data then varies according to "flags").</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>flags</otfieldname>
            <otfielddesc>component flag</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>glyphIndex</otfieldname>
            <otfielddesc>glyph index of component</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>argument1</otfieldname>
            <otfielddesc>x-offset for component or point number; type
              depends on bits 0 and 1 in component flags</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>argument2</otfieldname>
            <otfielddesc>y-offset for component or point number; type
              depends on bits 0 and 1 in component flags</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>Transformation Option</otfieldtype>
            <otfieldname></otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
        </otformat>

        <para>The C pseudo-code fragment below shows how the composite
          glyph information is stored and parsed; definitions for
          "flags" bits follow this fragment:</para>


<literallayout>
<![CDATA[
do {
        USHORT flags;
        USHORT glyphIndex;
        if ( flags & ARG_1_AND_2_ARE_WORDS) {
        (SHORT or FWord) argument1;
        (SHORT or FWord) argument2;
        } else {
                USHORT arg1and2; /* (arg1 << 8) | arg2 */
        }
        if ( flags & WE_HAVE_A_SCALE ) {
                F2Dot14  scale;    /* Format 2.14 */
        } else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) {
                F2Dot14  xscale;    /* Format 2.14 */
                F2Dot14  yscale;    /* Format 2.14 */
        } else if ( flags & WE_HAVE_A_TWO_BY_TWO ) {
                F2Dot14  xscale;    /* Format 2.14 */
                F2Dot14  scale01;   /* Format 2.14 */
                F2Dot14  scale10;   /* Format 2.14 */
                F2Dot14  yscale;    /* Format 2.14 */
        }
} while ( flags & MORE_COMPONENTS )
if (flags & WE_HAVE_INSTR){
        USHORT numInstr
        BYTE instr[numInstr]
]]>
</literallayout>

        <para>Argument1 and argument2 can be either x and y offsets to
          be added to the glyph or two point numbers. In the latter
          case, the first point number indicates the point that is to
          be matched to the new glyph. The second number indicates the
          new glyph's "matched" point. Once a glyph is added, its
          point numbers begin directly after the last glyphs (endpoint
          of first glyph + 1).</para>
        <para>When arguments 1 and 2 are an x and a y offset instead
          of points and the bit ROUND_XY_TO_GRID is set to 1, the
          values are rounded to those of the closest grid lines before
          they are added to the glyph. X and Y offsets are described
          in FUnits.</para>
        <para>If the bit WE_HAVE_A_SCALE is set, the scale value is
          read in 2.14 format-the value can be between -2 to almost
          +2. The glyph will be scaled by this value before
          grid-fitting.</para>
        <para>The bit WE_HAVE_A_TWO_BY_TWO allows for an
          interrelationship between the x and y coordinates. This
          could be used for 90-degree rotations, for example.</para>
        <para>These are the constants for the flags field:</para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="13pc"/>
            <colspec colwidth="2pc"/>
            <colspec colwidth="15pc"/>
            <thead>
              <row>
                <entry>Flags</entry>
                <entry>Bit</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>ARG_1_AND_2_ARE_WORDS</entry>
                <entry>0</entry>
                <entry>If this is set, the arguments are words;
                  otherwise, they are bytes.</entry>
              </row>
              <row>
                <entry>ARGS_ARE_XY_VALUES</entry>
                <entry>1</entry>
                <entry>If this is set, the arguments are xy values;
                  otherwise, they are points.</entry>
              </row>
              <row>
                <entry>ROUND_XY_TO_GRID</entry>
                <entry>2</entry>
                <entry>For the xy values if the preceding is
                  true.</entry>
              </row>
              <row>
                <entry>WE_HAVE_A_SCALE</entry>
                <entry>3</entry>
                <entry>This indicates that there is a simple scale for
                  the component. Otherwise, scale = 1.0.</entry>
              </row>
              <row>
                <entry>RESERVED</entry>
                <entry>4</entry>
                <entry>This bit is reserved. Set it to 0.</entry>
              </row>
              <row>
                <entry>MORE_COMPONENTS</entry>
                <entry>5</entry>
                <entry>Indicates at least one more glyph after this
                  one.</entry>
              </row>
              <row>
                <entry>WE_HAVE_AN_X_AND_Y_SCALE</entry>
                <entry>6</entry>
                <entry>The x direction will use a different scale from
                  the y direction.</entry>
              </row>
              <row>
                <entry>WE_HAVE_A_TWO_BY_TWO</entry>
                <entry>7</entry>
                <entry>There is a 2 by 2 transformation that will be
                  used to scale the component.</entry>
              </row>
              <row>
                <entry>WE_HAVE_INSTRUCTIONS</entry>
                <entry>8</entry>
                <entry>Following the last component are instructions
                  for the composite character.</entry>
              </row>
              <row>
                <entry>USE_MY_METRICS</entry>
                <entry>9</entry>
                <entry>If set, this forces the aw and lsb (and rsb)
                  for the composite to be equal to those from this
                  original glyph. This works for hinted and unhinted
                  characters.</entry>
              </row>
              <row>
                <entry>OVERLAP_COMPOUND</entry>
                <entry>10</entry>
                <entry>Used by Apple in GX fonts.</entry>
              </row>
              <row>
                <entry>SCALED_COMPONENT_OFFSET</entry>
                <entry>11</entry>
                <entry>Composite designed to have the component offset
                  scaled (designed for Apple rasterizer).</entry>
              </row>
              <row>
                <entry>UNSCALED_COMPONENT_OFFSET</entry>
                <entry>12</entry>
                <entry>Composite designed not to have the component
                  offset scaled (designed for the Microsoft TrueType
                  rasterizer).</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The purpose of USE_MY_METRICS is to force the lsb and
          rsb to take on a desired value. For example, an i-circumflex
          (U+00EF) is often composed of the circumflex and a
          dotless-i. In order to force the composite to have the same
          metrics as the dotless-i, set USE_MY_METRICS for the
          dotless-i component of the composite. Without this bit, the
          rsb and lsb would be calculated from the hmtx entry for the
          composite (or would need to be explicitly set with TrueType
          instructions).</para>
        <para>Note that the behavior of the USE_MY_METRICS operation
          is undefined for rotated composite components.</para>

      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Relax Schema for glyf table</code-title>
composite_glyph =
  element composite_glyph {
    glyph_attributes,
    element component {
      attribute flags { text },
      attribute gid { text },
      attribute arg1 { text },
      attribute arg2 { text },
      component_scale? } +,

    element instructions {
      attribute opcodes { text }} ?
  }

component_scale |=
   attribute scale { text ? }

component_scale |=
   attribute xscale { text ? },
   attribute yscale { text ? }

component_scale |=
   attribute xscale { text ? },
   attribute scale01 { text ? },
   attribute scale10 { text ? },
   attribute yscale { text ? }

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='glyf.methods'>
  public Block compositeGlyphFromXML (Element e) {

    NodeList components = e.getChildNodes ();
    int nbComponents = components.getLength ();

    Element instructionsElt = (Element) components.item (nbComponents - 1);
    Block instructions;

    if ("instructions".equals (instructionsElt.getTagName())) {
      nbComponents--;
      int opcodes [] = parseIntList (instructionsElt.getAttribute ("opcodes"));
      instructions = new Block (opcodes.length, 0);
      for (int i = 0; i &lt; opcodes.length; i++) {
        instructions.setuint8 (i, opcodes [i]); }}
    else {
      instructions = new Block (0, 0); }

    // pessimistic allocation
    Block data = new Block (10 + nbComponents * (4 + 4 + 8), 0);
    int dataOffset = 0;

    for (int c = 0; c &lt; nbComponents; c++) {
      Element component = (Element) components.item (c);

      int flags = Integer.decode (component.getAttribute ("flags"));
      int gid = Integer.decode (component.getAttribute ("gid"));
      int arg1 = Integer.decode (component.getAttribute ("arg1"));
      int arg2 = Integer.decode (component.getAttribute ("arg2"));

      int xscale = 1 &lt;&lt; 14;
      int scale01 = 0;
      int scale10 = 0;
      int yscale = 1 &lt;&lt; 14;

      if (component.getAttribute ("scale") != null
          &amp;&amp; ! "".equals (component.getAttribute ("scale"))) {
        xscale = Integer.parseInt (component.getAttribute ("scale"));
        yscale = xscale; }

      if (component.getAttribute ("xscale") != null
          &amp;&amp; ! "".equals (component.getAttribute ("xscale"))) {
        xscale = Integer.parseInt (component.getAttribute ("xscale")); }

      if (component.getAttribute ("scale01") != null
          &amp;&amp; ! "".equals (component.getAttribute ("scale01"))) {
        scale01 = Integer.parseInt (component.getAttribute ("scale01")); }

      if (component.getAttribute ("scale10") != null
          &amp;&amp; ! "".equals (component.getAttribute ("scale10"))) {
        scale10 = Integer.parseInt (component.getAttribute ("scale10")); }

      if (component.getAttribute ("yscale") != null
          &amp;&amp; ! "".equals (component.getAttribute ("yscale"))) {
        yscale = Integer.parseInt (component.getAttribute ("yscale")); }


      int flagsOffset = dataOffset;
      dataOffset += 2;

      data.setuint16 (dataOffset, gid); dataOffset += 2;

      // retain only those bits from our input, we will
      // set the others as needed
      flags &amp;= ARGS_ARE_XY_VALUES
            | ROUND_XY_TO_GRID
            | USE_MY_METRICS
            | OVERLAP_COMPOUND
            | SCALED_COMPONENT_OFFSET
            | UNSCALED_COMPONENT_OFFSET;

      if ((flags &amp; ARGS_ARE_XY_VALUES) != 0) {
        if (arg1 &lt; -128 || 127 &lt; arg1 || arg2 &lt; -128 || 127 &lt; arg2 ) {
          flags |= ARG_1_AND_2_ARE_WORDS;
          data.setint16 (dataOffset, arg1); dataOffset += 2;
          data.setint16 (dataOffset, arg2); dataOffset += 2; }
        else {
          data.setint8 (dataOffset, arg1); dataOffset += 1;
          data.setint8 (dataOffset, arg2); dataOffset += 1; }}
      else {
        if (256 &lt; arg1 || 256 &lt; arg2) {
          flags |= ARG_1_AND_2_ARE_WORDS;
          data.setuint16 (dataOffset, arg1); dataOffset += 2;
          data.setuint16 (dataOffset, arg2); dataOffset += 2; }
        else {
          data.setuint8 (dataOffset, arg1); dataOffset += 1;
          data.setuint8 (dataOffset, arg2); dataOffset += 1; }}

      if (scale01 != 0 || scale10 != 0) {
        flags |= WE_HAVE_A_TWO_BY_TWO;
        data.setuint16 (dataOffset, xscale); dataOffset += 2;
        data.setuint16 (dataOffset, scale01); dataOffset += 2;
        data.setuint16 (dataOffset, scale10); dataOffset += 2;
        data.setuint16 (dataOffset, yscale); dataOffset += 2; }

      else if (xscale != yscale) {
        flags |= WE_HAVE_AN_X_AND_Y_SCALE;
        data.setuint16 (dataOffset, xscale); dataOffset += 2;
        data.setuint16 (dataOffset, yscale); dataOffset += 2; }

      else if (xscale != 1 &lt;&lt;14) {
        flags |= WE_HAVE_A_SCALE;
        data.setuint16 (dataOffset, xscale); dataOffset += 2; }

      if (c &lt; nbComponents - 1) {
        flags |= MORE_COMPONENTS; }

      if (instructions.content.length > 0) {
        flags |= WE_HAVE_INSTRUCTIONS; }

      data.setuint16 (flagsOffset, flags); }

    int totalSize = 10 + dataOffset;
    if (instructions.content.length > 0) {
      totalSize += 2 + instructions.content.length; }

    if (totalSize % 2 == 1) {
      totalSize++; }

    Block result = new Block (totalSize, 0);
    int b = 0;

    result.setint16 (b, -1); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("xMin"))); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("yMin"))); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("xMax"))); b += 2;
    result.setint16 (b, Integer.parseInt (e.getAttribute ("yMax"))); b += 2;

    for (int i = 0; i &lt; dataOffset; i++) {
      result.setuint8 (b, data.content [i]); b++; }

    if (instructions.content.length > 0) {
      result.setuint16 (b, instructions.content.length); b += 2;

      System.arraycopy (instructions.content, 0,
                        result.content, b,
                        instructions.content.length);

      b += instructions.content.length; }

    return result;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='glyf.methods'>
  public void compositeGlyphToXML (DecompilerConfig conf, int offset)
      throws org.xml.sax.SAXException, InvalidFontException {

      boolean we_have_instructions = false;

      while (true) {
        AttributesImpl at = new AttributesImpl ();

        int flags = getuint16 (offset);
        at.addAttribute ("", "flags", "flags", "CDATA",
                         "0x" + Integer.toHexString (flags &amp; 0x1e06));
        offset += 2;

        we_have_instructions |= ((flags &amp; WE_HAVE_INSTRUCTIONS) != 0);

        int gid = getGlyphID (offset);
        at.addAttribute ("", "gid", "gid", "CDATA",
                         Integer.toString (gid));
        offset += 2;

        int arg1, arg2;
        if ((flags &amp; ARG_1_AND_2_ARE_WORDS) != 0) {
          if ((flags &amp; ARGS_ARE_XY_VALUES) != 0) {
            arg1 = getint16 (offset); offset += 2;
            arg2 = getint16 (offset); offset += 2; }
          else {
            arg1 = getuint16 (offset); offset += 2;
            arg2 = getuint16 (offset); offset += 2; }}
        else {
          if ((flags &amp; ARGS_ARE_XY_VALUES) != 0) {
            arg1 = getint8 (offset); offset += 1;
            arg2 = getint8 (offset); offset += 1; }
          else {
            arg1 = getuint8 (offset); offset += 1;
            arg2 = getuint8 (offset); offset += 1; }}

        at.addAttribute ("", "arg1", "arg1", "CDATA",
                         Integer.toString (arg1));
        at.addAttribute ("", "arg2", "arg2", "CDATA",
                         Integer.toString (arg2));

        if ((flags &amp; WE_HAVE_A_SCALE) != 0) {
          int scale = getFWord (offset); offset += 2;
          at.addAttribute ("", "scale", "scale", "CDATA",
                           Integer.toString (scale)); }

        else if ((flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) != 0) {
          int xscale = getFWord (offset); offset += 2;
          int yscale = getFWord (offset); offset += 2;
          at.addAttribute ("", "xscale", "xscale", "CDATA",
                           Integer.toString (xscale));
          at.addAttribute ("", "yscale", "yscale", "CDATA",
                           Integer.toString (yscale)); }


        else if ((flags &amp; WE_HAVE_A_TWO_BY_TWO) != 0) {
          int xscale = getFWord (offset); offset += 2;
          int scale01 = getFWord (offset); offset += 2;
          int scale10 = getFWord (offset); offset += 2;
          int yscale = getFWord (offset); offset += 2;

          at.addAttribute ("", "xscale", "xscale", "CDATA",
                           Integer.toString (xscale));
          at.addAttribute ("", "scale01", "scale01", "CDATA",
                           Integer.toString (scale01));
          at.addAttribute ("", "scale10", "scale10", "CDATA",
                           Integer.toString (scale10));
          at.addAttribute ("", "yscale", "yscale", "CDATA",
                           Integer.toString (yscale)); }

        conf.ch.element ("component", at);

        if ((flags &amp; MORE_COMPONENTS) == 0) {
          break; }}

      if (we_have_instructions) {
        int numInstr = getuint16 (offset); offset += 2;
        String opcodes = "";
        String prefix = "";
        for (int i = 0; i &lt; numInstr; i++) {
          opcodes += prefix + "0x" + Integer.toString (getuint8 (offset));
          offset += 1;
          prefix = " "; }

        AttributesImpl at = new AttributesImpl ();
        at.addAttribute ("", "opcodes", "opcodes", "CDATA",
                         opcodes);

        conf.ch.element ("instructions", at); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='glyf.methods'>
  <code-title>Glyf methods</code-title>
  public static final int ARG_1_AND_2_ARE_WORDS      = 0x0001;
  public static final int ARGS_ARE_XY_VALUES         = 0x0002;
  public static final int ROUND_XY_TO_GRID           = 0x0004;
  public static final int WE_HAVE_A_SCALE            = 0x0008;
  public static final int MORE_COMPONENTS            = 0x0020;
  public static final int WE_HAVE_AN_X_AND_Y_SCALE   = 0x0040;
  public static final int WE_HAVE_A_TWO_BY_TWO       = 0x0080;
  public static final int WE_HAVE_INSTRUCTIONS       = 0x0100;
  public static final int USE_MY_METRICS             = 0x0200;
  public static final int OVERLAP_COMPOUND           = 0x0400;
  public static final int SCALED_COMPONENT_OFFSET    = 0x0800;
  public static final int UNSCALED_COMPONENT_OFFSET  = 0x1000;


  static public class MaxpValues {
    int numPoints;
    int numCompositePoints;
    int numContours;
    int numCompositeContours;
    int numComponentElements;
    int componentDepth;
  };

  public MaxpValues getMaxpValues (int gid) {
    MaxpValues maxpValues = new MaxpValues ();
    maxpValues.numComponentElements = 0;
    maxpValues.numPoints = 0;
    maxpValues.numCompositePoints = 0;
    maxpValues.numContours = 0;
    maxpValues.numCompositeContours = 0;

    int offset = (int) font.loca.getGlyphLocation (gid);

    if (getint16 (offset) >= 0) {
      maxpValues.componentDepth = 0;
      maxpValues.numContours = getuint16 (offset);
      maxpValues.numPoints = getuint16 (offset + 10 + (maxpValues.numContours-1) * 2) + 1;

      maxpValues.numCompositeContours = maxpValues.numContours;
      maxpValues.numCompositePoints = maxpValues.numPoints; }

    else {
      maxpValues.componentDepth = 0;

      offset += 10;

      while (true) {
        int flags = getuint16 (offset);
        MaxpValues maxpValues2 = getMaxpValues (getuint16 (offset + 2));

        maxpValues.numCompositePoints += maxpValues2.numCompositePoints;
        maxpValues.numCompositeContours += maxpValues2.numCompositeContours;

        maxpValues.componentDepth = Math.max (maxpValues.componentDepth,
                                       1 + maxpValues2.componentDepth);

        maxpValues.numComponentElements += 1;

        offset += 4;
        if ((flags &amp; ARG_1_AND_2_ARE_WORDS) != 0) {
          offset += 4; }
        else {
          offset += 2; }

        if ((flags &amp; WE_HAVE_A_SCALE) != 0) {
          offset += 2; }
        else if ((flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) != 0) {
          offset += 4; }
        else if ((flags &amp; WE_HAVE_A_TWO_BY_TWO) != 0) {
          offset += 8; }

        if ((flags &amp; MORE_COMPONENTS) == 0) {
          break; }}}

    return maxpValues;
  }
</code-fragment>
      </section>

    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.loca'>
    <title>loca - Index to Location</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The indexToLoc table stores the offsets to the locations
          of the glyphs in the font, relative to the beginning of the
          glyphData table. In order to compute the length of the last
          glyph element, there is an extra entry after the last valid
          index.</para>
        <para>By definition, index zero points to the "missing
          character," which is the character that appears if a
          character is not found in the font. The missing character is
          commonly represented by a blank box (such as ) or a space.
          If the font does not contain an outline for the missing
          character, then the first and second offsets should have the
          same value. This also applies to any other character without
          an outline, such as the space character.</para>
        <para>Most routines will look at the <ottable>maxp</ottable>
          table to determine the number of glyphs in the font, but the
          value in the <ottable>loca</ottable> table should
          agree.</para>
        <para>There are two versions of this table, the short and the
          long. The version is specified in the indexToLocFormat entry
          in the <ottable>head</ottable> table.</para>

        <bridgehead>Short version</bridgehead>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>offsets [n]</otfieldname>
            <otfielddesc>The actual local offset divided by 2 is
              stored. The value of n is numGlyphs + 1. The value for
              numGlyphs is found in the <ottable>maxp</ottable>
              table.</otfielddesc>
          </otfield>
        </otformat>

        <bridgehead>Long version</bridgehead>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>offsets [n]</otfieldname>
            <otfielddesc>The actual local offset is stored. The value
              of n is numGlyphs + 1. The value for numGlyphs is found
              in the <ottable>maxp</ottable> table.</otfielddesc>
          </otfield>
        </otformat>

        <para>Note that the local offsets should be long-aligned,
          i.e., multiples of 4. Offsets which are not long-aligned may
          seriously degrade performance of some processors.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>We assume that 'indexToLoc' should be replaced by 'loca'
	  and 'glyphData' should be replaced by 'glyph'.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='loca.methods'>
  public void fromXML (Element cmap)
      throws InvalidFontException, UnsupportedFontException {

      //TODO
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='loca.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

      //TODO
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Loca'>
  <code-title>Loca class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Loca extends Table {

  public Loca () {
    super (Tag.loca);
  }

  public Loca (Font font) {
    super (Tag.loca, font);
  }

  <code-include linkend='loca.methods'/>
}
</code-fragment>

	<para>Here is a method to return the location of a glyph.</para>

<code-fragment id='loca.methods'>
  <code-title>Loca methods</code-title>
  public long getGlyphLocation (int gid) {

    if (font.head.getIndexToLocFormat () == 0) {
      return getuint16 (gid * 2) * 2; }
    else {
      return getuint32 (gid * 4); }
  }

  public void setGlyphLocation (int gid, int offset) {
    if (font.head.getIndexToLocFormat () == 0) {
      setuint16 (gid * 2, offset / 2); }
    else {
      setuint32 (gid * 4, offset); }
  }
</code-fragment>
      </section>

    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.prep'>
    <title>prep - Control Value Program </title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Control Value Program consists of a set of TrueType
          instructions that will be executed whenever the font or
          point size or transformation matrix change and before each
          glyph is interpreted. Any instruction is legal in the CVT
          Program but since no glyph is associated with it,
          instructions intended to move points within a particular
          glyph outline cannot be used in the CVT Program. The name
          <ottable>prep</ottable> is anachronistic.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>BYTE [n]</otfieldtype>
            <otfieldname></otfieldname>
            <otfielddesc>Set of instructions executed whenever point
	      size or font or transformation change. n is the number
	      of BYTE items that fit in the size of the table.</otfielddesc>
          </otfield>
        </otformat>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.CFF'>
    <title>CFF - PostScript font program (Compact Font Format)
      table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table contains a compact representation of a
          PostScript Type 1, or CIDFont and is structured according to
          Adobe Technical Note #5176: <ulink
            url="http://partners.adobe.com/asn/developer/pdfs/tn/5176.CFF.pdf">The
            Compact Font Format Specification</ulink> and Adobe
          Technical Note #5177: <ulink
            url="http://partners.adobe.com/asn/developer/pdfs/tn/5177.Type2.pdf">The
            Type 2 Charstring Format</ulink>.</para>

        <para>Existing TrueType fonts use a glyph index to specify and
          access glyphs within a font, e.g. to index the loca table
          and thereby access glyph data in the glyf table. This
          concept is retained in OpenType PostScript fonts except
          that glyph data is accessed through the CharStrings INDEX of
          the <ottable>CFF</ottable> table.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The CFF specification was developed independantly of the
          OpenType specification and is also meant to be used in other
          contexts. Because of that, some CFF FontSets are not legal
          CFF tables. These restrictions should be part of the
          OpenType specification and are mentioned here:</para>

        <para>It is unclear whether the deletion mechanism of CFF
          FontSets (by setting the first byte of a font name to 0) is
          allowed.  Given the intended use, it is not clear that such
          a mechanism is useful in OpenType fonts, and we assume that
          it is not allowed.</para>

        <para>It is unclear which font in a CFF FontSet should be used
          in the context of an OpenType font. One possibility is to
          impose that the CFF FontSet contain only one font, with the
          side effect of ruling out synthetic fonts. Another
          possibility is to use the first font in the FontSet. Yet
          another possibility is to use the font whose name matches
          some entry in the <ottable>name</ottable> table. We assume
          that the first possibility is actually the desired one.</para>

        <para>It is not clear whether the name stored in the Name INDEX
          must be equal to some entry in the OpenType
          <ottable>name</ottable> table.</para>

        <para>While the Top DICT must define (explicitly or
          implicitly) an Encoding, this Encoding is never used. Thus
          the best is to not include an Encoding entry in the Top DICT
          and to get the default Standard Encoding, regardless of the
          font content.</para>

        <para>Since Multiple Master technology is not part of
          OpenType, the Top DICT must not contain the operators
          BaseFontName and BaseFontBlend.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

        <para>Pretty simple:</para>

<code-fragment id='schema'>
  <code-title>CFF</code-title>
  CFF =
    element CFF { grammar { include "cfffontset.rnc" } }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='cff.methods'>
  public void fromXML (org.w3c.dom.Element cff)
      throws InvalidFontException, UnsupportedFontException {
    fontset = new CFFFontSet ();
    fontset.fromXML ((org.w3c.dom.Element) (cff.getChildNodes ().item (0)));
    dataIsRight = false;
    fontsetIsRight = true;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='cff.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {}

    conf.ch.startElement ("CFF"); {
      fontset.toXML (conf.ch);
      conf.ch.endElement ("CFF"); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Of course, we have a class to represent a CFF Table
          structure:</para>

<code-fragment package='com.adobe.aots.opentype' class='CFF'>
  <code-title>CFF class</code-title>
  package com.adobe.aots.opentype;

  import com.adobe.aots.util.ContentHandlerPlus;

  public class CFF extends Table {
    <code-include linkend='cff.members'/>
    <code-include linkend='cff.methods'/>

    public CFF () {
      super (Tag.CFF, null);
    }

    public CFF (Font font) {
      super (Tag.CFF, font);
    }
  }
</code-fragment>

        <para>A CFF table is really a container for a CFF FontSet.</para>

<code-fragment id='cff.members'>
  <code-title>CFF members</code-title>
  protected boolean dataIsRight = false;
  protected boolean fontsetIsRight = false;

  protected CFFFontSet fontset;
</code-fragment>

        <para>This CFF FontSet must contain a single CFF Font.
          Consequently, many of the operations on a CFF tables are
          delegated to the first font of the CFF FontSet:</para>

<code-fragment id='cff.methods'>
  public void makeFontsetRight ()
      throws InvalidFontException {
    if (! fontsetIsRight) {
      fontset = new CFFFontSet ();
      fontset.fromBinary (data);
      fontsetIsRight = true; }
  }

  private void makeDataRight () {
    if (! dataIsRight) {
      data = fontset.toBinary (); }
  }

  public String getGlyphName (int gid) {
    try {
      makeFontsetRight ();  }
    catch (InvalidFontException e) {
      return "??"; }
    return fontset.getGlyphName (0, gid);
  }

  public String[] getGlyphName (int[] gids) {
    String[] names = new String [gids.length];
    for (int i = 0; i &lt; gids.length; i++) {
      names [i] = getGlyphName (gids [i]); }
    return names;
  }

  public String[] getGlyphNames () {
    String[] names = new String [font.maxp.getNumGlyphs ()];
    for (int i = 0; i &lt; names.length; i++) {
      names [i] = getGlyphName (i); }
    return names;
  }

  public int getGlyphID (String glyphname)
      throws InvalidFontException {
    makeFontsetRight ();
    return fontset.getGlyphID (0, glyphname);
  }

  public void getGlyphOutline (int gid, StringBuilder sb) {
    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {
      System.err.println ("??"); }
    fontset.getGlyphOutline (0, gid, sb);
  }

  public void getGlyphLinesAndCurves (int gid, StringBuilder sb) {
    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {
      System.err.println ("??"); }
    fontset.getGlyphLinesAndCurves (0, gid, sb);
  }

  public BoundingBox getGlyphBoundingBox (int gid) {
    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {
      System.err.println ("??"); }
    return fontset.getGlyphBoundingBox (0, gid);
  }

  public String getPostScriptName ()
      throws InvalidFontException {
    makeFontsetRight ();
    return fontset.getName (0);
  }

  public boolean isNameKeyed ()
      throws InvalidFontException {
    makeFontsetRight ();
    return fontset.isNameKeyed (0);
  }
</code-fragment>

        <para>Our <varname>CFFFontSet</varname> class does not see our
          <varname>data</varname> and in fact requires that the binary
          data be processed before other methods can be invoked. More
          details can be found in the Annotated CFF
          specification.</para>

<code-fragment id='cff.methods'>
  <code-title>Loading/Unloading a CFF</code-title>
  public int fromBinary (java.io.InputStream in, int length)
      throws java.io.IOException, InvalidFontException {
    super.fromBinary (in, length);
    dataIsRight = true;
    fontsetIsRight = false;
    return length;
  }

  public byte[] toBinary () {
    makeDataRight ();
    return data;
  }
</code-fragment>

<code-fragment id='cff.methods'>
  <code-title>??</code-title>
  public void toCID () throws InvalidFontException {
    makeFontsetRight ();
    fontset.toCID (0);
    dataIsRight = false;
  }
</code-fragment>

      </section>

    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.advanced'>
    <title>Advanced Typographic Extensions &#x2013; OpenType
    Layout</title>


    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The Advanced Typographic tables (OpenType Layout tables)
	  extend the functionality of fonts with either TrueType or CFF
	outlines. OpenType Layout fonts contain additional information
	that extends the capabilities of the fonts to support
	high-quality international typography:

	  <itemizedlist>
	    <listitem>
	      <para>OpenType Layout fonts allow a rich mapping between
		characters and glyphs, which supports ligatures,
		positional forms, alternates, and other
		substitutions.</para>
	    </listitem>
	    <listitem>
	      <para>OpenType Layout fonts include information to
		support features for two-dimensional positioning and
		glyph attachment.</para>
	    </listitem>
	    <listitem>
	      <para>OpenType Layout fonts contain explicit script and
		language information, so a text-processing application
		can adjust its behavior accordingly.</para>
	    </listitem>
	    <listitem>
	      <para>OpenType Layout fonts have an open format that
		allows font developers to define their own
		typographical features.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This overview introduces the power and flexibility of
	  the OpenType Layout font model. The OpenType Layout tables
	  are described in more detail in the "Font File Tables"
	  section of the OpenType specification.</para>

	<para>OpenType Layout Common Table Formats are documented in
	  the chapter "OpenType Layout Common Table Formats".</para>

	<para>Registered OpenType Layout Tags for scripts, languages,
	  and baselines, are documented in the chapter "OpenType
	  Layout Registered Features". </para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>OpenType Layout at a Glance</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


	<para>OpenType Layout addresses complex typographical issues
	  that especially affect people using text-processing
	  applications in multi-lingual and non-Latin
	  environments.</para>

	<para>OpenType Layout fonts may contain alternative forms of
	  characters and mechanisms for accessing them. For example,
	  in Arabic, the shape of a character often varies with the
	  character's position in a word. As shown here, the ha
	  character will take any of four shapes, depending on whether
	  it stands alone or whether it falls at the beginning,
	  middle, or end of a word. OpenType Layout helps a
	  text-processing application determine which variant to
	  substitute when composing text. </para>

        <figure>
          <title>Figure 1a. Isolated, initial, medial, and final forms
	    of the Arabic character ha.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1a.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para> Similarly, OpenType Layout helps an application use the
	  correct forms of characters when text is positioned
	  vertically instead of horizontally, such as with Kanji. For
	  example, Kanji uses alternative forms of parentheses when
	  positioned vertically.</para>

        <figure>
          <title>Figure 1b. Alternative forms of parentheses used when
	    positioning Kanji vertically.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1b.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para> The OpenType Layout font format also supports the
	  composition and decomposition of ligatures. For example,
	  English, French, and other languages based on Latin can
	  substitute a single ligature, such as "fi", for its
	  component glyphs - in this case, "f" and "i". Conversely,
	  the individual "f" and "i" glyphs could replace the
	  ligature, possibly to give a text-processing application
	  more flexibility when spacing glyphs to fill a line of
	  justified text.</para>

        <figure>
          <title>Figure 1c. Two Latin glyphs and their associated
	    ligature.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1c.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Figure 1d. Three Arabic glyphs and their associated
	    ligature</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1d.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>Glyph substitution is just one way OpenType Layout
	  extends font capabilities. Using precise X and Y coordinates
	  for positioning glyphs, OpenType Layout fonts also can
	  identify points for attaching one glyph to another to create
	  cursive text and glyphs that need diacritical or other
	  special marks.</para>

	<para>OpenType Layout fonts also may contain baseline
	  information that specifies how to position glyphs
	  horizontally or vertically. Because baselines may vary from
	  one script (set of characters) to another, this information
	  is especially useful for aligning text that mixes glyphs
	  from scripts for different languages.</para>

        <figure>
          <title>Figure 1c. A line of text, baselines adjusted, mixing
	    Latin and Arabic scripts.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1e.gif'/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>TrueType versus OpenType Layout</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>A TrueType font is a collection of several tables that
	  contain different types of data: glyph outlines, metrics,
	  bitmaps, mapping information, and much more. OpenType Layout
	  fonts contain all this basic information, plus additional
	  tables containing information for advanced
	  typography.</para>

	<para>Text-processing applications - referred to as "clients"
	  of OpenType Layout - can retrieve and parse the information
	  in OpenType Layout tables. So, for example, a
	  text-processing client can choose the correct character
	  shapes and space them properly.</para>

	<para>As much as possible, the tables of OpenType Layout
	  define only the information that is specific to the font
	  layout. The tables do not try to encode information that
	  remains constant within the conventions of a particular
	  language or the typography of a particular script. Such
	  information that would be replicated across all fonts in a
	  given language belongs in the text-processing application
	  for that language, not in the fonts.</para>
      </section>
    </section>


    <!--======================================================================-->
    <section role='fragment'>
      <title>OpenType Layout Terminology</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The OpenType Layout model is organized around glyphs,
	  scripts, language systems, and features</para>

	<bridgehead>Characters versus glyphs</bridgehead>

	<para>Users don't view or print characters: a user views or
	  prints glyphs. A glyph is a representation of a
	  character. The character "capital letter A" is represented
	  by the glyph "A" in Times New Roman Bold and "A" in Arial
	  Bold. A font is a collection of glyphs. To retrieve glyphs,
	  the client uses information in the "cmap" table of the font,
	  which maps the client's character codes to glyph indices in
	  the table.</para>

	<para>Glyphs can also represent combinations of characters and
	  alternative forms of characters: glyphs and characters do
	  not strictly correspond one-to-one. For example, a user
	  might type two characters, which might be better represented
	  with a single ligature glyph. Conversely, the same character
	  might take different forms at the beginning, middle, or end
	  of a word, so a font would need several different glyphs to
	  represent a single character. OpenType Layout fonts contain
	  a table that provides a client with information about
	  possible glyph substitutions.</para>


        <figure>
          <title>Figure 1f. Multiple glyphs for the ampersand character.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1f.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<bridgehead>Scripts</bridgehead>

	<para>A script is composed of a group of related characters,
	  which may be used by one or more languages. Latin, Arabic,
	  and Thai are examples of scripts. A font may use a single
	  script, or it may use many scripts. Within an OpenType
	  Layout font, scripts are identified by unique 4-byte
	  tags.</para>

        <figure>
          <title>Figure 1g. Glyphs in the Latin, Kanji, and Arabic
	    scripts.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig2a.gif'/>
            </imageobject>
          </mediaobject>
        </figure>


	<bridgehead>Language systems</bridgehead>

	<para>Scripts, in turn, may be divided into language
	  systems. For example, the Latin script is used to write
	  English, French, or German, but each language has its own
	  special requirements for text processing. A font developer
	  can choose to provide information that is tailored to the
	  script, to the language system, or to both.</para>

	<para>Language systems, unlike scripts, are not necessarily
	  evident when a text-processing client examines the
	  characters being used. To avoid ambiguity, the user or the
	  operating system needs to identify the language
	  system. Otherwise, the client will use the default
	  language-system information provided with each
	  script.</para>


        <figure>
          <title>Figure 1h. Differences in the English, French, and
	    German language system.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1h.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<bridgehead>Features</bridgehead>

	<para>Features define the basic functionality of the font. A
	  font that contains tables to handle diacritical marks will
	  have a "mark" feature. A font that supports substitution of
	  vertical glyphs will have a "vert" feature.</para>

	<para>The OpenType Layout feature model provides great
	  flexibility to font developers because features do not have
	  to be predefined by Microsoft Corporation. Instead, font
	  developers can work with application developers to determine
	  useful features for fonts, add such features to OpenType
	  Layout fonts, and enable client applications to support such
	  features.</para>

        <figure>
          <title>Figure 1i. The relationship of scripts, language
	    systems, features, and lookups for substitution and
	    positioning tables.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig1i.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<bridgehead>OpenType Layout tables</bridgehead>

	<para>OpenType Layout comprises five new tables: GSUB, GPOS,
	  BASE, JSTF, and GDEF. These tables and their formats are
	  discussed in detail in the chapters that follow this
	  overview.</para>

	<para>GSUB: Contains information about glyph substitutions to
	  handle single glyph substitution, one-to-many substitution
	  (ligature decomposition), aesthetic alternatives, multiple
	  glyph substitution (ligatures), and contextual glyph
	  substitution.</para>

	<para>GPOS: Contains information about X and Y positioning of
	  glyphs to handle single glyph adjustment, adjustment of
	  paired glyphs, cursive attachment, mark attachment, and
	  contextual glyph positioning.</para>

	<para>BASE: Contains information about baseline offsets on a
	  script-by-script basis.</para>

	<para>JSTF: Contains justification information, including
	  whitespace and Kashida adjustments.</para>

	<para>GDEF: Contains information about all individual glyphs
	  in the font: type (simple glyph, ligature, or combining
	  mark), attachment points (if any), and ligature caret (if a
	  ligature glyph).</para>

	<para>Common Table Formats: Several common table formats are
	  used by the OpenType Layout tables.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Text processing with OpenType Layout fonts</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>A text-processing client follows a standard process to
	  convert the string of characters entered by a user into
	  positioned glyphs. To produce text with OpenType Layout
	  fonts:</para>

	<orderedlist>
	  <listitem>
	    <para>Using the cmap table in the font, the client
	      converts the character codes into a string of glyph
	      indices.</para>
	  </listitem>
	  <listitem>
	    <para>Using information in the GSUB table, the client
	      modifies the resulting string, substituting positional
	      or vertical glyphs, ligatures, or other alternatives as
	      appropriate.</para>
	  </listitem>
	  <listitem>
	    <para>Using positioning information in the GPOS table and
	      baseline offset information in the BASE table, the
	      client then positions the glyphs.</para>
	  </listitem>
	  <listitem>
	    <para>Using design coordinates the client determines
	      device-independent line breaks. Design coordinates are
	      high-resolution and device-independent.</para>
	  </listitem>
	  <listitem>
	    <para>Using information in the JSTF table, the client
	      justifies the lines, if the user has specified such
	      alignment.</para>
	  </listitem>
	  <listitem>
	    <para>The operating system rasterizes the line of glyphs
	      and renders the glyphs in device coordinates that
	      correspond to the resolution of the output
	      device.</para>
	  </listitem>
	</orderedlist>

	<para>Throughout this process the text-processing client keeps
	  track of the association between the character codes for the
	  original text and the glyph indices of the final, rendered
	  text. In addition, the client may save language and script
	  information within the text stream to clearly associate
	  character codes with typographical behavior.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>An alternative point of view is to say that the font, and
	  in particular the GSUB and GPOS tables contain fragments of
	  programs which operate on a glyph run. The layout engine
	  decides how the typographic treatments specified in its
	  input should be realized, and in particular whether some of
	  the programs fragments should be invoked to manipulate the
	  glyph run. These program fragments are written in a very
	  specialized language.</para>

	<para>The implementation of the glyph run structure is not
	  part of this specification. However, there is some
	  connection since the GSUB and GPOS programs do operate on
	  that structure. We capture here this connection in the form
	  of an interface:</para>

<code-fragment package='com.adobe.aots.opentype' class='GlyphRun'>
  <code-title>GlyphRun interface</code-title>
package com.adobe.aots.opentype;

public interface GlyphRun {
  <code-include linkend='glyphrun.methods'/>
}
</code-fragment>

	<para>First, we have two simple methods to access the number
	  of glyphs in the run and the ID of glyph at a specific
	  position:</para>

<code-fragment id='glyphrun.methods'>
  <code-title>GlyphRun interface</code-title>
  public int glyphCount ();
  public int glyphAt (int pos);
</code-fragment>

	<para>Another pair of accessors, this time to get the position
	  of a glyph:</para>

<code-fragment id='glyphrun.methods'>
  <code-title>GlyphRun interface</code-title>
  public int getXPos (int g);
  public int getYPos (int g);
</code-fragment>


         <para>The specification does not address the situation where
	  a feature is applied to only part of a glyph run. However,
	  it is necessary to support that situation: consider the case
	  of a fragment on which 'onum' is applied, while 'kern' is
	  applied to whole glyph run. Clearly, it is not possible to
	  decompose that glyph run in three independant glyph runs to
	  be processed separately, since it would imply no kerning
	  between the last glyph subject to 'onum' and the glyph
	  followin it. Thus, a GPOS/GSUB engine needs
	  to figure out if a given lookup is to be applied at a given
	  position:</para>

<code-fragment id='glyphrun.methods'>
  <code-title>GlyphRun interface</code-title>
  public boolean isLookupApplied (int lookupIndex, int start, int stop);
</code-fragment>

	<para>The MarkToLigature GPOS lookup type has the implicit
	  notion of ligature component, and of the component to which
	  a mark following a ligature attaches to:</para>

<code-fragment id='glyphrun.methods'>
  <code-title>GlyphRun interface</code-title>
  public void setLigComponents (int[] components);
  public int getLigComponent (int g);
</code-fragment>

	<para>The GSUB lookups result in the replaced of one or more
	  glyphs by one or more glyphs:</para>

<code-fragment id='glyphrun.methods'>
  <code-title>GlyphRun interface</code-title>
  public void replace (int position, int replacementGlyph);
  public void replace (int position, int[] replacementGlyphs);
  public void replace (int[] positions, int replacementGlyph);
</code-fragment>

	<para>The GPOS lookups result in the adjustment of a glyph
	  position:</para>

<code-fragment id='glyphrun.methods'>
  <code-title>GlyphRun interface</code-title>
  public void adjustPlacementAndAdvance (int g, ValueRecord vr);
  public void move (int g, int x, int y);
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>For the purpose of testing our OpenType implementation,
	  here is a very simple implementation of the GlyphRun
	  interface:</para>

<code-fragment package='com.adobe.aots.opentype' class='GlyphRunImpl'>
  <code-title>TestGlyphrun Class</code-title>

package com.adobe.aots.opentype;

public class GlyphRunImpl implements GlyphRun {
  protected int[] glyphs;
  protected int totGlyphs;

  public int glyphCount () {
    return totGlyphs;
  }

  public int glyphAt (int position) {
    if (position &lt; 0 || totGlyphs &lt;= position) {
      return -1; }
    else {
      return glyphs [position]; }
  }

  public void setGlyphAt (int position, int glyph) {
    if (position &lt; 0 || totGlyphs &lt;= position) {
      return; }
    else {
      glyphs [position] = glyph; }
  }

  public void setGlyphs (int [] glyphs, int count) {
    this.glyphs = new int [count];
    System.arraycopy (glyphs, 0, this.glyphs, 0, count);
    this.totGlyphs = count;
  }

  public void setGlyphs (int [] glyphs) {
    setGlyphs (glyphs, glyphs.length);
  }

  public boolean isLookupApplied (int lookupIndex, int start, int stop) {
    return (0 &lt;= start &amp;&amp; stop &lt; totGlyphs);
  }

  public void replace (int position, int replacementGlyph) {
    // replace the glyph at position by replacementGlyph
    glyphs [position] = replacementGlyph;
  }

  public void replace (int position, int[] replacementGlyphs) {
    // replace the glyph at position by replacementGlyphs
    if (totGlyphs + replacementGlyphs.length - 1 > glyphs.length) {
      int[] temp = new int [totGlyphs + replacementGlyphs.length + 100];
      System.arraycopy (glyphs, 0, temp, 0, totGlyphs);
      glyphs = temp; }
    System.arraycopy (glyphs, position + 1,
                      glyphs, position + replacementGlyphs.length,
                      totGlyphs - position - 1);
    System.arraycopy (replacementGlyphs, 0,
                      glyphs, position,
                      replacementGlyphs.length);
    totGlyphs += replacementGlyphs.length - 1;
  }

  public void replace (int[] positions, int replacementGlyph) {
    // replace the glyphs at positions by replacementGlyph
    // = replace the glyph at positions[0] by replacementGlyph
    //   + delete the glyphs at positions[i], i>0

    glyphs [positions [0]] = replacementGlyph;

    for (int i = positions.length - 1; i >= 1; i--) {
      System.arraycopy (glyphs, positions[i] + 1,
                        glyphs, positions[i],
                        totGlyphs - (positions[i] + 1));
      totGlyphs--; }
  }

  public void dump (int curGlyph) {
    for (int i = 0; i &lt; totGlyphs; i++) {
      if (i == curGlyph) {
        System.out.print (" *" + glyphs[i]); }
      else {
        System.out.print ("  " + glyphs[i]); }}
    System.out.println ("");
  }

  public int [] xPos;
  public int [] yPos;

  public void setDefaultPlacementsAndAdvances (Font font) {
    xPos = new int [totGlyphs];
    yPos = new int [totGlyphs];

    // this works for horizontal layout only.
    xPos [0] = 0;
    yPos [0] = 0;

    for (int i = 1; i &lt; totGlyphs; i++) {
      xPos [i] = xPos [i-1] + font.hmtx.getHorizontalAdvance (glyphs [i-1]);
      yPos [i] = 0; }
  }

  public void adjustPlacementAndAdvance (int g, ValueRecord vr) {
    xPos [g] += vr.xPlacement;
    yPos [g] += vr.yPlacement;
    for (int i = g + 1; i &lt; totGlyphs; i++) {
      xPos [i] += vr.xAdvance;
      yPos [i] += vr.yAdvance; }
  }

  public void move (int g, int x, int y) {
    xPos [g] = x;
    yPos [g] = y;
  }

  public int getXPos (int g) {
    return xPos [g];
  }

  public int getYPos (int g) {
    return yPos [g];
  }

  public int [] ligComponents = null;

  public void setLigComponents (int[] components) {
    ligComponents = components;
  }

  public int getLigComponent (int g) {
    if (ligComponents == null) {
      return -1; }
    else {
      return ligComponents [g]; }
  }
}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>OpenType Layout fonts in Windows 95</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The core system fonts in the Middle East and Far East
	  versions of Windows 95 are OpenType Layout fonts. These
	  fonts demonstrate aspects of OpenType Layout's
	  versatility.</para>


	<bridgehead>Middle East Windows 95</bridgehead>

	<para>Middle East Windows 95 uses several Arabic OpenType
	  Layout fonts: fixed regular weight, proportional regular
	  weight, fixed bold, and proportional bold. These fonts take
	  advantage of many glyph substitution features available in
	  OpenType Layout, namely simple substitution (one-to-one
	  contextual), ligature substitution (many-to-one), and mark
	  set substitutions. In Middle East Windows 95, the operating
	  system itself handles glyph substitution, using data in the
	  GSUB table of each font.</para>


	<bridgehead>Far East Windows 95</bridgehead>

	<para>Far East Windows 95 also uses several OpenType Layout
	  fonts: fixed serif, proportional serif, fixed sans serif,
	  and proportional sans serif. The Japanese fonts take
	  advantage of a subset of OpenType Layout features, including
	  vertical glyph substitution and baseline positioning. As
	  with Middle East Windows 95, the operating system in Far
	  East Windows 95 will handle glyph substitution, using data
	  in the GSUB table in each font. However, the text-processing
	  client will need to handle baseline positioning, using data
	  in the BASE table in each font. </para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.common_tables' web:index='yes'>
    <title>OpenType Layout Common Table Formats</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>OpenType Layout consists of five tables: the Glyph
          Substitution table (<ottable>GSUB</ottable>), the Glyph
          Positioning table (<ottable>GPOS</ottable>), the Baseline
          table (<ottable>BASE</ottable>), the Justification table
          (<ottable>JSTF</ottable>), and the Glyph Definition table
          (<ottable>GDEF</ottable>). These tables use some of the same
          data formats.</para>

        <para>This chapter explains the conventions used in all
          OpenType Layout tables, and it describes the common table
          formats. Separate chapters provide complete details about
          the <ottable>GSUB</ottable>, <ottable>GPOS</ottable>,
          <ottable>BASE</ottable>, <ottable>JSTF</ottable>, and
          <ottable>GDEF</ottable> tables.</para>

        <para>The OpenType Layout tables provide typographic
          information for properly positioning and substituting
          glyphs, operations that are required for accurate typography
          in many language environments. OpenType Layout data is
          organized by script, language system, typographic feature,
          and lookup.</para>

        <para>Scripts are defined at the top level. A script is a
          collection of glyphs used to represent one or more languages
          in written form (see Figure 2a). For instance, a single
          script-Latin-is used to write English, French, German, and
          many other languages. In contrast, three scripts-Hiragana,
          Katakana, and Kanji-are used to write Japanese. With
          OpenType Layout, multiple scripts may be supported by a
          single font.</para>

        <figure>
          <title>Figure 2a. Glyphs in the Latin, Kanji, and Arabic
          scripts</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig2a.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>A language system may modify the functions or appearance
          of glyphs in a script to represent a particular
          language. For example, the eszet ligature is used in the
          German language system, but not in French or English (see
          Figure 2b). And the Arabic script contains different glyphs
          for writing the Farsi and Urdu languages. In OpenType
          Layout, language systems are defined within scripts.</para>

        <figure>
          <title>Figure 2b. Differences in the English, French, and
          German language systems</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig2b.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>A language system defines features, which are
          typographic rules for using glyphs to represent a
          language. Sample features are a "vert" feature that
          substitutes vertical glyphs in Japanese, a "liga" feature
          for using ligatures in place of separate glyphs, and a
          "mark" feature that positions diacritical marks with respect
          to base glyphs in Arabic (see Figure 2c). In the absence of
          language-specific rules, default language system features
          apply to the entire script. For instance, a default language
          system feature for the Arabic script substitutes initial,
          medial, and final glyph forms based on a glyph's position in
          a word.</para>


        <figure>
          <title>Figure 2c. A ligature glyph feature substitutes the
          &lt;etc&gt; ligature for individual glyphs, and a mark
          feature positions diacritical marks above an Arabic ligature
          glyph.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig2c.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Features are implemented with lookup data that the
          text-processing client uses to substitute and position
          glyphs. Lookups describe the glyphs affected by an
          operation, the type of operation to be applied to these
          glyphs, and the resulting glyph output.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>The layout tables heavily use subtables, that is blocks
	of data that points one to the other. In general, the shape of
	this graph of blocks is mostly a tree, but it is possible for
	a subtable to be referenced from multiple subtables. A typical
	example is that of a coverage, which may be used in multiple
	lookup subtables.</para>

	<para>We are using a consistent approach to represent those
	subtables and the pointers between them. The rest of this
	section describes this approach, and illustrates it with (a
	simplified version of) coverage subtables.</para>

	<para>We have one definition with the same name as the
	table. This definition contains the attributes and elements
	that represent the content of the table. A typical example
	is:</para>

<literallayout>
  coverageTable =
    ... attributes and elements representing the content of a coverage table
</literallayout>

        <para>When a subtable is pointed from multiple places, we just
        describe it in its one element, which has the same name as the
        subtable. This element will typically be a direct child of the
        element representing the OpenType table. It has an
        <sgmltag>id</sgmltag> attribute, to allow the various places
        that point to the subtable to refer to it:</para>

<literallayout>
  standaloneCoverageTable =
    element coverageTable { attribute id { text}, coverageTable }
</literallayout>

        <para>Whenever a subtable points to another, the former
        contains an offset to the latter. If there is a single pointer
        to the latter, we just include its representation
        &#x201C;in-line&#x201D;; otherwise, we use the
        <sgmltag>name</sgmltag> attribute to refer to the standalone
        table. This is supported by a declaration of the style:</para>

<literallayout>
  coverageTableOffset = attribute name { text } | coverageTable
</literallayout>

	<para>In a subtable that references coverages, such as a
	MarkToMark subtable which contains two references to
	coverage subtables, we would then use something like:</para>

<literallayout>
  markToMarkTable =
    ...
    element mark1Coverage { coverageTableOfset }
    element mark2Coverage { coverageTableOfset }
    ...
</literallayout>

	<para>This allows the following font contents::</para>

<literallayout><![CDATA[
  <coverageTable id='c' format='2'>
    <range start='10' end='20'/>
    <range start='30' end='40'/>
  </coverageTable>

  <markToMarkTable id='m'>
    ...
    <mark1Coverage name='c'/>

    <mark2Coverage format='2'>
      <range start='50' end='60'/>
      <range start='70' end='80'/>
    </mark2Coverage>
    ...
  </markToMarkTable>
]]>
</literallayout>

        <para>Often, the content of a subtable can take one of a few
        formats. For those cases, we have a bunch of definitions
        combined as choices, with the attribute <sgmltag>format</sgmltag>
        used to distinguish them:</para>

<literallayout>
  coverageTable |=
    attribute format { "1" }
    ... attributes and elements for a format 1 coverage table

  coverageTable |=
    attribute format { "2" }
    ... attributes and elements for a format 2 coverage table
</literallayout>

	<para>furthermore, we often will create an "abstract"
	  representation, which captures the essence of the subtable,
	  but does not imply a choice of format. In that case, we use
	  have one more <sgmltag>define</sgmltag> and we use the value
	  <sgmltag>any</sgmltag> for the format.</para>

<literallayout>
  coverageTable |=
    attribute format { "any" }
    ... attributes and elements for a coverage in any format
</literallayout>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>The five layout tables do indeed share subtable formats,
          but only <ottable>GSUB</ottable> and <ottable>GPOS</ottable>
          have Script, Language and Lookups. Consequently, we have two
          base classes for these layout tables: LayoutTable for all of
          them, and LookupTable for <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable>.</para>

<code-fragment package='com.adobe.aots.opentype' class='LayoutTable'>
  <code-title>LayoutTable class</code-title>
package com.adobe.aots.opentype;

import java.util.TreeSet;
import java.util.SortedSet;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public abstract class LayoutTable extends Table {

  public LayoutTable (long tag, Font font) {
    super (tag, font);
  }

  <code-include linkend='layouttable.methods'/>
}
</code-fragment>

<code-fragment package='com.adobe.aots.opentype' class='LookupTableListener'>
  <code-title>LookupTableListener interface</code-title>
package com.adobe.aots.opentype;

import java.net.URL;

public interface LookupTableListener {
  public void init (Font font, URL fontURL,
                    java.io.PrintStream out, boolean positioned)
      throws InvalidFontException;

  public void selectedLookups (int[] lookupIndices);

  public void applyingLookup (int lookupIndex, GlyphRun gr);
    public void applyingLookupAtPos (int lookupIndex, GlyphRun gr, int position);
      public void replace (int oldGlyphId, int newGlyphId);
      public void replace (int oldGlyphId, int[] newGlyphIds);
      public void replace (int[] oldGlyphId, int newGlyphId);
      public void adjust (ValueRecord vr, int format);
      public void move (int x, int y);
      public void applyingSubtable (int lookupIndex, GlyphRun gr,
                                    int position, String table, int stOffset);
      public void noSubtableApplied (int lookupIndex, GlyphRun gr, int position);
    public void applyingLookupAtPosDone (int lookupIndex, GlyphRun gr, int position);
  public void applyingLookupDone (int lookupIndex, GlyphRun gr);

  public void shutdown ();
}
</code-fragment>



<code-fragment package='com.adobe.aots.opentype' class='TextLookupTableListener'>
  <code-title>TextLookupTableListener class</code-title>
package com.adobe.aots.opentype;

import java.net.URL;

public class TextLookupTableListener implements LookupTableListener {

  java.io.PrintStream out;

  TextLookupTableListener (int details) {
  }

  public void init (Font font, URL fontURL,
                    java.io.PrintStream out, boolean positioned) {
    this.out = out;
  }

  public void selectedLookups (int[] lookupIndices) {
    out.print ("lookups selected: ");
    for (int k = 0; k &lt; lookupIndices.length; k++) {
      out.print (" " + lookupIndices [k]); }
    out.println ("");
  }

  public void applyingLookup (int lookupIndex, GlyphRun gr) {
    out.println ("Applying lookup " + lookupIndex);
  }

  String action = "";
  public void applyingLookupAtPos (int lookupIndex, GlyphRun gr, int position) {
    out.println ("Applying lookup " + lookupIndex
                        + " at " + position + " (gid=" + gr.glyphAt (position) + ")");
    action = "";
  }

  public void replace (int oldGlyphId, int newGlyphId) {
    action = "" + oldGlyphId + "->" + newGlyphId;
  }

  public void replace (int oldGlyphId, int[] newGlyphIds) {
    action = "" + oldGlyphId + "->";
    for (int i = 0; i &lt; newGlyphIds.length; i++) {
      action += "" + newGlyphIds[i] + " "; }
  }

  public void replace (int[] oldGlyphIds, int newGlyphId) {
    action = "";
    for (int i = 0; i &lt; oldGlyphIds.length; i++) {
      action += "" + oldGlyphIds[i] + " "; }
    action += "->" + newGlyphId;
  }


  public void adjust (ValueRecord vr, int format) {
    action = "";
    if ((format &amp; 0x001) != 0) {
      action += "xp " + vr.xPlacement + " "; }
    if ((format &amp; 0x002) != 0) {
      action += "yp " + vr.yPlacement + " "; }
    if ((format &amp; 0x004) != 0) {
      action += "xa " + vr.xAdvance + " "; }
    if ((format &amp; 0x008) != 0) {
      action += "ya " + vr.yAdvance + " "; }
  }

  public void move (int x, int y) {
    action = "x " + x + "  y " + y;
  }

  public void applyingSubtable (int lookupIndex, GlyphRun gr,
                                int position, String table, int stOffset) {
    out.println ("Apply subtable at " + table + "." + stOffset
                 + " (" + action + ")");
  }

  public void noSubtableApplied (int lookupIndex, GlyphRun gr,
                                 int position) {
  }

  public void applyingLookupAtPosDone (int lookupIndex, GlyphRun gr,
                                       int position) {
    out.println ("Applying lookup at pos done");
  }

  public void applyingLookupDone (int lookupIndex, GlyphRun gr) {
    out.println ("Applying lookup done");
  }

  public void shutdown () {
    out.close ();
  }
}
</code-fragment>

<code-fragment package='com.adobe.aots.opentype' class='SVGLookupTableListener'>
  <code-title>SVGLookupTableListener class</code-title>
package com.adobe.aots.opentype;

import java.net.URL;

public class SVGLookupTableListener implements LookupTableListener {
  protected int y;
  protected Font font;
  protected boolean positioned;
  protected int details;
  protected java.io.PrintStream out;

  public SVGLookupTableListener (int details) {
    this.details = details;
  }

  protected int scale (int x) {
    return (x * 1000) / 18;
  }

  public void init (Font font, URL fontURL,
                    java.io.PrintStream out,
                    boolean positioned)
      throws InvalidFontException {
    init (font, fontURL, out, positioned, false);
  }
  public void init (Font font, URL fontURL,
                    java.io.PrintStream out, boolean positioned,
                    boolean useSystemFonts) {
    this.font = font;
    this.out = out;
    this.positioned = positioned;

    out.println ("&lt;?xml version='1.0'?&gt;");
    out.println ("&lt;!--_____________________________________________________________________________");
    out.println ("");
    out.println ("  Copyright 2000-2016 Adobe Systems Incorporated. All Rights Reserved.");
    out.println ("");
    out.println ("  Licensed under the Apache License, Version 2.0 (the 'License');");
    out.println ("  you may not use these files except in compliance with the License.");
    out.println ("  You may obtain a copy of the License at");
    out.println ("");
    out.println ("   http://www.apache.org/licenses/LICENSE-2.0");
    out.println ("");
    out.println ("  Unless required by applicable law or agreed to in writing, software");
    out.println ("  distributed under the License is distributed on an 'AS IS' BASIS,");
    out.println ("  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.");
    out.println ("  See the License for the specific language governing permissions and");
    out.println ("  limitations under the License.");
    out.println ("  ____________________________________________________________________________-->");
    out.println ("");

    out.println ("&lt;svg xml:space='preserve' &gt;");
    out.println ("  &lt;style type='text/css'&gt;");

    if (useSystemFonts) {
      out.println ("   .st1{font-family:'Courier';font-size:700}");
      out.println ("   .st2{font-family:'ZapfDingbats';font-size:700}");
      out.println ("   .st0{font-family:'" + font.name.getName (0x409, 1) + "'");
      String subFamily = font.name.getName (0x409, 2);
      if ("Bold".equals (subFamily)) {
        out.println (";font-weight: bold"); }
      else if ("Italic".equals (subFamily)) {
        out.println (";font-style: italic"); }
      else if ("Bold Italic".equals (subFamily)) {
        out.println (";font-weight: bold");
        out.println (";font-style: italic"); }
      out.println (";font-subfamily:'" + subFamily + "'");
      out.println (";font-size:1000}"); }
    else {
      out.println ("   .st0{font-family:'t';font-size:1000}");
      out.println ("   .st1{font-family:'c';font-size:700}");
      out.println ("   .st2{font-family:'z';font-size:700}");
      out.println ("   @font-face{font-family:'c';src:url(c.cef)}");
      out.println ("   @font-face{font-family:'z';src:url(z.cef)}");
      out.println ("   @font-face{font-family:'t';src:url('" + fontURL + "')}"); }

    out.println ("  &lt;/style&gt;");
    out.println ("  &lt;g class='st0'&gt;");

    out.println ("&lt;g transform='scale(0.018)'&gt;");

    out.print ("  &lt;text x='" + scale(10) + "' y='" + scale(20) + "' class='st1'&gt;");
    out.print (font.name.getName (0x409, 4));
    out.println ("&lt;/text&gt;");

    out.print ("  &lt;text x='" + scale (10) + "' y='" + scale(35) + "' class='st1'&gt;");
    out.print (font.name.getName (0x409, 5));
    out.println ("&lt;/text&gt;");

    y = 50;

  }


  public void outputLine (String s) {
    out.print ("&lt;text x='" + scale(10 + 20*depth)
                      + "' y='" + scale(y+22) + "' class='st0'&gt;"
                      + s + "&lt;/text&gt;");
    y += 22; }

  public void outputLine (String s1, String s2) {
    out.print ("&lt;text x='" + scale(10 + 20*depth)
                      + "' y='" + scale(y+22) + "' class='st0'&gt;"
                      + s1 + "&lt;/text&gt;");
    out.print ("&lt;text x='" + scale(400) + "' y='" + scale(y+22) + "' class='st0'&gt;"
                      + s2 + "&lt;/text&gt;");
    y += 22;
  }

  public void outputLine (String s1, String s2, String s3) {
    out.print ("&lt;text x='" + scale(10 + 20*depth)
                      + "' y='" + scale(y+22) + "' class='st0'&gt;"
                      + s1 + "&lt;/text&gt;");
    out.print ("&lt;text x='" + scale(400) + "' y='" + scale(y+22) + "' class='st0'&gt;"
                      + s2 + "&lt;/text&gt;");
    out.print ("&lt;text x='" + scale(600) + "' y='" + scale(y+22) + "' class='st0'&gt;"
                      + s3 + "&lt;/text&gt;");
    y += 22;
  }


  public String annotation (String s) {
    return ("&lt;tspan class='st1'&gt;" + s + "&lt;/tspan&gt;");
  }

  static final String arrow
       = "&lt;tspan class='st2'&gt;&amp;#x2192;&lt;/tspan&gt;";

  static final String undef
       = "&lt;tspan class='st1'&gt;&amp;#x7f;&lt;/tspan&gt;";

  public String glyphRun (GlyphRun gr) {
    String s = "";
    if (positioned) {
      String xPos = "" + gr.getXPos (0);
      String yPos = "" + gr.getYPos (0);
      for (int i = 0; i &lt; gr.glyphCount (); i++) {
        s += "&lt;altGlyph glyphRef='$$" + gr.glyphAt (i) + "'>X&lt;/altGlyph>";
        if (i &gt; 0) {
          xPos += " " + (gr.getXPos (i) - gr.getXPos (i-1)
                          - font.hmtx.getHorizontalAdvance (gr.glyphAt (i-1)));
          yPos += " " + (-(gr.getYPos (i) - gr.getYPos (i-1))); }}
      s = "&lt;tspan dx='" + xPos + "' dy='" + yPos + "'&gt;"
           + s + "&lt;/tspan&gt;"; }
    else {
      for (int i = 0; i &lt; gr.glyphCount (); i++) {
        s += "&lt;altGlyph glyphRef='$$" + gr.glyphAt (i) + "'>X&lt;/altGlyph>"; }}
    return s;
  }

  public String glyphRun (GlyphRun gr, int position) {
    String s = "";
    for (int i = 0; i &lt; gr.glyphCount (); i++) {
      if (i == position) {
        s += annotation ("*"); }
      else {
        s += annotation (" "); }
      s += "&lt;altGlyph glyphRef='$$" + gr.glyphAt (i) + "'>X&lt;/altGlyph>"; }
    return s;
  }

  int depth = 0;



  public void selectedLookups (int[] lookupIndices) {
    String s = "lookups selected:";
    for (int k = 0; k &lt; lookupIndices.length; k++) {
      s += " " + lookupIndices [k]; }
    outputLine (annotation (s));
  }


  String action = "";
  protected void addAction (String s) {
    if (! action.equals ("")) {
      action += "; "; }
    action += s;
  }


  public String intList (int[] ints) {
    if (ints.length == 0) {
      return ""; }

    String s = "" + ints [0];
    for (int i = 1; i &lt; ints.length; i++) {
      s += "," + ints[i]; }
    return s;
  }

  public String stringList (String[] strings) {
    if (strings.length == 0) {
      return ""; }

    String s = "" + strings [0];
    for (int i = 1; i &lt; strings.length; i++) {
      s += "," + strings[i]; }
    return s;
  }

  public void replace (int oldGlyphId, int newGlyphId) {
    addAction ("" + oldGlyphId + arrow + newGlyphId);
    if (font.cff != null) {
      addAction (font.cff.getGlyphName (oldGlyphId)
                  + " " + arrow + " "
                  + font.cff.getGlyphName (newGlyphId)); }
  }

  public void replace (int oldGlyphId, int[] newGlyphIds) {
    addAction ("" + oldGlyphId + arrow + intList (newGlyphIds));
    if (font.cff != null) {
      addAction (font.cff.getGlyphName (oldGlyphId)
                  + " " + arrow + " "
                  + stringList (font.cff.getGlyphName (newGlyphIds))); }
  }

  public void replace (int[] oldGlyphIds, int newGlyphId) {
    addAction ("" + intList (oldGlyphIds) + arrow + newGlyphId);
    if (font.cff != null) {
      addAction (stringList (font.cff.getGlyphName (oldGlyphIds))
                  + " " + arrow + " "
                  + font.cff.getGlyphName (newGlyphId)); }
  }

  public void adjust (ValueRecord vr, int format) {
    String s = "";
    if ((format &amp; 0x001) != 0) {
      s += "xp " + vr.xPlacement + " "; }
    if ((format &amp; 0x002) != 0) {
      s += "yp " + vr.yPlacement + " "; }
    if ((format &amp; 0x004) != 0) {
      s += "xa " + vr.xAdvance + " "; }
    if ((format &amp; 0x008) != 0) {
      s += "ya " + vr.yAdvance + " "; }
    addAction (s);
  }

  public void move (int x, int y) {
    String s = "x " + x + "  y " + y;
    addAction (s);
  }

  public void applyingLookup (int lookupIndex, GlyphRun gr) {
    String l = Integer.toString (lookupIndex);
    while (l.length () &lt; 3) {
      l = " " + l; }
    outputLine (annotation ("applying lookup " + lookupIndex + " on ")
                 + glyphRun (gr));
  }

  public void applyingLookupAtPos (int lookupIndex, GlyphRun gr, int position) {
    depth++;
    action = "";
  }

  public void applyingSubtable (int lookupIndex, GlyphRun gr,
                                int curGlyph, String table, int stOffset) {
    if (   (details >= 1 &amp;&amp; depth == 1)
        || (details >= 2)) {
      outputLine (glyphRun (gr, curGlyph),
                  annotation ("using " + table + ".0x"
                              + Integer.toHexString (stOffset)),
                  annotation (action)); }
  }

  public void noSubtableApplied (int lookupIndex, GlyphRun gr,
                                 int curGlyph) {
    if (details >= 3) {
      outputLine (glyphRun (gr, curGlyph), "", ""); }
  }

  public void applyingLookupAtPosDone (int lookupIndex, GlyphRun gr,
                                       int position) {
    depth--;
  }

  public void applyingLookupDone (int lookupIndex, GlyphRun gr) {
    if (details >= 1) {
      depth++;
      outputLine (glyphRun (gr, -1), "", "");
      depth--; }

    outputLine (annotation ("             result: ") + glyphRun (gr));
  }

  public void shutdown () {
    out.println ("  &lt;/g&gt;");
    out.println ("  &lt;/g&gt;");
    out.println ("&lt;/svg&gt;");
    out.close ();
  }
}
</code-fragment>

<code-fragment package='com.adobe.aots.opentype' class='LookupTable'>
  <code-title>LookupTable class</code-title>
package com.adobe.aots.opentype;

import java.util.TreeSet;
import java.util.SortedSet;
import java.util.Iterator;
import java.util.Vector;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public abstract class LookupTable extends LayoutTable {

  public LookupTable (long tag, Font font) {
    super (tag, font);
  }

  protected LookupTableListener listener = null;

  public void setLookupTableListener (LookupTableListener l) {
   listener = l;
  }

  public void removeLookupTableListener () {
    listener = null;
  }

  <code-include linkend='lookuptable.methods'/>

  abstract String lookupName (int lookupType);
  abstract int lookupType (String name);

  abstract void lookupSubtableToXMLCount (int offset, int[] counts,
                                          int lookupType);

  abstract void lookupSubtableOffsetToXML (DecompilerConfig conf, int offset,
                                           int[] counts,
                                           int lookupType)
     throws org.xml.sax.SAXException, InvalidFontException;

  abstract void lookupSubtableToXML (DecompilerConfig conf, int offset,
                                     int[] counts,
                                     int lookupType)
     throws org.xml.sax.SAXException, InvalidFontException;

  public void recordUse (int offset) {
  }
}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Table Organization</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Two OpenType Layout tables, <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable>, use the same data formats to
          describe the typographic functions of glyphs and the
          languages and scripts that they support: a ScriptList table,
          a FeatureList table, and a LookupList table. In
          <ottable>GSUB</ottable>, the tables define glyph
          substitution data. In <ottable>GPOS</ottable>, they define
          glyph positioning data. This chapter describes these common
          table formats.</para>

        <para>The ScriptList identifies the scripts in a font, each of
          which is represented by a Script table that contains script
          and language-system data. Language system tables reference
          features, which are defined in the FeatureList. Each feature
          table references the lookup data defined in the LookupList
          that describes how, when, and where to implement the
          feature</para>

        <figure>
          <title>Figure 2d. The relationship of scripts, language
          systems, features, and lookups for substitution and
          positioning tables</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig2d.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <blockquote>
          <para>Note: The data in the <ottable>BASE</ottable> and
            <ottable>JSTF</ottable> tables also is organized by script
            and language system. However, the data formats differ from
            those in <ottable>GSUB</ottable> and
            <ottable>GPOS</ottable>, and they do not include a
            FeatureList or LookupList. The <ottable>BASE</ottable> and
            <ottable>JSTF</ottable> data formats are described in the
            <ottable>BASE</ottable> and <ottable>JSTF</ottable>
            chapters.</para>
        </blockquote>

        <para>The information used to substitute and position glyphs
          is defined in Lookup subtables. Each subtable supplies one
          type of information, depending upon whether the lookup is
          part of a <ottable>GSUB</ottable> or <ottable>GPOS</ottable>
          table. For instance, a <ottable>GSUB</ottable> lookup might
          specify the glyphs to be substituted and the context in
          which a substitution occurs, and a <ottable>GPOS</ottable>
          lookup might specify glyph position adjustments for kerning.
          OpenType Layout has seven types of <ottable>GSUB</ottable>
          lookups (described in the <ottable>GSUB</ottable> chapter)
          and nine types of <ottable>GPOS</ottable> lookups (described
          in the <ottable>GPOS</ottable> chapter).</para>

        <para>Each subtable (except for an Extension LookupType
          subtable) includes a Coverage table that lists the
          "covered" glyphs that will result in a glyph substitution or
          positioning operation. The Coverage table formats are
          described in this chapter.</para>

        <para>Some substitution or positioning operations may apply to
          groups, or classes, of glyphs. <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> Lookup subtables use the Class
          Definition table to assign glyphs to classes. This chapter
          includes a description of the Class Definition table
          formats.</para>

        <para>Lookup subtables also may contain device tables,
          described in this chapter, to adjust scaled contour glyph
          coordinates for particular output sizes and
          resolutions. This chapter also describes the data types used
          in OpenType Layout. Sample tables and lists that illustrate
          the common data formats are supplied at the end of this
          chapter.</para>

        <para>Scripts and Languages</para>

        <para>Three tables and their associated records apply to
          scripts and languages: the Script List table (ScriptList)
          and its script record (ScriptRecord), the Script table and
          its language system record (LangSysRecord), and the Language
          System table (LangSys).</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>A basic operation is to find the list of lookups
          corresponding to a 'featureTagsList' for a given
          'scriptTag'/'languageTag'. The strategy is to find the
          langSys table for the script/language, convert the set of
          feature tags into a set of feature indices, and finally to
          convert those to an ordered list of lookup indices.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Find Lookups</code-title>
  public int[] findLookups (long scriptTag, long langSysTag,
                            long[] selectedFeatureTags) {

    int langSysOffset = -1;
    <code-include linkend='method_Table_findLookups2'/>
    if (langSysOffset == -1) {
      return new int[0]; }

    int[] selectedFeatureIndices = new int [selectedFeatureTags.length + 1];
    int   selectedFeatureIndicesCount = 0;
    int featureListOffset = getFeatureListOffset ();

    <code-include linkend='method_Table_findLookups4'/>

    SortedSet&lt;Integer> selectedLookups = new TreeSet&lt;Integer> ();
    <code-include linkend='method_Table_findLookups7'/>

    // turn the set of selectedLookups in an ordered list and return it
    int[] selectedL = new int [selectedLookups.size ()];
    int k = 0;
    for (Integer i : selectedLookups) {
      selectedL [k++] = i.intValue (); }

    return selectedL;
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Script List Table and Script Record</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>OpenType Layout fonts may contain one or more groups of
          glyphs used to render various scripts, which are enumerated
          in a ScriptList table. Both the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables define Script List tables
          (ScriptList):</para>

        <itemizedlist>
          <listitem>
            <para>The <ottable>GSUB</ottable> table uses the
              ScriptList table to access the glyph substitution
              features that apply to a script. For details, see the
              chapter, The Glyph Substitution Table
              (<ottable>GSUB</ottable>).</para>
          </listitem>

          <listitem>
            <para>The <ottable>GPOS</ottable> table uses the
              ScriptList table to access the glyph positioning
              features that apply to a script. For details, see the
              chapter, The Glyph Positioning Table
              (<ottable>GPOS</ottable>).</para>
          </listitem>
        </itemizedlist>

        <para>A ScriptList table consists of a count of the scripts
          represented by the glyphs in the font (ScriptCount) and an
          array of records (ScriptRecord), one for each script for
          which the font defines script-specific features (a script
          without script-specific features does not need a
          ScriptRecord).</para>

	<para>If a Script table with the script tag 'DFLT' (default)
	  is present in the ScriptList table, it must have a non-NULL
	  DefaultLangSys and LangSysCount must be equal to 0. The 'DFLT'
	  Script table should be used if there is not an explicit entry
	  for the script being formatted.</para>

        <para>The ScriptRecord array stores the records alphabetically
          by a ScriptTag that identifies the script. Each ScriptRecord
          consists of a ScriptTag and an offset to a Script
          table.</para>

        <para>Example 1 at the end of this chapter shows a ScriptList
          table and ScriptRecords for a Japanese font that uses three
          scripts.</para>

        <otformat>
          <title>ScriptList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ScriptCount</otfieldname>
            <otfielddesc>Number of ScriptRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>ScriptRecord [ScriptCount]</otfieldname>
            <otfielddesc>Array of ScriptRecords - listed
              alphabetically by ScriptTag</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>ScriptRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>ScriptTag</otfieldname>
            <otfielddesc>4-byte ScriptTag identifier</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Script</otfieldname>
            <otfielddesc>Offset to Script table-from beginning of
              ScriptList</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>scriptListTable</code-title>
  scriptListTable =
    element script {
      attribute tag { text },
      scriptTableOffset
    }*

  standaloneScriptListTable =
    element scriptListTable { attribute id { text }, scriptListTable }

  scriptListTableOffset = attribute name { text } | scriptListTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>To output the ScriptList table of a layout table, we
          need to find all the <sgmltag>scriptRecord</sgmltag>
          elements.</para>

<code-fragment id='table.methods'>
  <code-title>Resolving XML ids</code-title>

  public Element resolveXMLid (Element table, String name) {
    NodeList l = table.getChildNodes ();
    for (int i = 0; i &lt; l.getLength (); i++) {
      Element e = (Element) l.item (i);
      String n = e.getAttribute ("id");
      if (name.equals (n)) {
        return e; }}
    warning ("Could not dereference '" + name + "'");
   return null;
  }
</code-fragment>

<code-fragment id='lookuptable.methods'>
  <code-title>Output the ScriptList table of a layout table</code-title>

  public Block scriptListTableFromXML (Element t,
                                       Element table,
				       Map&lt;Element, Block> blockCache,
                                       Map&lt;String, Integer> featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    NodeList scripts = t.getChildNodes ();
    int scriptCount = scripts.getLength ();

    Block me = new Block (2 + 6 * scriptCount, scriptCount);
    me.setuint16 (0, scriptCount);

    for (int i = 0; i &lt; scriptCount; i++) {
      Element script = (Element) scripts.item (i);
      me.setTag (2 + 6 * i, script.getAttribute ("tag"));
      me.setOffset (2 + 6 * i + 4,
                    scriptTableFromXML (script, table, blockCache,
                                        featureIndices)); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>In order to generate a fairly readable representation,
	  we first check if the scriptTables are shared or not, to
	  generate a "scriptRecord" or a "script" element:</para>

<code-fragment id='lookuptable.methods'>
  public void scriptListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
       scriptTableToXMLCount (getOffset (offset, 2 + 6*i + 4),
                              counts); }
  }

  public void scriptListTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "scriptListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      scriptListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void scriptListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "scriptListTable_" + Integer.toHexString (offset));
      scriptListTableToXMLEmit (conf, offset, counts,
                                "scriptListTable", at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      scriptTableToXML (conf,
                        getOffset (offset, 2 + 6*i + 4),
		        counts); }
  }

  protected void scriptListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
					String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset); i++) {
	at = new AttributesImpl ();
	at.addAttribute ("", "tag", "tag", "CDATA",
                         Tag.tag2string (getuint32 (offset + 2 + 6*i)));

        scriptTableOffsetToXML (conf, getOffset (offset, 2 + 6*i + 4),
                                counts, "script", at); }

      conf.ch.endElement (element); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Since there is no a-priori reason that all tables that
          contain ScriptList tables put them at the same place (or put
          pointers to them at the same place), we need an abstract
          method to get the offset of the ScriptList table.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to get the offset of ScriptList</code-title>
  abstract int getScriptListOffset ();
</code-fragment>

        <para>??</para>

<code-fragment id='method_Table_findLookups2'>
  <code-title>Find LangSys table for 'scriptTag'/'langSysTag' in ScriptList table</code-title>
  { int scriptListOffset = getScriptListOffset ();
    int scriptCount = getuint16 (scriptListOffset);

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      if (scriptTag == getuint32 (scriptListOffset + 2 + 6*scr)) {
        int scriptOffset
          = getOffset (scriptListOffset, 2 + 6*scr + 4);
        <code-include linkend='method_Table_findLookups3'/>
        break; }}}
</code-fragment>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to get the list of script/languages</code-title>
  public String[][] getScriptLangList () {
    int scriptListOffset = getScriptListOffset ();
    int scriptCount = getuint16 (scriptListOffset);

    String[][] result = new String [scriptCount][];

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      long scriptTag = getuint32 (scriptListOffset + 2 + 6*scr);
      int scriptOffset
         = getOffset (scriptListOffset, 2 + 6*scr + 4);
      <code-include linkend='LookupTable_getScriptLangList_2'/> }

    return result;
  }
</code-fragment>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to get the names of features in a script/language</code-title>
  public String[] getFeatureNames (String script, String language) {
    int scriptListOffset = getScriptListOffset ();
    int scriptCount = getuint16 (scriptListOffset);

    long scriptTag = Tag.string2tag (script);
    long languageTag = Tag.string2tag (language);

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      if (scriptTag == getuint32 (scriptListOffset + 2 + 6*scr)) {
        int scriptOffset
           = getOffset (scriptListOffset, 2 + 6*scr + 4);
        <code-include linkend='LookupTable_getFeatureNames_2'/> }}

    return null;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

<code-fragment id='validate_ScriptList'>
  <code-title>ScriptList validation</code-title>
  { if (! available (scriptListOffset, 2)) {
      return; }
    int scriptCount = getuint16 (scriptListOffset);

    if (! claim ("script list", scriptListOffset, 2 + 6*scriptCount)) {
      return; }

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      int scriptOffset
        = getOffset (scriptListOffset, 2 + 6*scr + 4);
      validateScript (scriptOffset); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Script Table and Language System Record</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Script table identifies each language system that
          defines how to use the glyphs in a script for a particular
          language. It also references a default language system that
          defines how to use the script's glyphs in the absence of
          language-specific knowledge.</para>

        <para>A Script table begins with an offset to the Default
          Language System table (DefaultLangSys), which defines the
          set of features that regulate the default behavior of the
          script. Next, Language System Count (LangSysCount) defines
          the number of language systems (excluding the
          DefaultLangSys) that use the script. In addition, an array
          of Language System Records (LangSysRecord) defines each
          language system (excluding the default) with an
          identification tag (LangSysTag) and an offset to a Language
          System table (LangSys). The LangSysRecord array stores the
          records alphabetically by LangSysTag.</para>

        <para>If no language-specific script behavior is defined, the
          LangSysCount is set to zero (0), and no LangSysRecords are
          allocated.</para>

        <otformat>
          <title>Script table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>DefaultLangSys</otfieldname>
            <otfielddesc>Offset to DefaultLangSys table-from beginning
              of Script table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LangSysCount</otfieldname>
            <otfielddesc>Number of LangSysRecords for this
              script-excluding the DefaultLangSys</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>LangSysRecord [LangSysCount]</otfieldname>
            <otfielddesc>Array of LangSysRecords-listed alphabetically
              by LangSysTag</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>LangSysRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>LangSysTag</otfieldname>
            <otfielddesc>4-byte LangSysTag identifier</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LangSys</otfieldname>
            <otfielddesc>Offset to LangSys table-from beginning of
              Script table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>scriptTable</code-title>
  scriptTable =
    element defaultLangSys { langSysTableOffset }?,
    element langSysRecord {
      attribute tag { text },
      langSysTableOffset
    }*

  standaloneScriptTable =
    element scriptTable { attribute id { text }, scriptTable }

  scriptTableOffset = attribute name { text } | scriptTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  <code-title>Output a Script table</code-title>

  private Block scriptTableFromXML (Element t, Element table,
                                    Map&lt;Element, Block> blockCache,
				    Map&lt;String, Integer> featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList langs = t.getChildNodes ();

    Element defaultLangSys = null;
    if (langs.getLength () > 0
        &amp;&amp; "defaultLangSys".equals (((Element) (langs.item (0))).getTagName ())) {
      defaultLangSys = (Element) langs.item (0);
      t.removeChild (defaultLangSys);
      langs = t.getChildNodes (); }

    int langSysCount = langs.getLength ();

    Block me = new Block (4 + 6 * langSysCount, langSysCount + 1);

    me.setOffset (0, defaultLangSys == null
                      ? null :
                        langSysTableFromXML (defaultLangSys, table,
                                             blockCache, featureIndices));
    me.setuint16 (2, langSysCount);
    for (int i = 0; i &lt; langSysCount; i++) {
      Element langSys = (Element) langs.item (i);
      me.setTag (4 + 6*i, langSys.getAttribute ("tag"));
      me.setOffset (4 + 6*i + 4,
                    langSysTableFromXML (langSys, table,
                                         blockCache, featureIndices)); }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void scriptTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    if (getOffset (offset, 0) != 0) {
      langSysTableToXMLCount (getOffset (offset, 0), counts); }

    for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
       langSysTableToXMLCount (getOffset (offset, 4 + 6*i + 4), counts); }
  }

  public void scriptTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "scriptTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      scriptTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void scriptTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "scriptTable_" + Integer.toHexString (offset));
      scriptTableToXMLEmit (conf, offset, counts,
                                "scriptTable", at);
      counts [offset] = 0; }

    if (getOffset (offset, 0) != 0) {
      langSysTableToXML (conf, getOffset (offset, 0), counts); }

    for (int i = 0; i &lt; getuint16 (offset+2); i++) {
      langSysTableToXML (conf,
                         getOffset (offset, 4 + 6*i + 4),
	 	         counts); }
  }

   void scriptTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
				    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      if (getOffset (offset, 0) != 0) {
        at = new AttributesImpl ();
        langSysTableOffsetToXML (conf, getOffset (offset, 0),
                                 counts, "defaultLangSys", at); }

      for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "tag", "tag", "CDATA",
                         Tag.tag2string (getuint32 (offset + 4 + 6*i)));

        langSysTableOffsetToXML (conf, getOffset (offset, 4 + 6*i + 4),
                                 counts, "langSysRecord", at); }

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>If we do not find the LangSys table specifically for the
          langugage, we revert to the default language table, if it
          exists.</para>

<code-fragment id='method_Table_findLookups3'>
  <code-title>Find LangSys table for 'langSysTag' in Script table at 'scriptOffset'</code-title>
  { int langSysCount = getuint16 (scriptOffset + 2);
    for (int lang = 0; lang &lt; langSysCount; lang++) {
      if (langSysTag == getuint32 (scriptOffset + 4 + 6*lang)) {
        langSysOffset = getOffset (scriptOffset, 4 + 6*lang + 4);
        break; }}

    if (langSysOffset == -1) {
      int defaultLangSysOffset = getOffset (scriptOffset, 0);
      if (defaultLangSysOffset != 0) {
        langSysOffset = defaultLangSysOffset; }}}
</code-fragment>

<code-fragment id='LookupTable_getScriptLangList_2'>
  <code-title>ddd</code-title>
  { int langSysCount = getuint16 (scriptOffset + 2);
    int defaultLangSysOffset = getOffset (scriptOffset);

    int n = langSysCount;
    if (defaultLangSysOffset != 0) {
      n++; }
    result [scr] = new String [n + 1];
    result [scr][0] = Tag.tag2string (scriptTag);

    for (int lang = 0; lang &lt; langSysCount; lang++) {
      long langSysTag = getuint32 (scriptOffset + 4 + 6*lang);
      result [scr] [lang+1] = Tag.tag2string (langSysTag); }

    if (defaultLangSysOffset != 0) {
      result [scr] [langSysCount + 1] = "dflt"; }}
</code-fragment>

<code-fragment id='LookupTable_getFeatureNames_2'>
  <code-title>Return the names of features for 'scriptOffset', if any</code-title>
  { int langSysCount = getuint16 (scriptOffset + 2);
    int defaultLangSysOffset = getOffset (scriptOffset);

    for (int lang = 0; lang &lt; langSysCount; lang++) {
      if (languageTag == getuint32 (scriptOffset + 4 + 6*lang)) {
        int langSysOffset
          = scriptOffset + getOffset (scriptOffset + 4 + 6*lang + 4);
        return getFeatureNamesForLang (langSysOffset); }}

    if (defaultLangSysOffset != 0) {
      int langSysOffset = scriptOffset + defaultLangSysOffset;
      return getFeatureNamesForLang (langSysOffset); }}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Language System Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Language System table (LangSys) identifies
          language-system features used to render the glyphs in a
          script. (The LookupOrder offset is reserved for future
          use.)</para>

        <para>Optionally, a LangSys table may define a Required
          Feature Index (ReqFeatureIndex) to specify one feature as
          required within the context of a particular language
          system. For example, in the Cyrillic script, the Serbian
          language system always renders certain glyphs differently
          than the Russian language system.</para>

        <para>Only one feature index value can be tagged as the
          ReqFeatureIndex. This is not a functional limitation,
          however, because the feature and lookup definitions in
          OpenType Layout are structured so that one feature table can
          reference many glyph substitution and positioning
          lookups. When no required features are defined, then the
          ReqFeatureIndex is set to 0xFFFF.</para>

        <para>All other features are optional. For each optional
          feature, a zero-based index value references a record
          (FeatureRecord) in the FeatureRecord array, which is stored
          in a Feature List table (FeatureList). The feature indices
          themselves (excluding the ReqFeatureIndex) are stored in
          arbitrary order in the FeatureIndex array. The FeatureCount
          specifies the total number of features listed in the
          FeatureIndex array.</para>

        <para>Features are specified in full in the FeatureList table,
          FeatureRecord, and Feature table, which are described later
          in this chapter. Example 2 at the end of this chapter shows
          a Script table, LangSysRecord, and LangSys table used for
          contextual positioning in the Arabic script.</para>

        <otformat>
          <title>LangSys table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookupOrder</otfieldname>
            <otfielddesc>= NULL (reserved for an offset to a
              reordering table)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ReqFeatureIndex</otfieldname>
            <otfielddesc>Index of a feature required for this language
              system- if no required features = 0xFFFF</otfielddesc>
          </otfield>
          <otfield>
           <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatureCount</otfieldname>
            <otfielddesc>Number of FeatureIndex values for this
              language system-excludes the required
              feature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatureIndex [FeatureCount]</otfieldname>
            <otfielddesc>Array of indices into the FeatureList-in
              arbitrary order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>langSysTable</code-title>
  langSysTable =
    element requiredFeature {
      attribute name { text }
    }?,
    element featureIndex {
      attribute name { text }
    }*

  standaloneLangSysTable =
    element langSysTable { attribute id { text }, langSysTable }

  langSysTableOffset = attribute name { text } | langSysTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block langSysTableFromXML (Element t, Element table,
                                     Map&lt;Element, Block> blockCache,
				     Map&lt;String, Integer> featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList features = t.getChildNodes ();

    Element requiredFeature = null;
    if (features.getLength () > 0
        &amp;&amp; "requiredFeature".equals (((Element)features.item (0)).getTagName ())) {
      requiredFeature = (Element) features.item (0);
      t.removeChild (requiredFeature);
      features = t.getChildNodes (); }

    int featureCount = features.getLength ();

    Block me = new Block (6 + 2 * featureCount, 1);
    blockCache.put (t, me);

    me.setOffset (0, null);

    if (requiredFeature == null) {
      me.setuint16 (2, 0xffff); }
    else {
      String featureName = requiredFeature.getAttribute ("name");
      Integer ii = featureIndices.get (featureName);
      if (ii == null) {
        warning ("Cannot resolve '" + featureName + "'"); }
      else {
        me.setuint16 (2, ii.intValue ()); }}
    me.setuint16 (4, featureCount);
    for (int i = 0; i &lt; featureCount; i++) {
      Element feature = (Element) features.item (i);
      String featureName = feature.getAttribute ("name");
      Integer ii = featureIndices.get (featureName);
      if (ii == null) {
        warning ("cannot resolve '" + featureName + "'"); }
      else {
        me.setuint16 (6 + 2*i, ii.intValue ()); }}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void langSysTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void langSysTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "langSysTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      langSysTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void langSysTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "langSysTable_" + Integer.toHexString (offset));
      langSysTableToXMLEmit (conf, offset, counts,
                                "langSysTable", at);
      counts [offset] = 0; }
  }

  public void langSysTableToXMLEmit (DecompilerConfig conf, int offset,
                                     int[] counts,
				     String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      if (getuint16 (offset + 2) != 0xffff) {
        at = new AttributesImpl ();
        at.addAttribute ("", "name", "name", "CDATA",
                         "feature_" + getuint16 (offset+2)); }

      for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "name", "name", "CDATA",
                         "feature_" + getuint16 (offset + 6 + 2*i));
        conf.ch.element ("featureIndex", at); }

      conf.ch.endElement (element); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='method_Table_findLookups4'>
  <code-title>Convert 'selectedFeatureTags' to
           'selectedFeatureIndices' using table at 'langSysOffset'</code-title>
  { int requiredFeature = getuint16 (langSysOffset + 2);
    if (requiredFeature != 0xffff) {
      selectedFeatureIndices [selectedFeatureIndicesCount++] = requiredFeature; }

    int featureCount = getuint16 (langSysOffset + 4);
    for (int f = 0; f &lt; featureCount; f++) {
      int featureIndex = getuint16 (langSysOffset + 6 + 2*f);
      <code-include linkend='method_Table_findLookups6'/> }}
</code-fragment>


<code-fragment id='lookuptable.methods'>
  <code-title>aaa</code-title>
  private String[] getFeatureNamesForLang (int langSysOffset) {
    int featureCount = getuint16 (langSysOffset + 4);

    int featureListOffset = getFeatureListOffset ();

    String [] result = new String [featureCount];
    for (int f = 0; f &lt; featureCount; f++) {
      int featureIndex = getuint16 (langSysOffset + 6 + 2*f);
      <code-include linkend='LookupTable_getFeatureNamesForLang_2'/> }

    return result;
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Features and Lookups</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Features define the functionality of an OpenType Layout
          font and they are named to convey meaning to the
          text-processing client. Consider a feature named "liga" to
          create ligatures. Because of its name, the client knows what
          the feature does and can decide whether to apply it. For
          more information, see the <ulink
            url="http://www.microsoft.com/typography/otspec/TTOREG.htm">OpenType
            Layout Registered Features</ulink> chapter. Font
          developers can use these features, as well as create their
          own.</para>

        <para>After choosing which features to use, the client
          assembles all lookups from the selected features. Multiple
          lookups may be needed to define the data required for
          different substitution and positioning actions, as well as
          to control the sequencing and effects of those
          actions.</para>

        <para>To implement features, a client applies the lookups in
          the order the lookup definitions occur in the LookupList. As
          a result, within the <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> table, lookups from several
          different features may be interleaved during text
          processing. A lookup is finished when the client locates a
          target glyph or glyph context and performs a substitution
          (if specified) or a positioning (if specified).</para>

        <para>Note: The substitution (<ottable>GSUB</ottable>) lookups
          always occur before the positioning
          (<ottable>GPOS</ottable>) lookups. The lookup sequencing
          mechanism in TrueType relies on the font to determine the
          proper order of text-processing operations.</para>

        <para>Lookup data is defined in one or more subtables that
          contain information about specific glyphs and the operations
          to be performe on them. Each type of lookup has one or more
          corresponding subtable definitions. The choice of a subtable
          format depends upon two factors: the precise content of the
          information being applied to an operation, and the required
          storage efficiency. (For complete definitions of all lookup
          types and subtables, see the the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> chapters of this document.)</para>

        <para>OpenType Layout features define information that is
          specific to the layout of the glyphs in a font. They do not
          encode information that is constant within the conventions
          of a particular language or the typography of a particular
          script. Information that would be replicated across all
          fonts in a given language belongs in the text-processing
          application for that language, not in the fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Feature List Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The headers of the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables contain offsets to Feature
          List tables (FeatureList) that enumerate all the features in
          a font. Features in a particular FeatureList are not limited
          to any single script. A FeatureList contains the entire list
          of either the <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> features that are used to render the
          glyphs in all the scripts in the font.</para>

        <para>The FeatureList table enumerates features in an array of
          records (FeatureRecord) and specifies the total number of
          features (FeatureCount). Every feature must have a
          FeatureRecord, which consists of a FeatureTag that
          identifies the feature and an offset to a Feature table
          (described next). The FeatureRecord array is arranged
          alphabetically by FeatureTag names.</para>

        <para>Note: The values stored in the FeatureIndex array of a
          LangSys table are used to locate records in the
          FeatureRecord array of a FeatureList table.</para>

        <otformat>
          <title>FeatureList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatureCount</otfieldname>
            <otfielddesc>Number of FeatureRecords in this
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>FeatureRecord [FeatureCount]</otfieldname>
            <otfielddesc>Array of FeatureRecords-zero-based (first
              feature has FeatureIndex = 0)-listed alphabetically by
              FeatureTag</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>FeatureRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>FeatureTag</otfieldname>
            <otfielddesc>4-byte feature identification
              tag</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Feature</otfieldname>
            <otfielddesc>Offset to Feature table-from beginning of
              FeatureList</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>featureListTable</code-title>
  featureListTable =
    element feature {
      attribute id { text },
      attribute tag { text },
      featureTableOffset
    }*

  standaloneFeatureListTable =
    element featureListTable { attribute id { text }, featureListTable }

  featureListTableOffset = attribute name { text } | featureListTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>FeatureRecords are referenced by indices. As we fill the
          FeatureList table, we also remember the index of a
          FeatureRecord by storing it in the
          <sgmltag>attribute</sgmltag> index. This method must be
          called before indices are needed.</para>

<code-fragment id='lookuptable.methods'>
  public Block featureListTableFromXML (Element t, Element table,
                                        Map&lt;Element, Block> blockCache,
					Map&lt;String, Integer> lookupIndices,
                                        Map&lt;String, Integer> featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    NodeList features = t.getChildNodes ();
    int featureCount = features.getLength ();

    Block me = new Block (2 + 6 * featureCount, featureCount);
    me.setuint16 (0, featureCount);

    for (int i= 0; i &lt; featureCount; i++) {
      Element feature = (Element) features.item (i);
      featureIndices.put (feature.getAttribute ("id"), i);
      me.setTag (2 + 6 * i, feature.getAttribute ("tag"));
      me.setOffset (2 + 6 * i + 4,
                    featureTableFromXML (feature, table, blockCache,
                                         lookupIndices)); }

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void featureListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
       featureTableToXMLCount (getOffset (offset, 2 + 6*i + 4), counts); }
  }

  public void featureListTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "featureListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      featureListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void featureListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "featureListTable_" + Integer.toHexString (offset));
      featureListTableToXMLEmit (conf, offset, counts,
                                "featureListTable", at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      featureTableToXML (conf,
                         getOffset (offset, 2 + 6*i + 4),
	 	         counts); }
  }

  public void featureListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
					String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "id", "id", "CDATA",
                         "feature_" + i);
        at.addAttribute ("", "tag", "tag", "CDATA",
                         Tag.tag2string (getuint32 (offset + 2 + 6*i)));

        featureTableOffsetToXML (conf, getOffset (offset, 2 + 6*i + 4),
                                 counts, "feature", at); }
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>


        <para>Since there is no a-priori reason that all tables that
          contain FeatureList tables put them at the same place (or
          put pointers to them at the same place), we need an abstract
          method to get the offset of the FeatureList table.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to find the offset of FeatureList</code-title>
  abstract int getFeatureListOffset ();
</code-fragment>

        <para>??</para>

<code-fragment id='method_Table_findLookups6'>
  <code-title>Include 'featureIndex' if its tag is in 'selectedFeatureTags'</code-title>
  { long featureTag = getuint32 (featureListOffset + 2 + 6*featureIndex);
    for (int i = 0; i &lt; selectedFeatureTags.length; i++) {
      if (selectedFeatureTags [i] == featureTag) {
        selectedFeatureIndices [selectedFeatureIndicesCount++] = featureIndex; }}}
</code-fragment>

<code-fragment id='LookupTable_getFeatureNamesForLang_2'>
  <code-title>ddd</code-title>
  { long featureTag = getuint32 (featureListOffset + 2 + 6*featureIndex);
    result [f] = Tag.tag2string (featureTag); }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Feature Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Feature table defines a feature with one or more
          lookups. The client uses the lookups to substitute or
          position glyphs.</para>

        <para>Feature tables defined within the
          <ottable>GSUB</ottable> table contain references to glyph
          substitution lookups, and feature tables defined within the
          <ottable>GPOS</ottable> table contain references to glyph
          positioning lookups. If a text-processing operation requires
          both glyph substitution and positioning, then both the
          <ottable>GSUB</ottable> and <ottable>GPOS</ottable> tables
          must each define a Feature table, and the tables must use
          the same FeatureTags.</para>

        <para>A Feature table consists of an offset to a Feature
          Parameters (FeatureParams) table (if one has been defined
          for this feature - see note in the following paragraph), a
          count of the lookups listed for the feature (LookupCount),
          and an arbitrarily ordered array of indices into a
          LookupList (LookupListIndex). The LookupList indices are
          references into an array of offsets to Lookup tables.</para>

        <para>The format of the Feature Parameters table is specific
          to a particular feature, and must be specified in the
          feature's entry in the Feature Tags section of the OpenType
          Layout Tag Registry. The length of the Feature Parameters
          table must be implicitly or explicitly specified in the
          Feature Parameters table itself. The FeatureParams field in
          the Feature Table records the offset relative to the
          beginning of the Feature Table. If a Feature Parameters
          table is not needed, the FeatureParams field must be set to
          NULL.</para>

        <para>To identify the features in a <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> table, a text-processing client
          reads the FeatureTag of each FeatureRecord referenced in a
          given LangSys table. Then the client selects the features it
          wants to implement and uses the LookupList to retrieve the
          Lookup indices of the chosen features. Next, the client
          arranges the indices in the LookupList order. Finally, the
          client applies the lookup data to substitute or position
          glyphs.</para>

        <para>Example 3 at the end of this chapter shows the
          FeatureList and Feature tables used to substitute ligatures
          in two languages.</para>

        <otformat>
          <title>Feature table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>FeatureParams</otfieldname>
            <otfielddesc>= NULL (reserved for offset to
              FeatureParams)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of LookupList indices for this
              feature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupListIndex [LookupCount]</otfieldname>
            <otfielddesc>Array of LookupList indices for this feature
              -zero-based (first lookup is LookupListIndex =
              0)</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The description of the FeatureParams field used to be in
          v1.25: "Offset to Feature Parameters table (if one has been
          defined for the feature), relative to the beginning of the
          Feature Table; = NULL if not required". It is unclear why it
          has been changed and in fact the old version is better,
          since there are font with feature params.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>featureTable</code-title>
  featureTable =
    element lookupIndex {
      attribute name { text }
    }*

  standaloneFeatureTable =
    element featureTable { attribute id { text }, featureTable }

  featureTableOffset = attribute name { text } | featureTable
</code-fragment>

      </section>
      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  public Block featureParamsTableFromXML (Element t)
      throws InvalidFontException, UnsupportedFontException {

    Block me;
    return null;
  }

  public Block featureTableFromXML (Element t, Element table,
                                    Map&lt;Element, Block> blockCache,
                                    Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
       t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList lookups = t.getChildNodes ();
    int lookupCount = lookups.getLength ();

    Block me = new Block (4 + 2 * lookupCount, 1);
    blockCache.put (t, me);

    me.setOffset (0, null);
    me.setuint16 (2, lookupCount);
    for (int i = 0; i &lt; lookupCount; i++) {
      Element lookup = (Element) lookups.item (i);
      String lookupName = lookup.getAttribute ("name");
      Integer ii = lookupIndices.get (lookupName);
      if (ii == null) {
        warning ("cannot resolve '" + lookupName + "'"); }
      else {
        me.setuint16 (4 + 2 * i, ii.intValue ()); }}

    return me;
  }

/* feature params? */

</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void featureTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void featureTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "featureTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      featureTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void featureTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "featureTable_" + Integer.toHexString (offset));
      featureTableToXMLEmit (conf, offset, counts,
                                "featureTable", at);
      counts [offset] = 0; }
  }

  public void featureTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
					String element, AttributesImpl at)
      throws org.xml.sax.SAXException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "name", "name", "CDATA",
                       "lookup_" + getuint16 (offset + 4 + 2*i));
        conf.ch.element ("lookupIndex", at); }

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='method_Table_findLookups7'>
  <code-title>Add the lookups of 'selectedFeatureIndices' to 'selectedLookups'</code-title>
  { for (int f = 0; f &lt; selectedFeatureIndicesCount; f++) {
      int featureOffset
         = featureListOffset
           + getuint16 (featureListOffset + 2 + selectedFeatureIndices[f]*6 + 4);
      int lookupCount = getuint16 (featureOffset + 2);
      for (int l = 0; l &lt; lookupCount; l++) {
        selectedLookups.add (getuint16 (featureOffset + 4 + l*2)); }}}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup List Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The headers of the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables contain offsets to Lookup
          List tables (LookupList) for glyph substitution
          (<ottable>GSUB</ottable> table) and glyph positioning
          (<ottable>GPOS</ottable> table). The LookupList table
          contains an array of offsets to Lookup tables (Lookup). The
          font developer defines the Lookup sequence in the Lookup
          array to control the order in which a text-processing client
          applies lookup data to glyph substitution and positioning
          operations. LookupCount specifies the total number of Lookup
          table offsets in the array.</para>

        <para>Example 4 at the end of this chapter shows three
          ligature lookups in the LookupList table.</para>

        <otformat>
          <title>LookupList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of lookups in this table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Lookup [LookupCount]</otfieldname>
            <otfielddesc>Array of offsets to Lookup tables-from
              beginning of LookupList -zero based (first lookup is
              Lookup index = 0)</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>lookupListTable</code-title>
  GSUBlookup =
    element lookup {
      attribute id { text },
      GSUBlookupTableOffset
    }

  GSUBlookupListTable =
    GSUBlookup*

  standaloneGSUBLookupListTable =
    element lookupListTable { attribute id { text }, GSUBlookupListTable }

  GSUBlookupListTableOffset =  attribute name { text } | GSUBlookupListTable


  GPOSlookup =
    element lookup {
      attribute id { text },
      GPOSlookupTableOffset
    }

  GPOSlookupListTable =
    GPOSlookup*

  standaloneGPOSLookupListTable =
    element lookupListTable { attribute id { text }, GPOSlookupListTable }

  GPOSlookupListTableOffset =  attribute name { text } | GPOSlookupListTable

  lookup = GSUBlookup | GPOSlookup
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>Lookups are referenced by indices. As we fill the
          FeatureList table, we also remember the index of a
          Lookup by storing it in the
          <sgmltag>attribute</sgmltag> index. This method must be
          called before indices are needed.</para>

<code-fragment id='lookuptable.methods'>
  public Block lookupListTableFromXML (Element t, Element table,
                                       Map&lt;Element, Block> blockCache,
				       Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    NodeList lookups = t.getChildNodes ();
    int lookupCount = lookups.getLength ();

    for (int i = 0; i &lt; lookupCount; i++) {
      Element lookup = (Element) lookups.item (i);
      lookupIndices.put (lookup.getAttribute ("id"), i); }

    Block me = new Block (2 + 2 * lookupCount, lookupCount);
    me.setuint16 (0, lookupCount);
    for (int i = 0; i &lt; lookupCount; i++) {
      Element lookup = (Element) lookups.item (i);
      me.setOffset (2 + 2*i,
                    lookupTableFromXML (lookup, table, blockCache,
                                        lookupIndices)); }

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void lookupListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
       lookupTableToXMLCount (getOffset (offset, 2 + 2*i), counts); }
  }

  public void lookupListTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "lookupListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      lookupListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void lookupListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "lookupTable_" + Integer.toHexString (offset));
      lookupListTableToXMLEmit (conf, offset, counts,
                                "lookupListTable", at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      lookupTableToXML (conf,
                        getOffset (offset, 2 + 2*i),
	 	        counts); }
  }

  public void lookupListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
				        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "id", "id", "CDATA", "lookup_" + i);

        lookupTableOffsetToXML (conf, getOffset (offset, 2 + 2*i),
                                counts, "lookup", at); }
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Since there is no a-priori reason that all tables that
          contain LookupList tables put them at the same place (or put
          pointers to them at the same place), we need an abstract
          method to get the offset of the LookupList table.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to get the offset of LookupList</code-title>
  abstract int getLookupListOffset ();
</code-fragment>

        <para>We can then find the offset of a Lookup.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to get the offset of a Lookup</code-title>
  int getLookupOffset (int lookupIndex) {
    int lookupListOffset = getLookupListOffset ();
    return lookupListOffset + getOffset (lookupListOffset + 2 + 2*lookupIndex);
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Lookup table (Lookup) defines the specific conditions,
          type, and results of a substitution or positioning action
          that is used to implement a feature. For example, a
          substitution operation requires a list of target glyph
          indices to be replaced, a list of replacement glyph indices,
          and a description of the type of substitution action.</para>

        <para>Each Lookup table may contain only one type of
          information (LookupType), determined by whether the lookup
          is part of a <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> table. <ottable>GSUB</ottable>
          supports five LookupTypes, and <ottable>GPOS</ottable>
          supports seven LookupTypes (for details about LookupTypes,
          see the <ottable>GSUB</ottable> and <ottable>GPOS</ottable>
          chapters of the document).</para>

        <para>Each LookupType is defined with one or more subtables,
          and each subtable definition provides a different
          representation format. The format is determined by the
          content of the information required for an operation and by
          required storage efficiency. When glyph information is best
          presented in more than one format, a single lookup may
          contain more than one subtable, as long as all the subtables
          are the same LookupType. For example, within a given lookup,
          a glyph index array format may best represent one set of
          target glyphs, whereas a glyph index range format may be
          better for another set of target glyphs.</para>

        <para>During text processing, a client applies a lookup to
          each glyph in the string before moving to the next lookup. A
          lookup is finished for a glyph after the client makes the
          substitution/positioning operation. To move to the "next"
          glyph, the client will typically skip all the glyphs that
          participated in the lookup operation: glyphs that were
          substituted/positioned as well as any other glyphs that
          formed a context for the operation. However, in the case of
          pair positioning operations (i.e., kerning), the "next"
          glyph in a sequence may be the second glyph of the
          positioned pair (see pair positioning lookup for
          details).</para>

        <para>A Lookup table contains a LookupType, specified as an
          integer, that defines the type of information stored in the
          lookup. The LookupFlag specifies lookup qualifiers that
          assist a text-processing client in substituting or
          positioning glyphs. The SubTableCount specifies the total
          number of SubTables. The SubTable array specifies offsets,
          measured from the beginning of the Lookup table, to each
          SubTable enumerated in the SubTable array.</para>

        <otformat>
          <title>Lookup table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupType</otfieldname>
            <otfielddesc>Different enumerations for
              <ottable>GSUB</ottable> and
              <ottable>GPOS</ottable></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupFlag</otfieldname>
            <otfielddesc>Lookup qualifiers</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubTableCount</otfieldname>
            <otfielddesc>Number of SubTables for this
              lookup</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubTable [SubTableCount]</otfieldname>
            <otfielddesc>Array of offsets to SubTables-from beginning
              of Lookup table</otfielddesc>
          </otfield>
        </otformat>

        <para>The LookupFlag uses four bits and one byte:

          <itemizedlist>
            <listitem>
              <para>Each of the first four bits can be set in order to
                specify additional instructions for applying a lookup
                to a glyph string. The LookUpFlag bit enumeration
                table provides details about the use of these bits.
              </para>
            </listitem>
            <listitem>
              <para>The high byte is set to specify the type of mark
                attachment.</para>
            </listitem>
          </itemizedlist>
        </para>

        <table>
          <title>LookupFlag bit enumeration</title>

          <tgroup cols='3'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="10pc"/>
            <colspec colwidth="14pc"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0x0001</entry>
                <entry>RightToLeft</entry>
                <entry>
                  <para>This bit relates only to the correct
                    processing of the cursive attachment lookup type
                    (GPOS lookup type 3). When this bit is set, the
                    last glyph in a given sequence to which the
                    cursive attachment lookup is applied, will be
                    positioned on the baseline.</para>
                  <para><emphasis>Note: Setting of this bit is not
                      intended to be used by operating systems or
                      applications to determine text
                      direction.</emphasis></para>
                </entry>
              </row>
              <row>
                <entry>0x0002</entry>
                <entry>IgnoreBaseGlyphs</entry>
                <entry>If set, skips over base glyphs</entry>
              </row>
              <row>
                <entry>0x0004</entry>
                <entry>IgnoreLigatures</entry>
                <entry>If set, skips over ligatures</entry>
              </row>
              <row>
                <entry>0x0008</entry>
                <entry>IgnoreMarks</entry>
                <entry>If set, skips over combining marks</entry>
              </row>
              <row>
                <entry>0x00F0</entry>
                <entry>Reserved</entry>
                <entry>For future use</entry>
              </row>
              <row>
                <entry>0xFF00</entry>
                <entry>MarkAttachmentType</entry>
                <entry>If not zero, skips over all marks of attachment
                  type different from specified.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <para>For example, in Arabic text, a character string might
          have the pattern &lt;base character - mark character - base
          character>. That string could be converted into a ligature
          composed of two components, one for each base character,
          with the combining mark glyph over the first component. To
          produce this ligature, the font developer would set the
          IgnoreMarks bit to tell the client to ignore the mark,
          substitute the ligature glyph first, and then position the
          mark glyph over the ligature. Alternatively, a lookup which
          did not set the IgnoreMarks bit could be used to describe a
          three-component ligature glyph, composed of the first base
          glyph, the mark glyph, and the second base glyph. Here's
          another example: A lookup which creates a ligature of a base
          glyph with a top mark may skip over all bottom marks by
          specifying the mark attachment type as top marks. You can
          define attachment types of marks in the MarkAttachClassDef
          subtable in the <ottable>GDEF</ottable> table.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>Second paragraph, should read: "... GSUB supports seven
	LookupTypes and GPOS supports nine LookupTypes..."</para>

	<para>In general, each lookup subtable can be described by:
	  <itemizedlist>
	    <listitem>
	      <para>a pattern that the glyph string must match (at the
	      current position)</para>
	    </listitem>
	    <listitem>
	      <para>transformations that must performed
	      on the glyph string, if the pattern is matched.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>It is useful to describe each lookup subtable in those
	terms, and to do so using a somewhat formalized notation. This
	goes a long way toward resolving the inherent ambiguity of the
	English language.</para>

	<para>To describe patterns, we will use the usual regular
	expression notation: &#x2018;*&#x2019; for 0 or more
	occurrences, &#x2018;+&#x2019; for 1 or more occurrences. Each
	pattern consists of three parts, in that order: the backtrack
	part, the input part and the lookahead part. We indicate those
	parts by bracketing the input part with
	&#x2018;&#x25B6;&#x2019; and &#x2018;&#x25c0;&#x2019;.  The
	basic alphabet on which those regular expressions are built
	are sets of glyph IDs. The set L is the set of LookupFlag
	glyphs, that is the set of glyphs which need to be skipped
	according to LookupFlag. The other sets in the basic alphabet
	are introduced in the description of each lookup subtable
	format; all such sets are to be understood as excluding the
	glyphs in the set L. If a set is empty, then the pattern does
	not match any string.</para>

	<para>For example, the pattern matched by a Ligature table in
	a Ligature Substitution in format 1 is:</para>

	<blockquote>
	  <para>&#x25B6; L<subscript>0</subscript> L*
	  L<subscript>1</subscript> L* &#x2026; L*
	  L<subscript>ComponentCount-1</subscript> &#x25C0;</para>
	</blockquote>

	<para>where L<subscript>0</subscript> = {glyph ID to which
	this Ligature table corresponds} - L, and
	L<subscript>i</subscript> = {Component [i-1]} - L for i >
	0.</para>

	<para>The pattern matched by a Ligature Substitution is the
	union of the patterns matched by its subtables.</para>

	<para>Last sentence: &#x201C;You <emphasis>can</emphasis>
	define...&#x201D; seems a bit weak, since there does not seem
	to be any other place where this data can be found. In other
	words: &#x201C;The attachment type of the glyphs are found in
	the GDEF table.&#x201D;</para>

	<para>MarkAttachementType: A common use of this mechanism is
	when ligating a base character and a mark. The problem to
	solve handle is that there could be an intervening,
	non-interacting mark, as in the sequence &lt;base, mark_below,
	mark_above>. (The canonical ordering of the combining classes
	in Unicode is irrelevant &#x2013; just reverse the mark above
	and the mark below). We want to ligate the base and the mark
	above, so we have to skip the mark below. We cannot set
	ignoreMarks in lookupFlag, as to would force the mark above to
	be ignored as well! However, we cannot ignore base glyphs
	either; consider &lt;base, other_base, mark_above>, in which
	case we do not want to ligate. So the seemingly trivial
	&#x201C;skip over all <emphasis>marks</emphasis> of attachment
	type different from specified&#x201D; is actually quite
	strong: only the <emphasis>marks</emphasis> of the appropriate
	attachment type have to be skipped. This means that the test
	to determine if a glyph should be skipped cannot look just at
	the mark attachment class definition, it must also look at the
	glyph class definition.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Lookup type</code-title>
  lookupTableCommonAttributes =
    attribute rightToLeft         { yesOrNo }?,
    attribute ignoreBaseGlyphs    { yesOrNo }?,
    attribute ignoreLigatures     { yesOrNo }?,
    attribute ignoreMarks         { yesOrNo }?,
    attribute markAttachmentType  { text }?


  standaloneGSUBLookupTable =
    element lookupTable { attribute id { text }, GSUBlookupTable }

  GSUBlookupTableOffset = attribute name { text } | GSUBlookupTable


  standaloneGPOSLookupTable =
    element lookupTable { attribute id { text }, GPOSlookupTable }

  GPOSlookupTableOffset = attribute name { text } | GPOSlookupTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block lookupTableFromXML (Element t, Element table,
                                    Map&lt;Element, Block> blockCache,
				    Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList subtables = t.getChildNodes ();

    int subtableCount = subtables.getLength ();
    int type = lookupType (t.getAttribute ("type"));
    if (type == 0) {
      type = Integer.parseInt (t.getAttribute ("type")); }
    int lookupFlag = 0;
    if ("yes".equals (t.getAttribute ("rightToleft"))) {
      lookupFlag |= 0x0001; }
    if ("yes".equals (t.getAttribute ("ignoreBaseGlyphs"))) {
      lookupFlag |= 0x0002; }
    if ("yes".equals (t.getAttribute ("ignoreLigatures"))) {
      lookupFlag |= 0x0004; }
    if ("yes".equals (t.getAttribute ("ignoreMarks"))) {
      lookupFlag |= 0x0008; }
    String markAttachmentType = t.getAttribute ("markAttachmentType");
    if (   markAttachmentType != null
        &amp;&amp; ! "".equals (markAttachmentType)) {
      lookupFlag |= (Integer.parseInt (markAttachmentType) &amp; 0xff) &lt;&lt; 8; }

    Block me = new Block (6 + 2*subtableCount, subtableCount);
    blockCache.put (t, me);

    me.setuint16 (0, type);
    me.setuint16 (2, lookupFlag);
    me.setuint16 (4, subtableCount);
    for (int i = 0; i &lt; subtableCount; i++) {
      Element subtable =  (Element) subtables.item (i);
      Block block = lookupSubtableFromXML (subtable, table,
                                           blockCache, type,
					   lookupIndices);
      if (block == null) {
        String subtableName = subtable.getTagName ();
        warning ("unrecognized lookup subtable " + subtableName); }
      me.setOffset (6 + 2*i, block); }

    return me;
  }

  private Block lookupSubtableFromXML (Element lookupSubtable,
                                       Element table,
                                       Map&lt;Element, Block> blockCache,
                                       int lookupType,
				       Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = lookupSubtable.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        lookupSubtable = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (lookupSubtable);
      if (cached != null) {
        return cached; }}

    Block me = lookupSubtableBodyFromXML (lookupSubtable, table, blockCache,
                                          lookupType, lookupIndices);

    blockCache.put (lookupSubtable, me);
    return me;
  }

  abstract Block lookupSubtableBodyFromXML (Element lookupSubtable,
                                           Element table,
                                           Map&lt;Element, Block> blockCache,
                                           int lookupType,
		    		           Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException;
</code-fragment>

<code-fragment id='gpos.methods'>
  Block lookupSubtableBodyFromXML (Element lookupSubtable,
                                           Element table,
                                           Map&lt;Element, Block> blockCache,
                                           int lookupType,
					   Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    switch (lookupType) {
      case 1: { return singlePosLookupFromXML (lookupSubtable, table,
                                               blockCache); }
      case 2: { return pairPosLookupFromXML (lookupSubtable, table,
                                             blockCache); }
      case 3: { return cursivePosFormat1FromXML (lookupSubtable, table,
                                                 blockCache); }
      case 4: { return markBasePosFormat1FromXML (lookupSubtable, table,
                                                  blockCache); }
      case 5: { return markLigPosFormat1FromXML (lookupSubtable, table,
                                                 blockCache); }
      case 6: { return markMarkPosFormat1FromXML (lookupSubtable, table,
                                                  blockCache); }
      case 7: { return contextLookupFromXML (lookupSubtable, table,
                                              blockCache, lookupIndices); }
      case 8: { return chainingLookupFromXML (lookupSubtable, table,
                                              blockCache, lookupIndices); }
      case 9: { return extensionFormat1FromXML (lookupSubtable, table,
                                                blockCache, lookupIndices); }}

     /* cannot get there with valid document */
     throw new InvalidFontException
                  ("invalid lookupType (" + lookupType + ")");
  }
</code-fragment>

<code-fragment id='gsub.methods'>
  Block lookupSubtableBodyFromXML (Element lookupSubtable,
                                           Element table,
                                           Map&lt;Element, Block> blockCache,
                                           int lookupType,
					   Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

     switch (lookupType) {
       case 1: { return singleSubstLookupFromXML (lookupSubtable, table,
                                                   blockCache); }
       case 2: { return multipleSubstFormat1FromXML (lookupSubtable, table,
                                                     blockCache); }
       case 3: { return alternateSubstFormat1FromXML (lookupSubtable, table,
                                                      blockCache); }
       case 4: { return ligatureSubstFormat1FromXML (lookupSubtable, table,
                                                     blockCache); }
       case 5: { return contextLookupFromXML (lookupSubtable, table,
                                               blockCache, lookupIndices); }
       case 6: { return chainingLookupFromXML (lookupSubtable, table,
                                               blockCache, lookupIndices); }
       case 7: { return extensionFormat1FromXML (lookupSubtable, table,
                                                 blockCache, lookupIndices); }}

     /* cannot get there with valid document */
     throw new InvalidFontException
                  ("invalid lookupType (" + lookupType + ")");
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void lookupTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    int lookupType = getuint16 (offset);
    for (int st = 0; st &lt; getuint16 (offset + 4); st++) {
      int stOffset = getOffset (offset, 6 + 2*st);
      lookupSubtableToXMLCount (stOffset, counts, lookupType); }
  }

  public void lookupTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "lookupTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      lookupTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void lookupTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "lookupTable_" + Integer.toHexString (offset));
      lookupTableToXMLEmit (conf, offset, counts,
                            "lookupTable", at);
      counts [offset] = 0; }

    int lookupType = getuint16 (offset);
    for (int st = 0; st &lt; getuint16 (offset + 4); st++) {
      int stOffset = getOffset (offset, 6 + 2*st);
      lookupSubtableToXML (conf, stOffset, counts, lookupType); }
  }

  protected void lookupTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
				    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "type", "type", "CDATA", "" + getuint16 (offset));

    int lookupFlag = getuint16 (offset + 2);
    if ((lookupFlag &amp; 0x0001) != 0) {
      at.addAttribute ("", "rightToLeft", "rightToLeft", "CDATA",
                       ((lookupFlag &amp; 0x0001) != 0) ? "yes" : "no");  }
    if ((lookupFlag &amp; 0x0002) != 0) {
      at.addAttribute ("", "ignoreBaseGlyphs", "ignoreBaseGlyphs", "CDATA",
                       ((lookupFlag &amp; 0x0002) != 0) ? "yes" : "no"); }
    if ((lookupFlag &amp; 0x0004) != 0) {
      at.addAttribute ("", "ignoreLigatures", "ignoreLigatures", "CDATA",
                       ((lookupFlag &amp; 0x0004) != 0) ? "yes" : "no"); }
    if ((lookupFlag &amp; 0x0008) != 0) {
      at.addAttribute ("", "ignoreMarks", "ignoreMarks", "CDATA",
                       ((lookupFlag &amp; 0x0008) != 0) ? "yes" : "no"); }
    if ((lookupFlag &amp; 0xFF00) != 0) {
      at.addAttribute ("", "markAttachmentType", "markAttachmentType",
                       "CDATA", "" + ((lookupFlag >> 8) &amp; 0xff)); }

    conf.ch.startElement (element, at); {
      int lookupType = getuint16 (offset);
      for (int st = 0; st &lt; getuint16 (offset + 4); st++) {
        int stOffset = getOffset (offset, 6 + 2*st);
        lookupSubtableOffsetToXML (conf, stOffset, counts, lookupType); }
      conf.ch.endElement (element); }
  }
</code-fragment>

<code-fragment id='gsub.methods'>
  static final String[] lookupNames = {null, "singleSubst", "multipleSubst",
    "alternateSubst", "ligatureSubst", "contextual",
    "chainingContextual", "extensionSubst"};

  String lookupName (int lookupType) {
    return lookupNames [lookupType];
  }

  int lookupType (String name) {
    for (int i = 0; i &lt; lookupNames.length ; i++) {
      if (name.equals (lookupNames [i])) {
        return i; }}
    return 0;
  }

  public void lookupSubtableToXMLCount (int stOffset, int[] counts,
                                        int lookupType) {
    counts [stOffset]++;
    if (counts [stOffset] > 1) {
      return; }

    switch (lookupType) {
      case 1: { <code-include linkend='gsub.toXMLCount_1'/>;   break; }
      case 2: { <code-include linkend='gsub.toXMLCount_2'/>;   break; }
      case 3: { <code-include linkend='gsub.toXMLCount_3'/>;   break; }
      case 4: { <code-include linkend='gsub.toXMLCount_4'/>;   break; }
      case 5: { contextualLookupToXMLCount (stOffset, counts); break; }
      case 6: { chainingLookupToXMLCount (stOffset, counts);   break; }
      case 7: { extensionLookupToXMLCount (stOffset, counts);  break; }}
  }

  public void lookupSubtableOffsetToXML (DecompilerConfig conf, int stOffset,
                                         int [] counts,
                                         int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] != 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "name", "name", "CDATA",
                       lookupNames [lookupType] + "Table_"
		         + Integer.toHexString (stOffset));
      conf.ch.element (lookupNames [lookupType] + "Table", at); }

    else {
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType], new AttributesImpl (),
			       lookupType); }
  }

  public void lookupSubtableToXML (DecompilerConfig conf, int stOffset,
                                   int[] counts,
                                   int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       lookupNames [lookupType] + "Table_"
                         + Integer.toHexString (stOffset));
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType] + "Table", at,
                               lookupType);
      counts [stOffset] = 0; }

    switch (lookupType) {
      case 1: { <code-include linkend='gsub.toXML_1'/>;       break; }
      case 2: { <code-include linkend='gsub.toXML_2'/>;       break; }
      case 3: { <code-include linkend='gsub.toXML_3'/>;       break; }
      case 4: { <code-include linkend='gsub.toXML_4'/>;       break; }
      case 5: { contextualLookupToXML (conf, stOffset, counts); break; }
      case 6: { chainingLookupToXML (conf, stOffset, counts);   break; }
      case 7: { extensionLookupToXML (conf, stOffset, counts);  break; }}
  }

  public void lookupSubtableToXMLEmit (DecompilerConfig conf,
                                       int stOffset, int[] counts,
				       String element, AttributesImpl at,
                                       int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "format", "format", "CDATA",
                     "" + getuint16 (stOffset));
    conf.ch.startElement (element, at); {
      switch (lookupType) {
        case 1: { <code-include linkend='gsub.toXMLEmit_1'/>;       break; }
        case 2: { <code-include linkend='gsub.toXMLEmit_2'/>;       break; }
        case 3: { <code-include linkend='gsub.toXMLEmit_3'/>;       break; }
        case 4: { <code-include linkend='gsub.toXMLEmit_4'/>;       break; }
        case 5: { contextualLookupToXMLEmit (conf, stOffset, counts); break; }
	case 6: { chainingLookupToXMLEmit (conf, stOffset, counts);   break; }
	case 7: { extensionLookupToXMLEmit (conf, stOffset, counts);  break; }}
      conf.ch.endElement (element); }
  }
</code-fragment>


<code-fragment id='gpos.methods'>
  final String[] lookupNames = {null, "singlePos", "pairPos",
      "cursiveAttachment", "markToBaseAttachment",
      "markToLigatureAttachment", "markToMarkAttachment",
      "contextual", "chainingContextual", "extensionPos"};

  String lookupName (int lookupType) {
    return lookupNames [lookupType];
  }

  int lookupType (String name) {
    for (int i = 0; i &lt; lookupNames.length; i++) {
      if (name.equals (lookupNames [i])) {
        return i; }}
    return 0;
  }

  public void lookupSubtableToXMLCount (int stOffset, int[] counts,
                                        int lookupType) {
    counts [stOffset]++;
    if (counts [stOffset] > 1) {
      return; }

    switch (lookupType) {
      case 1: { <code-include linkend='gpos.toXMLCount_1'/>;   break; }
      case 2: { <code-include linkend='gpos.toXMLCount_2'/>;   break; }
      case 3: { <code-include linkend='gpos.toXMLCount_3'/>;   break; }
      case 4: { <code-include linkend='gpos.toXMLCount_4'/>;   break; }
      case 5: { <code-include linkend='gpos.toXMLCount_5'/>;   break; }
      case 6: { <code-include linkend='gpos.toXMLCount_6'/>;   break; }
      case 7: { contextualLookupToXMLCount (stOffset, counts); break; }
      case 8: { chainingLookupToXMLCount (stOffset, counts);   break; }
      case 9: { extensionLookupToXMLCount (stOffset, counts);  break; }}
  }

  public void lookupSubtableToXML (DecompilerConfig conf, int stOffset,
                                   int[] counts,
                                   int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       lookupNames [lookupType] + "Table_"
                         + Integer.toHexString (stOffset));
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType] + "Table", at,
                               lookupType);
      counts [stOffset] = 0; }

    switch (lookupType) {
      case 1: { <code-include linkend='gpos.toXML_1'/>;       break; }
      case 2: { <code-include linkend='gpos.toXML_2'/>;       break; }
      case 3: { <code-include linkend='gpos.toXML_3'/>;       break; }
      case 4: { <code-include linkend='gpos.toXML_4'/>;       break; }
      case 5: { <code-include linkend='gpos.toXML_5'/>;       break; }
      case 6: { <code-include linkend='gpos.toXML_6'/>;       break; }
      case 7: { contextualLookupToXML (conf, stOffset, counts); break; }
      case 8: { chainingLookupToXML (conf, stOffset, counts);   break; }
      case 9: { extensionLookupToXML (conf, stOffset, counts);  break; }}
  }

  public void lookupSubtableOffsetToXML (DecompilerConfig conf, int stOffset,
                                         int [] counts,
                                         int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] != 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "name", "name", "CDATA",
                       lookupNames [lookupType] + "Table_"
		         + Integer.toHexString (stOffset));
      conf.ch.element (lookupNames [lookupType], at); }

    else {
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType], new AttributesImpl (),
			       lookupType); }
  }

  public void lookupSubtableToXMLEmit (DecompilerConfig conf,
                                       int stOffset, int[] counts,
 				       String element, AttributesImpl at,
                                       int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "format", "format", "CDATA",
                     "" + getuint16 (stOffset));
    conf.ch.startElement (element, at); {
      switch (lookupType) {
        case 1: { <code-include linkend='gpos.toXMLEmit_1'/>;       break; }
        case 2: { <code-include linkend='gpos.toXMLEmit_2'/>;       break; }
	case 3: { <code-include linkend='gpos.toXMLEmit_3'/>;       break; }
	case 4: { <code-include linkend='gpos.toXMLEmit_4'/>;       break; }
	case 5: { <code-include linkend='gpos.toXMLEmit_5'/>;       break; }
	case 6: { <code-include linkend='gpos.toXMLEmit_6'/>;       break; }
	case 7: { contextualLookupToXMLEmit (conf, stOffset, counts); break; }
	case 8: { chainingLookupToXMLEmit (conf, stOffset, counts);   break; }
	case 9: { extensionLookupToXMLEmit (conf, stOffset, counts);  break; }}
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Since each table (<ottable>GSUB</ottable>,
          <ottable>GPOS</ottable>) defines different lookup subtables,
          we need to defer the application of a subtable to the
          corresponding classes. We encapsulate this operation in a
          method that applies a given subtable to a given position of
          a glyphrun.</para>

	<para>This method returns a complex result. The boolean
          <varname>applied</varname> is true iff the glyphrun matched
          the pattern of the subtable. If true, then the two other
          fields are defined: <varname>nextToProcess</varname> is the
          next glyph to process, and <varname>countAdjust</varname> is
          the difference between the number of glyphs after
          application and the number of glyph before application.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>LookupResult class</code-title>
  static public class LookupResult {
    public boolean applied;
    public int nextToProcess;
    public int countAdjust;

    public LookupResult (boolean applied, int nextToProcess, int countAdjust) {
      this.applied = applied;
      this.nextToProcess = nextToProcess;
      this.countAdjust = countAdjust;
    }
  }

  static public LookupResult lookupNotApplied = new LookupResult (false, 0, 0);
</code-fragment>

	<para>And is the declaration for applyLookupSubtable:</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to apply a lookup subtable at a glyph position</code-title>
  abstract public LookupResult applyLookupSubtable
              (int lookupIndex, int lookupType,
               int lookupFlag, int stOffset,
               GlyphRun gr, int curGlyph)
      throws InvalidFontException;
</code-fragment>

        <para>From there, we can apply a given lookup to a given
          position in a glyph run. It's simply a matter of trying each
          subtable in turn, until one succeeds. This method returns
          a <varname>LookupResult</varname>.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to apply a lookup at a glyph position</code-title>

  public LookupResult applyLookup (int lookupIndex, GlyphRun gr, int curGlyph)
    throws InvalidFontException {

    if (listener != null) {
      listener.applyingLookupAtPos (lookupIndex, gr, curGlyph); }

    try {
      int lookupOffset = getLookupOffset (lookupIndex);

      int lookupType = getuint16 (lookupOffset);
      int lookupFlag = getuint16 (lookupOffset + 2);
      int subtableCount = getuint16 (lookupOffset + 4);


      if (lookupFlagCovers (lookupFlag, gr.glyphAt (curGlyph))) {
        if (listener != null) {
          listener.noSubtableApplied (lookupIndex, gr, curGlyph); }
        return lookupNotApplied; }

      for (int st = 0; st &lt; subtableCount; st++) {
        int stOffset
          = lookupOffset + getOffset (lookupOffset + 6 + 2*st);

        LookupResult result = applyLookupSubtable (lookupIndex,
	                          lookupType, lookupFlag,
                                  stOffset, gr, curGlyph);
        if (result.applied) {
          return result; }}

      // no subtable worked, just move to the next glyph
      if (listener != null) {
        listener.noSubtableApplied (lookupIndex, gr, curGlyph); }

      return lookupNotApplied; }

    finally {
      if (listener != null) {
        listener.applyingLookupAtPosDone (lookupIndex, gr, curGlyph); }}
  }
</code-fragment>

        <para>Finally, we can apply a bunch of features to a glyph
          run:</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Apply features to a glyphrun</code-title>
  public void applyFeatures (long scriptTag, long langSysTag,
                             long []featureTags, GlyphRun gr)
      throws InvalidFontException {
    applyFeatures (scriptTag, langSysTag, featureTags,
                   gr, 0, gr.glyphCount () - 1);
  }

  public void applyFeatures (long scriptTag, long langSysTag,
                             long []featureTags, GlyphRun gr,
	                     int start, int stop)
      throws InvalidFontException {

    int[] lookupIndices = findLookups (scriptTag, langSysTag, featureTags);

    if (listener != null) {
      listener.selectedLookups (lookupIndices); }

    for (int l = 0; l &lt; lookupIndices.length; l++) {
      if (listener != null) {
        listener.applyingLookup (lookupIndices [l], gr); }
      int curGlyph = start;
      while (curGlyph &lt;= stop) {
        LookupResult result = applyLookup (lookupIndices [l], gr, curGlyph);
        if (result.applied) {
          curGlyph = result.nextToProcess;
          stop += result.countAdjust; }
        else {
          curGlyph++; }}
      if (listener != null) {
        listener.applyingLookupDone (lookupIndices [l], gr); }}
  }
</code-fragment>

        <para>When we apply a lookup, we will need to know if LookupFlag
          covers a glyph or not.</para>

<code-fragment id='layouttable.methods'>
  <code-title>Method to find if lookupFlag covers a glyph</code-title>
  public boolean lookupFlagCovers (int lookupFlag, int glyph)
    throws InvalidFontException {

    if (glyph == -1) {
      return false; }

    if ((lookupFlag &amp; 0x0E) != 0) {
      int glyphClass = font.gdef.getGlyphClass (glyph);
      if (   ((lookupFlag &amp; 0x2) != 0 &amp;&amp; glyphClass == 1)
          || ((lookupFlag &amp; 0x4) != 0 &amp;&amp; glyphClass == 2)
          || ((lookupFlag &amp; 0x8) != 0 &amp;&amp; glyphClass == 3))
        return true; }

    if (   (lookupFlag &amp; 0xff00) != 0
        &amp;&amp; font.gdef.getGlyphClass (glyph) == 3) {
      int markClass = font.gdef.getMarkAttachClass (glyph);
      if (((lookupFlag &amp; 0xff00) >> 8) != markClass) {
        return true; }}

    return false;
  }
</code-fragment>

      </section>
      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

	<section>
	  <title>LookupFlag</title>

	  <para>Testing the behavior of lookupFlag on every single
	  type of lookup would be an enormous tasks. In fact, it is
	  likely that the behaviour of lookupFlag is implemented in
	  our place (like our <function>lookupFlagCovers</function>
	  method above) and is used everywhere. So all our testing is
	  done using the simplest lookup type that is convenient to
	  reach the behaviour, LigatureSubstitutions.</para>

	  <para>Let&#x2019;s start by making sure that those work
	  reasonably well:</para>

<aots:test-font id='lookupflag_ignore_base_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
	<class classID='1' glyphs='24 25'/>
    </glyphClassDef>
  </GDEF>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
	<lookup id='lookup.test' type='4' ignoreBaseGlyphs="yes">
	  <ligatureSubst format='1'>
	    <coverage glyphs='18' format='any'/>
	    <subst in='18 19 20' out='23'/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <para>First, let&#x2019;s make sure we get the ligating
          behaviour even when no glyphs have to be skipped:</para>

	  <aots:gsub-test
	   id='lookupflag_ignore_base_t1' font='lookupflag_ignore_base_f1'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 23,         21'/>

	  <para>Let&#x2019;s skip a few glyphs:</para>

	  <aots:gsub-test
	   id='lookupflag_ignore_base_t2' font='lookupflag_ignore_base_f1'
	   inputs ='17, 18, 24, 24, 19, 25, 20, 21'
	   outputs='17, 23, 24, 24,     25,     21'/>

	  <para>Let&#x2019;s try ignoring ligatures:</para>

<aots:test-font id='lookupflag_ignore_ligatures_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
	<class classID='1' glyphs='24 25'/>
	<class classID='2' glyphs='26 27'/>
	<class classID='3' glyphs='28 29'/>
    </glyphClassDef>
  </GDEF>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
	<lookup id='lookup.test' type='4' ignoreLigatures="yes">
	  <ligatureSubst format='1'>
	    <coverage glyphs='18' format='any'/>
	    <subst in='18 19 20' out='23'/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='lookupflag_ignore_ligatures_t1'
	   font='lookupflag_ignore_ligatures_f1'
	   inputs ='17, 18, 26, 27, 19, 27, 20, 21'
	   outputs='17, 23, 26, 27,     27,     21'/>

	  <para>Let&#x2019;s not skip some glyphs in the other classes:</para>

          <aots:gsub-test
	   id='lookupflag_ignore_ligatures_t2'
	   font='lookupflag_ignore_ligatures_f1'
	   inputs ='17, 18, 26, 24, 19, 27, 20, 21'
	   outputs='17, 18, 26, 24, 19, 27, 20, 21'/>

	  <para>... including in class 0, which is always a bit special:</para>

          <aots:gsub-test
	   id='lookupflag_ignore_ligatures_t3'
	   font='lookupflag_ignore_ligatures_f1'
	   inputs ='17, 18, 26, 42, 19, 27, 20, 21'
	   outputs='17, 18, 26, 42, 19, 27, 20, 21'/>

	  <para>Let&#x2019;s try ignoring marks:</para>

<aots:test-font id='lookupflag_ignore_marks_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
	<class classID='1' glyphs='24 25'/>
	<class classID='2' glyphs='26 27'/>
	<class classID='3' glyphs='28 29'/>
    </glyphClassDef>
  </GDEF>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
	<lookup id='lookup.test' type='4' ignoreMarks="yes">
	  <ligatureSubst format='1'>
	    <coverage glyphs='18' format='any'/>
	    <subst in='18 19 20' out='23'/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='lookupflag_ignore_marks_t1' font='lookupflag_ignore_marks_f1'
	   inputs ='17, 18, 28, 29, 19, 29, 20, 21'
	   outputs='17, 23, 28, 29,     29,     21'/>

	  <para>Let&#x2019;s try ignoring marks by their attachment
	  class. Remember the discussion about base glyphs in the
	  annotations. Glyphs 10...15 are base glyphs, 20...24 are marks of one
	  class, and 25...29 are marks of another class. We want to
	  ligate 11, 13 and 26 into 15.</para>

<aots:test-font id='lookupflag_ignore_attach_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
	<class classID='1' glyphs='10 11 12 13 14 '/>
	<class classID='2' glyphs='15'/>
	<class classID='3' glyphs='20 21 22 23 24 25 26 27 28 29'/>
    </glyphClassDef>
    <markAttachClassDef format='any'>
	<class classID='1' glyphs='20 21 22 23 24'/>
	<class classID='2' glyphs='25 26 27 28'/>
    </markAttachClassDef>
  </GDEF>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
	<lookup id='lookup.test' type='4' markAttachmentType="2">
	  <ligatureSubst format='1'>
	    <coverage glyphs='11' format='any'/>
	    <subst in='11 13 26' out='15'/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <para>First, let&#x2019;s make sure the ligature works.</para>

          <aots:gsub-test
	   id='lookupflag_ignore_attach_t1' font='lookupflag_ignore_attach_f1'
	   inputs ='10, 11, 13, 26, 10'
	   outputs='10, 15,         10'/>

	  <para>Let&#x201D;s inject class 0 and 1 marks, which should be
	  skipped.</para>

          <aots:gsub-test
	   id='lookupflag_ignore_attach_t2' font='lookupflag_ignore_attach_f1'
	   inputs ='10, 11, 21, 13, 22, 23, 29, 26, 10'
	   outputs='10, 15, 21,     22, 23, 29,     10'/>

	  <para>Let&#x2019;s inject class 2 marks, which should
	  prevent the ligature</para>

          <aots:gsub-test
	   id='lookupflag_ignore_attach_t3' font='lookupflag_ignore_attach_f1'
	   inputs ='10, 11, 21, 13, 22, 27, 26, 10'
	   outputs='10, 11, 21, 13, 22, 27, 26, 10'/>

          <aots:gsub-test
	   id='lookupflag_ignore_attach_t4' font='lookupflag_ignore_attach_f1'
	   inputs ='10, 11, 27, 13, 22, 23, 26, 10'
	   outputs='10, 11, 27, 13, 22, 23, 26, 10'/>

	  <para>So do other base</para>

          <aots:gsub-test
	   id='lookupflag_ignore_attach_t5' font='lookupflag_ignore_attach_f1'
	   inputs ='10, 11, 27, 13, 14, 23, 26, 10'
	   outputs='10, 11, 27, 13, 14, 23, 26, 10'/>

	  <para>And of course, we have combinations!</para>

<aots:test-font id='lookupflag_ignore_combination_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
	<class classID='1' glyphs='24 25 26'/>
	<class classID='2' glyphs='27 28 29'/>
	<class classID='3' glyphs='30 31 32'/>
    </glyphClassDef>
    <markAttachClassDef format='any'>
	<class classID='1' glyphs='25 28 31 34'/>
	<class classID='2' glyphs='26 29 32 35'/>
    </markAttachClassDef>
  </GDEF>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
	<lookup id='lookup.test' type='4'
		ignoreBaseGlyphs="yes" markAttachmentType="2">
	  <ligatureSubst format='1'>
	    <coverage glyphs='18' format='any'/>
	    <subst in='18 19 20' out='23'/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='lookupflag_ignore_combination_t1'
	   font='lookupflag_ignore_combination_f1'
	   inputs ='17, 18, 26, 19, 20, 21'
	   outputs='17, 23, 26,        21'/>

          <aots:gsub-test
	   id='lookupflag_ignore_combination_t2'
	   font='lookupflag_ignore_combination_f1'
	   inputs ='17, 18, 26, 19, 24, 30, 31, 20, 21'
	   outputs='17, 23, 26,     24, 30, 31,     21'/>

          <aots:gsub-test
	   id='lookupflag_ignore_combination_t3'
	   font='lookupflag_ignore_combination_f1'
	   inputs ='17, 18, 26, 19, 24, 30, 32, 20, 21'
	   outputs='17, 18, 26, 19, 24, 30, 32, 20, 21'/>

	</section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Coverage Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Each subtable (except an Extension LookupType subtable)
          in a lookup references a Coverage table (Coverage), which
          specifies all the glyphs affected by a substitution or
          positioning operation described in the subtable. The
          <ottable>GSUB</ottable>, <ottable>GPOS</ottable>, and
          <ottable>GDEF</ottable> tables rely on this notion of
          coverage. If a glyph does not appear in a Coverage table,
          the client can skip that subtable and move immediately to
          the next subtable.</para>

        <para>A Coverage table identifies glyphs by glyph indices
          (GlyphIDs) either of two ways:</para>

        <itemizedlist>
          <listitem>
            <para>As a list of individual glyph indices in the glyph
              set.</para>
          </listitem>
          <listitem>
            <para>As ranges of consecutive indices. The range format
              gives a number of start-glyph and end-glyph index pairs
              to denote the consecutive glyphs covered by the
              table.</para>
          </listitem>
        </itemizedlist>

        <para>In a Coverage table, a format code (CoverageFormat)
          specifies the format as an integer: 1 = lists, and 2 =
          ranges.</para>

        <para>A Coverage table defines a unique index value (Coverage
          Index) for each covered glyph. This unique value specifies
          the position of the covered glyph in the Coverage table. The
          client uses the Coverage Index to look up values in the
          subtable for each glyph.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The specification does not mention a fairly interesting
          property of the existing subtable formats: A coverage is
          really a subset of n glyphs of the font, and those glyphs
          are enumerated in glyph index order by the Coverage Index<!--  -->
          (i.e. CI(0) is the glyph with the smallest glyph id in that
          subset, CI(1) is the next, and so on to CI(n-1) which is the
          glyph with the largest glyph id).</para>

        <para>It is possible that a new coverage be defined for which
          this property does not hold. However, this seems unlikely,
          and we will assume that the property will always
          hold. Recommendation: make that clear in the
          specification.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a coverage, but instead
	  would prefer the compiler to figure out the best
	  representation. For this purpose, we use the observation in
	  our annotations, and represent two attributes:
	  <sgmltag>format</sgmltag> with the value
	  <sgmltag>any</sgmltag> and <sgmltag>glyphs</sgmltag> to hold
	  the list of covered glyphs:</para>

<code-fragment id='schema'>
  <code-title>coverageTable</code-title>
  coverageTable |=
    attribute format { "any" },
    attribute glyphs { text }

  standaloneCoverageTable =
    element coverageTable { attribute id { text }, coverageTable }

  coverageTableOffset = attribute name { text } | coverageTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment package='com.adobe.aots.opentype' class='CoverageTableBlock'>
package com.adobe.aots.opentype;

public class CoverageTableBlock extends Block {
  public CoverageTableBlock (int size, int referenceCount) {
    super (size, referenceCount);
  }

  public int[] glyphs;

  public int index (int gid) {
    for (int ci = 0; ci &lt; glyphs.length; ci++) {
      if (glyphs [ci] == gid) {
        return ci; }}
    return -1;
  }
}
</code-fragment>


<code-fragment id='layouttable.methods'>
  public CoverageTableBlock coverageFromXML (Element t,
                                             Element table,
					     Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { CoverageTableBlock cached = (CoverageTableBlock) blockCache.get (t);
      if (cached != null) {
        return cached; }}

    CoverageTableBlock me = null;

    String format = t.getAttribute ("format");

    if ("any".equals (format)) {
      me = coverageFromGlyphs (getGlyphs (t.getAttribute ("glyphs"))); }
    else if ("1".equals (format)) {
      me = coverageFormat1FromXML (t, table, blockCache); }
    else if ("2".equals (format)) {
      me = coverageFormat2FromXML (t, table, blockCache); }
    else {
      /* cannot get there on valid document */
      throw new InvalidFontException
                 ("invalid coverage format (" + format + ")"); }

    blockCache.put (t, me);
    return me;
  }


  public CoverageTableBlock emptyCoverage () {
    return coverageFromGlyphs (new int[0], 0);
  }

  public CoverageTableBlock coverageFromGlyphs (int [] glyphs) {
    return coverageFromGlyphs (glyphs, glyphs.length);
  }

  public CoverageTableBlock coverageFromGlyphs (Integer [] glyphs) {
    return coverageFromGlyphs (glyphs, glyphs.length);
  }

  public CoverageTableBlock coverageFromGlyphs (Integer [] glyphs, int count) {
    int[] g = new int [count];
    for (int i = 0; i &lt; count; i++) {
      g[i] = glyphs[i].intValue (); }
    return coverageFromGlyphs (g, count);
  }

  public CoverageTableBlock coverageFromGlyphs (int [] glyphs, int count) {
    CoverageTableBlock table = new CoverageTableBlock (4 + 2*count, 0);
    table.glyphs = new int [count];
    System.arraycopy (glyphs, 0, table.glyphs, 0, count);

    for (int i = 0; i &lt; count - 1; i++) {
      for (int j = i + 1; j &lt; count; j++) {
        if (table.glyphs [i] > table.glyphs [j]) {
          int temp = table.glyphs [i];
          table.glyphs [i] = table.glyphs [j];
          table.glyphs [j] = temp; }}}

    table.setuint16 (0, 1);
    table.setuint16 (2, count);
    for (int i = 0; i &lt; count; i++) {
      table.setGlyphID (4 + 2*i, table.glyphs [i]); }

    return table;
  }
</code-fragment>

        <para>This method is given a nodelist, which must contains
        Elements only. Each element in the list must have the
        attribute <varname>attribute</varname>, the value of which is
        a sequence of glyph references. The coverage is built by
        taking the first glyph reference in each attribute (if
        firstOnly is true) or all the glyphs references (if firstOnly
        is false).</para>

<code-fragment id='layouttable.methods'>
  public CoverageTableBlock coverageFromXML (NodeList nl, String attribute)
      throws InvalidFontException, UnsupportedFontException {
    return coverageFromXML (nl, attribute, true);
  }

  public CoverageTableBlock coverageFromXML (NodeList nl, String attribute,
                                             boolean firstOnly)
      throws InvalidFontException, UnsupportedFontException {

    SortedSet&lt;Integer> s = new TreeSet&lt;Integer> ();

    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element e = (Element) nl.item (i);
      String v = e.getAttribute (attribute).trim ();
      if (e.hasAttribute (attribute)) {
        int[] gids = parseGlyphList (v);
        int count = firstOnly ? 1 : gids.length;
        for (int j = 0; j &lt; count; j++) {
          s.add (gids [j]); }}}

    int [] glyphs = new int [s.size ()];
    int glyphCount = 0;

    for (int gid : s) {
       glyphs [glyphCount++] = gid; }

    return coverageFromGlyphs (glyphs);
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='layouttable.methods'>
  public void coverageTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void coverageTableOffsetToXML (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "coverageTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      coverageTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void coverageTableToXML (DecompilerConfig conf, int offset,
                                  int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "coverageTable_" + Integer.toHexString (offset));
      coverageTableToXMLEmit (conf, offset, counts, "coverageTable", at);
      counts [offset] = 0; }
  }

  public void coverageTableToXMLEmit (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (conf.preciseCoverageFormat) {
      int format = getuint16 (offset);
      at.addAttribute ("", "format", "format", "CDATA", "" + format);
      switch (format) {
        case 1: { <code-include linkend='LayoutTable.coverageToXML.1'/>; break; }
        case 2: { <code-include linkend='LayoutTable.coverageToXML.2'/>; break; }}}

    else {
      int[] glyphs = getCoveredGlyphs (offset);
      StringBuilder sb = new StringBuilder ();

      if (conf.glyphNames != null) {
        for (int i = 0; i &lt; glyphs.length; i++) {
          glyphToXML (conf, sb, glyphs [i]); }}

      else {
        int i = 0;
        while (i &lt; glyphs.length) {
          int start = glyphs [i];
          int stop = start;
          i++;

          while (i &lt; glyphs.length &amp;&amp; (glyphs [i] == glyphs [i-1] + 1)) {
    	    stop = glyphs [i];
            i++; }

          if (start &lt; stop) {
            sb.append (" ");
	    sb.append (start);
            sb.append (":");
	    sb.append (stop); }
          else {
            sb.append (" ");
	    sb.append (start); }}}

        at.addAttribute ("", "format", "format", "CDATA", "any");
        at.addAttribute ("", "glyphs", "glyphs", "CDATA", sb.toString ());
        conf.ch.element (element, at); }
  }


  public int[] coverageToXMLDetailed (DecompilerConfig conf, int offset)
      throws org.xml.sax.SAXException {

    return null;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Getting a little bit ahead of the specification, we note
          that in all formats, a subtable starts with a uint16, which
          indicates its format.</para>

        <para>The first interesting operation on a coverage is to
          determine if a given glyph is covered;</para>

<!--
<code-method-decl id='layouttable.methods>
  <code-signature>
    <code-visible>protected</code-visible>
    <code-name>getCoverageIndex</code-name>

    <code-args>
      <code-arg>
        <code-type>int</code-type>
        <code-name>glyphID</code-name>
        <code-desc>The glyph for which the coverage index is
        desired</code-desc>
      <code-arg>
      <code-arg>
        <code-type>int</code-type>
        <code-name>coverageOffset</code-name>
        <code-desc>The offset of the coverage table to use, in the
        current table</code-desc>
      </code-arg>
    </code-args>

    <code-exceptions>
      <code-exception>
        <code-name>InvalidFontException</code-name>
        <code-desc>if the font cannot be parsed</code-desc>
      </code-exception>
    </code-exceptions>

    <code-return>
      <code-type>int</code-type>
      <code-desc>-1 if the glyph is not covered; otherwise its
      coverage index</code-desc>
    </code-return>
  <code-signature>

  <code-desc>Returns the coverage index of <varname>glyphID</varname>
  using the coverage table at
  <varname>coverageOffset</varname>.</code-desc>

  <code-body>
    int format = getuint16 (coverageOffset);

    switch (format) {
      case 1: { <code-include linkend='LayoutTable_getCoverageIndex1'/> }
      case 2: { <code-include linkend='LayoutTable_getCoverageIndex2'/> }
      default: throw new InvalidFontException (); }
  </code-body>

</code-method-decl>
-->



<code-fragment id='layouttable.methods'>
  <code-title>Method to get the coverage index of a glyph</code-title>
  /**
   * Returns the coverage index of glyphID using the coverage at
   * coverageOffset. If the glyph is not covered, returns -1.
   *
   * @param glyphID
   * @param coverageOffset the offset the coverage table in the current table
   * @return -1 if the glyph is not covered, its coverage index  otherwise.
   * @exception InvalidFontException
   *             if the font cannot be parsed.
   */
  protected int getCoverageIndex (int glyphID, int coverageOffset)
      throws InvalidFontException {

    if (glyphID == -1) {
      return -1; }

    int format = getuint16 (coverageOffset);

    switch (format) {
      case 1: { <code-include linkend='LayoutTable_getCoverageIndex1'/> }
      case 2: { <code-include linkend='LayoutTable_getCoverageIndex2'/> }
      default: throw new InvalidFontException (); }
  }
</code-fragment>

        <para>Another interesting operation is to enumerate all the
          covered glyphs:</para>

<code-fragment id='layouttable.methods'>
  <code-title>Method to get the glyphs covered by a Coverage Table</code-title>
  /**
   * Returns the glyphs covered by the coverage at
   * coverageOffset.
   *
   * @param coverageOffset the offset the coverage table in the current table
   * @return an array of glyphIDs. The coverage index of a glyph is
   *         its position in the array
   * @exception InvalidFontException
   *             if the font cannot be parsed.
   */
  protected int[] getCoveredGlyphs (int coverageOffset)
      throws InvalidFontException {

    int format = getuint16 (coverageOffset);

    switch (format) {
      case 1: { <code-include linkend='LayoutTable_getCoveredGlyphs1'/> }
      case 2: { <code-include linkend='LayoutTable_getCoveredGlyphs2'/> }
      default: throw new InvalidFontException (); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Coverage Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Coverage Format 1 consists of a format code
          (CoverageFormat) and a count of covered glyphs (GlyphCount),
          followed by an array of glyph indices (GlyphArray). The
          glyph indices must be in numerical order for binary
          searching of the list. When a glyph is found in the Coverage
          table, its position in the GlyphArray determines the
          Coverage Index that is returned-the first glyph has a
          Coverage Index = 0, and the last glyph has a Coverage Index
          = GlyphCount -1.</para>

        <para>Example 5 at the end of this chapter shows a Coverage
          table that uses Format 1 to list the GlyphIDs of all
          lowercase descender glyphs in a font.</para>

        <otformat>
          <title>CoverageFormat1 table: Individual glyph
          indices</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CoverageFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the
              GlyphArray</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>GlyphArray [GlyphCount]</otfieldname>
            <otfielddesc>Array of GlyphIDs-in numerical
              order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>coverageTable, format 1</code-title>
  coverageTable |=
    attribute format { "1" },
    attribute glyphs { text }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='layouttable.methods'>
  public CoverageTableBlock coverageFormat1FromXML (Element t,
                                                    Element table,
                                                    Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    return coverageFromGlyphs (getGlyphs (t.getAttribute ("glyphs")));
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.coverageToXML.1'>
  { StringBuilder sb = new StringBuilder ();
    int glyphCount = getuint16 (offset + 2);
    int firstGlyph = -1;
    int lastGlyph = -2;

    for (int i = 0; i &lt; glyphCount; i++) {
      int glyphID = getuint16 (offset + 4 + 2*i);
      if (glyphID == lastGlyph + 1) {
        lastGlyph = glyphID; }
      else {
        if (lastGlyph > firstGlyph) {
          sb.append (" " + firstGlyph + ":" + lastGlyph); }
        else if (lastGlyph == firstGlyph) {
          sb.append (" " + lastGlyph); }
        firstGlyph = lastGlyph = glyphID; }}

    if (lastGlyph > firstGlyph) {
      sb.append (" " + firstGlyph + ":" + lastGlyph); }
    else if (lastGlyph == firstGlyph) {
      sb.append (" " + lastGlyph); }

    at.addAttribute ("", "glyphs", "glyphs", "CDATA", sb.toString ());

    conf.ch.element (element, at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Here is our binary search to compute the coverage index
          of a glyph. The loop invariant is that a glyph is in the
          GlyphArray iff its position in it is between min and max
          (included).</para>

<code-fragment id='LayoutTable_getCoverageIndex1'>
  <code-title>Return the coverage index for a format 1 Coverage table</code-title>
  { int min = 0;
    int max = getuint16 (coverageOffset + 2) - 1;

    while (min &lt;= max) {
      int mid = (min + max) / 2;
      int g = getGlyphID (coverageOffset + 4 + 2*mid);

      if (glyphID &lt; g) {
        max = mid - 1; }
      else if (g &lt; glyphID) {
        min = mid + 1; }
      else {
        return mid; }}

    return -1; }
</code-fragment>

        <para>Building the list of covered glyphs is straithforward:</para>

<code-fragment id='LayoutTable_getCoveredGlyphs1'>
  <code-title>Return the glyphs covered by a format 1 Coverage table</code-title>
  { int glyphCount = getuint16 (coverageOffset + 2);
    int[] glyphs = new int [glyphCount];
    for (int i = 0; i &lt; glyphCount; i++) {
      glyphs [i] = getGlyphID (coverageOffset + 4 + 2*i); }
    return glyphs; }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Coverage Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 2 consists of a format code (CoverageFormat) and
          a count of glyph index ranges (RangeCount), followed by an
          array of records (RangeRecords). Each RangeRecord consists
          of a start glyph index (Start), an end glyph index (End),
          and the Coverage Index associated with the range's Start
          glyph. Ranges must be in GlyphID order, and they must be
          distinct, with no overlapping.</para>

        <para>The Coverage Indexes for the first range begin with zero
          (0), and the Start Coverage Indexes for each succeeding
          range are determined by adding the length of the preceding
          range (End GlyphID - Start GlyphID + 1) to the array Index.
          This allows for a quick calculation of the Coverage Index
          for any glyph in any range using the formula: Coverage Index
          (GlyphID) = StartCoverageIndex + GlyphID - Start
          GlyphID.</para>

        <para>Example 6 at the end of this chapter shows a Coverage
          table that uses Format 2 to identify a range of numeral
          glyphs in a font.</para>


        <otformat>
          <title>CoverageFormat2 table: Range of glyphs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CoverageFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>RangeCount</otfieldname>
            <otfielddesc>Number of RangeRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>RangeRecord [RangeCount]</otfieldname>
            <otfielddesc>Array of glyph ranges-ordered by Start
              GlyphID</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>RangeRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Start</otfieldname>
            <otfielddesc>First GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>End</otfieldname>
            <otfielddesc>Last GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>StartCoverageIndex</otfieldname>
            <otfielddesc>Coverage Index of first GlyphID in
              range</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>coverageTable, format 2</code-title>
  coverageTable |=
    attribute format { "2" },
    element range {
      attribute start { text },
      attribute end { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='layouttable.methods'>
  public CoverageTableBlock coverageFormat2FromXML (Element t,
                                                    Element table,
                                                    Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    NodeList ranges = t.getChildNodes ();
    int nbRanges = ranges.getLength ();

    CoverageTableBlock me = new CoverageTableBlock (4 + 6*nbRanges, 0);
    me.setuint16 (0, 2);
    me.setuint16 (2, nbRanges);
    int ci = 0;
    for (int r = 0; r &lt; nbRanges; r++) {
      Element range = (Element) ranges.item (r);
      int start = Integer.parseInt (range.getAttribute ("start"));
      int end = Integer.parseInt (range.getAttribute ("end"));
      me.setGlyphID (4 + 6*r, start);
      me.setGlyphID (4 + 6*r+2, end);
      me.setuint16 (4 + 6*r+4, ci);
      ci += (end - start + 1); }

    me.glyphs = new int [ci];
    ci = 0;
    for (int r = 0; r &lt; nbRanges; r++) {
      Element range = (Element) ranges.item (r);
      int start = Integer.parseInt (range.getAttribute ("start"));
      int end = Integer.parseInt (range.getAttribute ("end"));
      for (int k = start; k &lt;= end; k++) {
        me.glyphs [ci++] = k; }}

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.coverageToXML.2'>
  { conf.ch.startElement (element, at); {

      int rangeCount = getuint16 (offset + 2);
      for (int i = 0; i &lt; rangeCount; i++) {
        int start = getuint16 (offset + 4 + 6*i);
        int end = getuint16 (offset + 4 + 6*i + 2);
        at = new AttributesImpl ();
        at.addAttribute ("", "start", "start", "CDATA", "" + start);
        at.addAttribute ("", "end", "end", "CDATA", "" + end);
        conf.ch.element ("range", at); }

      conf.ch.endElement (element); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We use a binary search on the RangeRecords to find the
          coverage index of a glyph. The loop invariant is that a
          glyph is covered iff the index of the RangeRecord in which
          it occurs is between min and max (included).</para>

<code-fragment id='LayoutTable_getCoverageIndex2'>
  <code-title>Return the coverage index for a format 2 Coverage table</code-title>
  { int min = 0;
    int max = getuint16 (coverageOffset + 2) - 1;

    while (min &lt;= max) {
      int mid = (min + max) / 2;
      int start = getGlyphID (coverageOffset + 4 + 6*mid);
      int stop = getGlyphID (coverageOffset + 4 + 6*mid + 2);

      if (glyphID &lt; start) {
        max = mid - 1; }
      else if (stop &lt; glyphID) {
        min = mid + 1; }
      else {
        return getuint16 (coverageOffset + 4 + 6*mid + 4)
                 + (glyphID - start); }}

    return -1; }
</code-fragment>

        <para>We can compute the number of covered glyphs by first
          computing the coverage index of the last covered
          glyph.</para>

<code-fragment id='LayoutTable_getCoveredGlyphs2'>
  <code-title>Return the glyphs covered by a format 2 Coverage table</code-title>
  { int rangeCount = getuint16 (coverageOffset + 2);

    int lastRangeStart = getGlyphID (coverageOffset + 4 + 6*(rangeCount-1));
    int lastRangeEnd = getGlyphID (coverageOffset + 4 + 6*(rangeCount-1) + 2);
    int lastRangeStartCI = getuint16 (coverageOffset + 4 + 6*(rangeCount-1) + 4);
    int glyphCount = lastRangeStartCI + (lastRangeEnd - lastRangeStart) + 1;

    int[] glyphs = new int [glyphCount];

    for (int r = 0; r &lt; rangeCount; r++) {
      int start = getGlyphID (coverageOffset + 4 + 6*r);
      int stop = getGlyphID (coverageOffset + 4 + 6*r + 2);
      int ci = getuint16 (coverageOffset + 4 + 6*r + 4);
      for (int g = start; g &lt;= stop; g++) {
        glyphs [ci] = g;
        ci++; }}

    return glyphs; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class Definition Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>In OpenType Layout, index values identify glyphs. For
          efficiency and ease of representation, a font developer can
          group glyph indices to form glyph classes. Class assignments
          vary in meaning from one lookup subtable to another. For
          example, in the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables, classes are used to describe
          glyph contexts. <ottable>GDEF</ottable> tables also use the
          idea of glyph classes.</para>

        <para>Consider a substitution action that replaces only the
          lowercase ascender glyphs in a glyph string. To more easily
          describe the appropriate context for the substitution, the
          font developer might divide the font's lowercase glyphs into
          two classes, one that contains the ascenders and one that
          contains the glyphs without ascenders.</para>

        <para>A font developer can assign any glyph to any class, each
          identified with an integer called a class value. A Class
          Definition table (ClassDef) groups glyph indices by class,
          beginning with Class 1, then Class 2, and so on. All glyphs
          not assigned to a class fall into Class 0. Within a given
          class definition table, each glyph in the font belongs to
          exactly one class.</para>

        <para>The ClassDef table can have either of two formats: one
          that assigns a range of consecutive glyph indices to
          different classes, or one that puts groups of consecutive
          glyph indices into the same class.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a class definition, but instead
	  would prefer the compiler to figure out the best
	  representation. In that case, the classes are just listed:</para>

<code-fragment id='schema'>
  <code-title>classDefTable, any format</code-title>
  classDefTable |=
    attribute format { "any" },
    element class {
      attribute classID { text },
      attribute glyphs { text }
    }*

  standaloneClassDefTable =
    element classDefTable { attribute id { text }, classDefTable }

  classDefTableOffset = attribute name { text } | classDefTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment package='com.adobe.aots.opentype' class='ClassdefTableBlock'>
package com.adobe.aots.opentype;

public class ClassdefTableBlock extends Block {
    public ClassdefTableBlock (int size, int referenceCount) {
      super (size, referenceCount);
    }

    public int classCount;
  }
</code-fragment>

<code-fragment id='layouttable.methods'>
  public ClassdefTableBlock classdefFromXML (Element classdef, Element table,
                                             Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = classdef.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        classdef = resolveXMLid (table, name); }}

    { ClassdefTableBlock cached = (ClassdefTableBlock) blockCache.get (classdef);
      if (cached != null) {
        return cached; }}

    String format = classdef.getAttribute ("format");


    ClassdefTableBlock me = null;

    if ("any".equals (format)) {
      me = classdefFormatAnyFromXML (classdef, table, blockCache); }
    else if ("1".equals (format)) {
      me = classdefFormat1FromXML (classdef, table, blockCache); }
    else if ("2".equals (format)) {
      me = classdefFormat2FromXML (classdef, table, blockCache); }
    else {
      /* cannot get there on valid document */
      throw new InvalidFontException
                 ("invalid classdef format (" + format + ")"); }

    blockCache.put (classdef, me);
    return me;
  }


  public ClassdefTableBlock classdefFormatAnyFromXML (Element classdef,
                                                      Element table,
                                                      Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    /*TODO: generate a format 1 if smaller; generate a better format2 */
    /*generate a format 2 */

    int highestClass = 0;

    NodeList classes = classdef.getChildNodes ();
    java.util.SortedMap&lt;Integer, Integer> map
         = new java.util.TreeMap&lt;Integer, Integer> ();
    for (int i = 0; i &lt; classes.getLength (); i++) {
      Element aclass = (Element) classes.item (i);
      int classID = Integer.parseInt (aclass.getAttribute ("classID"));
      int [] glyphs = getGlyphs (aclass.getAttribute ("glyphs"));
      if (glyphs.length != 0) {
        if (classID > highestClass) {
	  highestClass = classID; }}
      if (classID != 0) {
        for (int j = 0; j &lt; glyphs.length; j++) {
          map.put (glyphs [j], classID); }}}

    Integer[] glyphs = map.keySet ().toArray (new Integer [0]);

    ClassdefTableBlock me = new ClassdefTableBlock (4 + 6 * glyphs.length, 0);
    me.classCount = highestClass + 1;
    me.setuint16 (0, 2);
    me.setuint16 (2, glyphs.length);
    for (int i = 0; i &lt; glyphs.length; i++) {
      me.setGlyphID (4 + 6*i, glyphs [i].intValue ());
      me.setGlyphID (4 + 6*i + 2, glyphs [i].intValue ());
      me.setuint16 (4 + 6*i + 4, map.get (glyphs [i])); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='layouttable.methods'>
  public void classDefTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void classDefTableOffsetToXML (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "classDefTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      classDefTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void classDefTableToXML (DecompilerConfig conf, int offset,
                                  int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "classDefTable_" + Integer.toHexString (offset));
      classDefTableToXMLEmit (conf, offset, counts, "classDefTable", at);
      counts [offset] = 0; }
  }

  public void classDefTableToXMLEmit (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    switch (getuint16 (offset)) {
      <code-include linkend='LayoutTable.classDefTableToXMLEmit.cases'/>
      default: {
        throw new InvalidFontException ("illegal classdef format at offset "
                                        + offset + ": " + getuint16 (offset)); }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='layouttable.methods'>
  <code-title>Method to find the class index of a glyph</code-title>

  protected int classIndex (int glyph, int offset)
     throws InvalidFontException {

    if (glyph == -1) {
      return -1; }

    int format = getuint16 (offset);

    switch (format) {
      case 1: { <code-include linkend='sub_classIndex1'/> }
      case 2: { <code-include linkend='sub_classIndex2'/> }
      default: throw new InvalidFontException (); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

	<para>To test classDef table, we use contextual GSUB tests.
	Here are some base lookups:</para>

<code-fragment id='layout.test.classdef'>
  <code-title>?</code-title>
   <lookup id='inc_by_3' type='1'>
     <singleSubst format='1'>
	  <coverage format='any' glyphs='0:99'/>
	  <delta v='3'/>
     </singleSubst>
   </lookup>

   <lookup id='inc_by_4' type='1'>
     <singleSubst format='1'>
	  <coverage format='any' glyphs='0:99'/>
	  <delta v='4'/>
     </singleSubst>
   </lookup>

   <lookup id='inc_by_5' type='1'>
     <singleSubst format='1'>
	  <coverage format='any' glyphs='0:99'/>
	  <delta v='5'/>
     </singleSubst>
   </lookup>
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class Definition Table Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The first class definition format (ClassDefFormat1)
          specifies a range of consecutive glyph indices and a list of
          corresponding glyph class values. This table is useful for
          assigning each glyph to a different class because the glyph
          indices in each class are not grouped together.</para>

        <para>A ClassDef Format 1 table begins with a format
          identifier (ClassFormat). The range of glyph indices
          (GlyphIDs) covered by the table is identified by two values:
          the GlyphID of the first glyph (StartGlyph), and the number
          of consecutive GlyphIDs (including the first one) that will
          be assigned class values (GlyphCount). The ClassValueArray
          lists the class value assigned to each GlyphID, starting
          with the class value for StartGlyph and following the same
          order as the GlyphIDs. Any glyph not included in the range
          of covered GlyphIDs automatically belongs to Class 0.</para>

        <para>Example 7 at the end of this chapter uses Format 1 to
          assign class values to the lowercase, x-height, ascender,
          and descender glyphs in a font.</para>

        <otformat>
          <title>ClassDefFormat1 table: Class array</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>StartGlyph</otfieldname>
            <otfielddesc>First GlyphID of the ClassValueArray</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Size of the ClassValueArray</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassValueArray [GlyphCount]</otfieldname>
            <otfielddesc>Array of Class Values-one per GlyphID</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>classDefTable, format 1</code-title>
  classDefTable |=
    attribute format { "1" },
    attribute startGlyph { text },
    attribute classes    { text }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='layouttable.methods'>
  public ClassdefTableBlock classdefFormat1FromXML (Element classdef,
                                                    Element table,
                                                    Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    int startGlyph = Integer.parseInt (classdef.getAttribute ("startGlyph"));
    int[] classes = parseIntList (classdef.getAttribute ("classes"));

    ClassdefTableBlock me = new ClassdefTableBlock (6 + 2 * classes.length, 0);

    me.classCount = 0;
    for (int i = 0; i &lt; classes.length; i++) {
      me.classCount = Math.max (me.classCount, classes [i] + 1); }

    if (me.classCount == 0) {
      me.classCount = 1; } // we always have at least class 0.
    me.setuint16 (0, 1);
    me.setuint16 (2, startGlyph);
    me.setuint16 (4, classes.length);
    for (int i = 0; i &lt; classes.length; i++) {
      me.setGlyphID (6 + 2*i, classes [i]); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.classDefTableToXMLEmit.cases'>
  case 1: {
    int startGlyph = getGlyphID (offset + 2);
    int glyphCount = getuint16 (offset + 4);

    if (conf.preciseClassDefFormat) {
      at.addAttribute ("", "format", "format", "CDATA", "1");
      at.addAttribute ("", "startGlyph", "startGlyph", "CDATA", "" + startGlyph);
      StringBuilder sb = new StringBuilder ();
      for (int i = 0; i &lt; glyphCount; i++) {
        sb.append (" ");
        sb.append (getuint16 (offset + 6 + 2*i)); }
      at.addAttribute ("", "classes", "classes", "CDATA", sb.toString ());

      conf.ch.element (element, at); }

    else {
      at.addAttribute ("", "format", "format", "CDATA", "any");
      conf.ch.startElement (element, at); {

        StringBuilder sb = new StringBuilder ();

        // there are at most glyphCount classes
        for (int cl = 1; cl &lt;= glyphCount; cl++) {
          for (int glyph = 0; glyph &lt; glyphCount; glyph++) {
            if (cl == getuint16 (offset + 6 + 2*glyph)) {
              glyphToXML (conf, sb, startGlyph + glyph); }}

          if (sb.length () != 0) {
            at = new AttributesImpl ();
            at.addAttribute ("", "classID", "classID", "CDATA", "" + cl);
            at.addAttribute ("", "glyphs", "glyphs", "CDATA", sb.toString ());
            conf.ch.element ("class", at);
            sb.setLength (0); }}
        conf.ch.endElement (element); }}

    break; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='sub_classIndex1'>
  <code-title>Find class in format 1 and return it</code-title>
  { int startGlyph = getuint16 (offset + 2);
    int glyphCount = getuint16 (offset + 4);

    if (startGlyph &lt;= glyph &amp;&amp; glyph &lt; startGlyph + glyphCount) {
      return getuint16 (offset + 6 + (glyph - startGlyph)*2); }

    return 0; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

	<para>Our first test is a single range covering glyphs 18:20,
	which are incremented by 5.</para>

<aots:test-font id='classdef1_font1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>
      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='1' startGlyph='18' classes='1 1 1'/>
	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
        </contextual>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef1_single_range' font='classdef2_font1'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 23, 24, 25, 21'/>

	  <para>Next, we try the case where one class (1) has no
	  glyphs. Note that we include a transformation for that
	  class, to make sure that no glyphs are matched with that
	  class.</para>

<aots:test-font id='classdef1_font2'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>

      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='1' startGlyph='18' classes='2 2 2'/>

	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_4'/>
	  </pattern>
	  <pattern in='2'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef1_empty_class' font='classdef1_font2'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 23, 24, 25, 21'/>

	  <para>Our most complex case has with multiple
	  ranges. Two ranges are assigned to class 2, and a range is
	  assigned to class 0.</para>

<aots:test-font id='classdef1_font3'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>

      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='1' startGlyph='18'
             classes='2 2 2 0 1 1 1 0 0 0 0 2 0 0 0 1 1'/>
	  <pattern in='0'>
	    <apply pos='0' lookup='inc_by_3'/>
	  </pattern>
	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_4'/>
	  </pattern>
	  <pattern in='2'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef1_multiple_ranges' font='classdef1_font3'
	   inputs ='17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36'
	   outputs='20, 23, 24, 25, 24, 26, 27, 28, 28, 29, 30, 31, 34, 33, 34, 35, 37, 38, 38, 39'/>

	  <para>The empty definition.</para>

<aots:test-font id='classdef1_font4'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>

      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='1' startGlyph='18' classes=''/>

	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_4'/>
	  </pattern>
	  <pattern in='2'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef1_empty' font='classdef1_font4'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 18, 19, 20, 21'/>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Class Definition Table Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The second class definition format (ClassDefFormat2)
          defines multiple groups of glyph indices that belong to the
          same class. Each group consists of a discrete range of glyph
          indices in consecutive order (ranges cannot overlap).</para>

        <para>The ClassDef Format 2 table contains a format identifier
          (ClassFormat), a count of ClassRangeRecords that define the
          groups and assign class values (ClassRangeCount), and an
          array of ClassRangeRecords ordered by the GlyphID of the
          first glyph in each record (ClassRangeRecord).</para>

        <para>Each ClassRangeRecord consists of a Start glyph index,
          an End glyph index, and a Class value. All GlyphIDs in a
          range, from Start to End inclusive, constitute the class
          identified by the Class value. Any glyph not covered by a
          ClassRangeRecord is assumed to belong to Class 0.</para>

        <para>Example 8 at the end of this chapter uses Format 2 to
          assign class values to four types of glyphs in the Arabic
          script.</para>

        <otformat>
          <title>ClassDefFormat2 table: Class ranges</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassRangeCount</otfieldname>
            <otfielddesc>Number of ClassRangeRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>ClassRangeRecord
              [ClassRangeCount]</otfieldname>
            <otfielddesc>Array of ClassRangeRecords-ordered by Start
              GlyphID</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>ClassRangeRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Start</otfieldname>
            <otfielddesc>First GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>End</otfieldname>
            <otfielddesc>Last GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class</otfieldname>
            <otfielddesc>Applied to all glyphs in the
              range</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>classDefTable, format 2</code-title>
  classDefTable |=
    attribute format { "2" },
    element range {
      attribute start { text },
      attribute end   { text },
      attribute class { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='layouttable.methods'>
  public ClassdefTableBlock classdefFormat2FromXML (Element classdef,
                                                    Element table,
                                                    Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    NodeList ranges = classdef.getChildNodes ();
    int nbRanges = ranges.getLength ();

    int lastClass = 0;

    ClassdefTableBlock me = new ClassdefTableBlock (4 + 6 * nbRanges, 0);
    me.setuint16 (0, 2);
    me.setuint16 (2, nbRanges);
    for (int i = 0; i &lt; nbRanges; i++) {
      Element range = (Element) ranges.item (i);
      me.setGlyphID (4 + 6*i,  Integer.parseInt (range.getAttribute ("start")));
      me.setGlyphID (4 + 6*i+2, Integer.parseInt (range.getAttribute ("end")));
      int classID = Integer.parseInt (range.getAttribute ("class"));
      if (classID > lastClass) {
        lastClass = classID; }
      me.setuint16 (4 + 6*i+4, classID); }

    me.classCount = lastClass + 1;
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.classDefTableToXMLEmit.cases'>
  case 2: {
    int classRangeCount = getuint16 (offset + 2);

    if (conf.preciseClassDefFormat) {
      at.addAttribute ("", "format", "format", "CDATA", "2");
      conf.ch.startElement (element, at); {
        int o = offset + 4;
        for (int r = 0; r &lt; classRangeCount; r++) {
          at = new AttributesImpl ();
          at.addAttribute ("", "start", "start", "CDATA", "" + getGlyphID (o));
          at.addAttribute ("", "end", "end", "CDATA", "" + getGlyphID (o + 2));
          at.addAttribute ("", "class", "class", "CDATA",
                           "" + getuint16 (o + 4));
          conf.ch.element ("range", at);
          o += 6; }

        conf.ch.endElement (element); }}

    else {
      at.addAttribute ("", "format", "format", "CDATA", "any");
      conf.ch.startElement (element, at); {

        int lastClass = 0;
        for (int r = 0; r &lt; classRangeCount; r++) {
          int thisClass = getuint16 (offset + 4 + 6*r + 4);
          if (thisClass > lastClass) {
            lastClass = thisClass; }}

// TODO: need to combine ranges; e.g. if
//    {range start='1' end='10' class=2'}
//    {range start='11' end='20' class='2'}
// generate a single range "1:20"
// probably involves having a method to return the glyphs in a class
// also need to combine with a seperate method to form the
// text representation of a list of glyphs, so that names can be emitted.

        StringBuilder sb = new StringBuilder ();
        for (int c = 1; c &lt;= lastClass; c++) {
          for (int r = 0; r &lt; classRangeCount; r++) {
            if (getuint16 (offset + 4 + 6*r + 4) == c) {
              int start = getGlyphID (offset + 4 + 6*r);
              int stop = getGlyphID (offset + 4 + 6*r + 2);
              if (conf.glyphNames != null) {
	        for (int i = start; i &lt; stop + 1; i++) {
                  glyphToXML (conf, sb, i); }}
              else {
                sb.append (" ");
		sb.append (start);
		if (start != stop) {
		  sb.append (":");
		  sb.append (stop); }}}}
          if (sb.length () != 0) {
            at = new AttributesImpl ();
            at.addAttribute ("", "classID", "classID", "CDATA", "" + c);
            at.addAttribute ("", "glyphs", "glyphs", "CDATA", sb.toString ());
            sb.setLength (0);
            conf.ch.element ("class", at); }}

        conf.ch.endElement (element); }}

    break; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='sub_classIndex2'>
  <code-title>Find class index in format 2 and return it</code-title>
  { int rangeCount = getuint16 (offset + 2);

    int min = 0;
    int max = rangeCount - 1;

    while (min &lt;= max) {
      int mid = (min + max) / 2;
      int start = getuint16 (offset + 4 + mid*6);
      int stop = getuint16 (offset + 4 + mid*6 + 2);

      if (glyph &lt; start) {
        max = mid - 1; }
      else if (stop &lt; glyph) {
        min = mid + 1; }
      else {
        return getuint16 (offset + 4 + mid*6 + 4); }}

    return 0; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

	<para>Our first test is a single range covering glyphs 18:20,
	which are incremented by 5.</para>

<aots:test-font id='classdef2_font1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>

      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='2'>
             <range start="18" end="20" class='1'/>
          </classDef>

	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef2_single_range' font='classdef2_font1'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 23, 24, 25, 21'/>

	  <para>Next, we try the case where one class (1) has no
	  glyphs. Note that we include a transformation for that
	  class, to make sure that no glyphs are matched with that
	  class.</para>

<aots:test-font id='classdef2_font2'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>
      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='2'>
             <range start="18" end="20" class='2'/>
          </classDef>

	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_4'/>
	  </pattern>
	  <pattern in='2'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef2_empty_class' font='classdef2_font2'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 23, 24, 25, 21'/>

	  <para>Our most complex case has multiple ranges. Two ranges
	  are assigned to class 2, and a range is assigned to class
	  0.</para>

<aots:test-font id='classdef2_font3'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>

      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='2'>
             <range start="18" end="20" class='2'/>
	     <range start='22' end='24' class='1'/>
	     <range start='26' end='28' class='0'/>
	     <range start='29' end='29' class='2'/>
	     <range start='33' end='34' class='1'/>
          </classDef>

	  <pattern in='0'>
	    <apply pos='0' lookup='inc_by_3'/>
	  </pattern>
	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_4'/>
	  </pattern>
	  <pattern in='2'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef2_multiple_ranges' font='classdef2_font3'
	   inputs ='17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36'
	   outputs='20, 23, 24, 25, 24, 26, 27, 28, 28, 29, 30, 31, 34, 33, 34, 35, 37, 38, 38, 39'/>

	  <para>The empty definition.</para>

<aots:test-font id='classdef2_font4'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <code-include linkend='layout.test.classdef'/>

      <lookup id='lookup.test' type='5'>
        <contextual format='2'>
          <coverage glyphs='0:99' format='any'/>
          <classDef format='2'/>

	  <pattern in='1'>
	    <apply pos='0' lookup='inc_by_4'/>
	  </pattern>
	  <pattern in='2'>
	    <apply pos='0' lookup='inc_by_5'/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='classdef2_empty' font='classdef2_font4'
	   inputs ='17, 18, 19, 20, 21'
	   outputs='17, 18, 19, 20, 21'/>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Device Tables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Glyphs in a font are defined in design units specified
          by the font developer. Font scaling increases or decreases a
          glyph's size and rounds it to the nearest whole
          pixel. However, precise glyph positioning often requires
          adjustment of these scaled and rounded values. Hinting,
          applied to points in the glyph outline, is an effective
          solution to this problem, but it may require the font
          developer to redesign or re-hint glyphs.</para>

        <para>Another solution-used by the <ottable>GPOS</ottable>,
          <ottable>BASE</ottable>, <ottable>JSTF</ottable>, and
          <ottable>GDEF</ottable> tables-is to use a Device table to
          specify correction values to adjust the scaled design
          units. A Device table applies the correction values to the
          range of sizes identified by StartSize and EndSize, which
          specify the smallest and largest pixel-per-em (ppem) sizes
          needing adjustment.</para>

        <para>Because the adjustments often are very small (a pixel or
          two), the correction can be compressed into a 2-, 4-, or
          8-bit representation per size. Two bits can represent a
          number in the range {-2, -1, 0, or 1}, four bits can
          represent a number in the range {-8 to 7}, and eight bits
          can represent a number in the range {-128 to 127}. The
          Device table identifies one of three data formats-signed 2-,
          4,- or 8-bit values-for the adjustment values
          (DeltaFormat). A single Device table provides delta
          information for one coordinate at a range of sizes.</para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="8pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="14pc"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>2</entry>
                <entry>Signed 2-bit value, 8 values per uint16</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>4</entry>
                <entry>Signed 4-bit value, 4 values per uint16</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>8</entry>
                <entry>Signed 8-bit value, 2 values per uint16</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>The 2-, 4-, or 8-bit signed values are packed into
          uint16's most significant bits first. For example, using a
          DeltaFormat of 2 (4-bit values), an array of values equal to
          {1, 2, 3, -1} would be represented by the DeltaValue
          0x123F.</para>

        <para>The DeltaValue array lists the number of pixels to
          adjust specified points on the glyph, or the entire glyph,
          at each ppem size in the targeted range. In the array, the
          first index position specifies the number of pixels to add
          or subtract from the coordinate at the smallest ppem size
          that needs correction, the second index position specifies
          the number of pixels to add or subtract from the coordinate
          at the next ppem size, and so on for each ppem size in the
          range.</para>

        <para>Example 9 at the end of this chapter uses a Device table
          to define the minimum extent value for a math script.</para>

        <otformat>
          <title>Device table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>StartSize</otfieldname>
            <otfielddesc>Smallest size to correct-in
              ppem</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>EndSize</otfieldname>
            <otfielddesc>Largest size to correct-in ppem</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>DeltaFormat</otfieldname>
            <otfielddesc>Format of DeltaValue array data: 1, 2, or
              3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>DeltaValue []</otfieldname>
            <otfielddesc>Array of compressed data</otfielddesc>
          </otfield>
        </otformat>
      </section>


      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>deviceTable</code-title>
  deviceTable =
    attribute startSize    { text },
    attribute endSize      { text },
    attribute deltaFormat  { text },
    attribute values       { text }

  standaloneDeviceTable =
    element deviceTable { attribute id { text }, deviceTable }

  deviceTableOffset = attribute name { text } | deviceTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='layouttable.methods'>
  protected Block deviceTableFromXML (Element t, Element table,
                                      Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    int startSize = Integer.parseInt (t.getAttribute ("startSize"));
    int endSize = Integer.parseInt (t.getAttribute ("endSize"));
    int[] values = parseIntList (t.getAttribute ("values"));

    if (endSize &lt; startSize) {
      warning ("device/@endSize must be bigger than device/@startSize"); }

    if (values.length != (endSize - startSize + 1)) {
      warning ("device/@values must have one value for each ppem "
               + "between " + startSize + " and " + endSize
               + " (included)" ); }

    int minValue = 0;
    int maxValue = 0;
    for (int i = 0; i &lt; values.length; i++) {
      minValue = Math.min (minValue, values [i]);
      maxValue = Math.max (maxValue, values [i]); }

    int[] min =             {0,  -2,  -8, -128};
    int[] max =             {0,   1,   7,  127};
    int[] valuesPerUint =   {0,   8,   4,    2};
    int[] bitsPerValue =    {0,   2,   4,    8};
    int[] mask =            {0, 0x3, 0xF, 0xFF};

    int minFormat = -1;
    for (int i = 1; i &lt; min.length; i++) {
      if (min[i] &lt;= minValue &amp;&amp; maxValue &lt;= max[i]) {
        minFormat = i;
        break; }}
    if (minFormat == -1) {
      warning ("device/@value must be in the range [-128, +127];"
               + " values will be truncated");
      minFormat = 3; }

    int format;
    String f = t.getAttribute ("format");
    if (f != null &amp;&amp; ! "".equals (f)) {
      int desiredFormat = Integer.parseInt (f);
      if (desiredFormat &lt; minFormat) {
        warning ("device/@format is too small; will use " + minFormat);
        format = minFormat; }
      else {
        format = desiredFormat; }}
    else {
      format = minFormat; }

    int nbUints = (values.length + valuesPerUint [format] - 1)
                  / valuesPerUint [format];
    int nbValues = valuesPerUint [format] * nbUints;

    if (nbValues != values.length) {
      int[] temp = new int [nbValues];
      System.arraycopy (values, 0, temp, 0, values.length);
      for (int i = values.length; i &lt; nbValues; i++) {
        temp [i] = 0; }
      values = temp; }

    Block me = new Block (6 + 2*nbUints, 0);
    me.setuint16 (0, startSize);
    me.setuint16 (2, endSize);
    me.setuint16 (4, format);

    for (int i = 0; i &lt; nbValues; i += valuesPerUint [format]) {
      int v = 0;
      for (int j = 0; j &lt; valuesPerUint [format]; j++) {
        v = (v &lt;&lt; bitsPerValue [format])
            | (values [i + j] &amp; mask [format]); }
      me.setuint16 (6 + 2 *(i / valuesPerUint [format]), v); }

    blockCache.put (t, me);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='layouttable.methods'>
  public void deviceTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void deviceTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "deviceTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      deviceTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void deviceTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "deviceTable_" + Integer.toHexString (offset));
      deviceTableToXMLEmit (conf, offset, counts, "deviceTable", at);
      counts [offset] = 0; }
  }

  public void deviceTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
                                    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    int startSize = getuint16 (offset);
    int endSize = getuint16 (offset + 2);
    int format = getuint16 (offset + 4);

    at.addAttribute ("", "startSize", "startSize", "CDATA", "" + startSize);
    at.addAttribute ("", "endSize", "endSize", "CDATA", "" + endSize);
    at.addAttribute ("", "deltaFormat", "deltaFormat", "CDATA", "" + format);

    StringBuilder s = new StringBuilder ();

    int[] bitsPerValue  = {0, 2,   4,   8};
    int[] bitMask       = {0, 0x3, 0xf, 0xff};
    int[] maxValue      = {0, 1,   7,   127};

    offset += 6;
    int bitsLeft = 0;
    int word = 0;

    for (int i = startSize; i &lt;= endSize; i++) {
      if (bitsLeft == 0) {
        word = getuint16 (offset);
        bitsLeft = 16;
        offset += 2; }

      int value = (word >> (bitsLeft - bitsPerValue [format])) &amp; bitMask [format];
      if (value > maxValue [format]) {
        value -= (bitMask [format] + 1); }

      bitsLeft -= bitsPerValue [format];

      s.append (" " + value); }
    at.addAttribute ("", "values", "values", "CDATA", s.toString ());

    conf.ch.element (element, at);
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Common Table Examples</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The rest of this chapter describes and illustrates
          examples of all the common table formats. All the examples
          reflect unique parameters, but the samples provide a useful
          reference for building tables specific to other
          situations.</para>

        <para>The examples have three columns showing hex data,
          source, and comments.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 1: ScriptList Table and ScriptRecords</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 1 illustrates a ScriptList table and
          ScriptRecord definitions for a Japanese font with multiple
          scripts: Han Ideographic, Kana, and Latin. Each script has
          script-specific behavior.</para>

        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ScriptList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheScriptList</otexsrc>
            <otexcom>ScriptList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ScriptCount. ScriptRecord[0],in alphabetical
                  order by ScriptTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>68616E69</otexdata>
            <otexsrc>"hani"</otexsrc>
            <otexcom>ScriptTag, Han Ideographic script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>HanIScriptTable</otexsrc>
            <otexcom>offset to Script table ScriptRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6B616E61</otexdata>
            <otexsrc>"kana"</otexsrc>
            <otexcom>ScriptTag, Hiragana and Katakana
                  scripts</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>KanaScriptTable</otexsrc>
            <otexcom>offset to Script table ScriptRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C61746E</otexdata>
            <otexsrc>"latn"</otexsrc>
            <otexcom>ScriptTag, Latin script</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>LatinScriptTable</otexsrc>
            <otexcom>offset to Script table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 2: Script Table, LangSysRecord, and LangSys Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>Example 2 illustrates the Script table, LangSysRecord,
          and LangSys table definitions for the Arabic script and the
          Urdu language system. The default LangSys table defines
          three default Arabic script features used to replace certain
          glyphs in words with their proper initial, medial, and final
          glyph forms. These contextual substitutions are invariant
          and occur in all language systems that use the Arabic
          script.</para>

        <para>Many alternative glyphs in the Arabic script have
          language-specific uses. For instance, the Arabic, Farsi, and
          Urdu language systems use different glyphs for numerals. To
          maintain character-set compatibility, the Unicode standard
          includes separate character codes for the Arabic and Farsi
          numeral glyphs. However, the standard uses the same
          character codes for Farsi and Urdu numerals, even though
          three of the Urdu glyphs (4, 6, and 7) differ from the Farsi
          glyphs. To access and display the proper glyphs for the Urdu
          numerals, users of the text-processing client must enter the
          character codes for the Farsi numerals. Then the
          text-processing client uses a required OpenType Layout glyph
          substitution feature, defined in the Urdu LangSys table, to
          access the correct Urdu glyphs for the 4, 6, and 7
          numerals.</para>

        <para>Note that the Urdu LangSys table repeats the default
          script features. This repetition is necessary because the
          Urdu language system also uses alternative glyphs in the
          initial, medial, and final glyph positions in words.</para>

        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Script</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ArabicScriptTable</otexsrc>
            <otexcom>Script table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>DefLangSys</otexsrc>
            <otexcom>offset to DefaultLangSys table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LangSysCount LangSysRecord[0], in alphabetical
                  order by LangSysTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>55524420</otexdata>
            <otexsrc>"URD "</otexsrc>
            <otexcom>LangSysTag, Urdu language</otexcom>
          </otexline>
          <otexline>
            <otexdata>0016</otexdata>
            <otexsrc>UrduLangSys</otexsrc>
            <otexcom>offset to LangSys table for Urdu</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LangSys</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DefLangSys</otexsrc>
            <otexcom>default LangSys table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>LookupOrder, reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFFF</otexdata>
            <otexsrc>0xFFFF</otexsrc>
            <otexcom>ReqFeatureIndex, no required features</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>FeatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>FeatureIndex[0], in arbitrary order "init"
                  feature (initial glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>FeatureIndex[1], "fina" feature (final
                  glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>FeatureIndex[2], for "medi" feature (medial
                  glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LangSys</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>UrduLangSys</otexsrc>
            <otexcom>LangSys table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>LookupOrder, reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ReqFeatureIndex, numeral subsitution in
                  Urdu</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>FeatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>FeatureIndex[0], in arbitrary order "init"
                  feature (initial glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>FeatureIndex[1], "fina" feature (final
                  glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>FeatureIndex[2], "medi" feature (medial
                  glyph)</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3: FeatureList Table and Feature Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 3 shows the FeatureList and Feature table
          definitions for ligatures in the Latin script. The
          FeatureList has three features, all optional and named
          "liga." One feature, also a default, implements ligatures in
          Latin if no language-specific feature specifies other
          ligatures. Two other features implement ligatures in the
          Turkish and German languages, respectively.</para>

        <para>Three lookups define glyph substitutions for rendering
          ligatures in this font. The first lookup produces the "ffi"
          and "fi" ligatures; the second produces the "ffl," "fl," and
          "ff" ligatures; and the third produces the eszet
          ligature.</para>

        <para>The ligatures that begin with an "f" are separated into
          two sets because Turkish has a dotless "i" glyph and so does
          not use "ffi" and "fi" ligatures. However, Turkish does use
          the "ffl," "fl," and "ff" ligatures, and the
          TurkishLigatures feature table lists this one lookup.</para>

        <para>Only the German language system uses the eszet ligature,
          so the GermanLigatures feature table includes a lookup for
          rendering that ligature.</para>

        <para>Because the Latin script can use both sets of ligatures,
          the DefaultLigatures feature table defines two LookupList
          indices: one for the "ffi" and "fi" ligatures, and one for
          the "ffl," "fl," and "ff" ligatures. If the text-processing
          client selects this feature, then the font applies both
          lookups.</para>

        <para>Note that the TurkishLigatures and DefaultLigatures
          feature tables both list a LookupListIndex of one (1) for
          the "ffl," "fl," and "ff" ligatures lookup. This is because
          language-specific lookups override all default
          language-system lookups, and a language-system feature table
          must explicitly list all lookups that apply to the
          language.</para>

        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FeatureList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheFeatureList</otexsrc>
            <otexcom>FeatureList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>FeatureCount FeatureRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C696761</otexdata>
            <otexsrc>"liga"</otexsrc>
            <otexcom>FeatureTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>TurkishLigatures</otexsrc>
            <otexcom>offset to Feature table, FflFfFlLiga
                  FeatureRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C696761</otexdata>
            <otexsrc>"liga"</otexsrc>
            <otexcom>FeatureTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>DefaultLigatures</otexsrc>
            <otexcom>offset to Feature table, FfiFiLiga, FflFfFlLiga
                  FeatureRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C696761</otexdata>
            <otexsrc>"liga"</otexsrc>
            <otexcom>FeatureTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>0022</otexdata>
            <otexsrc>GermanLigatures</otexsrc>
            <otexcom>offset to Feature table, EszetLiga</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Feature</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TurkishLigatures</otexsrc>
            <otexcom>Feature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>FeatureParams, reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex[1], ffl, fl, ff ligature
                  substitution Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Feature</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DefaultLigatures</otexsrc>
            <otexcom>Feature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>FeatureParams - reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>LookupListIndex[0], in arbitrary order, ffi, fi
                  ligatures</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex[1], ffl, fl, ff ligature
                  substitution Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Feature</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GermanLigatures</otexsrc>
            <otexcom>Feature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>FeatureParams - reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>LookupListIndex[0], in arbitrary order, ffi, fi
                  ligatures</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex[1], ffl, fl, ff ligature
                  substitution Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex[2], eszet ligature substitution
                  Lookup</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4: LookupList Table and Lookup Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A continuation of Example 3, Example 4 shows three
          ligature lookups in the LookupList table. The first
          generates the "ffi" and "fi" ligatures; the second produces
          the "ffl," "fl," and "ff" ligatures; and the third generates
          the eszet ligature. Each lookup table defines an offset to a
          subtable that contains data for the ligature
          substitution.</para>

        <otexample>
          <title>Example 4</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LookupList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheLookupList</otexsrc>
            <otexcom>LookupList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>FfiFiLookup</otexsrc>
            <otexcom>Offset to Lookup[0] table, in design
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>FflFlFfLookup</otexsrc>
            <otexcom>offset to Lookup[1] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>EszetLookup</otexsrc>
            <otexcom>offset to Lookup[2] table</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Lookup</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FfiFiLookup</otexsrc>
            <otexcom>Lookup[0] table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>LookupType, ligature subst</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>0x000C</otexsrc>
            <otexcom>LookupFlag, IgnoreLigatures,
                  IgnoreMarks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>FfiFiSubtable</otexsrc>
            <otexcom>offset to FfiFi ligature substitution
                  subtable</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Lookup</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FflFlFfLookup</otexsrc>
            <otexcom>Lookup[1] table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>LookupType ligature subst</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>0x000C</otexsrc>
            <otexcom>LookupFlag- IgnoreLigatures,
                  IgnoreMarks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>FflFlFfSubtable</otexsrc>
            <otexcom>offset to FflFlFf ligature substitution
                  subtable</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Lookup</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>EszetLookup</otexsrc>
            <otexcom>Lookup[2] table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>LookupType- ligature subst</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>0x000C</otexsrc>
            <otexcom>LookupFlag- IgnoreLigatures,
                  IgnoreMarks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>EszetSubtable</otexsrc>
            <otexcom>offset to Eszet ligature substitution
                  subtable</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 5: CoverageFormat1 Table (GlyphID List)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 5 illustrates a Coverage table that lists the
          GlyphIDs of all lowercase descender glyphs in a font. The
          table uses the list format instead of the range format
          because the GlyphIDs for the descender glyphs are not
          consecutively ordered.</para>


        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DescenderCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>5</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>gGlyphID</otexsrc>
            <otexcom>GlyphArray[0], in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>jGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>pGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>qGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>yGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 6: CoverageFormat2 Table (GlyphID Ranges)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 6 shows a Coverage table that defines ten
          numeral glyphs (0 through 9). The table uses the range
          format instead of the list format because the GlyphIDs are
          ordered consecutively in the font. The StartCoverageIndex of
          zero (0) indicates that the first GlyphID, for the zero
          glyph, returns a Coverage Index of 0. The second GlyphID,
          for the numeral one (1) glyph, returns a Coverage Index of
          1, and so on.</para>


        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>NumeralCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat, GlyphID ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004E</otexdata>
            <otexsrc>0glyphID</otexsrc>
            <otexcom>Start GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0057</otexdata>
            <otexsrc>9glyphID</otexsrc>
            <otexcom>End GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex, first CoverageIndex =
                  0</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 7: ClassDefFormat1 Table (Class Array)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The ClassDef table in Example 7 assigns class values to
          the lowercase glyphs in a font. The x-height glyphs are in
          Class 0, the ascender glyphs are in Class 1, and the
          descender glyphs are in Class 2. The array begins with the
          index for the lowercase "a" glyph.</para>


        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LowercaseClassDef</otexsrc>
            <otexcom>ClassDef table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>ClassFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>aGlyphID</otexsrc>
            <otexcom>StartGlyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>26</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>aGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>bGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>cGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>dGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>eGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>fGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>gGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>hGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>iGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>jGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>kGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>lGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>mGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>nGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>oGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>pGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>qGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>rGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>sGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>tGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>uGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>vGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>wGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>xGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>yGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>zGlyph, Xheight Class 0</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 8: ClassDefFormat2 Table (Class Ranges)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>In Example 8, the ClassDef table assigns class values to
          four types of glyphs in the Arabic script: medium-height
          base glyphs, high base glyphs, very high base glyphs, and
          default mark glyphs. The table lists only Class 1, Class 2,
          and Class 3; all glyphs not explicitly assigned a class fall
          into Class 0.</para>

        <para>The table uses the range format because the GlyphIDs in
          each class are ordered consecutively in the font. In the
          ClassRange array, ClassRange definitions are ordered by the
          Start glyph index in each range. The indices of the high
          base glyphs, defined in ClassRange[0], are first in the font
          and have a class value of 2. ClassRange[1] defines all the
          very high base glyphs and assigns a class value of 3.
          ClassRange[2] contains all default mark glyphs; the class
          value is 1. Class 0 consists of all the medium-height base
          glyphs, which are not explicitly assigned a class
          value.</para>


        <otexample>
          <title>Example 8</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GlyphHeightClassDef</otexsrc>
            <otexcom>Class table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class Format ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ClassRangeCount ClassRange[0], ordered by
                  StartGlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>tahGlyphID</otexsrc>
            <otexcom>Start first GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>dhahGlyphID</otexsrc>
            <otexcom>End Last GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class, high base glyphs, ClassRange[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>cafGlyphID</otexsrc>
            <otexcom>Start, first GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc> gafGlyphID</otexsrc>
            <otexcom>End, Last GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class, very high base glyphs,
                  ClassRange[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D2</otexdata>
            <otexsrc>fathatanDefaultGlyphID</otexsrc>
            <otexcom>Start, first GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D3</otexdata>
            <otexsrc>dammatanDefaultGlyphID</otexsrc>
            <otexcom>End, Last GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class default marks</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 9: Device Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 9 defines the minimum extent value for a math
          script, using a Device table to adjust the value according
          to the size of the output font. Here, the Device table
          defines single-pixel adjustments for font sizes from 11 ppem
          to 15 ppem. The DeltaFormat is 1, which signifies a packed
          array of signed 2-bit values, eight values per
          uint16.</para>


        <otexample>
          <title>Example 9</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MinCoordDeviceTable</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000B</otexdata>
            <otexsrc>11</otexsrc>
            <otexcom>StartSize, 11 ppem</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>EndSize, 15 ppem</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>DeltaFormat signed 2 bit value, 8 values per
                  uint16</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 11ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>5540</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppem by 1 pixel </otexcom>
          </otexline>
        </otexample>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.BASE'  web:index='yes'>
    <title>BASE - Baseline Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Baseline table (<ottable>BASE</ottable>) provides
          information used to align glyphs of different scripts and
          sizes in a line of text, whether the glyphs are in the same
          font or in different fonts. To improve text layout, the
          Baseline table also provides minimum (min) and maximum (max)
          glyph extent values for each script, language system, or
          feature in a font.</para>

        <para>Lines of text composed with glyphs of different scripts
          and point sizes need adjustment to correct interline spacing
          and alignment. For example, glyphs designed to be the same
          point size often differ in height and depth from one font to
          another (see figure 5a). This variation can produce
          interline spacing that looks too large or too small, and
          diacritical marks, math symbols, subscripts, and
          superscripts may be clipped.</para>

        <figure>
          <title>Figure 5a. Incorrect alignment of glyphs from Latin
            and Kanji (Latin dominant)</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig5a.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>In addition, different baselines can cause text lines to
          waver visually as glyphs from different scripts are placed
          next to one another. For example, ideographic scripts
          position all glyphs on a low baseline. With Latin scripts,
          however, the baseline is higher, and some glyphs descend
          below it. Finally, several Indic scripts use a high "hanging
          baseline" to align the tops of the glyphs.</para>

        <para>To solve these composition problems, the
          <ottable>BASE</ottable> table recommends baseline positions
          and min/max extents for each script (see figure 5b). Script
          min/max extents can be modified for particular language
          systems or features.</para>


        <figure>
          <title>Figure 5b. Proper alignment of glyphs from Latin and
            Kanji (Latin dominant)</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig5b.gif'/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Baseline Values</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>BASE</ottable> table uses a model that
          assumes one script at one size is the "dominant run" during
          text processing-that is, all other baselines are defined in
          relation to this the dominant run.</para>

        <para>For example, Latin glyphs and the ideographic Kanji
          glyphs have different baselines. If a Latin script of a
          particular size is specified as the dominant run, then all
          Latin glyphs of all sizes will be aligned on the roman
          baseline, and all Kanji glyphs will be aligned on the lower
          ideographic baseline defined for use with Latin text. As a
          result, all glyphs will look aligned within each line of
          text.</para>

        <para>The <ottable>BASE</ottable> table supplies recommended
          baseline positions; a client can specify others. For
          instance, the client may want to assign baseline positions
          different from those in the font.</para>

        <figure>
          <title>Figure 5c. Comparing Latin and Kanji baselines, with
            characters aligned according to the dominant run</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig5c.gif'/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Min/Max Extent Values</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>BASE</ottable> table gives clients the
          option of using script, language system, or feature-specific
          extent values to improve composition (see figure 5c). For
          example, suppose a font contains glyphs in Latin and Arabic
          scripts, and the min/max extents defined for the Arabic
          script are larger than the Latin extents. The font also
          supports Urdu, a language system that includes specific
          variants of the Arabic glyphs, and some Urdu variants
          require larger min/max extents than the default Arabic
          extents. To accommodate the Urdu glyphs, the
          <ottable>BASE</ottable> table can define language-specific
          min/max extent values that will override the default Arabic
          extents-but only when rendering Urdu glyphs.</para>

        <para>The <ottable>BASE</ottable> table also can define
          feature-specific min/max values that apply only when a
          particular feature is enabled.  Suppose that the font
          described earlier also supports the Farsi language system,
          which has one feature that requires a minor alteration of
          the Arabic script extents to display properly. The
          <ottable>BASE</ottable> table can specify these extent
          values and apply them only when that feature is enabled in
          the Farsi language.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Table Organization</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>BASE</ottable> table begins with offsets to
          Axis tables that describe layout data for the horizontal and
          vertical layout directions of text. A font can provide
          layout data for both text directions or for only one text
          direction:</para>

        <itemizedlist>
          <listitem>
           <para>The Horizontal Axis table (HorizAxis) defines
              information used to lay out text horizontally. All
              baseline and min/max values refer to the Y
              direction.</para>
          </listitem>
          <listitem>
            <para>The Vertical Axis table (VertAxis) defines
              information used to lay out text vertically. All
              baseline and min/max values refer to the X
              direction.</para>
          </listitem>
        </itemizedlist>

        <para>Note: The same baseline tags can be used for both
          horizontal and vertical axes. For example, the 'romn' tag
          description used for the vertical axis would indicate the
          baseline of rotated Latin text.</para>

        <para>Figure 5d shows how the <ottable>BASE</ottable> table is
        organized.</para>

        <figure>
          <title>Figure 5d. High-level organization of <ottable>BASE</ottable>
            table</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig5d.gif'/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Text Direction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The HorizAxis and VertAxis tables organize layout
          information by script in BaseScriptList tables. A
          BaseScriptList enumerates all scripts in the font that are
          written in a particular direction (horizontal or
          vertical).</para>
        <para>For example, consider a Japanese font that contains
          Kanji, Kana, and Latin scripts. Because all three scripts
          are rendered horizontally, all three are defined in the
          BaseScriptList of the HorizAxis table. Kanji and Kana also
          are rendered vertically, so those two scripts are defined in
          the BaseScriptList of the VertAxis table, too.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Baseline Data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Each Axis table also references a BaseTagList, which
          identifies all the baselines for all scripts written in the
          same direction (horizontal or vertical). The BaseTagList may
          also include baseline tags for scripts supported in other
          fonts.</para>

        <para>Each script in a BaseScriptList is represented by a
          BaseScriptRecord. This record references a BaseScript table,
          which contains layout data for the script. In turn, the
          BaseScript table references a BaseValues table, which
          contains baseline information and several MinMax tables that
          define min/max extent values.</para>

        <para>The BaseValues table specifies the coordinate values for
          all baselines in the BaseTagList. In addition, it identifies
          one of these baselines as the default baseline for the
          script. As glyphs in a script are scaled, they grow or
          shrink from the script's default baseline position. Each
          baseline can have unique coordinates. This contrasts with
          TrueType 1.0, which implies a single, fixed baseline for all
          scripts in a font. With the OpenType Layout tables, each
          script can be aligned independently, although more than one
          script may use the same baseline values.</para>

        <para>Baseline coordinates for scripts in the same font must
          be specified in relation to each other for correct alignment
          of the glyphs. Consider the font, discussed earlier,
          containing both Latin and Kanji glyphs. If the BaseTagList
          of the HorizAxis table specifies two baselines, the roman
          and the ideographic, then the layout data for both the Latin
          and Kanji scripts will specify coordinate positions for both
          baselines:</para>

        <itemizedlist>
          <listitem>
            <para>The BaseValues table for the Latin script will give
              coordinates for both baselines and specify the roman
              baseline as the default.</para>
          </listitem>
          <listitem>
            <para>The BaseValues table for the Kanji script will give
              coordinates for both baselines and specify the
              ideographic baseline as the default.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Min/Max Extents</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The BaseScript table can define minimum and maximum
          extent values for each script, language system, or feature.
          (These values are distinct from the min/max extent values
          recorded for the font as a whole in the head, hhea, vhea,
          and OS/2 tables.) These extent values appear in three
          tables:</para>

        <itemizedlist>
          <listitem>
            <para>The DefaultMinMax table defines the default min/max
              extents for the script.</para>
          </listitem>
          <listitem>
            <para>A MinMax table, referenced through a
              BaseLangSysRecord, specifies min/max extents to
              accommodate the glyphs in a specific language
              system.</para>
          </listitem>
          <listitem>
            <para>A FeatMinMaxRecord, referenced from the MinMax
              table, provides min/max extent values to support
              feature-specific glyph actions.</para>

            <para>Note: Language-system or feature-specific extent
              values may be essential to define some fonts. However,
              the default min/max extent values specified for each
              script should usually be enough to support high-quality
              text layout.</para>
          </listitem>
        </itemizedlist>

        <para>The actual baseline and min/max extent values used by
          the <ottable>BASE</ottable> table reside in BaseCoord
          tables. Three formats are defined for BaseCoord table
          data. All formats define single X or Y coordinate values in
          design units, but two formats support fine adjustments to
          these values based on a contour point or a Device
          table.</para>

        <para>The rest of this chapter describes all the tables
          defined within the <ottable>BASE</ottable> table. Sample
          tables and lists that illustrate typical data for a font are
          supplied at the end of the chapter.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BASE Header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>BASE</ottable> table begins with a header
          that consists of a version number for the table (Version),
          initially set to 1.0 (0x00010000), and offsets to horizontal
          and vertical Axis tables (HorizAxis and VertAxis).</para>
          <para>Each Axis table stores all baseline information and
          min/max extents for one layout direction. The HorizAxis
          table contains Y values for horizontal text layout; the
          VertAxis table contains X values for vertical text
          layout.</para> <para>A font may supply information for both
          layout directions. If a font has values for only one text
          direction, the Axis table offset value for the other
          direction will be set to NULL.</para>

        <para>Example 1 at the end of this chapter shows a sample
          <ottable>BASE</ottable> Header.</para>


        <otformat>
          <title>BASE Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>fixed32</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the <ottable>BASE</ottable>
              table-initially 0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>HorizAxis</otfieldname>
            <otfielddesc>Offset to horizontal Axis table-from
              beginning of <ottable>BASE</ottable> table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>VertAxis</otfieldname>
            <otfielddesc>Offset to vertical Axis table-from beginning
              of <ottable>BASE</ottable> table-may be
              NULL</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>BASE</code-title>
  BASE =
    element BASE {
      attribute major { "1" },
      attribute minor { "0" },
      element horizontalAxis { axisTableOffset }?,
      element verticalAxis { axisTableOffset }?,

      (  standaloneAxisTable
       | standaloneBaseTagListTable
       | standaloneBaseScriptListTable
       | standaloneBaseScriptTable
       | standaloneBaseValuesTable
       | standaloneMinMaxTable
       | standaloneBaseCoordTable
       | standaloneDeviceTable)*
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public void fromXML (Element base)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block> blockCache = new HashMap&lt;Element, Block> ();
    Block me = new Block (8, 2);
    me.setFixed (0, 1, 0);

    Element n = (Element) base.getFirstChild ();
    if (n != null
        &amp;&amp; "horizontalAxis".equals (n.getTagName ())) {
      me.setOffset (4, axisTableFromXML (n, base, blockCache));
      n = (Element) n.getNextSibling (); }
    else {
      me.setOffset (4, null); }

    if (n != null
        &amp;&amp; "verticalAxis".equals (n.getTagName ())) {
      me.setOffset (6, axisTableFromXML (n, base, blockCache)); }
    else {
      me.setOffset (6, null); }

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] counts = new int [data.length];
    for (int i = 0; i &lt; counts.length; i++) {
      counts [i] = 0; }

    // phase 1
    if (getOffset (4) != 0) {
      axisTableToXMLCount (getOffset (4), counts); }
    if (getOffset (6) != 0) {
      axisTableToXMLCount (getOffset (6), counts); }

    if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 1; }}
    if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 2; }}

    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);

    conf.ch.startElement ("BASE", at); {

      // phase 2

      if (getOffset (4) != 0) {
        axisTableOffsetToXML (conf, getOffset (4), counts,
                              "horizontalAxis", new AttributesImpl ()); }
      if (getOffset (6) != 0) {
        axisTableOffsetToXML (conf, getOffset (6), counts,
                              "verticalAxis", new AttributesImpl ()); }

      // phase 3
      if (getOffset (4) != 0) {
        axisTableToXML (conf, getOffset (4), counts); }
      if (getOffset (6) != 0) {
        axisTableToXML (conf, getOffset (6), counts); }

      conf.ch.endElement ("BASE"); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Base'>
  <code-title>BASE Class</code-title>
package com.adobe.aots.opentype;

import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Base extends LayoutTable {

  public Base () {
    super (Tag.BASE, null);
  }

  public Base (Font font) {
    super (Tag.BASE, font);
  }

  <code-include linkend='base.methods'/>

  public int[] getTableVersion () {
    return getFixed (0);
  }

}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Axis Tables: HorizAxis and VertAxis</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>An Axis table is used to render scripts either
          horizontally or vertically. It consists of offsets, measured
          from the beginning of the Axis table, to a BaseTagList and a
          BaseScriptList:</para>

        <itemizedlist>
          <listitem>
            <para>The BaseScriptList enumerates all scripts rendered
              in the text layout direction.</para>
          </listitem>
          <listitem>
            <para>The BaseTagList enumerates all baselines used to
              render the scripts in the text layout direction. If no
              baseline data is available for a text direction, the
              offset to the corresponding BaseTagList may be set to
              NULL.</para>
          </listitem>
        </itemizedlist>

        <para>Example 1 at the end of this chapter shows an example of
          an Axis table.</para>

        <otformat>
          <title>Axis Table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseTagList</otfieldname>
            <otfielddesc>Offset to BaseTagList table-from beginning of
              Axis table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseScriptList</otfieldname>
            <otfielddesc>Offset to BaseScriptList table-from beginning
              of Axis table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>axisTable</code-title>
  axisTable =
    element baseTagList    { baseTagListTableOffset }?,
    element baseScriptList { baseScriptListTableOffset }

  standaloneAxisTable =
    element axisTable { attribute id { text }, axisTable }

  axisTableOffset = attribute name { text } | axisTable
</code-fragment>
      </section>


      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block axisTableFromXML (Element t, Element table,
                                 Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    Block me = new Block (4, 2);

    Element n = (Element) t.getFirstChild ();
    if (n != null
        &amp;&amp; "baseTagList".equals (n.getTagName ())) {
      me.setOffset (0, baseTagListTableFromXML (n, table, blockCache));
      n = (Element) n.getNextSibling (); }
    else {
      me.setOffset (0, null); }

    if (n != null
        &amp;&amp; "baseScriptList".equals (n.getTagName ())) {
      me.setOffset (2, baseScriptListTableFromXML (n, table, blockCache)); }
    else {
      me.setOffset (2, null); }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  public void axisTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    if (getOffset (offset) != 0) {
      baseTagListTableToXMLCount (getOffset (offset, 0), counts); }
    baseScriptListTableToXMLCount (getOffset (offset, 2), counts);
  }


  public void axisTableOffsetToXML (DecompilerConfig conf, int offset,
                                    int [] counts,
                                    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "axisTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      axisTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void axisTableToXML (DecompilerConfig conf, int offset,
                              int [] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "axisTable_" + Integer.toHexString (offset));
      axisTableToXMLEmit (conf, offset, counts, "axisTable", at);
      counts [offset] = 0; }

    if (getOffset (offset) != 0) {
      baseTagListTableToXML (conf, getOffset (offset, 0), counts); }
    baseScriptListTableToXML (conf, getOffset (offset, 2), counts);
  }

  public void axisTableToXMLEmit (DecompilerConfig conf, int offset,
                                  int[] counts,
                                  String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {
      if (getOffset (offset) != 0) {
        at = new AttributesImpl ();
        baseTagListTableOffsetToXML (conf, getOffset (offset, 0), counts,
                                     "baseTagList", at); }

      at = new AttributesImpl ();
      baseScriptListTableOffsetToXML (conf, getOffset (offset, 2),
                                      counts,
                                      "baseScriptList", at);

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseTagList Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The BaseTagList table identifies the baselines for all
          scripts in the font that are rendered in the same text
          direction. Each baseline is identified with a 4-byte
          baseline tag. The <link
            linkend="ttoreg_basetags">Baseline Tags</link>
          section of the OpenType Tag Registry lists currently
          registered baseline tags. The BaseTagList can define any
          number of baselines, and it may include baseline tags for
          scripts supported in other fonts.</para>

        <para>Each script in the BaseScriptList table must designate
          one of these BaseTagList baselines as its default, which the
          OpenType Layout Services use to align all glyphs in the
          script. Even though the BaseScriptList and the BaseTagList
          are defined independently of one another, the BaseTagList
          typically includes a tag for each different default baseline
          needed to render the scripts in the layout direction. If
          some scripts use the same default baseline, the BaseTagList
          needs to list the common baseline tag only once. </para>

        <para>The BaseTagList table consists of an array of baseline
          identification tags (BaselineTag), listed alphabetically,
          and a count of the total number of baseline Tags in the
          array (BaseTagCount).</para>

        <para>Example 1 at the end of this chapter shows a sample
          BaseTagList table.</para>

        <otformat>
          <title>BaseTagList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseTagCount</otfieldname>
            <otfielddesc>Number of baseline identification tags in
              this text direction-may be zero (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>BaselineTag [BaseTagCount]</otfieldname>
            <otfielddesc>Array of 4-byte baseline identification
              tags-must be in alphabetical order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseTagListTable</code-title>
  baseTagListTable =
    element tag {
      attribute v { text }
    }*

  standaloneBaseTagListTable =
    element baseTagListTable { attribute id { text }, baseTagListTable }

  baseTagListTableOffset = attribute name { text } | baseTagListTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseTagListTableFromXML (Element t, Element table,
                                        Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList children = t.getChildNodes ();

    Block me = new Block (2 + 4 * children.getLength (), 0);
    me.setuint16 (0, children.getLength ());
    int offset = 2;
    for (int i = 0; i &lt; children.getLength (); i++) {
      me.setTag (offset, ((Element)(children.item (i))).getAttribute ("v"));
      offset += 4; }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>


      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  public void baseTagListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void baseTagListTableOffsetToXML (DecompilerConfig conf, int offset,
                                           int [] counts,
                                           String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "baseTagListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      baseTagListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void baseTagListTableToXML (DecompilerConfig conf, int offset,
                                     int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "baseTagListTable_" + Integer.toHexString (offset));
      baseTagListTableToXMLEmit (conf, offset, counts, "baseTagListTable", at);
      counts [offset] = 0; }
  }

  public void baseTagListTableToXMLEmit (DecompilerConfig conf, int offset,
                                         int[] counts,
                                         String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {
      for (int i = 0; i &lt; getuint16 (offset); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "v", "v", "CDATA",
                         Tag.tag2string (getuint32 (offset + 2 + 4*i)));
        conf.ch.element ("tag", at); }
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseScriptList Table and BaseScript Record</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The BaseScriptList table identifies all scripts in the
          font that are rendered in the same layout direction. If a
          script is not listed here, then the text-processing client
          will render the script using the layout information
          specified for the entire font.</para>

        <para>For each script listed in the BaseScriptList table, a
          BaseScriptRecord must be defined that identifies the script
          and references its layout data. BaseScriptRecords are stored
          in the BaseScriptRecord array, ordered alphabetically by the
          BaseScriptTag in each record. The BaseScriptCount specifies
          the total number of BaseScriptRecords in the array.</para>

        <para>Example 1 at the end of this chapter shows a sample
          BaseScriptList table.</para>

        <otformat>
          <title>BaseScriptList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseScriptCount</otfieldname>
            <otfielddesc>Number of BaseScriptRecords
              defined</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>BaseScriptRecord [BaseScriptCount]</otfieldname>
            <otfielddesc>Array of BaseScriptRecords-in alphabetical
              order by BaseScriptTag</otfielddesc>
          </otfield>
        </otformat>

        <para>A BaseScriptRecord contains a script identification tag
          (BaseScriptTag), which must be identical to the ScriptTag
          used to define the script in the ScriptList of a
          <ottable>GSUB</ottable> or <ottable>GPOS</ottable> table.
          Each record also must include an offset to a BaseScript
          table that defines the baseline and min/max extent data for
          the script.</para>

        <para>Example 1 at the end of this chapter shows a sample
          BaseScriptRecord.</para>

        <otformat>
          <title>BaseScriptRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>BaseScriptTag</otfieldname>
            <otfielddesc>4-byte script identification
            tag</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseScript</otfieldname>
            <otfielddesc>Offset to BaseScript table-from beginning of
            BaseScriptList</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseScriptListTable</code-title>
  baseScriptListTable =
    element baseScriptRecord {
      attribute tag { text },
      baseScriptTableOffset
    }*

  standaloneBaseScriptListTable =
    element baseScriptListTable { attribute id { text }, baseScriptListTable }

  baseScriptListTableOffset = attribute name { text } | baseScriptListTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseScriptListTableFromXML (Element t, Element table,
                                           Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList children = t.getChildNodes ();
    int nbChildren = children.getLength ();

    Block me = new Block (2 + 6*nbChildren, nbChildren);
    me.setuint16 (0, nbChildren);
    int offset = 2;

    for (int i = 0; i &lt; nbChildren; i++) {
      Element child = (Element) children.item (i);
      me.setTag (offset, child.getAttribute ("tag"));
      me.setOffset (offset + 4, baseScriptTableFromXML (child, table, blockCache));
      offset += 6; }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  public void baseScriptListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      baseScriptTableToXMLCount (getOffset (offset, 2 + 6*i + 4),
                             counts); }
  }

  public void baseScriptListTableOffsetToXML (DecompilerConfig conf, int offset,
                                              int [] counts,
                                              String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "baseScriptListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      baseScriptListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void baseScriptListTableToXML (DecompilerConfig conf, int offset,
                                        int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "baseScriptListTable_" + Integer.toHexString (offset));
      baseScriptListTableToXMLEmit (conf, offset, counts,
                                    "baseScriptListTable", at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      baseScriptTableToXML (conf,
                            getOffset (offset, 2 + 6*i + 4),
                            counts); }
  }

  public void baseScriptListTableToXMLEmit (DecompilerConfig conf, int offset,
                                            int[] counts,
                                            String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {
      for (int i = 0; i &lt; getuint16 (offset); i++) {
        at = new AttributesImpl ();
	at.addAttribute ("", "tag", "tag", "CDATA",
                         Tag.tag2string (getuint32 (offset + 2 + 6*i)));
        baseScriptTableOffsetToXML (conf, getOffset (offset, 2 + 6*i + 4),
                               counts, "baseScriptRecord", at); }
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseScript Table and BaseLangSys Record</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A BaseScript table organizes and specifies the baseline
          data and min/max extent data for one script. Within a
          BaseScript table, the BaseValues table contains baseline
          information, and one or more MinMax tables contain min/max
          extent data.</para>
        <para>The BaseValues table identifies the default baseline for
          the script and lists coordinate positions for each baseline
          named in the corresponding BaseTagList. Each script can
          assign a different position to each baseline, so each script
          can be aligned independently in relation to any other
          script. (For more details, see the BaseValues table
          description later in this chapter.)</para>
        <para>The DefaultMinMax table defines the default min/max
          extent values for the script. (For details, see the MinMax
          table description below.) If a language system or feature
          defined in the font has no effect on the script's default
          min/max extents, the OpenType Layout Services will use the
          default script values.</para>
        <para>Sometimes language-specific overrides for min/max
          extents are needed to properly render the glyphs in a
          specific language system. For example, a glyph substitution
          required in a language system may result in a glyph whose
          extents exceed the script's default min/max extents. Each
          language system that specifies min/max extent values must
          define a BaseLangSysRecord. The record should identify the
          language system (BaseLangSysTag) and contain an offset to a
          MinMax table of language-specific extent coordinates.</para>
        <para>Feature-specific overrides for min/max extents also may
          be needed to accommodate the effects of glyph actions used
          to implement a specific feature. For example, superscript or
          subscript features may require changes to the default script
          or language system extents. Feature-specific extent values
          not limited to a specific language system may be specified
          in the DefaultMinMax table. However, extent values used for
          a specific language system require a BaseLangSysRecord and a
          MinMax table. In addition to specifying coordinate data, the
          MinMax table must contain offsets to FeatMinMaxRecords that
          define the feature-specific min/max data.</para>

        <para>A BaseScript table has four components:</para>

        <itemizedlist>
          <listitem>
            <para>An offset to a BaseValues table (BaseValues). If no
              baseline data is defined for the script or the
              corresponding BaseTagList is set to NULL, the offset to
              the BaseValues table may be set to NULL.</para>
          </listitem>
          <listitem>
            <para>An offset to the DefaultMinMax table. If no default
              min/max extent data is defined for the script, this
              offset may be set to NULL.</para>
          </listitem>
          <listitem>
            <para>An array of BaseLangSysRecords (BaseLangSysRecord).
              The individual records stored in the BaseLangSysRecord
              array are listed alphabetically by
              BaseLangSysTag.</para>
          </listitem>
          <listitem>
            <para>A count of the BaseLangSysRecords included
              (BaseLangSysCount). If no language system or
              language-specific feature min/max values are defined,
              the BaseLangSysCount may be set to zero (0).</para>
          </listitem>
        </itemizedlist>

        <para>Example 2 at the end of this chapter shows a sample
          BaseScript table.</para>

        <otformat>
          <title>BaseScript Table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseValues</otfieldname>
            <otfielddesc>Offset to BaseValues table-from beginning of
              BaseScript table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>DefaultMinMax</otfieldname>
            <otfielddesc>Offset to MinMax table- from beginning of
              BaseScript table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseLangSysCount</otfieldname>
            <otfielddesc>Number of BaseLangSysRecords defined-may be
              zero (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>BaseLangSysRecord [BaseLangSysCount]</otfieldname>
            <otfielddesc>Array of BaseLangSysRecords-in alphabetical
              order by BaseLangSysTag</otfielddesc>
          </otfield>
        </otformat>

        <para>A BaseLangSysRecord defines min/max extents for a
          language system or a language-specific feature. Each record
          contains an identification tag for the language system
          (BaseLangSysTag) and an offset to a MinMax table (MinMax)
          that defines extent coordinate values for the language
          system and references feature-specific extent data.</para>

        <para>Example 2 at the end of this chapter shows a
          BaseLangSysRecord.</para>


        <otformat>
          <title>BaseLangSysRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>BaseLangSysTag</otfieldname>
            <otfielddesc>4-byte language system identification
              tag</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MinMax</otfieldname>
            <otfielddesc>Offset to MinMax table-from beginning of
              BaseScript table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseScriptTable</code-title>
  baseScriptTable =
    element baseValues    { baseValuesTableOffset }?,
    element defaultMinMax { minMaxTableOffset }?,
    element baseLangSysRecord {
      attribute tag { text },
      element minMax { minMaxTableOffset }
    }*

  standaloneBaseScriptTable =
     element baseScriptTable { attribute id { text }, baseScriptTable }

  baseScriptTableOffset = attribute name { text } | baseScriptTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseScriptTableFromXML (Element t, Element table,
                                       Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    Element child;

    Block baseValuesBlock = null;
    child = (Element) t.getFirstChild ();
    if (child != null
        &amp;&amp; "baseValues".equals (child.getTagName())) {
      baseValuesBlock = baseValuesTableFromXML (child,
                                                table, blockCache);
      t.removeChild (child); }

    Block defaultMinMaxBlock = null;
    child = (Element) table.getFirstChild ();
    if (child != null
        &amp;&amp;"defaultMinMax".equals (child.getTagName ())) {
      defaultMinMaxBlock = minMaxTableFromXML (child,
                                               table, blockCache);
      t.removeChild (child); }

    NodeList children = t.getChildNodes ();
    int nbChildren = children.getLength ();

    Block me = new Block (6 + 2*nbChildren, 2 + nbChildren);
    me.setOffset (0, baseValuesBlock);
    me.setOffset (2, defaultMinMaxBlock);
    me.setuint16 (4, nbChildren);

    int offset = 6;
    for (int i = 0; i &lt; nbChildren; i++) {
      child = (Element) children.item (i);
      me.setTag (offset, child.getAttribute ("tag"));
      me.setOffset (offset + 4, minMaxTableFromXML ((Element) child.getFirstChild (),
                                                    table, blockCache)); }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>
<!--GOO-->

<code-fragment id='base.methods'>
  public void baseScriptTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    if (getOffset (offset) != 0) {
      baseValuesTableToXMLCount (getOffset (offset, 0), counts); }
    if (getOffset (offset + 2) != 0) {
      minMaxTableToXMLCount (getOffset (offset, 2), counts); }
    for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
      minMaxTableToXMLCount (getOffset (offset, 6 + 6*i + 4), counts); }
  }

  public void baseScriptTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "baseScriptTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      baseScriptTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void baseScriptTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "baseScriptTable_" + Integer.toHexString (offset));
      baseScriptTableToXMLEmit (conf, offset, counts,
                               "baseScriptTable", at);
      counts [offset] = 0; }

    if (getOffset (offset) != 0) {
      baseValuesTableToXML (conf, getOffset (offset, 0), counts); }
    if (getOffset (offset + 2) != 0) {
      minMaxTableToXML (conf, getOffset (offset, 2), counts); }
    for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
      minMaxTableToXML (conf, getOffset (offset, 6 + 6*i + 4), counts); }
  }


  public void baseScriptTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
                                    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {
      if (getOffset (offset) != 0) {
        at = new AttributesImpl ();
        baseValuesTableOffsetToXML (conf, getOffset (offset, 0), counts,
                                    "baseValues", at); }

      if (getOffset (offset + 2) != 0) {
        at = new AttributesImpl ();
        minMaxTableOffsetToXML (conf, getOffset (offset, 2), counts,
                                "defaultMinMax", at); }

      for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "tag", "tag", "CDATA",
                         Tag.tag2string (getuint32 (offset + 6 + 6*i)));
        minMaxTableOffsetToXML (conf, getOffset (offset, 6 + 6*i + 4),
                                counts, "baseLangSysRecord", at); }

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseValues Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A BaseValues table lists the coordinate positions of all
          baselines named in the BaselineTag array of the
          corresponding BaseTagList and identifies a default baseline
          for a script.</para>

        <para>Note: When the offset to the corresponding BaseTagList
          is NULL, a BaseValues table is not needed. However, if the
          offset is not NULL, then each script must specify coordinate
          positions for all baselines named in the BaseTagList.</para>

        <para>The default baseline, one per script, is the baseline
          used to lay out and align the glyphs in the script. The
          DefaultIndex in the BaseValues table identifies the default
          baseline with a value that equals the array index position
          of the corresponding tag in the BaselineTag array.</para>
        <para>For example, the Han and Latin scripts use different
          baselines to align text. If a font supports both of these
          scripts, the BaselineTag array in the BaseTagList of the
          HorizAxis table will contain two tags, listed
          alphabetically: "ideo" in BaselineTag[0] for the Han
          ideographic baseline, and "romn" in BaselineTag[1] for the
          Latin baseline. The BaseValues table for the Latin script
          will specify the roman baseline as the default, so the
          DefaultIndex in the BaseValues table for Latin will be "1"
          to indicate the roman baseline tag. In the BaseValues table
          for the Han script, the DefaultIndex will be "0" to indicate
          the ideographic baseline tag.</para>
        <para>Two or more scripts may share a default baseline. For
          instance, if the font described above also supports the
          Cyrillic script, the BaselineTag array does not need a
          baseline tag for Cyrillic because Cyrillic and Latin share
          the same baseline. The DefaultIndex defined in the
          BaseValues table for the Cyrillic script will specify "1" to
          indicate the roman baseline tag, listed in the second
          position in the BaselineTag array.</para>
        <para>In addition to identifying the DefaultIndex, the
          BaseValues table contains an offset to an array of BaseCoord
          tables (BaseCoord) that list the coordinate positions for
          all baselines, including the default baseline, named in the
          associated BaselineTag array. One BaseCoord table is defined
          for each baseline. The BaseCoordCount defines the total
          number of BaseCoord tables, which must equal the number of
          baseline tags listed in BaseTagCount in the
          BaseTagList.</para>
        <para>Each baseline coordinate is defined as a single X or Y
          value in design units measured from the zero position on the
          relevant X or Y axis. For example, a BaseCoord table defined
          in the HorizAxis table will contain a Y value because
          horizontal baselines are positioned vertically. BaseCoord
          values may be negative. Each script may assign a different
          coordinate to each baseline.</para>
        <para>Offsets to each BaseCoord table are stored in a
          BaseCoord array within the BaseValues table. The order of
          the stored offsets corresponds to the order of the tags
          listed in the BaselineTag array of the BaseTagList. In other
          words, the first position in the BaseCoord array will define
          the offset to the BaseCoord table for the first baseline
          named in the BaselineTag array, the second position will
          define the offset to the BaseCoord table for the second
          baseline named in the BaselineTag array, and so on.</para>
        <para>Example 3 at the end of the chapter has two parts, one
          that shows a BaseValues table and one that shows a chart
          with different baseline positions defined for several
          scripts.</para>

        <otformat>
          <title>BaseValues table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>DefaultIndex</otfieldname>
            <otfielddesc>Index number of default baseline for this
              script-equals index position of baseline tag in
              BaselineArray of the BaseTagList</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseCoordCount</otfieldname>
            <otfielddesc>Number of BaseCoord tables defined-should
              equal BaseTagCount in the BaseTagList</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseCoord [BaseCoordCount]</otfieldname>
            <otfielddesc>Array of offsets to BaseCoord-from beginning
              of BaseValues table-order matches BaselineTag array in
              the BaseTagList</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseValuesTable</code-title>
  baseValuesTable =
    attribute defaultIndex { text },

    element baseCoord { baseCoordTableOffset }*

  standaloneBaseValuesTable =
    element baseValuesTable { attribute id { text }, baseValuesTable }

  baseValuesTableOffset = attribute name { text } | baseValuesTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseValuesTableFromXML (Element t, Element base,
                                       Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (base, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList children = t.getChildNodes ();
    int nbChildren = children.getLength ();

    Block me = new Block (4 + 2*nbChildren, nbChildren);
    me.setuint16 (0, Integer.parseInt (t.getAttribute ("defaultIndex")));
    me.setuint16 (2, nbChildren);

    int offset = 4;
    for (int i = 0; i &lt; nbChildren; i++) {
      Element child = (Element) children.item (i);
      me.setOffset (offset, baseCoordTableFromXML (child,
                                                   base, blockCache));
      offset += 2; }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  public void baseValuesTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
      baseCoordTableToXMLCount (getOffset (offset, 4 + 2*i), counts); }
  }

  public void baseValuesTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "baseValuesTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      baseValuesTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void baseValuesTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "baseValuesTable_" + Integer.toHexString (offset));
      baseValuesTableToXMLEmit (conf, offset, counts,
                                "baseValuesTable", at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
      baseCoordTableToXML (conf,
                           getOffset (offset, 4 + 2*i),
			   counts); }
  }

  public void baseValuesTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "defaultIndex", "defaultIndex", "CDATA",
                     "" + getuint16 (offset));
    conf.ch.startElement (element, at); {
      for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
        at = new AttributesImpl ();
        baseCoordTableOffsetToXML (conf, getOffset (offset, 4 + 2*i),
                                   counts, "baseCoord", at); }

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>The MinMax Table and FeatMinMaxRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The MinMax table specifies extents for scripts and
          language systems. It also contains an array of
          FeatMinMaxRecords used to define feature-specific
          extents.</para>
        <para>Both the MinMax table and the FeatMinMaxRecord define
          offsets to two BaseCoord tables: one that defines the
          mimimum extent value (MinCoord), and one that defines the
          maximum extent value (MaxCoord). Each extent value is a
          single X or Y value, depending upon the text direction, and
          is specified in design units. Coordinate values may be
          negative.</para>

        <para>Different tables define the min/max extent values for
          scripts, language systems, and features:</para>

        <itemizedlist>
          <listitem>
            <para>Min/max extent values for a script are defined in
              the DefaultMinMax table, referenced in a BaseScript
              table.</para>
          </listitem>
          <listitem>
            <para>Within the DefaultMinMax table, FeatMinMaxRecords
              can specify extent values for features that apply to the
              entire script.</para>
          </listitem>
          <listitem>
            <para>Min/max extent values for a language system are
              defined in the MinMax table, referenced in a
              BaseLangSysRecord.</para>
          </listitem>
          <listitem>
            <para>FeatMinMaxRecords can be defined within the MinMax
              table to specify extent values for features applied
              within a language system.</para>
          </listitem>
        </itemizedlist>

        <para>In a FeatMinMaxRecord, the MinCoord and MaxCoord tables
          specify the minimum and maximum coordinate values for the
          feature, and a FeatureTableTag defines a 4-byte feature
          identification tag. The FeatureTableTag must match the tag
          used to identify the feature in the FeatureList of the
          <ottable>GSUB</ottable> or <ottable>GPOS</ottable>
          table.</para>

        <para>Each feature that exceeds the default min/max values
          requires a FeatMinMaxRecord. All FeatMinMaxRecords are
          listed alphabetically by FeatureTableTag in an array
          (FeatMinMaxRecord) within the MinMax table. FeatMinMaxCount
          defines the total number of FeatMinMaxRecords.</para>

        <para>Text-processing clients should use the following
          procedure to access the script, language system, and
          feature-specific extent data:</para>

        <itemizedlist>
          <listitem>
            <para>Determine script extents in relation to the text
              content.</para>
          </listitem>
          <listitem>
            <para>Select language-specific extent values with respect
              to the language system in use.</para>
          </listitem>
          <listitem>
            <para>Have the application or user choose feature-specific
              extent values.</para>
          </listitem>
          <listitem>
            <para>If no extent values are defined for a language
              system or for language-specific features, use the
              default min/max extent values for the script.</para>
          </listitem>
        </itemizedlist>

        <para>Example 4 at the end of this chapter has two parts. One
          shows MinMax tables and a FeatMinMaxRecord for different
          script, language system, and feature extents. The second
          part shows how to define these tables when a language system
          needs feature-specific extent values for an obscure feature,
          but otherwise the language system and script extent values
          match.</para>


        <otformat>
          <title>MinMax table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MinCoord</otfieldname>
            <otfielddesc>Offset to BaseCoord table-defines minimum
              extent value-from the beginning of MinMax table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MaxCoord</otfieldname>
            <otfielddesc>Offset to BaseCoord table-defines maximum
              extent value-from the beginning of MinMax table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatMinMaxCount</otfieldname>
            <otfielddesc>Number of FeatMinMaxRecords-may be zero
              (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>FeatMinMaxRecord [FeatMinMaxCount]</otfieldname>
            <otfielddesc>Array of FeatMinMaxRecords-in alphabetical
              order, by FeatureTableTag</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>FeatMinMaxRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>FeatureTableTag</otfieldname>
            <otfielddesc>4-byte feature identification tag-must match
              FeatureTag in FeatureList</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MinCoord</otfieldname>
            <otfielddesc>Offset to BaseCoord table-defines minimum
              extent value-from beginning of MinMax table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MaxCoord</otfieldname>
            <otfielddesc>Offset to BaseCoord table-defines maximum
              extent value-from beginning of MinMax table-may be
              NULL</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  minMaxTable =
    element minCoord { baseCoordTableOffset }?,
    element maxCoord { baseCoordTableOffset }?,
    element featMinMax { featMinMaxRecord }*

  featMinMaxRecord =
    attribute v { text },

    element minCoord { baseCoordTableOffset }?,
    element maxCoord { baseCoordTableOffset }?

  standaloneMinMaxTable =
    element minMaxTable { attribute id { text }, minMaxTable }

  minMaxTableOffset = attribute name { text } | minMaxTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block minMaxTableFromXML (Element table, Element base,
                                   Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = table.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        table = resolveXMLid (base, name); }}

    { Block cached = blockCache.get (table);
      if (cached != null) {
        return cached; }}

    Element child;

    Block minCoordBlock = null;
    child = (Element) table.getFirstChild ();
    if (child != null
        &amp;&amp; "minCoord".equals (child.getTagName())) {
      minCoordBlock = baseCoordTableFromXML (child,
                                             base, blockCache);
      table.removeChild (child); }

    Block maxCoordBlock = null;
    child = (Element) table.getFirstChild ();
    if (child != null
        &amp;&amp;"maxCoord".equals (child.getTagName ())) {
      maxCoordBlock = baseCoordTableFromXML (child,
                                             base, blockCache);
      table.removeChild (child); }

    NodeList children = table.getChildNodes ();
    int nbChildren = children.getLength ();

    Block me = new Block (6 + 6*nbChildren, 2 + nbChildren);
    me.setOffset (0, minCoordBlock);
    me.setOffset (2, maxCoordBlock);
    me.setuint16 (4, nbChildren);

    int offset = 6;
    for (int i = 0; i &lt; nbChildren; i++) {
      child = (Element) children.item (i);
      me.setTag (offset, child.getAttribute ("tag"));
      Element subChild = (Element) child.getFirstChild ();
      if (subChild != null
          &amp;&amp; "minCoord".equals (subChild.getTagName ())) {
        me.setOffset (offset + 4, baseCoordTableFromXML (subChild,
                                                    base, blockCache));
        child.removeChild (subChild); }
      else {
        me.setOffset (offset + 4, null); }

      subChild = (Element) child.getFirstChild ();
      if (subChild != null
          &amp;&amp; "maxCoord".equals (subChild.getTagName ())) {
        me.setOffset (offset + 6, baseCoordTableFromXML (subChild,
                                                    base, blockCache));
        child.removeChild (subChild); }
      else {
        me.setOffset (offset + 6, null); }
      offset += 6; }

    blockCache.put (table, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  public void minMaxTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    if (getOffset (offset) != 0) {
      baseCoordTableToXMLCount (getOffset (offset, 0), counts); }
    if (getOffset (offset + 2) != 0) {
      baseCoordTableToXMLCount (getOffset (offset, 2), counts); }
    for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
      if (getOffset (offset + 6 + 8*i + 4) != 0) {
        baseCoordTableToXMLCount (getOffset (offset, 6 + 8*i + 4),
                                  counts); }
      if (getOffset (offset + 6 + 8*i + 6) != 0) {
        baseCoordTableToXMLCount (getOffset (offset, 6 + 8*i + 6),
                                  counts); }}
  }

  public void minMaxTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "minMaxTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      minMaxTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void minMaxTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "minMaxTable_" + Integer.toHexString (offset));
      minMaxTableToXMLEmit (conf, offset, counts,
                            "minMaxTable", at);
      counts [offset] = 0; }

    if (getOffset (offset) != 0) {
      baseCoordTableToXML (conf, getOffset (offset, 0), counts); }
    if (getOffset (offset + 2) != 0) {
      baseCoordTableToXML (conf, getOffset (offset, 2), counts); }
    for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
      if (getOffset (offset + 6 + 8*i + 4) != 0) {
        baseCoordTableToXML (conf, getOffset (offset, 6 + 8*i + 4),
                             counts); }
      if (getOffset (offset + 6 + 8*i + 6) != 0) {
        baseCoordTableToXML (conf, getOffset (offset, 6 + 8*i + 6),
                             counts); }}
  }

  public void minMaxTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
                                    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {
      if (getOffset (offset) != 0) {
        at = new AttributesImpl ();
        baseCoordTableOffsetToXML (conf, getOffset (offset, 0), counts,
                                   "minCoord", at); }

      if (getOffset (offset + 2) != 0) {
        at = new AttributesImpl ();
        baseCoordTableOffsetToXML (conf, getOffset (offset, 2), counts,
                                   "maxCoord", at); }

      for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
        at = new AttributesImpl ();
        conf.ch.startElement ("featMinMax", at); {

          at = new AttributesImpl ();
          at.addAttribute ("", "v", "v", "CDATA",
                           Tag.tag2string (getuint32 (offset + 6 + 8*i)));
          conf.ch.element ("tag", at);

          if (getOffset (offset + 6 + 8*i + 4) != 0) {
            at = new AttributesImpl ();
            baseCoordTableOffsetToXML (conf, getOffset (offset, 6 + 8*i + 4),
                                       counts, "minCoord", at); }

          if (getOffset (offset + 6 + 8*i + 6) != 0) {
            at = new AttributesImpl ();
            baseCoordTableOffsetToXML (conf, getOffset (offset, 6 + 8*i + 6),
                                       counts, "maxCoord", at); }

          conf.ch.endElement ("featMinMax"); }}

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseCoord Tables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Within the <ottable>BASE</ottable> table, a BaseCoord table defines
          baseline and min/max extent values. Each BaseCoord table
          defines one X or Y value:</para>

        <itemizedlist>
          <listitem>
            <para>If defined within the HorizAxis table, then the
              BaseCoord table contains a Y value.</para>
          </listitem>
          <listitem>
            <para>If defined within the VertAxis table, then the
              BaseCoord table contains an X value.</para>
          </listitem>
        </itemizedlist>

        <para>All values are defined in design units, which typically
          are scaled and rounded to the nearest integer when scaling
          the glyphs. Values may be negative.</para>
        <para>Three formats available for BaseCoord table data define
          single X or Y coordinate values in design units. Two of the
          formats also support fine adjustments to the X or Y values
          based on a contour point or a Device table.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseCoordTable</code-title>
  standaloneBaseCoordTable =
    element baseCoordTable { attribute id { text }, baseCoordTable }

  baseCoordTableOffset = attribute name { text } | baseCoordTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  <code-title>Compile pairPos lookups</code-title>
  private Block baseCoordTableFromXML (Element t,
                                       Element base,
                                       Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (base, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    String format = t.getAttribute ("format");
    Block me;

    if ("1".equals (format)) {
      me = baseCoordTableFormat1FromXML (t, base, blockCache); }
    else if ("2".equals (format)) {
      me = baseCoordTableFormat2FromXML (t, base, blockCache); }
    else if ("3".equals (format)) {
      me = baseCoordTableFormat3FromXML (t, base, blockCache); }
    else {
      /* cannot get here from a valid document */
      throw new InvalidFontException
                  ("invalid pair pos lookup format (" + format + ")"); }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='base.methods'>
  <code-title>??</code-title>

  public void baseCoordTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return;}

    switch (getuint16 (offset)) {
      <code-include linkend='baseCoordTableToXMLCount.cases'/>
    }
  }

  public void baseCoordTableOffsetToXML (DecompilerConfig conf, int offset,
                                         int [] counts,
                                         String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "baseCoordTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      baseCoordTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void baseCoordTableToXML (DecompilerConfig conf, int offset,
                                   int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "baseCoordTable_" + Integer.toHexString (offset));
      baseCoordTableToXMLEmit (conf, offset, counts,
                               "baseCoordTable", at);
      counts [offset] = 0; }

    switch (getuint16 (offset)) {
      <code-include linkend='baseCoordTableToXML.cases'/>
    }
  }

  public void baseCoordTableToXMLEmit (DecompilerConfig conf, int offset,
                                       int[] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "format", "format", "CDATA", "" + getuint16 (offset));

    switch (getuint16 (offset)) {
      <code-include linkend='baseCoordTableToXMLEmit.cases'/>
    }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseCoord Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The first BaseCoord format (BaseCoordFormat1) consists
          of a format identifier, followed by a single design unit
          coordinate that specifies the BaseCoord value. This format
          has the benefits of small size and simplicity, but the
          BaseCoord value cannot be hinted for fine adjustments at
          different sizes or device resolutions.</para>
        <para>Example 5 at the end of the chapter shows a sample of a
          BaseCoordFormat1 table.</para>


        <otformat>
          <title>BaseCoordFormat1 table: Design units only</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseCoordFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>Coordinate</otfieldname>
            <otfielddesc>X or Y value, in design units</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseCoordTable, format 1</code-title>
  baseCoordTable |=
    attribute format { "1" },
    attribute coord { text }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseCoordTableFormat1FromXML (Element t, Element base,
                                             Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (4, 0);
    me.setuint16 (0, 1);
    me.setuint16 (2, Integer.parseInt (t.getAttribute ("coord")));

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='baseCoordTableToXMLEmit.cases'>
  case 1: {
    at.addAttribute ("", "coord", "coord", "CDATA", "" + getint16 (offset + 2));
    conf.ch.element (element, at);
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseCoord Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The second BaseCoord format (BaseCoordFormat2) specifies
          the BaseCoord value in design units, but also supplies a
          glyph index and a contour point for reference. During font
          hinting, the contour point on the glyph outline may move.
          The point's final position after hinting provides the final
          value for rendering a given font size.</para>

        <blockquote>
          <para>Note: Glyph positioning operations defined in the
            <ottable>GPOS</ottable> table do not affect the point's
            final position.</para>
        </blockquote>

        <para>Example 6 shows a sample of a BaseCoordFormat2
          table.</para>


        <otformat>
          <title>BaseCoordFormat2 table: Design units plus contour point</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseCoordFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>Coordinate</otfieldname>
            <otfielddesc>X or Y value, in design units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>ReferenceGlyph</otfieldname>
            <otfielddesc>GlyphID of control glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseCoordPoint</otfieldname>
            <otfielddesc>Index of contour point on the
              ReferenceGlyph</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseCoordTable, format 2</code-title>
  baseCoordTable |=
    attribute format { "2" },
    attribute coord { text },
    attribute glyphID { text },
    attribute baseCoordPoint { text }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseCoordTableFormat2FromXML (Element table, Element base,
                                             Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (8, 0);
    me.setuint16 (0, 2);
    me.setuint16 (2, Integer.parseInt (table.getAttribute ("coord")));
    me.setuint16 (4, Integer.parseInt (table.getAttribute ("glyphID")));
    me.setuint16 (6, Integer.parseInt (table.getAttribute ("baseCoordPoint")));

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='baseCoordTableToXMLEmit.cases'>
  case 2: {
    at.addAttribute ("", "coord", "coord", "CDATA",
                     "" + getint16 (offset + 2));
    at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                     "" + getuint16 (offset + 4));
    at.addAttribute ("", "baseCoordPoint", "baseCoordPoint", "CDATA",
                     "" + getuint16 (offset + 6));
    conf.ch.element (element, at);
    break; }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BaseCoord Format 3</title>

      <!--___________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The third BaseCoord format (BaseCoordFormat3) also
          specifies the BaseCoord value in design units, but it uses a
          Device table rather than a contour point to adjust the
          value. This format offers the advantage of fine-tuning the
          BaseCoord value for any font size and device resolution.
          (For more information about Device tables, see the chapter,
          Common Table Formats.)</para>

        <para>Example 7 at the end of this chapter shows a sample of a
          BaseCoordFormat3 table.</para>


        <otformat>
          <title>BaseCoordFormat3 table: Design units plus Device table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseCoordFormat</otfieldname>
            <otfielddesc>Format identifier-format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>Coordinate</otfieldname>
            <otfielddesc>X or Y value, in design units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>DeviceTable</otfieldname>
            <otfielddesc>Offset to Device table for X or Y
              value</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>baseCoordTable, format 3</code-title>
  baseCoordTable |=
    attribute format { "3" },
    attribute coord {text },
    element deviceTable { deviceTableOffset }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='base.methods'>
  public Block baseCoordTableFormat3FromXML (Element table, Element base,
                                             Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (6, 1);
    me.setuint16 (0, 3);
    me.setuint16 (2, Integer.parseInt (table.getAttribute ("coord")));
    me.setOffset (4, deviceTableFromXML ((Element) table.getFirstChild (),
                                         base, blockCache));

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='baseCoordTableToXMLCount.cases'>
  case 3: {
    deviceTableToXMLCount (getOffset (offset, 4), counts);
    break; }
</code-fragment>

<code-fragment id='baseCoordTableToXML.cases'>
  case 3: {
    deviceTableToXML (conf, getOffset (offset, 4), counts);
    break; }
</code-fragment>

<code-fragment id='baseCoordTableToXMLEmit.cases'>
  case 3: {
    at.addAttribute ("", "coord", "coord", "CDATA", "" + getint16 (offset + 2));
    conf.ch.startElement (element, at);  {
      deviceTableOffsetToXML (conf, getOffset (offset, 4), counts,
                              "deviceTable", new AttributesImpl ()); }
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>BASE Table Examples</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The rest of this chapter describes and illustrates
          examples of all the <ottable>BASE</ottable> tables. All the
          examples reflect unique parameters described below, but the
          samples provide a useful reference for building tables
          specific to other situations.</para>

        <para>Most of the examples have three columns showing hex
          data, source, and comments.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 1: BASE Header Table, Axis Table, BaseTagList
        Table, BaseScriptList Table, and BaseScriptRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 1 describes a sample font that contains four
          scripts: Cyrillic, Devanagari, Han, and Latin. All four
          scripts are rendered horizontally; only one script, Han, is
          rendered vertically. As a result, the
          <ottable>BASE</ottable> header gives offsets to two Axis
          tables: HorizAxis and VertAxis. Example 1 only shows data
          defined in the HorizAxis table.</para>

        <para>In the HorizAxis table, the BaseScriptList enumerates
          all four scripts. The BaseTagList table names three
          horizontal baselines for rendering these scripts: hanging,
          ideographic, and roman. The hanging baseline is the default
          for Devanagari, the ideographic baseline is the default for
          Han, and the roman baseline is the default for both Latin
          and Cyrillic.</para>

        <para>The VertAxis table (not shown) would be defined
          similarly: its BaseScriptList would enumerate one script,
          Han, and its BaseTagList would specify the vertically
          centered baseline for rendering the Han script.</para>


        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc><emphasis>BASEHeader</emphasis></otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheBASEHeader</otexsrc>
            <otexcom><ottable>BASE</ottable> table header definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00010000</otexdata>
            <otexsrc>0x00010000</otexsrc>
            <otexcom>Version</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>HorizontalAxisTable</otexsrc>
            <otexcom>Offset to HorizAxis table</otexcom>
          </otexline>
          <otexline>
            <otexdata>010C</otexdata>
            <otexsrc>VerticalAxisTable</otexsrc>
            <otexcom>Offset to VertAxis tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Axis</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizontalAxisTable</otexsrc>
            <otexcom>Axis table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>HorizBaseTagList</otexsrc>
            <otexcom>Offset to BaseTagList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>HorizBaseScriptList</otexsrc>
            <otexcom>Offset to BaseScriptList tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseTagList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizBaseTagList</otexsrc>
            <otexcom>BaseTagList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>BaseTagCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>68616E67</otexdata>
            <otexsrc>"hang"</otexsrc>
            <otexcom>BaselineTag[0], in alphabetical order</otexcom>
          </otexline>
          <otexline>
            <otexdata>6964656F</otexdata>
            <otexsrc>"ideo"</otexsrc>
            <otexcom>BaselineTag[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>726F6D6E</otexdata>
            <otexsrc>"romn"</otexsrc>
            <otexcom>BaselineTag[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseScriptList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizBaseScriptList</otexsrc>
            <otexcom>BaseScriptList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>BaseScriptCount BaseScriptRecord[0], in
                  alphabetical order</otexcom>
          </otexline>
          <otexline>
            <otexdata>6379726C</otexdata>
            <otexsrc>"cyrl"</otexsrc>
            <otexcom>BaseScriptTag for Cyrillic script</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>HorizCyrillicBaseScriptTable</otexsrc>
            <otexcom>Offset to BaseScript table for Cyrillic script
                  BaseScriptRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6465766E</otexdata>
            <otexsrc>"devn"</otexsrc>
            <otexcom>BaseScriptTag for Devanagari script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0060</otexdata>
            <otexsrc>HorizDevanagariBaseScriptTable</otexsrc>
            <otexcom>Offset to BaseScript table for Devanagari
                  script BaseScriptRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>68616E69</otexdata>
            <otexsrc>"hani"</otexsrc>
            <otexcom>BaseScriptTag for Han script</otexcom>
          </otexline>
          <otexline>
            <otexdata>008A</otexdata>
            <otexsrc>HorizHanBaseScriptTable</otexsrc>
            <otexcom>Offset to BaseScript table for Han script
                  BaseScriptRecord[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C61746E</otexdata>
            <otexsrc>"latn"</otexsrc>
            <otexcom>BaseScriptTag for Latin script</otexcom>
          </otexline>
          <otexline>
            <otexdata>00B4</otexdata>
            <otexsrc>HorizLatinBaseScriptTable</otexsrc>
            <otexcom>Offset to BaseScript table for Latin
                  script</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 2: BaseScript Table and BaseLangSysRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 2 shows the BaseScript table and
          BaseLangSysRecord for the Cyrillic script, one of the four
          scripts included in the sample font described in Example 1.
          The BaseScript table specifies offsets to tables that
          contain the baseline and min/max extent data for Cyrillic.
          (The BaseScript tables for the other three scripts in the
          font would be defined similarly.) Again, the table specifies
          only the horizontal text-layout information.</para>
        <para>The HorizCyrillicBaseValues table contains the baseline
          information for the script, and the
          HorizCyrillicDefaultMinMax table contains the default script
          extents. In addition, a BaseLangSysRecord defines min/max
          extent data for the Russian language system.</para>


        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseScript</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicBaseScriptTable</otexsrc>
            <otexcom>BaseScript table definition for Cyrillic
                  script</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>HorizCyrillicBaseValuesTable</otexsrc>
            <otexcom>Offset to BaseValues table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0022</otexdata>
            <otexsrc>HorizCyrillicDefaultMinMaxTable</otexsrc>
            <otexcom>Offset to DefaultMinMax table default script
                  extents</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseLangSysCount, feature-specific extents
                  BaseLangSysRecord[0] in alphabetical order</otexcom>
          </otexline>
          <otexline>
            <otexdata>52555320</otexdata>
            <otexsrc>"RUS "</otexsrc>
            <otexcom>BaseLangSysTag, Russian language system</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>HorizRussianMinMaxTable</otexsrc>
            <otexcom>Offset to MinMax table feature-specific
                  extents</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3: BaseValues Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 3 extends the <ottable>BASE</ottable> table
          definition for the Cyrillic script described in Examples 1
          and 2. It contains two parts:</para>

        <itemizedlist>
          <listitem>
            <para>Example 3A illustrates a fully defined BaseValues
              table for Cyrillic. The table includes the corresponding
              BaseCoord table definitions.</para>
          </listitem>
          <listitem>
            <para>Example 3B shows two different sets of baseline
              values that can be defined for each of the four scripts
              in the sample font.</para>
          </listitem>
        </itemizedlist>

        <para>The examples show only horizontal text-layout data, and
          the font uses 2,048 design units/em.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3A: BaseValues Table for Cyrillic</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The BaseValues table of Example 3A identifies the
          default baseline for Cyrillic and specifies coordinate
          positions for each baseline listed in the BaseTagList shown
          in Example 1:</para>

        <itemizedlist>
          <listitem>
            <para>The hanging baseline is the default for the
              Devanagari script, and it has the highest baseline
              position.</para>
          </listitem>
          <listitem>
            <para>The ideographic baseline is the default for the Han
              script, and it has the lowest baseline position.</para>
          </listitem>
          <listitem>
            <para>The roman baseline is the default for both the Latin
              and Cyrillic scripts, and its position lies between the
              hanging and ideographic baselines.</para>
          </listitem>
        </itemizedlist>

        <otexample>
          <title>Example 3A</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseValues</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicBaseValuesTable</otexsrc>
            <otexcom>BaseValues table definition for Cyrillic
                  script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>DefaultIndex, roman baseline BaselineTag
                  index</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>BaseCoordCount, equals BaseTagCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>HorizHangingBaseCoordForCyrl</otexsrc>
            <otexcom>Offset to BaseCoord[0] table hanging baseline
                  coordinate, order matches order of BaselineTag array
                  in BaseTagList</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>HorizideographicBaseCoordForCyrl</otexsrc>
            <otexcom>Offset to BaseCoord[1] table ideographic
                  baseline coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>HorizromanBaseCoordForCyrl</otexsrc>
            <otexcom>Offset to BaseCoord[2] table roman baseline
                  coordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizHangingBaseCoordForCyrl</otexsrc>
            <otexcom>BaseCoord table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>05DC</otexdata>
            <otexsrc>1500</otexsrc>
            <otexcom>Coordinate Y value, in design unit</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizideographicBaseCoordForCyrl</otexsrc>
            <otexcom>BaseCoord table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FEE0</otexdata>
            <otexsrc>-288</otexsrc>
            <otexcom>Coordinate Y value, in design unit</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizromanBaseCoordinateForCyrl</otexsrc>
            <otexcom>BaseCoord table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat, design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Coordinate, Y value, in design units</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3B: Baseline Values for Four Scripts</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 3B shows two tables that contain baseline values
          for each of the four scripts in the sample font described in
          Example 1:</para>

        <itemizedlist>
          <listitem>
            <para>The first table shows what might happen if the
              baseline values in all four scripts are designed
              consistently. Their respective BaseValues tables list
              identical baseline values with the roman baseline
              positioned at a Y value of zero (0), the ideographic
              baseline at 1500, and the hanging baseline at
              -288.</para>
          </listitem>
          <listitem>
            <para>The second table shows what might happen if the
              baseline values in the scripts are designed differently
              with the default baseline for each script at the zero
              (0) coordinate.</para>
          </listitem>
        </itemizedlist>
        <para>Either method of assigning baseline values can be used
          in the <ottable>BASE</ottable> table.</para>


        <table>
          <title>Example 3B: Identical baseline values</title>

          <tgroup cols='5'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <thead>
              <row>
                <entry>Baseline type</entry>
                <entry>Han</entry>
                <entry>Latin</entry>
                <entry>Cyrillic</entry>
                <entry>Devanagari</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>hanging</entry>
                <entry>1500</entry>
                <entry>1500</entry>
                <entry>1500</entry>
                <entry>1500</entry>
              </row>
              <row>
                <entry>roman</entry>
                <entry>0</entry>
                <entry>0</entry>
                <entry>0</entry>
                <entry>0</entry>
              </row>
              <row>
                <entry>ideographic</entry>
                <entry>-288</entry>
                <entry>-288</entry>
                <entry>-288</entry>
                <entry>-288</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Example 3B: Assigned baseline values with default
            baselines at 0</title>

          <tgroup cols='5'>
            <colspec colwidth="10pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <colspec colwidth="5pc"/>
            <thead>
              <row>
                <entry>Baseline type</entry>
                <entry>Han</entry>
                <entry>Latin</entry>
                <entry>Cyrillic</entry>
                <entry>Devanagari</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>hanging</entry>
                <entry>1788</entry>
                <entry>1500</entry>
                <entry>1500</entry>
                <entry>0</entry>
              </row>
              <row>
                <entry>roman</entry>
                <entry>288</entry>
                <entry>0</entry>
                <entry>0</entry>
                <entry>-1500</entry>
              </row>
              <row>
                <entry>ideographic</entry>
                <entry>0</entry>
                <entry>-288</entry>
                <entry>-288</entry>
                <entry>-1788</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4: MinMax Table and FeatMinMaxRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 4 shows MinMax table and FeatMinMaxRecord
          definitions for the same Cyrillic script described in the
          previous example. It contains two parts:</para>

        <itemizedlist>
          <listitem>
            <para>Example 4A defines tables with different script,
              language system, and feature extents.</para>
          </listitem>
          <listitem>
            <para>Example 4B shows these same table definitions
              written when the language system extents match the
              script extents, but an obscure feature of the language
              system requires feature-specific extents if that feature
              is implemented.</para>
          </listitem>
        </itemizedlist>

        <para>The examples show only horizontal text-layout data, and
          the font uses 2,048 design units/em.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4A: Min/Max Extents For Cyrillic Script, Russian
        Language, and Russian Feature</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 4A shows two MinMax tables and a
          FeatMinMaxRecord for the Cyrillic script, along with sample
          BaseCoord tables. Only the MinCoord extent data is
          included.</para>

        <para>The DefaultMinMax table defines the default minimum and
          maximum extents for the Cyrillic script. Another MinMax
          table defines language-specific min/max extents for the
          Russian language system to accommodate the height and width
          of certain glyphs used in Russian. Also, a FeatMinMaxRecord
          defines min/max extents for a single feature in the Russian
          language system that substitutes a tall integral math symbol
          when required.</para>


        <otexample>
          <title>Example 4A</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MinMax</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicDefaultMinMaxTable</otexsrc>
            <otexcom>DefaultMinMax table definition, Cyrillic
                  script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>HorizCyrillicMinCoordTable</otexsrc>
            <otexcom>MinCoord offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>HorizCyrillicMaxCoordTable</otexsrc>
            <otexcom>MaxCoord offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>FeatMinMaxCount no default feature extents
                  FeatMinMaxRecord[], no FeatMinMaxRecord</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicMinCoordTable</otexsrc>
            <otexcom>BaseCoord table definition, default Cyrillic
              Min extent coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat, design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF38</otexdata>
            <otexsrc>-200</otexsrc>
            <otexcom>Coordinate Y value, in design unit</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicMaxCoordTable</otexsrc>
            <otexcom>BaseCoord table
                  definition default Cyrillic Max extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat, design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0674</otexdata>
            <otexsrc>1652</otexsrc>
            <otexcom>Coordinate Y value, in design unit</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MinMax</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianMinMaxTable</otexsrc>
            <otexcom>MinMax table definition
                  Russian language extents</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>HorizRussianLangSysMinCoordTable</otexsrc>
            <otexcom>MinCoord Offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>HorizRussianLangSysMaxCoordTable</otexsrc>
            <otexcom>MaxCoord Offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>FeatMinMaxCount FeatMinMaxRecord[0] in
                  alphabetical order</otexcom>
          </otexline>
          <otexline>
            <otexdata>696E7467</otexdata>
            <otexsrc>"intg"</otexsrc>
            <otexcom>FeatureTableTag integral math symbol Feature
                  must be same as Tag in FeatureList</otexcom>
          </otexline>
          <otexline>
            <otexdata>0016</otexdata>
            <otexsrc>HorizRussianFeatureMinCoordTable</otexsrc>
            <otexcom>MinCoord Offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>HorizRussianFeatureMaxCoordTable</otexsrc>
            <otexcom>MaxCoord Offset to BaseCoord tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianLangSys</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MinCoordTable</otexsrc>
            <otexcom>BaseCoord table definition
                  Russian language min extent coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF08</otexdata>
            <otexsrc>-248</otexsrc>
            <otexcom>Coordinate Y value, in design units, increased
                  Min extent beyond default Cyrillic min exten</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianLangSysMaxCoordTable</otexsrc>
            <otexcom>BaseCoord
                  table definition Russian language feature Max extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>06A4</otexdata>
            <otexsrc>1700</otexsrc>
            <otexcom>Coordinate Y value, in design units increased
                  max extent beyond default Cyrillic max exten</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianFeatureMinCoordTable</otexsrc>
            <otexcom>BaseCoord
                  table definition Russian language Min extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat Design Units Only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FED8</otexdata>
            <otexsrc>-296</otexsrc>
            <otexcom>Coordinate Y value, in design units, increased
                  Min extent beyond default Cyrillic script and
                  Russian language min extent</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianFeatureMaxCoordTable</otexsrc>
            <otexcom>BaseCoord
                  table definition Russian language feature Max extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>06D8</otexdata>
            <otexsrc>1752</otexsrc>
            <otexcom>Coordinate Y value, in design units increased
                  Max extent beyond default Cyrillic script and
                  Russian language max extents</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4B: Min/Max Extents For Cyrillic Script and
        Russian Feature</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A particular language system does not need to define
          min/max extent coordinates if its extents match the default
          extents defined for the script. However, an obscure or
          infrequently used feature within the language system may
          require feature-specific extent values for proper
          rendering.</para>
        <para>Example 4B shows the MinMax and FeatMinMaxRecord table
          definitions for this situation. The example also includes a
          BaseScript table, but not a BaseValues tables since it is
          not relevant in this example. The example shows horizontal
          text layout extents for the Cyrillic script and
          feature-specific extents for one feature in the Russian
          language system. Much of the data is repeated from Example
          4A and modified here for comparison.</para>
        <para>The BaseScript table includes a DefaultMinMax table for
          the Cyrillic script and a BaseLangSysRecord that defines a
          BaseLangSysTag and an offset to a MinMax table for the
          Russian language. The MinMax table includes a
          FeatMinMaxRecord and specifies a FeatMinMaxCount, but both
          the MinCoord and MaxCoord offsets in the MinMax table are
          set to NULL since no language-specific extent values are
          defined for Russian. The FeatMinMaxRecord defines the
          min/max coordinates for the Russian feature and specifies
          the correct FeatureTableTag.</para>


        <otexample>
          <title>Example 4B</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseScript</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicBaseScriptTable</otexsrc>
            <otexcom>BaseScript table
                  definition Cyrillic script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to BaseValues table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>HorizCyrillicDefault MinMaxTable</otexsrc>
            <otexcom>offset to DefaultMinMax table for default
                  script extents</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseLangSysCount</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc></otexsrc>
            <otexcom>BaseLangSysRecord[0] for Russian
                  feature-specific-extents</otexcom>
          </otexline>
          <otexline>
            <otexdata>52555320</otexdata>
            <otexsrc>"RUS</otexsrc>
            <otexcom>" BaseLangSysTag = Russian</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>HorizRussianMinMaxTable</otexsrc>
            <otexcom>offset to MinMax table for feature-specific
                  extent</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MinMax</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicDefaultMinMaxTable</otexsrc>
            <otexcom>DefaultMinMax
                  table definition Cyrillic script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>HorizCyrillicMinCoordTable</otexsrc>
            <otexcom>MinCoord offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>HorizCyrillicMaxCoordTable</otexsrc>
            <otexcom>MaxCoord offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>FeatMinMaxCount, no default feature extents
                  FeatMinMaxRecord[], no FeatMinMaxRecords</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicMinCoordTable</otexsrc>
            <otexcom>BaseCoord table
                  definition default Cyrillic Min extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF38</otexdata>
            <otexsrc>-200</otexsrc>
            <otexcom>Coordinate Y value, in design unit</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizCyrillicMaxCoordTable</otexsrc>
            <otexcom>BaseCoord table
                  definition default Cyrillic Min extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0674</otexdata>
            <otexsrc>1652</otexsrc>
            <otexcom>Coordinate Y value, in design unit</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MinMax</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianMinMaxTable</otexsrc>
            <otexcom>MinMax table definition
                  for Russian feature no extent differences for
                  Russian language itself</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to Min BaseCoord table not defined,
                  matches default</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to Max BaseCoord table not defined,
                  matches default</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>FeatMinMaxCount, FeatMinMaxRecord[0] in
                  alphabetical order</otexcom>
          </otexline>
          <otexline>
            <otexdata>696E7467</otexdata>
            <otexsrc>"intg"</otexsrc>
            <otexcom>FeatureTableTag integral math sign Feature must
                  be same as Tag in FeatureList</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>HorizRussianFeatureMinCoordTable</otexsrc>
            <otexcom>MinCoord offset to BaseCoord table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>HorizRussianFeatureMaxCoordTable</otexsrc>
            <otexcom>MaxCoord offset to BaseCoord tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianFeatureMinCoordTable</otexsrc>
            <otexcom>BaseCoord
                  table definition Russian Feature Min extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat, design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FED8</otexdata>
            <otexsrc>-296</otexsrc>
            <otexcom>Coordinate Y value, in design units increased
                  Min extent beyond default Cyrillic Min
                  extent</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizRussianFeatureMaxCoordTable</otexsrc>
            <otexcom>BaseCoord
                  table definition, Russian feature Max extent
                  coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>06D8</otexdata>
            <otexsrc>1752</otexsrc>
            <otexcom>Coordinate Y value, in design units, increased
                  Max extent beyond default Cyrillic Max
                  extent</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 5: BaseCoordFormat1 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 5 illustrates BaseCoordFormat1, which specifies
          single coordinate values in design units only. The font uses
          2,048 design units/em. The example defines the default
          minimum extent coordinate for a math script.</para>


        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizMathMinCoordTable</otexsrc>
            <otexcom>Definition of BaseCoord
                  table for Math Min coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCoordFormat, design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>FEE8</otexdata>
            <otexsrc>-280</otexsrc>
            <otexcom>Coordinate Y value, in design units</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 6: BaseCoordFormat2 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 6 illustrates the BaseCoord Format 2. Like
          Example 5, it specifies the minimum extent coordinate for a
          math script. With this format, the coordinate value depends
          on the final position of a specific contour point on one
          glyph, the integral math symbol, after hinting. Again, the
          value is in design units (2,048 units/em).</para>


        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizMathMinCoordTable</otexsrc>
            <otexcom>BaseCoord table
                  definition for Math Min coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>BaseCoordFormat design units plus contour
                  point</otexcom>
          </otexline>
          <otexline>
            <otexdata>FEE8</otexdata>
            <otexsrc>-280</otexsrc>
            <otexcom>Coordinate Y value, in design units</otexcom>
          </otexline>
          <otexline>
            <otexdata>0128</otexdata>
            <otexsrc>IntegralSignGlyphID</otexsrc>
            <otexcom>ReferenceGlyph math integral sign</otexcom>
          </otexline>
          <otexline>
            <otexdata>0043</otexdata>
            <otexsrc>67</otexsrc>
            <otexcom>BaseCoordPoint glyph contour point
                  index</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 7: BaseCoordFormat3 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 7 illustrates the BaseCoord Format 3. Like
          Examples 5 and 6, it specifies the minimum extent coordinate
          for a math script in design units (2,048 units/em). This
          format, however, uses a Device table to modify the
          coordinate value for the point size and resolution of the
          output font. Here, the Device table defines pixel
          adjustments for font sizes from 11 ppem to 15 ppem. The
          adjustments add one pixel at each size.</para>


        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseCoordFormat3</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizMathMinCoordTable</otexsrc>
            <otexcom>BaseCoord table
                  definition for Math Min coordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>BaseCoordFormat design units plus device
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>-280</otexsrc>
            <otexcom>Coordinate Y value, in design
                  units</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>HorizMathMinCoordDeviceTable</otexsrc>
            <otexcom>Offset to Device tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HorizMathMinCoordDeviceTable</otexsrc>
            <otexcom>Device table
                  definition for MinCoord</otexcom>
          </otexline>
          <otexline>
            <otexdata>000B</otexdata>
            <otexsrc>11</otexsrc>
            <otexcom>StartSize -11 ppem</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>EndSize -15 ppem</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>DeltaFormat signed 2 bit value, 8 values per
                  uint16</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Increase 11ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>5540</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Increase 15ppem by 1 pixel</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.GDEF' web:index='yes'>
    <title>GDEF - The Glyph Definition Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Glyph Definition (<ottable>GDEF</ottable>) table
          contains three types of information in three independent
          tables:</para>


        <itemizedlist>
          <listitem>
            <para>The <emphasis>GlyphClassDef</emphasis> table
              classifies the different types of glyphs in the
              font.</para>
          </listitem>
          <listitem>
            <para>The <emphasis>AttachmentList</emphasis> table
              identifies all attachment points on the glyphs, which
              streamlines data access and bitmap caching.</para>
          </listitem>
          <listitem>
            <para>The <emphasis>LigatureCaretList</emphasis> table
              contains positioning data for ligature carets, which the
              text-processing client uses on screen to select and
              highlight the individual components of a ligature
              glyph.</para>
          </listitem>
          <listitem>
            <para>The <emphasis>MarkAttachClassDef</emphasis> table
              classifies mark glyphs, to help group together marks
              that are positioned similarly.</para>
          </listitem>
        </itemizedlist>

        <para>Both the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables reference the
          <ottable>GDEF</ottable> table information to supplement
          their own data for substituting and positioning glyphs. Even
          so, a <ottable>GDEF</ottable> table is optional for a font,
          included at the discretion of the font developer. Without a
          <ottable>GDEF</ottable> table, however, the text-processing
          client may have to define and maintain the
          <ottable>GDEF</ottable> information on its own when
          substituting and positioning glyphs.</para>

        <para>A client may use any one or more of the three
          <ottable>GDEF</ottable> tables during text processing. This
          overview explains how each of the three tables are organized
          and used (See Figure 7a). The rest of this chapter describes
          the individual <ottable>GDEF</ottable> tables and the tables
          that they reference.</para>

        <figure>
          <title>Figure 7a. High-level organization of <ottable>GDEF</ottable>
          table</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fig7a.gif"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>


        <para>First sentence, both occurrences of 'three' should be
	  replaced by 'four'.</para>

        <para>Last two sentences of paragraph after the bullet list: I
          am not sure that this comment applies to GlyphClassDef for
          example. There does not seem to be any mandatory data in
          <ottable>GSUB</ottable> or <ottable>GPOS</ottable> that
          would indicate the class of a glyph. Suppose that there is
          only a <ottable>GSUB</ottable> table, no
          <ottable>GPOS</ottable> and no <ottable>GDEF</ottable>; that
          <ottable>GSUB</ottable> contains only one SingleSubstitution
          lookup with LookupFlag set to ignoreBaseGlyphs. What glyphs
          should be ignored by this lookup? Or is this font
          illegal?</para>

        <para>Last paragraph: both occurrences of 'three' should be
	  replaced by 'four'.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Glyph Class Definition Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Glyph Class Definition (GlyphClassDef) table
          identifies four types of glyphs in a font: base glyphs,
          ligature glyphs, combining mark glyphs, and glyph components
          (see Figure 7b). <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> lookups define and use these glyph
          classes to differentiate the types of glyphs in a string.
          For example, <ottable>GPOS</ottable> uses the glyph classes
          to distinguish between a simple base glyph and the mark
          glyph that follows it.</para>

        <figure>
          <title>Figure 7b. A base glyph, ligature glyph, mark
            glyph, and glyph components</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fig7b.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>In addition, a client uses class definitions to apply
          <ottable>GSUB</ottable> and <ottable>GPOS</ottable>
          LookupFlag data correctly. For example, a LookupFlag may
          specify ignoring ligatures and marks during a glyph
          operation. If the font does not include a GlyphClassDef
          table, the client must define and maintain this information
          when using the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables.</para>
      </section>


      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>First sentence: shouldn&#x2019;t &#x201C;glyph
        components&#x201D; be replaced by &#x201C;component
        glyphs&#x201D;? Similarly in the figure&#x2019;s title.</para>

        <para>Last sentence: How can the client figure out the class
        of a glyph from a font lacking a GlyphClassDef table?</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Attachment Point List Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Attachment Point List table (AttachmentList)
          identifies all the attachment points defined in the
          <ottable>GPOS</ottable> table and their associated glyphs so
          a client can quickly access coordinates for each glyph's
          attachment points. As a result, the client can cache
          coordinates for attachment points along with glyph bitmaps
          and avoid recalculating the attachment points each time it
          displays a glyph. Without this table, processing speed would
          be slower because the client would have to decode the
          <ottable>GPOS</ottable> lookups that define attachment
          points and compile the points in a list.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Ligature Caret List Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Ligature Caret List table (LigatureCaretList),
          particularly useful in Arabic and other scripts with many
          ligatures, specifies coordinates for positioning carets on
          all ligatures in a font. The client uses this data to select
          and highlight ligature components in displayed text (see
          Figure 7c).</para>

        <figure>
          <title>Figure 7c. Proper ligature caret postioning</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fig7c.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Each ligature can have more than one caret position,
          with each position defined as an X or Y value on the
          baseline according to the writing direction of the script or
          language system. The font developer can use any of three
          formats to represent a caret coordinate value. One format
          represents values in design units only, another fine-tunes a
          value based on a designated contour point, and the third
          uses a Device table to adjust values at specific font
          sizes.</para>

        <para>Without a Ligature Caret List table, the client would
          have to define caret positions without knowing the positions
          of the ligature components. The resulting highlighting or
          hit-testing might be ambiguous. For example, suppose a
          client places a caret at the midpoint position along the
          width of a hyphothetical "wi" ligature. Because the "w" is
          wider than the "i," that position would not clearly indicate
          which component is selected. Instead, for accurate
          selection, the caret should be moved to the right so that
          either the "w" or "i" could be clearly highlighted.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>GDEF Header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>GDEF</ottable> table begins with a header
          that consists of a version number (Version), initially set
          to 0x00010000, an offset to a table defining the types of
          glyphs in the font (GlyphClassDef), an offset to a list
          defining attachment points on the glyphs(AttachList), an
          offset to a ligature caret list (LigCaretList) and an offset
          to a list defining types of marks that can be attached
          (MarkAttachClassDef). The format used for the
          MarkAttachClassDef is the same as that for GlyphClassDef.
          Please refer the 'LookupFlag bit enumeration' section in the
          Common Table Formats for more on using lookup flags with the
          information in these fields.</para>

        <para>Example 1 at the end of this chapter shows a
          <ottable>GDEF</ottable> Header table.</para>

        <otformat>
          <title>GDEF Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the <ottable>GDEF</ottable>
              table-initially 0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>GlyphClassDef</otfieldname>
            <otfielddesc>Offset to class definition table for glyph
              type-from beginning of <ottable>GDEF</ottable> header
              (may be NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>AttachList</otfieldname>
            <otfielddesc>Offset to list of glyphs with attachment
              points-from beginning of <ottable>GDEF</ottable> header
              (may be NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigCaretList</otfieldname>
            <otfielddesc>Offset to list of positioning points for
              ligature carets-from beginning of
              <ottable>GDEF</ottable> header (may be
              NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MarkAttachClassDef</otfieldname>
            <otfielddesc>Offset to class definition table for mark
              attachment type-from beginning of
              <ottable>GDEF</ottable> header (may  be
              NULL)</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>GDEF</code-title>
  GDEF =
    element GDEF {
      attribute major { "1" },
      attribute minor { "0" },
      element glyphClassDef      { classDefTableOffset }?,
      element attachList         { attachListTableOffset }?,
      element ligCaretList       { ligCaretListTableOffset }?,
      element markAttachClassDef { classDefTableOffset }?,

      (  standaloneClassDefTable
       | standaloneAttachListTable
       | standaloneLigCaretListTable
       | standaloneLigGlyphTable
       | standaloneCaretValueTable
       | standaloneCoverageTable
       | standaloneDeviceTable)*
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gdef.methods'>
  public void fromXML (Element gdef)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block> blockCache = new HashMap&lt;Element, Block> ();
    NodeList l = gdef.getChildNodes ();

    boolean glyphClassDefSet = false;
    boolean attachListSet = false;
    boolean ligCaretListSet = false;
    boolean markAttachClassDefSet = false;

    Block me = new Block (12, 4);
    me.setFixed (0, 1, 0);

    for (int i = 0; i &lt; l.getLength (); i++) {
      Element e = (Element) l.item (i);
      if ("glyphClassDef".equals (e.getTagName ())) {
        me.setOffset (4, classdefFromXML (e, gdef, blockCache));
        glyphClassDefSet = true;}
      if ("attachList".equals (e.getTagName ())) {
        me.setOffset (6, null /*TODO*/);
        attachListSet = true;}
      if ("ligCaretList".equals (e.getTagName ())) {
        me.setOffset (8, null /*TODO*/);
        ligCaretListSet = true; }
      if ("markAttachClassDef".equals (e.getTagName ())) {
        me.setOffset (10, classdefFromXML (e, gdef, blockCache));
        markAttachClassDefSet = true;}}

    if (! glyphClassDefSet) {
      me.setOffset (4, null); }
    if (! attachListSet) {
      me.setOffset (6, null); }
    if (! ligCaretListSet) {
      me.setOffset (8, null); }
    if (! markAttachClassDefSet) {
      me.setOffset (10, null); }

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gdef.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] counts = new int [data.length];
    for (int i = 0; i &lt; counts.length; i++) {
      counts [i] = 0; }

    if (getOffset (0, 4) != 0) {
      classDefTableToXMLCount (getOffset (0, 4), counts); }
    if (getOffset (0, 6) != 0) {
      attachListTableToXMLCount (getOffset (0, 6), counts); }
    if (getOffset (0, 8) != 0) {
      ligCaretListTableToXMLCount (getOffset (0, 8), counts); }
    if (getOffset (0, 10) != 0) {
      classDefTableToXMLCount (getOffset (0, 10), counts); }

    if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 1; }}
    if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 2; }}

    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);

    conf.ch.startElement ("GDEF", at); {

      if (getOffset (0, 4) != 0) {
        classDefTableOffsetToXML (conf, getOffset (0, 4), counts,
                                  "glyphClassDef", new AttributesImpl ()); }
      if (getOffset (0, 6) != 0) {
        attachListTableOffsetToXML (conf, getOffset (0, 6), counts,
                                   "attachList", new AttributesImpl ()); }
      if (getOffset (0, 8) != 0) {
        ligCaretListTableOffsetToXML (conf, getOffset (0, 8), counts,
                                      "ligCaretList", new AttributesImpl ()); }
      if (getOffset (0, 10) != 0) {
        classDefTableOffsetToXML (conf, getOffset (0, 10), counts,
                                  "markAttachClassDef", new AttributesImpl ()); }

      if (getOffset (0, 4) != 0) {
        classDefTableToXML (conf, getOffset (0, 4), counts); }
      if (getOffset (0, 6) != 0) {
        attachListTableToXML (conf, getOffset (0, 6), counts); }
      if (getOffset (0, 8) != 0) {
        ligCaretListTableToXML (conf, getOffset (0, 8), counts); }
      if (getOffset (0, 10) != 0) {
        classDefTableToXML (conf, getOffset (0, 10), counts); }

      conf.ch.endElement ("GDEF"); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Gdef'>
  <code-title>GDEF Class</code-title>
package com.adobe.aots.opentype;

import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Gdef extends LayoutTable {

  public Gdef () {
    super (Tag.GDEF, null);
  }

  public Gdef (Font font) {
    super (Tag.GDEF, font);
  }

  public int[] getTableVersion () {
    return getFixed (0);
  }

  <code-include linkend='gdef.methods'/>
}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Glyph Class Definition Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>GSUB</ottable> and <ottable>GPOS</ottable>
          tables use the Glyph Class Definition table (GlyphClassDef)
          to identify which glyph classes to adjust with
          lookups.</para>

        <para>The table uses the same format as the Class Definition
          table (for details, see the chapter, Common Table
          Formats). However, the GlyphClassDef table uses class values
          already defined in the GlyphClassDef Enumeration
          list:</para>

        <table>
          <title>GlyphClassDef Enumeration List</title>

          <tgroup cols='2'>
            <colspec colwidth="6pc"/>
            <colspec colwidth="24pc"/>
            <thead>
              <row>
                <entry>Class</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>Base glyph (single character, spacing glyph)</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Ligature glyph (multiple character, spacing
                  glyph)</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Mark glyph (non-spacing combining glyph)</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Component glyph (part of single character,
                  spacing glyph)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The font developer does not have to classify every glyph
        in the font, but any glyph not assigned a class value falls
        into Class zero (0). For instance, class values might be
        useful for the Arabic glyphs in a font, but not for the Latin
        glyphs. Then the GlyphClassDef table will list only Arabic
        glyphs, and-by default-the Latin glyphs will be assigned to
        Class 0. Component glyphs can be put together to generate
        ligatures. A ligature can be generated by creating a glyph in
        the font that references the component glyphs, or outputting
        the component glyphs in the desired sequence.  Component
        glyphs are not used in defining any <ottable>GSUB</ottable> or
        <ottable>GPOS</ottable> formats.</para>

        <para>Example 2 at the end of this chapter defines a
          GlyphClassDef table with a sample glyph for each of the
          assigned classes.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gdef.methods'>
  <code-title>Method to compute the GDEF class of a glyph</code-title>
  public int getGlyphClass (int glyph)
    throws InvalidFontException {

    int glyphClassOffset = getuint16 (4);
    return classIndex (glyph, glyphClassOffset);
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Attachment List Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Attachment List table (AttachList) may be used to
          cache attachment point coordinates along with glyph
          bitmaps.</para>

        <para>The table consists of an offset to a Coverage table
        (Coverage) listing all glyphs that define attachment points in
        the <ottable>GPOS</ottable> table, a count of the glyphs with
        attachment points (GlyphCount), and an array of offsets to
        AttachPoint tables (AttachPoint). The array lists the
        AttachPoint tables, one for each glyph in the Coverage table,
        in the same order as the Coverage Index.</para>

        <otformat>
          <title>AttachList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table - from beginning of
              AttachList table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs with attachment
              points</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>AttachPoint [GlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to AttachPoint tables-from
              beginning of AttachList table-in Coverage Index
              order</otfielddesc>
          </otfield>
        </otformat>

        <para>An AttachPoint table consists of a count of the
          attachment points on a single glyph (PointCount) and an
          array of contour indices of those points (PointIndex),
          listed in increasing numerical order.</para>

        <para>Example 3 at the end of the chapter demonstrates an
          AttachList table that defines attachment points for two
          glyphs.</para>


        <otformat>
          <title>AttachPoint table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PointCount</otfieldname>
            <otfielddesc>Number of attachment points on this
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PointIndex [PointCount]</otfieldname>
            <otfielddesc>Array of contour point indices -in increasing
              numerical order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>attachListTable</code-title>
  attachListTable =
    element coverage { coverageTableOffset }?,
    element attachPoint {
      attribute glyphID { text },
      element point {
        attribute index { text }
      }*
    }*

  standaloneAttachListTable =
    element attachListTable { attribute id { text }, attachListTable }

  attachListTableOffset = attribute name { text } | attachListTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gdef.methods'>
  public void attachListTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void attachListTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int[] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "attachListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      attachListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void attachListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "attachListTable_" + Integer.toHexString (offset));
      attachListTableToXMLEmit (conf, offset, counts, "attachListTable", at);
      counts [offset] = 0; }
  }

  public void attachListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {


    conf.ch.startElement (element, at); {
      int[] coveredGlyphs = getCoveredGlyphs (getOffset (offset, 0));
      int glyphCount = getuint16 (offset + 2);

      for (int g = 0; g &lt; glyphCount; g++) {
        int attachPointOffset = getOffset (offset, 4 + 2*g);
        if (attachPointOffset != 0) {
	  at = new AttributesImpl ();
          at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                           "" + coveredGlyphs [g]);
	  conf.ch.startElement ("attachPoint", at); {
	    int pointCount = getuint16 (attachPointOffset);
	    int o = attachPointOffset + 2;
	    for (int p = 0; p &lt; pointCount; p++) {
	      int pointIndex = getuint16 (o);
	      o += 2;
	      at = new AttributesImpl ();
	      at.addAttribute ("", "index", "index", "CDATA", "" + pointIndex);
	      conf.ch.element ("point", at); }

	      conf.ch.endElement ("attachPoint"); }}}

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Ligature Caret List Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Ligature Caret List table (LigCaretList) defines
          caret positions for all the ligatures in a font. The table
          consists of an offset to a Coverage table that lists all the
          ligature glyphs (Coverage), a count of the defined ligatures
          (LigGlyphCount), and an array of offsets to LigGlyph tables
          (LigGlyph). The array lists the LigGlyph tables, one for
          each ligature in the Coverage table, in the same order as
          the Coverage Index.</para>

        <para>Example 4 at the end of this chapter shows a
          LigCaretList table.</para>


        <otformat>
          <title>LigCaretList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table - from beginning of
              LigCaretList table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LigGlyphCount</otfieldname>
            <otfielddesc>Number of ligature glyphs</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigGlyph [LigGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to LigGlyph tables-from
              beginning of LigCaretList table-in Coverage Index
              order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>ligCaretListTable </code-title>
  ligCaretListTable =
    element coverage { coverageTableOffset }?,
    element ligGlyph {
      attribute glyphID { text },
      ligGlyphTableOffset
    }*

  standaloneLigCaretListTable =
    element ligCaretListTable { attribute id { text }, ligCaretListTable }

  ligCaretListTableOffset = attribute name { text } | ligCaretListTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gdef.methods'>
  public void ligCaretListTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    int glyphCount = getuint16 (offset + 2);

    for (int g = 0; g &lt; glyphCount; g++) {
      int ligGlyphOffset = getOffset (offset, 4 + 2*g);
      if (ligGlyphOffset != 0) {
        ligGlyphTableToXMLCount (ligGlyphOffset, counts); }}
  }

  public void ligCaretListTableOffsetToXML (DecompilerConfig conf, int offset,
                                            int[] counts,
                                            String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "attachListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      ligCaretListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void ligCaretListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "ligCaretListTable_" + Integer.toHexString (offset));
      ligCaretListTableToXMLEmit (conf, offset, counts, "ligCaretListTable", at);
      counts [offset] = 0; }

    int[] coveredGlyphs = getCoveredGlyphs (getOffset (offset, 0));
    int glyphCount = getuint16 (offset + 2);

    for (int g = 0; g &lt; glyphCount; g++) {
      int ligGlyphOffset = getOffset (offset, 4 + 2*g);
      if (ligGlyphOffset != 0) {
        ligGlyphTableToXML (conf, ligGlyphOffset, counts); }}
  }

  public void ligCaretListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {


    conf.ch.startElement (element, at); {
      int[] coveredGlyphs = getCoveredGlyphs (getOffset (offset, 0));
      int glyphCount = getuint16 (offset + 2);

      for (int g = 0; g &lt; glyphCount; g++) {
        int ligGlyphOffset = getOffset (offset, 4 + 2*g);
        if (ligGlyphOffset != 0) {
          at = new AttributesImpl ();
          at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                           "" + coveredGlyphs [g]);
          ligGlyphTableOffsetToXML (conf, ligGlyphOffset, counts,
                                    "ligGlyph", at); }}

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Ligature Glyph Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Ligature Glyph table (LigGlyph) contains the caret
          coordinates for a single ligature glyph. The number of
          coordinate values, each defined in a separate CaretValue
          table, equals the number of components in the ligature minus
          one (1).</para>

        <para>The LigGlyph table consists of a count of the number of
          CaretValue tables defined for the ligature (CaretCount) and
          an array of offsets to CaretValue tables
          (CaretValue).</para>

        <para>Example 4 at the end of the chapter shows a LigGlyph
          table.</para>

        <otformat>
          <title>LigGlyph table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CaretCount</otfieldname>
            <otfielddesc>Number of CaretValues for this ligature
              (components - 1)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>CaretValue [CaretCount]</otfieldname>
            <otfielddesc>Array of offsets to CaretValue tables-from
              beginning of LigGlyph table-in increasing coordinate
              order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>ligGlyphTable</code-title>
  ligGlyphTable = element caretValue { caretValueTableOffset }*

  standaloneLigGlyphTable =
    element ligGlyphTable { attribute id { text }, ligGlyphTable }

  ligGlyphTableOffset = attribute name { text } | ligGlyphTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gdef.methods'>
  public void ligGlyphTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    int caretCount = getuint16 (offset);
    for (int c = 0; c &lt; caretCount; c++) {
      int caretValueOffset = getOffset (offset, 2 + 2*c);
      if (caretValueOffset != 0) {
        caretValueTableToXMLCount (caretValueOffset, counts); }}
  }

  public void ligGlyphTableOffsetToXML (DecompilerConfig conf, int offset,
                                            int[] counts,
                                            String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "attachListTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      ligGlyphTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void ligGlyphTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "ligGlyphTable_" + Integer.toHexString (offset));
      ligGlyphTableToXMLEmit (conf, offset, counts, "ligGlyphTable", at);
      counts [offset] = 0; }

    int caretCount = getuint16 (offset);
    for (int c = 0; c &lt; caretCount; c++) {
      int caretValueOffset = getOffset (offset, 2 + 2*c);
      if (caretValueOffset != 0) {
        caretValueTableToXML (conf, caretValueOffset, counts); }}
  }

  public void ligGlyphTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {


    conf.ch.startElement (element, at); {
      int caretCount = getuint16 (offset);

      for (int c = 0; c &lt; caretCount; c++) {
        int caretValueOffset = getOffset (offset, 2 + 2*c);
        if (caretValueOffset != 0) {
          at = new AttributesImpl ();
          caretValueTableOffsetToXML (conf, caretValueOffset, counts,
                                      "caretValue", at); }}

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Caret Values Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Caret Values table (CaretValues), which defines caret
          positions for a ligature, can be any of three possible
          formats. One format uses design units to define the caret
          position. The other two formats use a contour point or
          Device table to fine-tune a caret's position at specific
          font sizes and device resolutions. Caret coordinates are
          either X or Y values, depending upon the text
          direction.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>caretValueTable</code-title>
  standaloneCaretValueTable =
    element caretValueTable { attribute id { text }, caretValueTable }

  caretValueTableOffset = attribute name { text } | caretValueTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gdef.methods'>
  <code-title>??</code-title>

  public void caretValueTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return;}

    switch (getuint16 (offset)) {
      <code-include linkend='caretValueTableToXMLCount.cases'/>
    }
  }

  public void caretValueTableOffsetToXML (DecompilerConfig conf, int offset,
                                         int [] counts,
                                         String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "caretValueTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      caretValueTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void caretValueTableToXML (DecompilerConfig conf, int offset,
                                   int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "caretValueTable_" + Integer.toHexString (offset));
      caretValueTableToXMLEmit (conf, offset, counts,
                               "caretValueTable", at);
      counts [offset] = 0; }

    switch (getuint16 (offset)) {
      <code-include linkend='caretValueTableToXML.cases'/>
    }
  }

  public void caretValueTableToXMLEmit (DecompilerConfig conf, int offset,
                                       int[] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "format", "format", "CDATA", "" + getuint16 (offset));

    switch (getuint16 (offset)) {
      <code-include linkend='caretValueTableToXMLEmit.cases'/> }

  }
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>CaretValue Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The first format (CaretValueFormat1) consists of a
          format identifier (CaretValueFormat), followed by a single
          coordinate for the caret position (Coordinate). The
          Coordinate is in design units.</para>

        <para>This format has the benefits of small size and
          simplicity, but the Coordinate value cannot be hinted for
          fine adjustments at different device resolutions.</para>

        <para>Exampel 4 at the end of this chapter shows a
          CaretValueFormat1 table.</para>

        <otformat>
          <title>CaretValueFormat1 table: Design units only</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CaretValueFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>Coordinate</otfieldname>
            <otfielddesc>X or Y value, in design units</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>caretValueTable, format 1</code-title>
  caretValueTable |=
    attribute format { "1" },
    attribute coord { text }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='caretValueTableToXMLEmit.cases'>
  case 1: {
    at.addAttribute ("", "coord", "coord", "CDATA", "" + getint16 (offset + 2));
    conf.ch.element (element, at);
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>CaretValue Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The second format (CaretValueFormat2) specifies the
          caret coordinate in terms of a contour point index on a
          specific glyph. During font hinting, the contour point on
          the glyph outline may move. The point's final position after
          hinting provides the final value for rendering a given font
          size.</para>

        <para>The table contains a format identifier
          (CaretValueFormat) and a contour point index
          (CaretValuePoint).</para>

        <para>Example 5 at the end of this chapter demonstrates a
          CaretValueFormat2 table.</para>

        <otformat>
          <title>CaretValueFormat2 table: Contour point</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CaretValueFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CaretValuePoint</otfieldname>
            <otfielddesc>Contour point index on glyph</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>caretValueTable, format 2</code-title>
  caretValueTable |=
    attribute format { "2" },
    attribute countourPoint { text }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='caretValueTableToXMLEmit.cases'>
  case 2: {
    at.addAttribute ("", "contourPoint", "contourPoint", "CDATA",
                     "" + getint16 (offset + 2));
    conf.ch.element (element, at);
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>CaretValue Format 3</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The third format (CaretValueFormat3) also specifies the
          value in design units, but it uses a Device table rather
          than a contour point to adjust the value. This format offers
          the advantage of fine-tuning the Coordinate value for any
          device resolution. (For more information about Device
          tables, see the chapter, Common Table Formats.)</para>

        <para>The format consists of a format identifier
          (CaretValueFormat), an X or Y value (Coordinate), and an
          offset to a Device table (DeviceTable).</para>

        <para>Example 6 at the end of this chapter shows a
          CaretValueFormat3 table.</para>

        <otformat>
          <title>CaretValueFormat3 table: Design units plus Device table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CaretValueFormat</otfieldname>
            <otfielddesc>Format identifier-format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>Coordinate</otfieldname>
            <otfielddesc>X or Y value, in design units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>DeviceTable</otfieldname>
            <otfielddesc>Offset to Device table for X or Y value-from
              beginning of CaretValue table</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>caretValueTable, format 3</code-title>
  caretValueTable |=
    attribute format { "3" },
    attribute coord { text },
    element deviceTable { deviceTableOffset }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='caretValueTableToXMLCount.cases'>
  case 3: {
    deviceTableToXMLCount (getOffset (offset, 4), counts);
    break; }
</code-fragment>

<code-fragment id='caretValueTableToXML.cases'>
  case 3: {
    deviceTableToXML (conf, getOffset (offset, 4), counts);
    break; }
</code-fragment>

<code-fragment id='caretValueTableToXMLEmit.cases'>
  case 3: {
    at.addAttribute ("", "coord", "coord", "CDATA", "" + getint16 (offset + 2));
    conf.ch.startElement (element, at); {
      deviceTableOffsetToXML (conf, getOffset (offset, 4), counts,
                              "deviceTable", new AttributesImpl ());
      conf.ch.endElement (element); }
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Mark Attachment Class Definition Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Mark Attachment Class Definition Table defines the
          class to which a mark glyph may belong. This table uses the
          same format as the Class Definition table (for details, see
          the chapter, Common Table Formats ).</para>

        <para>Example 7 in this document shows a MarkAttachClassDef
        table.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gdef.methods'>
  <code-title>Method to compute the Mark Attachment class of a glyph</code-title>
  public int getMarkAttachClass (int glyph)
    throws InvalidFontException {

    int markAttachOffset = getuint16 (10);

    if (markAttachOffset != 0) {
      return classIndex (glyph, markAttachOffset); }
    else {
      return 0; }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>GDEF Table Examples</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The rest of this chapter describes examples of all the
          <ottable>GDEF</ottable> table formats. All the examples reflect unique
          parameters described below, but the samples provide a useful
          reference for building tables specific to other
          situations.</para>
        <para>The examples have three columns showing hex data,
          source, and comments.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 1: GDEF Header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 1 shows a <ottable>GDEF</ottable> Header
          definition with offsets to each of the main tables in
          <ottable>GDEF</ottable>.</para>

        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GDEFHeader</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheGDEFHeader</otexsrc>
            <otexcom>GDEFHeader table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00010000</otexdata>
            <otexsrc>0x00010000</otexsrc>
            <otexcom>Version</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>GlyphClassDefTable</otexsrc>
            <otexcom>offset to GlyphClassDef table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0026</otexdata>
            <otexsrc>AttachListTable</otexsrc>
            <otexcom>offset to AttachList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>LigCaretListTable</otexsrc>
            <otexcom>offset to LigCaretList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>005A</otexdata>
            <otexsrc>MarkAttachClassDefTable</otexsrc>
            <otexcom>offset to Mark Attachment Class Definition
                  Table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 2: GlyphClassDef Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The GlyphClassDef table in Example 2 specifies a glyph
          for the each of the glyph classes predefined in the
          GlyphClassDef Enumeration List.</para>

        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GlyphClassDefTable</otexsrc>
            <otexcom>ClassDef table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>ClassRangeCount ClassRangeRecord[0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0024</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0024</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class, 1 = base glyphs
                  ClassRangeRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>009F</otexdata>
            <otexsrc>ffiLigGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>009F</otexdata>
            <otexsrc>ffiLigGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class, 2 = ligature glyphs
                  ClassRangeRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0058</otexdata>
            <otexsrc>umlautAccentGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0058</otexdata>
            <otexsrc>umlautAccentGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class, 3 = mark glyphs
                  ClassRangeRecord[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>018F</otexdata>
            <otexsrc>CurvedTailComponentGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>018F</otexdata>
            <otexsrc>CurvedTailComponentGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>Class, 4 = component glyphs</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3: AttachList Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>In Example 3, the AttachList table enumerates the
          attachment points defined for two glyphs. The GlyphCoverage
          table identifies the glyphs: "a" and "e." For each covered
          glyph, an AttachPoint table specifies the attachment point
          count and point indices: one point for the "a" glyph and two
          for the "e" glyph.</para>

        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AttachList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AttachListTable</otexsrc>
            <otexcom>AttachList table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>GlyphCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>aAttachPoint</otexsrc>
            <otexcom>AttachPoint[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>eAttachPoint</otexsrc>
            <otexcom>AttachPoint[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AttachPoint</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>aAttachPoint</otexsrc>
            <otexcom>AttachPoint table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PointCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>18</otexsrc>
            <otexcom>PointIndex[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AttachPoint</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>eAttachPoint</otexsrc>
            <otexcom>AttachPoint table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>PointCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>14</otexsrc>
            <otexcom>PointIndex[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0017</otexdata>
            <otexsrc>23</otexsrc>
            <otexcom>PointIndex[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GlyphCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>aGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>eGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4: LigCaretList Table, LigGlyph Table and
        CaretValueFormat1 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 4 defines a list of ligature carets. The
          LigCoverage table lists all the ligature glyphs that define
          caret positions. In this example, two ligatures are covered,
          "ffi" and "fi." For each covered glyph, a LigGlyph table
          specifies the number of carets for the ligature and their
          coordinate values. The "fi" ligature defines one caret,
          positioned between the "f" and "i" components; the "ffi"
          ligature defines two, one positioned between the two "f"
          components and the other positioned between the "f" and "i."
          The CaretValue tables shown here use Format1, where values
          are specified in design units only.</para>

        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigCaretList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigCaretListTable</otexsrc>
            <otexcom>LigCaretList table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>LigCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LigGlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>fiLigGlyph</otexsrc>
            <otexcom>offset to LigGlyph table[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>ffiLigGlyph</otexsrc>
            <otexcom>offset to LigGlyph table[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>009F</otexdata>
            <otexsrc>ffiLigGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>00A5</otexdata>
            <otexsrc>fiLigGlyphID</otexsrc>
            <otexcom>GlyphArray[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigGlyph</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>fiLigGlyph</otexsrc>
            <otexcom>LigGlyph table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CaretCount, equals the number of components -
                  1</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>CaretFI</otexsrc>
            <otexcom>CaretValue[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigGlyph</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ffiLigGlyph</otexsrc>
            <otexcom>LigGlyph table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CaretCount, equals the number of components -
                  1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>CaretFFI1</otexsrc>
            <otexcom>CaretValue[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>CaretFFI2</otexsrc>
            <otexcom>CaretValue[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretValueFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretFI</otexsrc>
            <otexcom>CaretValue table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CaretValueFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>025B</otexdata>
            <otexsrc>603</otexsrc>
            <otexcom>Coordinate X or Y valu</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretValueFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretFFI1</otexsrc>
            <otexcom>CaretValue table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CaretValueFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>025B</otexdata>
            <otexsrc>603</otexsrc>
            <otexcom>Coordinate X or Y valu</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretValueFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretFFI2</otexsrc>
            <otexcom>CaretValue table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CaretValueFormat design units only</otexcom>
          </otexline>
          <otexline>
            <otexdata>04B6</otexdata>
            <otexsrc>1206</otexsrc>
            <otexcom>Coordinate X or Y value</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 5: CaretValueFormat2 Table </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 5 shows a CaretValueFormat2 table that specifies
          a ligature caret coordinate in terms of a contour point
          index on a specific glyph. The final position of the caret
          depends on the location of the contour point on the glyph
          after hinting.</para>

        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretValueFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Caret1</otexsrc>
            <otexcom>CaretValue table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CaretValueFormat contour point</otexcom>
          </otexline>
          <otexline>
            <otexdata>000D</otexdata>
            <otexsrc>13</otexsrc>
            <otexcom>CaretValuePoint contour point index</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 6: CaretValueFormat3 Table </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>In Example 6, the CaretValueFormat3 table defines a
          caret position in design units, but includes a Device table
          to adjust the X or Y coordinate for the point size and
          resolution of the output font. Here, the Device table
          specifies pixel adjustments for font sizes from 12 ppem to
          17 ppem.</para>

        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretValueFormat3</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Caret3</otexsrc>
            <otexcom>CaretValue table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>CaretValueFormat design units plus Device
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>04B6</otexdata>
            <otexsrc>1206</otexsrc>
            <otexcom>Coordinate X or Y value, design units</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>CaretDevice</otexsrc>
            <otexcom>offset to Device tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CaretDevice</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>12</otexsrc>
            <otexcom>StartSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0011</otexdata>
            <otexsrc>17</otexsrc>
            <otexcom>EndSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>DeltaFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppm by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppm by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppm by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>1111</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppm by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>increase 16ppm by 2 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>2200</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>increase 17ppm by 2 pixel</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 7: MarkAttachClassDef Table </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>In Example 7, the MarkAttachClassDef table specifies an
          attachment class for the each of the glyph ranges predefined
          in the GlyphClassDef Enumeration List as marks.</para>

        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>theMarkAttachClassDefTable</otexsrc>
            <otexcom>ClassDef table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>ClassRangeCount ClassRangeRecord[0] </otexcom>
          </otexline>
          <otexline>
            <otexdata>0268</otexdata>
            <otexsrc>graveAccentGlyphID</otexsrc>
            <otexcom>Start </otexcom>
          </otexline>
          <otexline>
            <otexdata>026A</otexdata>
            <otexsrc>circumflexAccentGlyphID</otexsrc>
            <otexcom>End </otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class, 1 = top marks ClassRangeRecord[1]
                </otexcom>
          </otexline>
          <otexline>
            <otexdata>0270</otexdata>
            <otexsrc>diaeresisAccentGlyphID</otexsrc>
            <otexcom>Start </otexcom>
          </otexline>
          <otexline>
            <otexdata>0272</otexdata>
            <otexsrc>acuteAccentGlyphID</otexsrc>
            <otexcom>End </otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class, 1 = top marks ClassRangeRecord[2]
                </otexcom>
          </otexline>
          <otexline>
            <otexdata>028C</otexdata>
            <otexsrc>diaeresisBelowGlyphID</otexsrc>
            <otexcom>Start </otexcom>
          </otexline>
          <otexline>
            <otexdata>028F</otexdata>
            <otexsrc>cedillaGlyphID</otexsrc>
            <otexcom>End </otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class, 2 = bottom marks ClassRangeRecord[3]
                </otexcom>
          </otexline>
          <otexline>
            <otexdata>0295</otexdata>
            <otexsrc>circumflexBelowGlyphID</otexsrc>
            <otexcom>Start </otexcom>
          </otexline>
          <otexline>
            <otexdata>0295</otexdata>
            <otexsrc>circumflexBelowGlyphID</otexsrc>
            <otexcom>End </otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class, 2 = bottom marks </otexcom>
          </otexline>
        </otexample>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.GPOS' web:index='yes'>
    <title>GPOS - The Glyph Positioning Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Glyph Positioning table (<ottable>GPOS</ottable>)
          provides precise control over glyph placement for
          sophisticated text layout and rendering in each script and
          language system that a font supports.</para>

        <para>Complex glyph positioning becomes an issue in writing
          systems, such as Vietnamese, that use diacritical and other
          marks to modify the sound or meaning of characters. These
          writing systems require controlled placement of all marks in
          relation to one another for legibility and linguistic
          accuracy.</para>

        <figure>
          <title>Figure 4a. Vietnamese words with marks.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig4a.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Other writing systems require sophisticated glyph
          positioning for correct typographic composition. For
          instance, Urdu glyphs are calligraphic and connect to one
          another along a descending, diagonal text line that proceeds
          from right to left. To properly render Urdu, a
          text-processing client must modify both the horizontal (X)
          and vertical (Y) positions of each glyph.</para>

        <figure>
          <title>Figure 4b. Urdu layout requires glyph positioning
            control, as well as contextual substitution</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig4b.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>With the <ottable>GPOS</ottable> table, a font developer
          can define a complete set of positioning adjustment features
          in an OpenType font. <ottable>GPOS</ottable> data,
          organized by script and language system, is easy for a
          text-processing client to use to position glyphs.</para>

        <para>Positioning Glyphs with TrueType 1.0</para>

        <para>Glyph positioning in TrueType uses only two values,
          placement and advance, to specify a glyph's position for
          text layout. If glyphs are positioned with respect to a
          virtual "pen point" that moves along a line of text,
          placement describes the glyph's position with respect to the
          current pen point, and advance describes where to move the
          pen point to position the next glyph (see Figure 4c). For
          horizontal text, placement corresponds to the left side
          bearing, and advance corresponds to the advance
          width.</para>

        <figure>
          <title>Figure 4c. Glyph positioning with TrueType</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig4c.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>TrueType specifies placement and advance only in the X
          direction for horizontal layout and only in the Y direction
          for vertical layout. For simple Latin text layout, these two
          values may be adequate to position glyphs correctly. But,
          for texts that require more sophisticated layout, the values
          must cover a richer range. Placement and advance may need
          adjustment vertically, as well as horizontally.</para>

        <para>The only positioning adjustment defined in TrueType is
          pair kerning, which modifies the horizontal spacing between
          two glyphs. A typical kerning table lists pairs of glyphs
          and specifies how much space a text-processing client should
          add or remove between the glyphs to properly display each
          pair. It does not provide specific information about how to
          adjust the glyphs in each pair, and cannot adjust contexts
          of more than two glyphs.</para>

        <para>Positioning Glyphs with OpenType</para>

        <para>OpenType fonts allow excellent control and flexibility
          for positioning a single glyph and for positioning multiple
          glyphs in relation to one another. By using both X and Y
          values that the <ottable>GPOS</ottable> table defines for
          placement and advance and by using glyph attachment points,
          a client can more precisely adjust the position of a
          glyph.</para>

        <para>In addition, the <ottable>GPOS</ottable> table can
          reference a Device table to define subtle, device-dependent
          adjustments to any placement or advance value at any font
          size and device resolution. For example, a Device table can
          specify adjustments at 51 pixels per em (ppem) that do not
          occur at 50 ppem.</para>

        <para>X and Y values specified in OpenType fonts for placement
          operations are always within the typical Cartesian
          coordinate system (origin at the baseline of the left side),
          regardless of the writing direction. Additionally, all
          values specified are done so in font unit measurements. This
          is especially convenient for font designers, since glyphs
          are drawn in the same coordinate system. However, it's
          important to note that the meaning of "advance width"
          changes, depending on the writing direction.</para>

        <para>For example, in left-to-right scripts, if the first
          glyph has an advance width of 100, then the second glyph
          begins at 100,0. In right-to-left scripts, if the first
          glyph has an advance width of 100, then the second glyph
          begins at -100,0. For a top-to-bottom feature, to increase
          the advance height of a glyph by 100, the YAdvance = 100.
          For any feature, regardless of writing direction, to lower
          the dieresis over an 'o' by 10 units, set the YPlacement =
          -10.</para>

        <para>Other <ottable>GPOS</ottable> features can define
          attachment points to combine glyphs and position them with
          respect to one another. A glyph might have multiple
          attachment points. The point used will depend on the glyph
          to be attached. For instance, a base glyph could have
          attachment points for different diacritical marks.</para>


        <figure>
          <title>Base glyph with multiple attachment points.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='attach.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>To reduce the size of the font file, a base glyph may
          use the same attachment point for all mark glyphs assigned
          to a particular class. For example, a base glyph could have
          two attachment points, one above and one below the glyph.
          Then all marks that attach above glyphs would be attached at
          the high point, and all marks that attach below glyphs would
          be attached at the low point. Attachment points are useful
          in scripts, such as Arabic, that combine numerous glyphs
          with vowel marks.</para>

        <para>Attachment points also are useful for connecting
          cursive-style glyphs. Glyphs in cursive fonts can be
          designed to attach or overlap when rendered. Alternatively,
          the font developer can use OpenType to create a cursive
          attachment feature and define explicit exit and entry
          attachment points for each glyph (see Figure 4d).</para>

        <figure>
          <title>Figure 4d. Entry and exit points marked on contextual
            Urdu glyph variations</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig4d.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The <ottable>GPOS</ottable> table supports eight types
          of actions for positioning and attaching glyphs:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>single adjustment</emphasis> positions
              one glyph, such as a superscript or subscript.</para>
          </listitem>
          <listitem>
            <para>A <emphasis>pair adjustment</emphasis> positions two
              glyphs with respect to one another. Kerning is an
              example of pair adjustment.</para>
          </listitem>
          <listitem>
            <para>A <emphasis>cursive attachment</emphasis> describes
              cursive scripts and other glyphs that are connected with
              attachment points when rendered.</para>
          </listitem>
          <listitem>
            <para>A <emphasis>MarkToBase attachment</emphasis>
              positions combining marks with respect to base glyphs,
              as when positioning vowels, diacritical marks, or tone
              marks in Arabic, Hebrew, and Vietnamese.</para>
          </listitem>
          <listitem>
            <para>A <emphasis>MarkToLigature attachment</emphasis>
              positions combining marks with respect to ligature
              glyphs. Because ligatures may have multiple points for
              attaching marks, the font developer needs to associate
              each mark with one of the ligature glyph's
              components.</para>
          </listitem>
          <listitem>
            <para>A <emphasis>MarkToMark attachment</emphasis>
              positions one mark relative to another, as when
              positioning tone marks with respect to vowel diacritical
              marks in Vietnamese.</para>
          </listitem>
          <listitem>
            <para><emphasis>Contextual positioning</emphasis>
              describes how to position one or more glyphs in context,
              within an identifiable sequence of specific glyphs,
              glyph classes, or varied sets of glyphs. One or more
              positioning operations may be performed on "input"
              context sequences. Figure 4e illustrates a context for
              positioning adjustments.</para>
          </listitem>
          <listitem>
            <para><emphasis>Chaining Contextual positioning</emphasis>
              describes how to position one or more glyphs in a
              chained context, within an identifiable sequence of
              specific glyphs, glyph classes, or varied sets of
              glyphs. One or more positioning operations may be
              performed on "input" context sequences.</para>
          </listitem>
        </itemizedlist>

        <figure>
          <title>Figure 4e. Contextual positioning lowered the accent
            over a vowel glyph that followed an overhanging uppercase
            glyph</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig4e.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Table Organization</para>

        <para>The <ottable>GPOS</ottable> table begins with a header
          that defines offsets to a ScriptList, a FeatureList, and a
          LookupList (see Figure 4f):</para>

        <itemizedlist>
          <listitem>
            <para>The ScriptList identifies all the scripts and
              language systems in the font that use glyph
              positioning.</para>
          </listitem>
          <listitem>
            <para>The FeatureList defines all the glyph positioning
              features required to render these scripts and language
              systems.</para>
          </listitem>
          <listitem>
            <para>The LookupList contains all the lookup data needed
              to implement each glyph positioning feature.</para>
          </listitem>
        </itemizedlist>

        <para>For a detailed discussion of ScriptLists, FeatureLists,
          and LookupLists, see the chapter, Common Table Formats. The
          following discussion summarizes how the <ottable>GPOS</ottable> table
          works.</para>

        <figure>
          <title>Figure 4f. High-level organization of <ottable>GPOS</ottable>
            table</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig4f.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The <ottable>GPOS</ottable> table is organized so text
          processing clients can easily locate the features and
          lookups that apply to a particular script or language
          system. To access <ottable>GPOS</ottable> information,
          clients should use the following procedure:</para>

        <orderedlist>
          <listitem>
            <para>Locate the current script in the
              <ottable>GPOS</ottable> ScriptList table.</para>
          </listitem>
          <listitem>

            <para>If the language system is known, search the script
              for the correct LangSys table; otherwise, use the
              script's default language system (DefaultLangSys
              table).</para>
          </listitem>
          <listitem>

            <para>The LangSys table provides index numbers into the
              <ottable>GPOS</ottable> FeatureList table to access a
              required feature and a number of additional
              features.</para>
          </listitem>
          <listitem>

            <para>Inspect the FeatureTag of each feature, and select
              the features to apply to an input glyph string.</para>
          </listitem>
          <listitem>

            <para>Each feature provides an array of index numbers into
              the <ottable>GPOS</ottable> LookupList table. Lookup
              data is defined in one or more subtables that contain
              information about specific glyphs and the kinds of
              operations to be performed on them.</para>
          </listitem>
          <listitem>

            <para>Assemble all lookups from the set of chosen
              features, and apply the lookups in the order given in
              the LookupList table.</para>
          </listitem>
        </orderedlist>

        <para>A lookup uses subtables to define the specific
          conditions, type, and results of a positioning action used
          to implement a feature. All subtables in a lookup must be of
          the same LookupType, as listed in the LookupType Enumeration
          table:</para>

        <table>
          <title>LookupType Enumeration table for glyph
            positioning</title>

          <tgroup cols='3'>
            <colspec colwidth="3pc"/>
            <colspec colwidth="11pc"/>
            <colspec colwidth="16pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>Single adjustment</entry>
                <entry>Adjust position of a single glyph</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Pair adjustment</entry>
                <entry>Adjust position of a pair of glyphs</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Cursive attachment</entry>
                <entry>Attach cursive glyphs</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>MarkToBase attachment</entry>
                <entry>Attach a combining mark to a base glyph</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>MarkToLigature attachment</entry>
                <entry>Attach a combining mark to a ligature</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>MarkToMark attachment</entry>
                <entry>Attach a combining mark to another mark</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Context positioning</entry>
                <entry>Position one or more glyphs in context</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Chained Context positioning</entry>
                <entry>Position one or more glyphs in chained
                  context</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Extension positioning</entry>
                <entry>Extension mechanism for other positionings</entry>
              </row>
              <row>
                <entry>10+</entry>
                <entry>Reserved</entry>
                <entry>For future use</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Each LookupType is defined by one or more subtables,
          whose format depends on the type of positioning operation
          and the resulting storage efficiency. When glyph information
          is best presented in more than one format, a single lookup
          may define more than one subtable, as long as all the
          subtables are of the same LookupType. For example, within a
          given lookup, a glyph index array format may best represent
          one set of target glyphs, whereas a glyph index range format
          may be better for another set.</para>

        <para>A series of positioning operations on the same glyph or
          string requires multiple lookups, one for each separate
          action. The values in the ValueRecords are accumulated in
          these cases. Each lookup is given a different array number
          in the LookupList table and is applied in the LookupList
          order.</para>

        <para>During text processing, a client applies a lookup to
          each glyph in the string before moving to the next lookup. A
          lookup is finished for a glyph after the client locates the
          target glyph or glyph context and performs a positioning, if
          specified. To move to the "next" glyph, the client will
          typically skip all the glyphs that participated in the
          lookup operation: glyphs that were positioned as well as any
          other glyphs that formed a context for the operation.</para>

        <para>There is just one exception: the "next" glyph in a
          sequence may be one of those that formed a context for the
          operation just performed. For example, in the case of pair
          positioning operations (i.e., kerning), if the position
          value record for the second glyph is null, that glyph is
          treated as the "next" glyph in the sequence.</para>

        <para>This rest of this chapter describes the
          <ottable>GPOS</ottable> header and the subtables defined for
          each LookupType. Several <ottable>GPOS</ottable> subtables
          share other tables: ValueRecords, Anchor tables, and
          MarkArrays. For easy reference, the shared tables are
          described at the end of this chapter.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>lookupTable for GPOS</code-title>
  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "1" | "singlePos" },
    element singlePos { singlePosTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "2" | "pairPos" },
    element pairPos { pairPosTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "3" | "cursiveAttachment" },
    element cursiveAttachment { cursiveAttachmentTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "4" | "markToBaseAttachement" },
    element markToBaseAttachment { markToBaseAttachmentTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "5" | "markToLigatureAttachment" },
    element markToLigatureAttachment { markToLigatureAttachmentTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "6" | "markToMarkAttachment" },
    element markToMarkAttachment { markToMarkAttachmentTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "7" | "contextual" },
    element contextual { contextualTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "8" | "chainingContextual" },
    element chainingContextual { chainingContextualTableOffset }*

  GPOSlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "9" | "extensionPos" },
    element extensionPos { extensionTableOffset }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>TODO: This really belongs to the 'size' feature and should be
	moved there sometime.</para>

	<para>The 'size' feature is not really a  layout feature,
	  just a place we have	stored some numbers. Here is a method
	  that returns those numbers.</para>

	<para>Historically, we have shipped fonts with an incorrect
	  form: we made the offset of the feature params relative to
	  the featureList rather than relative to the feature
	  itself. So this method takes a boolean to either allow or disallow
	  automatic fixing of this problem. </para>

<code-fragment id='gpos.methods'>
  <code-title>Method to return the size parameters</code-title>
  public class SizeParameters {
    public int designSize;
    public int subfamilyId;
    public int nameId;
    public int minSize;
    public int maxSize; };

  public SizeParameters getSizeParameters () {
    return getSizeParameters (true);
  }

  public SizeParameters getSizeParameters (boolean useFeatureListOffset) {

    int featureListOffset = getFeatureListOffset ();
    int featureCount = getuint16 (featureListOffset);

    for (int i = 0; i &lt; featureCount; i++) {
       if (getint32 (featureListOffset + 2 + 6*i) == Tag.string2tag ("size")) {
	  int featureOffset = featureListOffset + getOffset (
                             featureListOffset + 2 + 6*i + 4);
	  int featureParamsOffset = getOffset (featureOffset);

	  if (useFeatureListOffset) {
	   featureParamsOffset += featureListOffset; }
	  else {
           featureParamsOffset += featureOffset; }

	  SizeParameters res = new SizeParameters ();
	  res.designSize = getuint16 (featureParamsOffset);
	  res.subfamilyId = getuint16 (featureParamsOffset + 2);
	  res.nameId = getuint16 (featureParamsOffset + 4);
	  res.minSize = getuint16 (featureParamsOffset + 6);
	  res.maxSize = getuint16 (featureParamsOffset + 8);
	  return res; }}

    return null;
  }
</code-fragment>

	<para>Here is a program to extract the size parameters of a
	font.</para>

<code-fragment package='com.adobe.aots.opentype' class='SizeParams'>
  <code-title>SizeParams class</code-title>
package com.adobe.aots.opentype;

import java.io.File;
import java.net.URL;

public class SizeParams {

  public static void outputSp (Font font, Gpos.SizeParameters sp) {
    String c;
    if (sp.designSize == 0) {
      c = "*"; }
    else if (   sp.subfamilyId == 0
             &amp;&amp; sp.nameId == 0
             &amp;&amp; sp.minSize == 0
             &amp;&amp; sp.maxSize == 0) {
      c = " "; }
    else if (   sp.designSize &lt; sp.minSize
             || sp.maxSize &lt; sp.designSize
             || sp.nameId &lt; 256
             || sp.nameId > 32767
             /*|| font.name.getName (-1, sp.nameId) == null)*/) {
      c = "*"; }
    else {
      c = " "; }
    System.out.println (c + "     sizes = " + sp.minSize + ", "
                        + sp.designSize + ", " + sp.maxSize
                        + "; subfamilyId=" + sp.subfamilyId
                        + "; nameId=" + sp.nameId
	                + " = " + font.name.getName (-1, sp.nameId));
  }

  public static void main (String args[]) throws Exception {
    Font font = new Font ();
    font.fromBinary (new URL ("file:" + args [0]));

    Gpos.SizeParameters sp = null;
    Gpos.SizeParameters sp2 = null;
    if (font.gpos != null) {
      sp = font.gpos.getSizeParameters (false);
      sp2 = font.gpos.getSizeParameters (true); }

    if (sp != null || sp2 != null) {
      System.out.println ("--- " + args [0]);
      outputSp (font, sp);
      outputSp (font, sp2); }

  }
}
</code-fragment>

        <para>Here is a method for decompilation.</para>

<code-fragment id='gpos.methods'>
  public void opticalSizeToXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    SizeParameters sp = null;
    sp = getSizeParameters (false);
    if (sp == null) {
      sp = getSizeParameters (true); }

    if (sp == null) {
      return; }

    AttributesImpl at;
    at = new AttributesImpl ();
    at.addAttribute ("", "designSize", "designSize", "CDATA", "" + sp.designSize);
    at.addAttribute ("", "subfamilyId", "subfamilyId", "CDATA", "" + sp.subfamilyId);
    at.addAttribute ("", "nameId", "nameId", "CDATA", "" + sp.nameId);
    at.addAttribute ("", "minSize", "minSize", "CDATA", "" + sp.minSize);
    at.addAttribute ("", "maxSize", "maxSize", "CDATA", "" + sp.maxSize);

    conf.ch.startElement ("opticalSize", at); {
      conf.ch.endElement ("opticalSize"); }
}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>GPOS Header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>GPOS</ottable> table begins with a header
          that contains a version number (Version) initially set to
          1.0 (0x00010000) and offsets to three tables: ScriptList,
          FeatureList, and LookupList. For descriptions of these
          tables, see the chapter, Common Table Formats. Example 1 at
          the end of this chapter shows a <ottable>GPOS</ottable>
          Header table definition.</para>

        <otformat>
          <title>GPOS Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the <ottable>GPOS</ottable>
              table-initially = 0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ScriptList</otfieldname>
            <otfielddesc>Offset to ScriptList table-from beginning of
              <ottable>GPOS</ottable> table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>FeatureList</otfieldname>
            <otfielddesc>Offset to FeatureList table-from beginning of
              <ottable>GPOS</ottable> table </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookupList</otfieldname>
            <otfielddesc>Offset to LookupList table-from beginning of
              <ottable>GPOS</ottable> table</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>
        <para>Nothing to note.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>GPOS</code-title>
  GPOS =
    element GPOS {
      attribute major { "1" },
      attribute minor { "0" },
      element scriptList { scriptListTableOffset },
      element featureList { featureListTableOffset },
      element lookupList { GPOSlookupListTableOffset },

      (  standaloneScriptListTable
       | standaloneScriptTable
       | standaloneLangSysTable
       | standaloneFeatureListTable
       | standaloneFeatureTable
       | standaloneGPOSLookupListTable
       | standaloneGPOSLookupTable
       | standaloneSinglePosTable
       | standalonePairPosTable
       | standaloneCursiveAttachmentTable
       | standaloneMarkToBaseAttachmentTable
       | standaloneMarkToLigatureAttachmentTable
       | standaloneMarkToMarkAttachmentTable
       | standaloneContextualTable
       | standaloneChainingContextualTable
       | standaloneExtensionTable
       | standaloneAnchorTable
       | standaloneCoverageTable
       | standaloneClassDefTable
       | standaloneDeviceTable
       | standalonePairSetTable)*
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  public void fromXML (Element gpos)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block> blockCache = new HashMap&lt;Element, Block> ();
    NodeList l = gpos.getChildNodes ();

    Block me = new Block (10, 3);
    me.setFixed (0, 1, 0);

    Map&lt;String, Integer> lookupIndices = new HashMap&lt;String, Integer> ();
    Block b1 = lookupListTableFromXML ((Element) l.item (2),
                                       gpos, blockCache,
                                       lookupIndices);

    Map  &lt;String, Integer>featureIndices = new HashMap &lt;String, Integer> ();
    Block b2 = featureListTableFromXML ((Element) l.item (1),
                                        gpos, blockCache,
                                        lookupIndices, featureIndices);

    Block b3 = scriptListTableFromXML ((Element) l.item (0),
                                       gpos, blockCache,
                                       featureIndices);

    me.setOffset (4, b3);
    me.setOffset (6, b2);
    me.setOffset (8, b1);
    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] counts = new int [data.length];
    for (int i = 0; i &lt; counts.length; i++) {
      counts [i] = 0; }

    scriptListTableToXMLCount (getOffset (4), counts);
    featureListTableToXMLCount (getOffset (6), counts);
    lookupListTableToXMLCount (getOffset (8), counts);

    if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 1; }}
    if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 2; }}

    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);

    conf.ch.startElement ("GPOS", at); {

      scriptListTableOffsetToXML (conf, getOffset (4), counts,
                                  "scriptList", new AttributesImpl ());
      featureListTableOffsetToXML (conf, getOffset (6), counts,
                                   "featureList", new AttributesImpl ());
      lookupListTableOffsetToXML (conf, getOffset (8), counts,
                                  "lookupList", new AttributesImpl ());

      scriptListTableToXML (conf, getOffset (4), counts);
      featureListTableToXML (conf, getOffset (6), counts);
      lookupListTableToXML (conf, getOffset (8), counts);
      conf.ch.endElement ("GPOS"); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We have a class that represents a
          <ottable>GPOS</ottable> table and provides the approriate
          operations.</para>

<code-fragment package='com.adobe.aots.opentype' class='Gpos'>
  <code-title>GPOS Class</code-title>
package com.adobe.aots.opentype;

import java.util.Map;
import java.util.HashMap;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.Iterator;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Gpos extends LookupTable {

  public Gpos () {
    super (Tag.GPOS, null);
  }

  public Gpos (Font font) {
    super (Tag.GPOS, font);
  }

  public int[] getTableVersion () {
    return getFixed (0);
  }

  <code-include linkend='gpos.methods'/>
}
</code-fragment>

    <para>The base class defined a number of abstract methods to
    access the ScriptList, the FeatureList and the LookupList:</para>

<code-fragment id='gpos.methods'>
  <code-title>Methods to find ScriptList, FeatureList and LookupList</code-title>
  int getScriptListOffset () {
    return getOffset (4);
  }

  int getFeatureListOffset () {
    return getOffset (6);
  }

  int getLookupListOffset () {
    return getOffset (8);
  }
</code-fragment>

    <para>The most basic operation is apply a given lookup subtable to
    a given position in a glyph run. This method returns -1 if the
    subtable does not apply (i.e. its input pattern does not match the
    glyph run), or the position of first glyph following input pattern
    match.</para>

<code-fragment id='gpos.methods'>
  <code-title>Method to apply a GPOS subtable to a glyph</code-title>
  public LookupResult applyLookupSubtable (int lookupIndex, int lookupType,
                                           int lookupFlag, int stOffset,
					   GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    switch (lookupType) {
      case 1: { <code-include linkend='gpos_1'/> }
      case 2: { <code-include linkend='gpos_2'/> }
      case 3: { <code-include linkend='gpos_3'/> }
      case 4: { <code-include linkend='gpos_4'/> }
      case 5: { <code-include linkend='gpos_5'/> }
      case 6: { <code-include linkend='gpos_6'/> }
      case 7: { return applyContextualLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      case 8: { return applyChainingContextualLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      case 9: { return applyExtensionLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      default: {
        throw new InvalidFontException ("GPOS -" + lookupType + "-"); }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

<code-fragment package='com.adobe.aots.opentype' class='GposTester'>
  <code-title>GposTester class</code-title>

  package com.adobe.aots.opentype;

  <code-include linkend='test_imports'/>

  public class GposTester {

    <code-include linkend='test_methods'/>

    public static void main (String[] args) {
      try {
        String testName = "anonymousTest";
	URL fontURL = null;
	Font font = null;
	long script = Tag.string2tag ("latn");
	long language = Tag.string2tag ("DFLT");
	long[] features = null;
        int[] inputs= null;
	int[] components = null;
	int[] xdeltas = null;
	int[] ydeltas = null;
	int traceDepth = 3;
	String svgTraceOutput = null;
	String textTraceOutput = null;

        for (int i = 0; i &lt; args.length; i++) {
          if ("-testname".equals (args [i])) {
	    i++;
	    testName = args [i]; }

	  if ("-font".equals (args [i])) {
	    i++;
	    fontURL = new File (args [i]).getAbsoluteFile ().toURL ();
	    font = new Font ();
	    font.fromBinary (fontURL); }

	  if ("-script".equals (args [i])) {
	    i++;
	    script = Tag.string2tag (args [i]); }

	  if ("-language".equals (args [i])) {
	    i++;
	    language = Tag.string2tag (args [i]); }

	  if ("-features".equals (args [i])) {
	    i++;
	    features = Tag.string2tags (args [i]); }

	  if ("-glyphs".equals (args [i])) {
	    i++;
	    inputs = parseIntList (args [i]); }

	  if ("-components".equals (args [i])) {
	    i++;
	    components = parseIntList (args [i]); }

	  if ("-xdeltas".equals (args [i])) {
	    i++;
	    xdeltas = parseIntList (args [i]); }

	  if ("-ydeltas".equals (args [i])) {
	    i++;
	    ydeltas = parseIntList (args [i]); }

	  if ("-tracedepth".equals (args [i])) {
	    i++;
	    traceDepth = Integer.parseInt (args [i]); }

	  if ("-trace=svg".equals (args [i])) {
	    i++;
	    svgTraceOutput = args [i]; }

	  if ("-trace=text".equals (args [i])) {
	    i++;
	    textTraceOutput = args [i]; }}


        LookupTableListener listener = null;
        if (svgTraceOutput != null) {
          SVGLookupTableListener l = new SVGLookupTableListener (traceDepth);
          java.io.PrintStream out
            = new java.io.PrintStream (new java.io.FileOutputStream (svgTraceOutput));
          l.init (font, fontURL, out, false, false);
          font.gpos.setLookupTableListener (l);
          listener = l; }
        else if (textTraceOutput != null) {
          LookupTableListener l = new TextLookupTableListener (traceDepth);
          java.io.PrintStream out
            = new java.io.PrintStream (new java.io.FileOutputStream (textTraceOutput));
          l.init (font, fontURL, out, false);
          font.gpos.setLookupTableListener (l);
          listener = l; }


        GlyphRunImpl gr = new GlyphRunImpl ();
        gr.glyphs = inputs;
        gr.totGlyphs = inputs.length;

        gr.setDefaultPlacementsAndAdvances (font);

        if (font.gsub != null) {
          font.gsub.applyFeatures (script, language, features, gr); }

        if (components != null) {
          gr.setLigComponents (components); }

        font.gpos.applyFeatures (script, language, features, gr);

        if (listener != null) {
          listener.shutdown (); }

        boolean pass = true;
        if (xdeltas != null) {
          int[] actualDeltas = new int [xdeltas.length];
          for (int i = 0; i &lt; gr.glyphCount (); i++) {
            actualDeltas [i] = gr.xPos [i] - 1500 * i; }
          if (! compareIntLists (xdeltas, actualDeltas, gr.glyphCount ())) {
            pass = false;
	    System.err.println ("Incorrect xdeltas");
            System.err.print ("Wanted: ");
            for (int i = 0; i &lt; gr.glyphCount (); i++) {
              System.err.print (" " + xdeltas [i]); }
            System.err.println ();
            System.err.print ("Actual: ");
            for (int i = 0; i &lt; gr.glyphCount (); i++) {
              System.err.print (" " + actualDeltas [i]); }
            System.err.println (); }}

        if (ydeltas != null) {
          int[] actualDeltas = new int [xdeltas.length];
          for (int i = 0; i &lt; gr.glyphCount (); i++) {
             actualDeltas [i] = gr.yPos [i]; }
          if (! compareIntLists (ydeltas, actualDeltas, gr.glyphCount ())) {
            pass = false;
	    System.err.println ("Incorrect ydeltas");
            System.err.print ("Wanted: ");
            for (int i = 0; i &lt; gr.glyphCount (); i++) {
              System.err.print (" " + ydeltas [i]); }
            System.err.println ();
            System.err.print ("Actual: ");
            for (int i = 0; i &lt; gr.glyphCount (); i++) {
              System.err.print (" " + actualDeltas [i]); }
            System.err.println (); }}

        if (xdeltas != null || ydeltas != null) {
          reportStatus (testName, pass); }}

      catch (Exception e) {
        System.out.println ("Exception: " + e.getMessage ());
        e.printStackTrace (); }
    }
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 1: Single Adjustment Positioning Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A single adjustment positioning subtable (SinglePos) is
          used to adjust the position of a single glyph, such as a
          subscript or superscript. In addition, a SinglePos subtable
          is commonly used to implement lookup data for contextual
          positioning.</para>

        <para>A SinglePos subtable will have one of two formats: one
          that applies the same adjustment to a series of glyphs, or
          one that applies a different adjustment for each unique
          glyph.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>None</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>Here is the boiler plate:</para>

<code-fragment id='schema'>
  <code-title>singlePostTable</code-title>
  standaloneSinglePosTable =
    element singlePosTable { attribute id { text }, singlePosTable }

  singlePosTableOffset = attribute name { text } | singlePosTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  <code-title>Compile singlePos lookups</code-title>
  private Block singlePosLookupFromXML (Element lookupSubtable,
                                        Element table,
                                        Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute ("format");
    if ("1".equals (format)) {
      return singlePosFormat1FromXML (lookupSubtable, table, blockCache); }
    if ("2".equals (format)) {
      return singlePosFormat2FromXML (lookupSubtable, table, blockCache); }

    /* cannot get here from a valid document */
    throw new InvalidFontException
                  ("invalid single pos lookup format (" + format + ")");
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_1'>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gpos.toXMLCount_1_1'/>; break; }
    case 2: { <code-include linkend='gpos.toXMLCount_1_2'/>; break; }}
</code-fragment>

<code-fragment id='gpos.toXML_1'>
   switch (getuint16 (stOffset)) {
     case 1: { <code-include linkend='gpos.toXML_1_1'/>; break; }
     case 2: { <code-include linkend='gpos.toXML_1_2'/>; break; }}
</code-fragment>

<code-fragment id='gpos.toXMLEmit_1'>
   switch (getuint16 (stOffset)) {
     case 1: { <code-include linkend='gpos.toXMLEmit_1_1'/>; break; }
     case 2: { <code-include linkend='gpos.toXMLEmit_1_2'/>; break; }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Both subtable formats start with the same field, the uint16
          PosFormat, so that we can distinguish them.</para>

<code-fragment id='gpos_1'>
  <code-title>Execute GPOS 1 subtable and return</code-title>
  { int posFormat = getuint16 (stOffset);
    switch (posFormat) {
      case 1: { <code-include linkend='gpos_1_1'/> }
      case 2: { <code-include linkend='gpos_1_2'/> }
      default:
        throw new InvalidFontException ("GPOS 1/-" + posFormat + "-"); }}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Single Adjustment Positioning: Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A SinglePosFormat1 subtable applies the same positioning
          value or values to each glyph listed in its Coverage table.
          For instance, when a font uses old-style numerals, this
          format could be applied to uniformly lower the position of
          all math operator glyphs.</para>

        <para>The Format 1 subtable consists of a format identifier
	  (PosFormat), an offset to a Coverage table that defines the
	  glyphs to be adjusted by the positioning values (Coverage),
	  and the format identifier (ValueFormat) that describes the
	  amount and kinds of data in the ValueRecord.</para>

        <para>The ValueRecord specifies one or more positioning values
	  to be applied to all covered glyphs (Value). For example, if
	  all glyphs in the Coverage table require both horizontal and
	  vertical adjustments, the ValueRecord will specify values
	  for both XPlacement and Yplacement.</para>

        <para>Example 2 at the end of this chapter shows a
	  SinglePosFormat1 subtable used to adjust the placement of
	  subscript glyphs.</para>

        <otformat>
          <title>SinglePosFormat1 subtable: Single positioning value</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              SinglePos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueFormat</otfieldname>
            <otfielddesc>Defines the types of data in the
              ValueRecord</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>ValueRecord</otfieldtype>
            <otfieldname>Value</otfieldname>
            <otfielddesc>Defines positioning value(s) &#x2013; applied to all
              glyphs in the Coverage table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>The pattern matched by this subtable is &#x25B6; C
	  &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to adjust the glyph
	  matched by C by {ValueFormat, Value}.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>singlePosTable, format 1</code-title>
  singlePosTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset },
    element value { valueRecord }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  public Block singlePosFormat1FromXML (Element subtable, Element table,
                                        Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    Element coverageNode = (Element)subtable.getFirstChild ();
    Element valueNode = (Element) coverageNode.getNextSibling ();

    Value value = parseValue (valueNode);
    int valueSize = valueSize (value.format);

    Block coverage = coverageFromXML (coverageNode, table, blockCache);

    me = new Block (6 + valueSize, 1);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, value.format);
    me.setValue (6, value);

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_1_1'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gpos.toXML_1_1'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gpos.toXMLEmit_1_1'>
  int coverageOffset = stOffset + getOffset (stOffset + 2);
  int valueFormat = getuint16 (stOffset + 4);

  at = new AttributesImpl ();
  coverageTableOffsetToXML (conf, coverageOffset, counts, "coverage", at);

  at = new AttributesImpl ();
  new ValueRecord().fromBinary (this, stOffset + 6, valueFormat).toXML (at);
  conf.ch.element ("value", at);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos_1_1'>
  <code-title>Execute GPOS 1/1 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), coverageOffset) == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int valueFormat = getuint16 (stOffset + 4);
    ValueRecord vr = new ValueRecord().fromBinary (this, stOffset + 6, valueFormat);

    if (listener != null) {
      listener.adjust (vr, valueFormat);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, "GPOS", stOffset); }

    gr.adjustPlacementAndAdvance (inPos, vr);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos1_1_simple</title>

          <para>In this series, we have a simple adjustment of one of
            the Value fields.</para>

          <para>Our first test adjusts the xPlacement of glyphs 18 and 20 by
            -200.</para>

<aots:test-font id='gpos1_1_simple_f1'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='1'>
        <singlePos format='1'>
          <coverage format='any' glyphs='18 20'/>
          <value xPlacement='-200'/>
       </singlePos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_1_simple_t1' font='gpos1_1_simple_f1'
	   inputs= '17,   18,   19,   20,   21'
	   xdeltas=' 0, -200,    0, -200,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>

          <para>Next, we adjust the yPlacement of glyphs 18 and 20 by
            -200.</para>

<aots:test-font id='gpos1_1_simple_f2'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='1'>
        <singlePos format='1'>
          <coverage glyphs='18 20' format='any'/>
          <value yPlacement='-200'/>
	</singlePos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_1_simple_t2'
	   font='gpos1_1_simple_f2'
	   inputs= '17,   18,   19,   20,   21'
           xdeltas=' 0,    0,    0,    0,    0'
	   ydeltas=' 0, -200,    0, -200,    0'/>

          <para>Next, we adjust the xAdvance of glyphs 18 and 20 by -200.</para>

<aots:test-font id='gpos1_1_simple_f3'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup  id="lookup.test" type='1'>
	<singlePos format='1'>
	  <coverage glyphs='18 20' format='any'/>
	  <value xAdvance='-200'/>
	</singlePos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_1_simple_t3'
	   font='gpos1_1_simple_f3'
	   inputs= '17,   18,    19,   20,   21'
	   xdeltas=' 0,    0,  -200, -200, -400'
	   ydeltas=' 0,    0,     0,    0,    0'>

          <para>Next, we adjust the yAdvance of glyphs 18 and 20 by -200.</para>

<aots:test-font id='gpos1_1_simple_f4'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='1'>
	<singlePos format='1'>
	  <coverage glyphs='18 20' format='any'/>
	  <value yAdvance='-200'/>
	</singlePos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_1_simple_t4'
	   font='gpos1_1_simple_f4'
	   inputs= '17,   18,    19,   20,   21'
	   xdeltas=' 0,    0,     0,    0,    0'
	   ydeltas=' 0,    0,  -200, -200, -400'/>
          </aots:gpos-test>
        </section>

	<section>
	  <title>gpos1_1_lookupflag</title>

	  <para>This test case exercises LookupFlag. The trick
	    to have a glyph which is both in the collection defined by
	    LookupFlag and transformed. Since LookupFlag takes
	    precedence over Coverage, the glyph should not be
	    transformed. In addition, looking at the step by step
	    execution of the lookup over the glyphrun, one should see
	    that there is a single lookup application for this glyph
	    and the next glyph (which is transformed). While the font
	    may seem at first improperly built, it could be that the
	    Coverage is shared with another table.</para>

<aots:test-font id='gpos1_1_lookupflag_f1'>
  <base-font name='base.otf'/>

  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='1'>
        <singlePos format='1'>
          <coverage glyphs='18 20' format='any'/>
          <value xPlacement='-300'/>
        </singlePos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_1_lookupflag_t1'
	   font='gpos1_1_lookupflag_f1'
	   inputs= '17,   18,   19,   20,   21'
	   xdeltas=' 0,    0,    0, -300,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Single Adjustment Positioning: Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A SinglePosFormat2 subtable provides an array of
          ValueRecords that contains one positioning value for each
          glyph in the Coverage table. This format is more flexible
          than Format 1, but it requires more space in the font
          file.</para>

        <para>For example, assume that the Cyrillic script will be
          used in left-justified text. For all glyphs, Format 2 could
          define position adjustments for left side bearings to align
          the left edges of the paragraphs. To achieve this, the
          Coverage table would list every glyph in the script, and the
          SinglePosFormat2 subtable would define a ValueRecord for
          each covered glyph. Correspondingly, each ValueRecord would
          specify an XPlacement adjustment value for the left side
          bearing.</para>

        <blockquote>
          <para>Note: All ValueRecords defined in a SinglePos subtable
            must have the same ValueFormat. In this example, if
            XPlacement is the only value that a ValueRecord needs to
            optically align the glyphs, then XPlacement will be the
            only value specified in the ValueFormat of the
            subtable.</para>
        </blockquote>

        <para>As in Format 1, the Format 2 subtable consists of a
          format identifier (PosFormat), an offset to a Coverage table
          that defines the glyphs to be adjusted by the positioning
          values (Coverage), and the format identifier (ValueFormat)
          that describes the amount and kinds of data in the
          ValueRecords. In addition, the Format 2 subtable
          includes:</para>

        <itemizedlist>
          <listitem>
            <para>A count of the ValueRecords (ValueCount). One
              ValueRecord is defined for each glyph in the Coverage
              table.</para>
          </listitem>
          <listitem>
            <para>An array of ValueRecords that specify positioning
              values (Value). Because the array follows the Coverage
              Index order, the first ValueRecord applies to the first
              glyph listed in the Coverage table, and so on.</para>
          </listitem>
        </itemizedlist>

        <para>Example 3 at the end of this chapter shows how to adjust
          the spacing of three dash glyphs with a SinglePosFormat2
          subtable.</para>

        <otformat>
          <title>SinglePosFormat2 subtable: Array of positioning values</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              SinglePos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueFormat</otfieldname>
            <otfielddesc>Defines the types of data in the
              ValueRecord</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueCount</otfieldname>
            <otfielddesc>Number of ValueRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ValueRecord</otfieldtype>
            <otfieldname>Value [ValueCount]</otfieldname>
            <otfielddesc>Array of ValueRecords &#x2013; positioning values
              applied to glyphs</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>It is unclear whether ValueCount must equal the number of covered
          glyphs. We assume that is must be equal.</para>

	<para>The pattern matched by this subtable is &#x25B6; C
	  &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to adjust the glyph
	  matched by C by {ValueFormat, Value [Coverage[g]]}, where g
	  is the glyph id of the matched glyph.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>singlePosTable, format 2</code-title>
  singlePosTable |=
    attribute format { "2" },
    element coverage { coverageTableOffset }?,
    element value {
      attribute glyph { text },
      valueRecord
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  private Block singlePosFormat2FromXML (Element subtable, Element table,
                                         Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if ("coverage".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }
    else {
      coverage = coverageFromXML (subtable.getChildNodes (), "glyph"); }

    NodeList children = subtable.getChildNodes ();
    Value[] values = new Value [coverage.glyphs.length];

    for (int i = 0; i &lt; children.getLength (); i++) {
      Element pos = (Element) children.item (i);
      int[] in = getGlyphs (pos.getAttribute ("glyph"));
      Value value = parseValue (pos);

      if (in.length != 1) {
        warning ("singlePosFormat2/pos/@in must have exactly one glyph"); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          values [j] = value;
          covered = true;
          break; }}

      if (! covered) {
       warning ("in glyph '" + in[0]
                + "' must be covered in singlePosFormat2"); }}

    int valueFormat = 0;
    for (int i = 0; i &lt; coverage.glyphs.length; i++) {
      if (values [i] == null) {
        warning ("no 'pos' for glyph " + coverage.glyphs [i]
                 + " in SinglePosFormat2"); }
      else {
        valueFormat |= values [i].format; }}

    int valueSize = valueSize (valueFormat);

    me = new Block (8 + valueSize * coverage.glyphs.length, 1);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setuint16 (4, valueFormat);
    me.setuint16 (6, coverage.glyphs.length);

    int offset = 8;
    for (int i = 0; i &lt; coverage.glyphs.length; i++) {
      me.setValue (offset, valueFormat, values[i]);
      offset += valueSize; }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_1_2'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gpos.toXML_1_2'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gpos.toXMLEmit_1_2'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int valueFormat = getuint16 (stOffset + 4);
    int valueCount = getuint16 (stOffset + 6);
    int valueRecordSize = ValueRecord.getSize (valueFormat);

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, coverageOffset, counts,
                              "coverage", at);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; valueCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "glyph", "glyph", "CDATA", "" + glyphs [i]);
      new ValueRecord().fromBinary (this, stOffset + 8 + valueRecordSize*i,
                                    valueFormat).toXML (at);
      conf.ch.element ("value", at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>The context pattern for this subtable format is C,
          where C is the collection of glyphs covered by
          Coverage.</para>

<code-fragment id='gpos_1_2'>
  <code-title>Execute GPOS 1/2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int valueFormat = getuint16 (stOffset + 4);
    int valueRecordOffset = stOffset + 8 + ValueRecord.getSize (valueFormat) * ci;
    ValueRecord vr = new ValueRecord().fromBinary (this, valueRecordOffset, valueFormat);

    if (listener != null) {
      listener.adjust (vr, valueFormat);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, "GPOS", stOffset); }

    gr.adjustPlacementAndAdvance (inPos, vr);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

	<section>
	  <title>gpos1_2_font1: basic test</title>

          <para>Our first test adjusts the xPlacement of glyph 18 by
              -200 and glyph 20 by -300.</para>

<aots:test-font id='gpos1_2_font1'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='1'>
	<singlePos format='2'>
	  <value glyph='18' xPlacement='-200'/>
	  <value glyph='20' xPlacement='-300'/>
	</singlePos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_2_test1'
	   font='gpos1_2_font1'
	   inputs= '17,   18,   19,   20,   21'
	   xdeltas=' 0, -200,    0, -300,    0'
	   ydeltas=' 0,    0,  0,    0,  0'/>
        </section>

	<section>
	  <title>gpos1_2_font2: lookup flags</title>

	  <para>Our second test case exercises LookupFlag. The trick
	    to have a glyph which is both in the collection defined by
	    LookupFlag and transformed. Since LookupFlag takes
	    precedence over Coverage, the glyph should not be
	    transformed. In addition, looking at the step by step
	    execution of the lookup over the glyphrun, one should see
	    that there is a single lookup application for this glyph
	    and the next glyph (which is transformed). While the font
	    may seem at first improperly built, it could be that the
	    Coverage is shared with another table.</para>

<aots:test-font id='gpos1_2_font2'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='1'>
      <singlePos format='2'>
        <value glyph='18' xPlacement='-200'/>
        <value glyph='20' xPlacement='-300'/>
      </singlePos>
    </lookup>
   </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos1_2_lookupflag_t1'
	   font='gpos1_2_font2'
	   inputs= '17,   18,   19,   20,   21'
	   xdeltas=' 0,    0,    0, -300,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 2: Pair Adjustment Positioning Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A pair adjustment positioning subtable (PairPos) is used
          to adjust the positions of two glyphs in relation to one
          another-for instance, to specify kerning data for pairs of
          glyphs. Compared to a typical kerning table, however, a
          PairPos subtable offers more flexiblity and precise control
          over glyph positioning. The PairPos subtable can adjust each
          glyph in a pair independently in both the X and Y
          directions, and it can explicitly describe the particular
          type of adjustment applied to each glyph. In addition, a
          PairPos subtable can use Device tables to subtly adjust
          glyph positions at each font size and device
          resolution.</para>

        <para>PairPos subtables can be either of two formats: one that
          identifies glyphs individually by index (Format 1), or one
          that identifies glyphs by class (Format 2).</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>pairPosTable</code-title>
  standalonePairPosTable =
    element pairPosTable { attribute id { text }, pairPosTable }

  pairPosTableOffset = attribute name { text } | pairPosTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  <code-title>Compile pairPos lookups</code-title>
  private Block pairPosLookupFromXML (Element t,
                                      Element table,
                                      Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    String format = t.getAttribute ("format");
    if ("1".equals (format)) {
      return pairPosFormat1FromXML (t, table, blockCache); }
    if ("2".equals (format)) {
      return pairPosFormat2FromXML (t, table, blockCache); }

    /* cannot get here from a valid document */
    throw new InvalidFontException
                  ("invalid pair pos lookup format (" + format + ")");
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_2'>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gpos.toXMLCount_2_1'/>; break; }
    case 2: { <code-include linkend='gpos.toXMLCount_2_2'/>; break; }}
</code-fragment>

<code-fragment id='gpos.toXML_2'>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gpos.toXML_2_1'/>; break; }
    case 2: { <code-include linkend='gpos.toXML_2_2'/>; break; }}
</code-fragment>

<code-fragment id='gpos.toXMLEmit_2'>
   switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gpos.toXMLEmit_2_1'/>; break; }
    case 2: { <code-include linkend='gpos.toXMLEmit_2_2'/>; break; }}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Both subtable formats start with the same field, the
          uint16 PosFormat, so that we can distinguish them.</para>

<code-fragment id='gpos_2'>
  <code-title>Execute GPOS 2 subtable and return</code-title>
  { int posFormat = getuint16 (stOffset);
    switch (posFormat) {
      case 1: { <code-include linkend='gpos_2_1'/> }
      case 2: { <code-include linkend='gpos_2_2'/> }
      default:
        throw new InvalidFontException ("GPOS 2/-" + posFormat + "-"); }}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Pair Positioning Adjustment: Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 1 uses glyph indices to access positioning data
          for one or more specific pairs of glyphs. All pairs are
          specified in the order determined by the layout direction of
          the text.</para>

        <blockquote>
          <para>Note: For text written from right to left, the
            right-most glyph will be the first glyph in a pair;
            conversely, for text written from left to right, the
            left-most glyph will be first.</para>
        </blockquote>

        <para>A PairPosFormat1 subtable contains a format identifier
          (PosFormat) and two ValueFormats:</para>

        <itemizedlist>
          <listitem>
            <para>ValueFormat1 applies to the ValueRecord of the first
              glyph in each pair. ValueRecords for all first glyphs
              must use ValueFormat1. If ValueFormat1 is set to zero
              (0), the corresponding glyph has no ValueRecord and,
              therefore, should not be repositioned.</para>
          </listitem>
          <listitem>
            <para>ValueFormat2 applies to the ValueRecord of the
              second glyph in each pair. ValueRecords for all second
              glyphs must use ValueFormat2. If ValueFormat2 is set to
              null, then the second glyph of the pair is the "next"
              glyph for which a lookup should be performed.</para>
          </listitem>
        </itemizedlist>

        <para>A PairPos subtable also defines an offset to a Coverage
          table (Coverage) that lists the indices of the first glyphs
          in each pair. More than one pair can have the same first
          glyph, but the Coverage table will list that glyph only
          once.</para>

        <para>The subtable also contains an array of offsets to
          PairSet tables (PairSet) and a count of the defined tables
          (PairSetCount). The PairSet array contains one offset for
          each glyph listed in the Coverage table and uses the same
          order as the Coverage Index.</para>

        <otformat>
          <title>PairPosFormat1 subtable: Adjustments for glyph pairs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table - from beginning of
              PairPos subtable - only the first glyph in each
              pair</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueFormat1</otfieldname>
            <otfielddesc>Defines the types of data in ValueRecord1 - for
              the first glyph in the pair - may be zero
              (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueFormat2</otfieldname>
            <otfielddesc>Defines the types of data in ValueRecord2 - for
              the second glyph in the pair - may be zero
              (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PairSetCount</otfieldname>
            <otfielddesc>Number of PairSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>PairSetOffset [PairSetCount]</otfieldname>
            <otfielddesc>Array of offsets to PairSet tables - from
              beginning of PairPos subtable - ordered by Coverage
              Index</otfielddesc>
          </otfield>
        </otformat>


        <para>A PairSet table enumerates all the glyph pairs that
          begin with a covered glyph. An array of PairValueRecords
          (PairValueRecord) contains one record for each pair and
          lists the records sorted by the GlyphID of the second glyph
          in each pair. PairValueCount specifies the number of
          PairValueRecords in the set.</para>

        <otformat>
          <title>PairSet table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PairValueCount</otfieldname>
            <otfielddesc>Number of PairValueRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PairValueRecord
              [PairValueCount]</otfieldname>
            <otfielddesc>Array of PairValueRecords - ordered by GlyphID
              of the second glyph</otfielddesc>
          </otfield>
        </otformat>


        <para>A PairValueRecord specifies the second glyph in a pair
          (SecondGlyph) and defines a ValueRecord for each glyph
          (Value1 and Value2). If ValueFormat1 is set to zero (0) in
          the PairPos subtable, ValueRecord1 will be empty; similarly,
          if ValueFormat2 is 0, Value2 will be empty.</para>

        <para>Example 4 at the end of this chapter shows a
          PairPosFormat1 subtable that defines two cases of pair
          kerning.</para>

        <otformat>
          <title>PairValueRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>SecondGlyph</otfieldname>
            <otfielddesc>GlyphID of second glyph in the pair-first
              glyph is listed in the Coverage table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>ValueRecord</otfieldtype>
            <otfieldname>Value1</otfieldname>
            <otfielddesc>Positioning data for the first glyph in the
              pair</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ValueRecord</otfieldtype>
            <otfieldname>Value2</otfieldname>
            <otfielddesc>Positioning data for the second glyph in the
              pair</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
          <title>Annotation</title>

        <para>The type of the last field in PairPosFormat1 is wrong; it
          should be Offset.</para>

        <para>It is unclear whether PairSetCount must equal the number of
          covered glyphs. We assume that it must.</para>

        <para>It is unclear whether a PairSet entry can be null. We
	  assume that none can be.</para>

        <para>It is unclear whether a PairValueRecord can be null. We
	  assume that none can be.</para>

	<para>It is unclear whether ValueFormat1 and ValueFormat2 can
	  be both 0 at the same time. We assume they can be.</para>

	<para>If ValueFormat2 &#x2260; 0, the pattern matched by the
	PairValueRecord r = PairSet [m].PairValueRecord [n] is
	&#x25B6; I<subscript>0</subscript> L*
	I<subscript>1</subscript> &#x25C0;, where:
	  <itemizedlist>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]}
	      &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>1</subscript> is {r.SecondGlyph}
	      &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist>
	  If ValueFormat2 = 0, the pattern matched by that record is
	  &#x25B6; I<subscript>0</subscript> &#x25C0; L*
	  I<subscript>1</subscript>.</para>

	<para>The action of this subtable is to adjust the glyph
	  matched by I<subscript>0</subscript> by {ValueFormat1,
	  r.Value1} and then the glyph matched by
	  I<subscript>1</subscript> by {ValueFormat2,
	  r.Value2}.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>pairPosTable, format 1</code-title>
  pairPosTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element pairSet {
      attribute in { text },
      pairSetTableOffset
    }*

  pairSetTable =
    element pos2 {
      attribute in { text },
      element value1 { valueRecord }?,
      element value2 { valueRecord }?
    }*

  standalonePairSetTable =
    element pairSetTable { attribute id { text }, pairSetTable }

  pairSetTableOffset = attribute name { text } | pairSetTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  private void pairSetValueFormatFromXML (Element t, Element table,
                                         int[] format) {
    String name = t.getAttribute ("name");
    if (name != null &amp;&amp; ! "".equals (name)) {
      t = resolveXMLid (table, name); }

    NodeList l = t.getChildNodes ();
    for (int j = 0; j &lt; l.getLength (); j++) {
      Element pos2 = (Element) l.item (j);

      NodeList m = pos2.getChildNodes ();
      for (int k = 0; k &lt; m.getLength (); k++) {
        Element v = (Element) m.item (k);
        if ("value1".equals (v.getTagName ())) {
          format [0] |= parseValue (v).format; }
        else if ("value2".equals (v.getTagName ())) {
          format [1] |= parseValue (v).format; }}}
  }


  private Block pairSetTableFromXML (Element t, Element table,
                                     Map&lt;Element, Block> blockCache,
				     int[] valueFormat)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    int valueSize1 = valueSize (valueFormat [0]);
    int valueSize2 = valueSize (valueFormat [1]);

    CoverageTableBlock coverage = coverageFromXML (t.getChildNodes (), "in");

    int pairValueSize = (2 + valueSize1 + valueSize2);

    Block me = new Block (2 + coverage.glyphs.length * pairValueSize, 0);
    blockCache.put (t, me);

    me.setuint16 (0, coverage.glyphs.length);

    NodeList l = t.getChildNodes ();
    for (int i = 0; i &lt; l.getLength (); i++) {
      Element pos2 = (Element) l.item (i);
      int[] gids = parseGlyphList (pos2.getAttribute ("in"));
      for (int j = 0; j &lt; gids.length; j++) {
        int ci = coverage.index (gids [j]);
        int offset = 2 + ci * pairValueSize;
        me.setuint16 (offset, gids [j]);
        offset += 2;

        NodeList m = pos2.getChildNodes ();
        for (int k = 0; k &lt; m.getLength (); k++) {
          Element v = (Element) m.item (k);
          if ("value1".equals (v.getTagName ())) {
            me.setValue (offset, valueFormat [0], parseValue (v));
            offset += valueSize1; }
          else if ("value2".equals (v.getTagName ())) {
            me.setValue (offset, valueFormat [1], parseValue (v));
            offset += valueSize2; }}}}


    return me;
  }

  private Block pairPosFormat1FromXML (Element t, Element table,
                                       Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    CoverageTableBlock coverage;
    Element firstChild = (Element) t.getFirstChild ();
    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if ("coverage".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      t.removeChild (firstChild); }
    else {
      coverage = coverageFromXML (t.getChildNodes (), "in"); }

    NodeList pairSets = t.getChildNodes ();
    int[] valueFormat = new int [2];
    valueFormat [0] = 0;
    valueFormat [1] = 0;
    for (int i = 0; i &lt; pairSets.getLength(); i++) {
      Element pairSet = (Element) pairSets.item (i);
      pairSetValueFormatFromXML (pairSet, table, valueFormat); }

    me = new Block (10 + 2*coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, valueFormat [0]);
    me.setuint16 (6, valueFormat [1]);
    me.setuint16 (8, coverage.glyphs.length);

    for (int i = 0; i &lt; pairSets.getLength(); i++) {
      Element pairSet = (Element) pairSets.item (i);
      int[] gids = parseGlyphList (pairSet.getAttribute ("in"));
      for (int k = 0; k &lt; gids.length; k++) {
        int ci = coverage.index (gids [k]);
        me.setOffset (10 + 2*ci,
                      pairSetTableFromXML (pairSet, table, blockCache,
                                           valueFormat)); }}

    return me;
  }

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>When a PairSet table is referenced multiple times from a
	a PairPos table, we are going to group those references, so we
	need to count that PairSet table only once. However, it is
	still possible that the PairSet table could also be referenced
	from another PairPos table.</para>

<code-fragment id='gpos.toXMLCount_2_1'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
  int pairSetCount = getuint16 (stOffset + 8);
  for (int i = 0; i &lt; pairSetCount; i++) {
    int offset = stOffset + getOffset (stOffset + 10 + 2*i);

    boolean seen = false;
    int j = 0;
    while (j &lt; i &amp;&amp; ! seen) {
      int previousOffset = stOffset + getOffset (stOffset + 10 + 2*j);
      if (previousOffset == offset) {
        seen = true; }
      else {
        j++; }}

    if (! seen) {
      pairSetTableToXMLCount (offset, counts); }}
</code-fragment>

<code-fragment id='gpos.methods'>
  public void pairSetTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }
</code-fragment>

<code-fragment id='gpos.toXML_2_1'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
  int pairSetCount = getuint16 (stOffset + 8);
  int valueFormat1 = getuint16 (stOffset + 4);
  int valueFormat2 = getuint16 (stOffset + 6);
  for (int i = 0; i &lt; pairSetCount; i++) {
    pairSetTableToXML (conf, stOffset + getOffset (stOffset + 10 + 2*i), counts,
                       valueFormat1, valueFormat2); }
</code-fragment>

<code-fragment id='gpos.methods'>
  public void pairSetTableOffsetToXML (DecompilerConfig conf, int offset,
                                       int[] counts,
                                       String element, AttributesImpl at,
                                       int valueFormat1, int valueFormat2)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "pairSetTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      pairSetTableToXMLEmit (conf, offset, counts, element, at,
                             valueFormat1, valueFormat2); }
  }

  public void pairSetTableToXML (DecompilerConfig conf,
                                 int offset, int[] counts,
                                 int valueFormat1, int valueFormat2)
      throws org.xml.sax.SAXException, InvalidFontException {


    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "pairSetTable_" + Integer.toHexString (offset));
      pairSetTableToXMLEmit (conf, offset, counts, "pairSetTable", at,
                             valueFormat1, valueFormat2);
      counts [offset] = 0; }
  }
</code-fragment>

<code-fragment id='gpos.toXMLEmit_2_1'>
  int coverageOffset = stOffset + getOffset (stOffset + 2);
  int valueFormat1 = getuint16 (stOffset + 4);
  int valueFormat2 = getuint16 (stOffset + 6);
  int[] glyphs = getCoveredGlyphs (coverageOffset);
  int pairSetCount = getuint16 (stOffset + 8);

  at = new AttributesImpl ();
  coverageTableOffsetToXML (conf, coverageOffset, counts, "coverage", at);

  Map&lt;Integer, String> m = new HashMap&lt;Integer, String> ();
  for (int i = 0; i &lt; pairSetCount; i++) {
    int pairSetOffset = stOffset + getOffset (stOffset + 10 + 2 * i);
    String s = m.get (pairSetOffset);
    if (s == null) {
      s = glyphToXML (conf, glyphs [i]); }
    else {
      s = s.concat (" " + glyphToXML (conf, glyphs [i])); }
    m.put (pairSetOffset, s); }

  // for readability and for round-tripping stability, we
  // want to enumerate the pairSet tables in the numeric
  // order of their first glyph
  SortedMap&lt;String,Integer> mm = new TreeMap&lt;String, Integer> ();
  for (int pairSetOffset : m.keySet ()) {
    String s = m.get (pairSetOffset);
    mm.put (s, pairSetOffset); }

  for (String s : mm.keySet ()) {
    int pairSetOffset = mm.get (s);
    at = new AttributesImpl ();
    at.addAttribute ("", "in", "in", "CDATA", m.get (pairSetOffset));
    pairSetTableOffsetToXML (conf, pairSetOffset, counts, "pairSet", at,
                             valueFormat1, valueFormat2); }
</code-fragment>


<code-fragment id='gpos.methods'>
  public void pairSetTableToXMLEmit (DecompilerConfig conf, int offset,
                                     int[] counts,
				     String element, AttributesImpl at,
                                     int valueFormat1, int valueFormat2)
      throws org.xml.sax.SAXException, InvalidFontException {


    int valueRecord1Size = ValueRecord.getSize (valueFormat1);
    int valueRecord2Size = ValueRecord.getSize (valueFormat2);
    int pairValueRecordSize = 2 + valueRecord1Size + valueRecord2Size;

    conf.ch.startElement (element, at); {
      int pairValueCount = getuint16 (offset);

      for (int j = 0; j &lt; pairValueCount; j++) {
        int pairValueRecordOffset = offset + 2 + pairValueRecordSize * j;
        int secondGlyph = getGlyphID (pairValueRecordOffset);

        at = new AttributesImpl ();
        at.addAttribute ("", "in", "in", "CDATA",
   			 glyphToXML (conf, secondGlyph));
        conf.ch.startElement ("pos2", at); {
          ValueRecord vr1 = new ValueRecord().fromBinary (this,
                                 pairValueRecordOffset + 2, valueFormat1);
          ValueRecord vr2 =  new ValueRecord().fromBinary (this,
                   pairValueRecordOffset + 2 + valueRecord1Size, valueFormat2);

          if (true || ! vr1.isNull ()) {
            at = new AttributesImpl ();
	      vr1.toXML (at);
            conf.ch.element ("value1", at); }

          if (! vr2.isNull ()) {
            at = new AttributesImpl ();
            vr2.toXML (at);
            conf.ch.element ("value2", at); }

          conf.ch.endElement ("pos2"); }}
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Note that contrary to other lookups, the next glyph to
          process is not always the first glyph after the matched
          sequenced: if valueFormat2 is 0, then the next glyph to
          process is the second matching glyph.</para>

<code-fragment id='gpos_2_1'>
  <code-title>Execute GPOS 2/1 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int firstGlyphPos = inPos++;

    while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
      inPos++; }

    if (! gr.isLookupApplied (lookupIndex, firstGlyphPos, inPos)) {
      return lookupNotApplied; }

    int valueFormat1 = getuint16 (stOffset + 4);
    int valueFormat2 = getuint16 (stOffset + 6);
    int valueRecord1Size = ValueRecord.getSize (valueFormat1);
    int valueRecord2Size = ValueRecord.getSize (valueFormat2);
    int pairValueRecordSize = 2 + valueRecord1Size + valueRecord2Size;

    int pairSetOffset = stOffset + getOffset (stOffset + 10 + 2*ci);
    int pairValueCount = getuint16 (pairSetOffset);
    for (int p = 0; p &lt; pairValueCount; p++) {
      int pairValueRecordOffset = pairSetOffset + 2 + pairValueRecordSize * p;
      int secondGlyph = getGlyphID (pairValueRecordOffset);

      if (secondGlyph == gr.glyphAt (inPos)) {
        ValueRecord value1
	  = new ValueRecord().fromBinary (this,
                                          pairValueRecordOffset + 2,
                                          valueFormat1);
        ValueRecord value2
	  = new ValueRecord().fromBinary (this,
	                                  pairValueRecordOffset + 2 + valueRecord1Size,
                                          valueFormat2);
        if (listener != null) {
          listener.adjust (value1, valueFormat1);
          listener.adjust (value2, valueFormat2);
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     "GPOS", stOffset); }

        if (valueFormat1 != 0) {
          gr.adjustPlacementAndAdvance (firstGlyphPos, value1); }
        if (valueFormat2 != 0) {
          gr.adjustPlacementAndAdvance (inPos, value2); }

        if (valueFormat2 == 0) {
          return new LookupResult (true, inPos, 0); }
        else {
          return new LookupResult (true, inPos + 1, 0); }}}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos2_1_simple_f1</title>

          <para>Our first test adjusts the pair of glyphs 18 and
	    19. The xPlacement of glyph 18 is adjusted by -200, and
	    the yPlacement of glyph 19 is adjusted by -100.</para>

<aots:test-font id='gpos2_1_simple_f1'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='1'>
	  <coverage glyphs='18' format='any'/>
	  <pairSet in='18'>
	    <pos2 in='19'>
	      <value1 xPlacement='-200'/>
	      <value2 yPlacement='-100'/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_simple_t1'
	   font='gpos2_1_simple_f1'
	   inputs= '17,   18,   19,   17,   18,   20'
	   xdeltas=' 0, -200,    0,    0,    0,    0'
	   ydeltas=' 0,    0, -100,    0,    0,    0'/>

          <para>In this test case, the input glyph run is exhausted in
          the middle of the match.</para>

          <aots:gpos-test
	   id='gpos2_1_simple_t2'
	   font='gpos2_1_simple_f1'
	   inputs= '17,   18'
	   xdeltas=' 0,    0'
	   ydeltas=' 0,    0'/>
        </section>

        <section>
          <title>LookupFlag</title>

          <para>Our second test exercises LookupFlag, which
            captures glyph 18:</para>

<aots:test-font id='gpos2_1_lookupflag_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
      </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='2'>
	<pairPos format='1'>
	  <coverage glyphs='19' format='any'/>
	  <pairSet in='19'>
	    <pos2 in='20'>
	      <value1 xPlacement='-200'/>
	      <value2 yPlacement='-100'/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_lookupflag_t1'
	   font='gpos2_1_lookupflag_f1'
	   inputs= '17,   19,   20,   17,   19,   18,   20,    17'
	   xdeltas=' 0, -200,    0,    0, -200,    0,    0,     0'
	   ydeltas=' 0,    0, -100,    0,    0,    0, -100,     0'/>

          <para>Here, we verify that the xAdvance is correctly applied
	    to the glyphs captured by LookupFlag.</para>

<aots:test-font id='gpos2_1_lookupflag_f2'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='2'>
	<pairPos format='1'>
	  <coverage glyphs='19' format='any'/>
	  <pairSet in='19'>
	    <pos2 in='20'>
	      <value1 xAdvance='-200'/>
	      <value2 yPlacement='-100'/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_lookupflag_t2'
	   font='gpos2_1_lookupflag_f2'
	   inputs= '17,   19,   20,   17,   19,   18,  20,    17'
           xdeltas=' 0,    0, -200, -200, -200, -400, -400, -400'
	   ydeltas=' 0,    0, -100,    0,    0,    0, -100,    0'/>

        </section>

        <section>
          <title>gpos2_1_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
            processed after a type 2 lookup is applied. The lookup
            matches the sequence 18 18 and both glyphs have a non-null
            ValueFormat. Given the sequence 18 18 18 18, only the
            first and third glyphs should be moved.</para>

<aots:test-font id='gpos2_1_next_glyph_f1'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='1'>
	  <coverage glyphs='18' format='any'/>
	  <pairSet in='18'>
	    <pos2 in='18'>
	      <value1 xPlacement='-100'/>
	      <value2 yPlacement='-100'/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_next_glyph_t1'
	   font='gpos2_1_next_glyph_f1'
           inputs= '  18,   18,   18,   18'
           xdeltas='-100,    0, -100,    0'
	   ydeltas='   0, -100,    0, -100'/>

          <para>Here we test the special case where ValueFormat2 is 0,
            in which case the next glyph to process is the second
            glyph.</para>

<aots:test-font id='gpos2_1_next_glyph_f2'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='1'>
	  <coverage glyphs='18' format='any'/>
	  <pairSet in='18'>
	    <pos2 in='18'>
	      <value1 xPlacement='-100'/>
	      <value2/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_next_glyph_t2'
	   font='gpos2_1_next_glyph_f2'
	   inputs= '  18,   18,   18,   18'
	   xdeltas='-100, -100, -100,    0'
	   ydeltas='   0,    0,    0,    0'/>

        </section>

        <section>
          <title>More complex tests</title>

          <para>Here is a test with multiple PairValue records.</para>

<aots:test-font id='gpos2_1_font6'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='1'>
	  <coverage glyphs='18' format='any'/>
	  <pairSet in='18'>
	    <pos2 in='19'>
	      <value1 xPlacement='-200'/>
	      <value2 yPlacement='-100'/>
	    </pos2>
	    <pos2 in='20'>
	      <value1 xPlacement='-300'/>
	      <value2 yPlacement='-400'/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_test6'
	   font='gpos2_1_font6'
	   inputs= '17,   18,   19,   17,   18,   20,   17'
	   xdeltas=' 0, -200,    0,    0, -300,    0,    0'
	   ydeltas=' 0,    0, -100,    0,    0, -400,    0'/>

          <para>Another one:</para>

<aots:test-font id='gpos2_1_font7'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='1'>
	  <coverage glyphs='18 21' format='any'/>
	  <pairSet in='18'>
	    <pos2 in='19'>
	      <value1 xPlacement='-200'/>
	      <value2 yPlacement='-100'/>
	    </pos2>
	    <pos2 in='20'>
	      <value1 xPlacement='-300'/>
	      <value2 yPlacement='-400'/>
	    </pos2>
	  </pairSet>
	  <pairSet in='21'>
	    <pos2 in='22'>
	      <value1 xPlacement='-500'/>
	      <value2 yPlacement='-600'/>
	    </pos2>
	  </pairSet>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_1_test7'
	   font='gpos2_1_font7'
	   inputs= '17,   18,   19,   17,   18,   20,   17,    21,    22,  17'
	   xdeltas=' 0, -200,    0,    0, -300,    0,    0,  -500,     0,   0'
	   ydeltas=' 0,    0, -100,    0,    0, -400,    0,     0,  -600,   0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Pair Positioning Adjustment: Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 2 defines a pair as a set of two glyph classes
          and modifies the positions of all the glyphs in a class. For
          example, this format is useful in Japanese scripts that
          apply specific kerning operations to all glyph pairs that
          contain punctuation glyphs. One class would be defined as
          all glyphs that may be coupled with punctuation marks, and
          the other classes would be groups of similar punctuation
          glyphs.</para>

        <para>The PairPos Format2 subtable begins with a format
          identifier (PosFormat) and an offset to a Coverage table
          (Coverage), measured from the beginning of the PairPos
          subtable. The Coverage table lists the indices of the first
          glyphs that may appear in each glyph pair. More than one
          pair may begin with the same glyph, but the Coverage table
          lists the glyph index only once.</para>

        <para>A PairPosFormat2 subtable also includes two
          ValueFormats:</para>

        <itemizedlist>
          <listitem>
            <para>ValueFormat1 applies to the ValueRecord of the first
              glyph in each pair. ValueRecords for all first glyphs
              must use ValueFormat1. If ValueFormat1 is set to zero
              (0), the corresponding glyph has no ValueRecord and,
              therefore, should not be repositioned.</para>
          </listitem>
          <listitem>
            <para>ValueFormat2 applies to the ValueRecord of the
	      second glyph in each pair. ValueRecords for all second
	      glyphs must use ValueFormat2. If ValueFormat2 is set to
	      null, then the second glyph of the pair is the "next"
	      glyph for which a lookup should be performed.</para>
          </listitem>
        </itemizedlist>

        <para>PairPosFormat2 requires that each glyph in all pairs be
          assigned to a class, which is identified by an integer
          called a class value. (For details about classes, see the
          chapter, Common Table Formats.) Pairs are then represented
          in a two-dimensional array as sequences of two class values.
          Multiple pairs can be represented in one Format 2
          subtable.</para>

        <para>A PairPosFormat2 subtable contains offsets to two class
          definition tables: one that assigns class values to all the
          first glyphs in all pairs (ClassDef1), and one that assigns
          class values to all the second glyphs in all pairs
          (ClassDef2). If both glyphs in a pair use the same class
          definition, the offset value will be the same for ClassDef1
          and ClassDef2. The subtable also specifies the number of
          glyph classes defined in ClassDef1 (Class1Count) and in
          ClassDef2 (Class2Count), including Class0.</para>

        <para>For each class identified in the ClassDef1 table, a
          Class1Record enumerates all pairs that contain a particular
          class as a first component. The Class1Record array stores
          all Class1Records according to class value.</para>

        <blockquote>
          <para>Note: Class1Records are not tagged with a class value
            identifier. Instead, the index value of a Class1Record in
            the array defines the class value represented by the
            record. For example, the first Class1Record enumerates
            pairs that begin with a Class 0 glyph, the second
            Class1Record enumerates pairs that begin with a Class1
            glyph, and so on.</para>
        </blockquote>

        <otformat>
          <title>PairPosFormat2 subtable: Class pair adjustment</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table - from beginning of
              PairPos subtable - for the first glyph of the
              pair</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueFormat1</otfieldname>
            <otfielddesc>ValueRecord definition - for the first glyph of
              the pair - may be zero (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ValueFormat2</otfieldname>
            <otfielddesc>ValueRecord definition - for the second glyph
              of the pair - may be zero (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ClassDef1</otfieldname>
            <otfielddesc>Offset to ClassDef table - from beginning of
              PairPos subtable - for the first glyph of the
              pair</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ClassDef2</otfieldname>
            <otfielddesc>Offset to ClassDef table - from beginning of
              PairPos subtable - for the second glyph of the
              pair</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class1Count</otfieldname>
            <otfielddesc>Number of classes in ClassDef1 table - includes
              Class0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class2Count</otfieldname>
            <otfielddesc>Number of classes in ClassDef2 table - includes
              Class0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>Class1Record [Class1Count]</otfieldname>
            <otfielddesc>Array of Class1 records - ordered by
              Class1</otfielddesc>
          </otfield>
        </otformat>


        <para>Each Class1Record contains an array of Class2Records
          (Class2Record), which also are ordered by class value. One
          Class2Record must be declared for each class in the
          ClassDef2 table, including Class 0.</para>

        <otformat>
          <title>Class1Record</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>Class2Record [Class2Count]</otfieldname>
            <otfielddesc>Array of Class2 records - ordered by
              Class2</otfielddesc>
          </otfield>
        </otformat>

        <para>A Class2Record consists of two ValueRecords, one for the
          first glyph in a class pair (Value1) and one for the second
          glyph (Value2). If the PairPos subtable has a value of zero
          (0) for ValueFormat1 or ValueFormat2, the corresponding
          record (ValueRecord1 or ValueRecord2) will be empty.</para>

        <para>Example 5 at the end of this chapter demonstrates pair
          kerning with glyph classes in a PairPosFormat2
          subtable.</para>

        <otformat>
          <title>Class2Record</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ValueRecord</otfieldtype>
            <otfieldname>Value1</otfieldname>
            <otfielddesc>Positioning for first glyph - empty if
              ValueFormat1 = 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>ValueRecord</otfieldtype>
            <otfieldname>Value2</otfieldname>
            <otfielddesc>Positioning for second glyph - empty if
              ValueFormat2 = 0</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>It is unclear whether ValueFormat1 and ValueFormat2 can
	  be both 0 at the same time. We assume they can be.</para>


	<para>If ValueFormat2 &#x2260; 0, the pattern matched by the
	Class2Record r = Class1Record
	[m].Class2Record [n] is &#x25B6; I<subscript>0</subscript> L*
	I<subscript>1</subscript> &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>I<subscript>0</subscript> is ClassDef1[m] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>1</subscript> is ClassDef2[n] &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist>
	  If ValueFormat2 = 0, the pattern is &#x25B6;
	  I<subscript>0</subscript> &#x25C0; L* I<subscript>1</subscript>.</para>

	<para>The action of r is to adjust the glyph matched by
	I<subscript>0</subscript> by {ValueFormat1, r.Value1} and then
	the glyph matched by I<subscript>1</subscript> by
	{ValueFormat2, r.Value2}.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>pairPosTable, format 2</code-title>
  pairPosTable |=
    attribute format { "2" },
    element coverage { coverageTableOffset }?,
    element classdef { classDefTableOffset },
    element classdef { classDefTableOffset },
    element pos2 {
      attribute in { text },
      element value1 { valueRecord }?,
      element value2 { valueRecord }?
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  private Block pairPosFormat2FromXML (Element t, Element table,
                                       Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    CoverageTableBlock coverage;
    Element firstChild = (Element) t.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if ("coverage".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      t.removeChild (firstChild); }
    else {
      coverage = coverageFromXML (t.getChildNodes (), "in"); }

    ClassdefTableBlock classdef1
        = classdefFromXML ((Element) t.getFirstChild (),
                           table, blockCache);
    t.removeChild (t.getFirstChild ());
    ClassdefTableBlock classdef2
        = classdefFromXML ((Element) t.getFirstChild (),
                           table, blockCache);
    t.removeChild (t.getFirstChild ());

    NodeList children = t.getChildNodes ();

    int valueFormat1 = 0;
    int valueFormat2 = 0;
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element pos = (Element) children.item (i);
      Element value1 = (Element) pos.getFirstChild ();
      valueFormat1 |= parseValue (value1).format;
      Element value2 = (Element) value1.getNextSibling ();
      valueFormat2 |= parseValue (value2).format; }

    int valueSize1 = valueSize (valueFormat1);
    int valueSize2 = valueSize (valueFormat2);

    // System.err.println ("vs1=" + valueSize1 + " vs2=" + valueSize2
    // + "  c1=" + classdef1.classCount + " c2=" + classdef2.classCount);

    me = new Block (16
                    + (valueSize1 + valueSize2)
                      *  (classdef1.classCount * classdef2.classCount),
                    3);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setuint16 (4, valueFormat1);
    me.setuint16 (6, valueFormat2);
    me.setOffset (8, classdef1);
    me.setOffset (10, classdef2);
    me.setuint16 (12, classdef1.classCount);
    me.setuint16 (14, classdef2.classCount);

    int offset = 16;
    for (int i = 0; i &lt; classdef1.classCount; i++) {
      for (int j = 0; j &lt; classdef2.classCount; j++) {
        me.setValue (offset, valueFormat1, null);
        offset += valueSize1;
        me.setValue (offset, valueFormat2, null);
        offset += valueSize2; }}


    for (int k = 0; k &lt; children.getLength (); k++) {
      Element pos2 = (Element) children.item (k);
      int[] classes = getGlyphs (pos2.getAttribute ("in"));
      offset = 16 + (classdef2.classCount * classes [0]
                     + classes [1]) * (valueSize1 + valueSize2);
      Element value1 = (Element) pos2.getFirstChild ();
      me.setValue (offset, valueFormat1, parseValue (value1));
      offset += valueSize1;
      Element value2 = (Element) value1.getNextSibling ();
      me.setValue (offset, valueFormat2, parseValue (value2)); }

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_2_2'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 8), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 10), counts);
</code-fragment>

<code-fragment id='gpos.toXML_2_2'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 8), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 10), counts);
</code-fragment>

<code-fragment id='gpos.toXMLEmit_2_2'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int classDef1Offset = stOffset + getOffset (stOffset + 8);
    int classDef2Offset = stOffset + getOffset (stOffset + 10);
    int valueFormat1 = getuint16 (stOffset + 4);
    int valueFormat2 = getuint16 (stOffset + 6);
    int valueRecord1Size = ValueRecord.getSize (valueFormat1);
    int valueRecord2Size = ValueRecord.getSize (valueFormat2);
    int pairValueRecordSize = 2 + valueRecord1Size + valueRecord2Size;

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, coverageOffset, counts, "coverage", at);

    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, classDef1Offset, counts, "classdef", at);

    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, classDef2Offset, counts, "classdef", at);

    int class1Count = getuint16 (stOffset + 12);
    int class2Count = getuint16 (stOffset + 14);

    int vrOffset =  stOffset + 16;

    for (int i = 0; i &lt; class1Count; i++) {
      for (int j = 0; j &lt; class2Count; j++) {

        ValueRecord vr1 = new ValueRecord().fromBinary (this, vrOffset,
                                                        valueFormat1);
        vrOffset += valueRecord1Size;
        ValueRecord vr2 = new ValueRecord().fromBinary (this, vrOffset,
                                                        valueFormat2);
        vrOffset += valueRecord2Size;

        if (! (vr1.isNull () &amp;&amp; vr2.isNull ())) {
          at = new AttributesImpl ();
          at.addAttribute ("", "in", "in", "CDATA", "" + i + " " + j);
	  conf.ch.startElement ("pos2", at); {

            if (! vr1.isNull ()) {
	      at = new AttributesImpl ();
	      vr1.toXML (at);
	      conf.ch.element ("value1", at); }

	    if (! vr2.isNull ()) {
	      at = new AttributesImpl ();
	      vr2.toXML (at);
	      conf.ch.element ("value2", at); }

	    conf.ch.endElement ("pos2"); }}}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos_2_2'>
  <code-title>Execute GPOS 2/2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), coverageOffset) == -1) {
      return lookupNotApplied; }

    int firstGlyphPos = inPos++;

    while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
      inPos++; }

    if (! gr.isLookupApplied (lookupIndex, firstGlyphPos, inPos)) {
      return lookupNotApplied; }


    int firstGlyphClass = classIndex (gr.glyphAt (firstGlyphPos),
                                      stOffset + getOffset (stOffset + 8));
    int secondGlyphClass = classIndex (gr.glyphAt (inPos),
                                       stOffset + getOffset (stOffset + 10));
    int class1Count = getuint16 (stOffset + 12);
    int class2Count = getuint16 (stOffset + 14);
    int valueFormat1 = getuint16 (stOffset + 4);
    int valueFormat2 = getuint16 (stOffset + 6);
    int valueRecord1Size = ValueRecord.getSize (valueFormat1);
    int valueRecord2Size = ValueRecord.getSize (valueFormat2);
    int class2RecordSize = valueRecord1Size + valueRecord2Size;
    int class1RecordSize = class2RecordSize * class2Count;

    int class2RecordOffset
       = stOffset + 16
          + firstGlyphClass * class1RecordSize
          + secondGlyphClass * class2RecordSize;
    ValueRecord value1 = new ValueRecord().fromBinary (this, class2RecordOffset,
                                         valueFormat1);
    ValueRecord value2 = new ValueRecord().fromBinary (this, class2RecordOffset + valueRecord1Size,
                                         valueFormat2);
    if (listener != null) {
      listener.adjust (value1, valueFormat1);
      listener.adjust (value2, valueFormat2);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, "GPOS", stOffset); }

    if (valueFormat1 != 0) {
      gr.adjustPlacementAndAdvance (firstGlyphPos, value1); }
    if (valueFormat2 != 0) {
      gr.adjustPlacementAndAdvance (inPos, value2); }

    if (valueFormat2 == 0) {
      return new LookupResult (true, inPos, 0); }
    else {
      return new LookupResult (true, inPos + 1, 0); }}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos2_2_font1: basic tests</title>

          <para>Here is a simple test to start with:</para>

<aots:test-font id='gpos2_2_font1'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='2'>
	  <coverage glyphs='18' format='any'/>
	  <classdef format='any'>
	    <class classID='1' glyphs='18'/>
	  </classdef>
	  <classdef format='any'>
	    <class classID='1' glyphs='19'/>
	  </classdef>
	  <pos2 in='1 1'>
	    <value1 xPlacement='-200'/>
	    <value2 yPlacement='-100'/>
	  </pos2>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_2_test1a'
	   font='gpos2_2_font1'
	   inputs= '17,   18,   19,   17,   18,   20'
	   xdeltas=' 0, -200,    0,    0,    0,    0'
	   ydeltas=' 0,    0, -100,    0,    0,    0'/>
        </section>

        <section>
          <title>LookupFlag</title>

          <para>Our second test exercises LookupFlag, which captures
          glyph 18:</para>

<aots:test-font id='gpos2_2_font2'>
  <base-font name='base.otf'/>

  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='2'>
	<pairPos format='2'>
	  <coverage glyphs='19' format='any'/>
	  <classdef format='any'>
	    <class classID='1' glyphs='19'/>
	  </classdef>
	  <classdef format='any'>
	    <class classID='1' glyphs='20'/>
	  </classdef>
	  <pos2 in='1 1'>
	    <value1 xPlacement='-200'/>
	    <value2 yPlacement='-100'/>
	  </pos2>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_2_test2'
	   font='gpos2_2_font2'
	   inputs= '17,   19,   20,   17,   19,   18,   20,    17'
	   xdeltas=' 0, -200,    0,    0, -200,    0,    0,     0'
	   ydeltas=' 0,    0, -100,    0,    0,    0, -100,     0'/>

          <para>Here, we verify that the xAdvance is correctly applied
          to the glyphs captured by LookupFlag.</para>

<aots:test-font id='gpos2_2_font3'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='2'>
	<pairPos format='2'>
	  <coverage glyphs='19' format='any'/>
	  <classdef format='any'>
	    <class classID='1' glyphs='19'/>
	  </classdef>
	  <classdef format='any'>
	    <class classID='1' glyphs='20'/>
	  </classdef>
	  <pos2 in='1 1'>
	    <value1 xAdvance='-200'/>
	    <value2 yPlacement='-100'/>
	  </pos2>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_2_test3'
	   font='gpos2_2_font3'
	   inputs= '17,   19,   20,   17,   19,   18,  20,    17'
	   xdeltas=' 0,    0, -200, -200, -200, -400, -400,  -400'
	   ydeltas=' 0,    0, -100,    0,    0,    0, -100,    0'/>
        </section>

        <section>
          <title>gpos2_2_font4,5: next glyph to process</title>

          <para>Our next test verifies that the proper glyph is
          processed after a type 2 lookup is applied. The lookup
          matches the sequence 18 18, and both glyphs have a non-null
          ValueFormat. Given the sequence 18 18 18 18, only the first
          and third glyphs should be moved.</para>

<aots:test-font id='gpos2_2_font4'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='2'>
	  <coverage glyphs='18' format='any'/>
	  <classdef format='any'>
	    <class classID='1' glyphs='18'/>
	  </classdef>
	  <classdef format='any'>
	    <class classID='1' glyphs='18'/>
	  </classdef>
	  <pos2 in='1 1'>
	    <value1 xPlacement='-100'/>
	    <value2 yPlacement='-100'/>
	  </pos2>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_2_test4'
	   font='gpos2_2_font4'
	   inputs= '  18,   18,   18,   18'
	   xdeltas='-100,    0, -100,    0'
	   ydeltas='   0, -100,    0, -100'/>


          <para>Here we test the special case where ValueFormat2 is 0,
            in which case the next glyph to process is the second
            glyph.</para>

<aots:test-font id='gpos2_2_font5'>
  <base-font name='base.otf'/>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='2'>
	<pairPos format='2'>
	  <coverage glyphs='18' format='any'/>
	  <classdef format='any'>
	    <class classID='1' glyphs='18'/>
	  </classdef>
	  <classdef format='any'>
	    <class classID='1' glyphs='18'/>
	  </classdef>
	  <pos2 in='1 1'>
	    <value1 xPlacement='-100'/>
	    <value2/>
	  </pos2>
	</pairPos>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos2_2_test5'
	   font='gpos2_2_font5'
	   inputs= '  18,   18,   18,   18'
	   xdeltas='-100, -100, -100,    0'
	   ydeltas='   0,    0,    0,    0'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 3: Cursive Attachment Positioning Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Some cursive fonts are designed so that adjacent glyphs
          join when rendered with their default positioning. However,
          if positioning adjustments are needed to join the glyphs, a
          cursive attachment positioning (CursivePos) subtable can
          describe how to connect the glyphs by aligning two anchor
          points: the designated exit point of a glyph, and the
          designated entry point of the following glyph.</para>

        <para>The subtable has one format: CursivePosFormat1. It
          begins with a format identifier (PosFormat) and an offset to
          a Coverage table (Coverage), which lists all the glyphs that
          define cursive attachment data.</para>

        <para>In addition, the subtable contains one EntryExitRecord
          for each glyph listed in the Coverage table, a count of
          those records (EntryExitCount), and an array of those
          records in the same order as the Coverage Index
          (EntryExitRecord).</para>

        <otformat>
          <title>CursivePosFormat1 subtable: Cursive attachment</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table - from beginning of
              CursivePos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>EntryExitCount</otfieldname>
            <otfielddesc>Number of EntryExit records</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>EntryExitRecord [EntryExitCount]</otfieldname>
            <otfielddesc>Array of EntryExit records - in Coverage Index
              order</otfielddesc>
          </otfield>
        </otformat>

        <para>Each EntryExitRecord consists of two offsets: one to an
          Anchor table that identifies the entry point on the glyph
          (EntryAnchor), and an offset to an Anchor table that
          identifies the exit point on the glyph (ExitAnchor). (For a
          complete description of the Anchor table, see the end of
          this chapter.)</para>

        <para>To position glyphs using the CursivePosFormat1 subtable,
          a text-processing client aligns the ExitAnchor point of a
          glyph with the EntryAnchor point of the following glyph. If
          no corresponding anchor point exists, either the EntryAnchor
          or ExitAnchor offset may be NULL.</para>

        <para>At the end of this chapter, Example 6 describes cursive
          glyph attachment in the Urdu language.</para>

        <otformat>
          <title>EntryExitRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>EntryAnchor</otfieldname>
            <otfielddesc>Offset to EntryAnchor table-from beginning of
              CursivePos subtable-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExitAnchor</otfieldname>
            <otfielddesc>Offset to ExitAnchor table-from beginning of
              CursivePos subtable-may be NULL</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The specification indicates that under some
          circumstances, the ExitAnchor point of one glyph is aligned
          with the EntryAnchor of another. But it does not define
          &#x201c;align&#x201d; in any way: does it mean the two
          points are made to coincide, or that they are made to be on
          the same horizontal or vertical line? And what is moved to
          achieve that: the first glyph, the second glyph, both? What
          about the glyphs following the second one? The example may
          help those of you familiar with Urdu, but is otherwise
          unhelpful.</para>

	<para>In this implementation, we assume that the second glyph
	  is moved such that the anchors coincide, and none of the
	  glyphs following the second glyph, nor any of the glyphs
	  skipped by lookupFlag between the first and second glyph
	  are moved.</para>

	<para>We also assume that the input context is the first
	  glyph, meaning that the next glyph to process is the glyph
	  following the first glyph. The alternative is to make both
	  glyphs in the input context, but that would mean that the
	  second glyph could not be the first component of another
	  cursive attachment.</para>

	<para>[All this is obviously wrong, but I need more work to
	  figure out how this lookup type really works.]</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>cursiveAttachmentTable</code-title>
  cursiveAttachmentTable =
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element entryExit {
      attribute glyphID { text },
      element entry { anchorTableOffset }?,
      element exit  { anchorTableOffset }?
    }*

  standaloneCursiveAttachmentTable =
    element cursiveAttachmentTable { attribute id { text }, cursiveAttachmentTable }
  cursiveAttachmentTableOffset = attribute name { text } | cursiveAttachmentTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  <code-title>Compile cursivePosFormat1 lookups</code-title>
  public CoverageTableBlock coverageFromEntryExitFromXML (NodeList nl)
      throws InvalidFontException, UnsupportedFontException {
    int [] glyphs = new int [nl.getLength ()];
    int glyphCount = 0;

    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element entryExit = (Element) nl.item (i);
      int glyph = Integer.parseInt (entryExit.getAttribute ("glyphID"));
      glyphs [glyphCount++] = glyph; }

    return coverageFromGlyphs (glyphs);
  }

  private Block cursivePosFormat1FromXML (Element subtable, Element table,
                                          Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if ("coverage".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }
    else {
      coverage = coverageFromEntryExitFromXML (subtable.getChildNodes ()); }

    me = new Block (6 + 4*coverage.glyphs.length,
                    1 + 2*coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    NodeList children = subtable.getChildNodes ();

    boolean[] seen = new boolean [coverage.glyphs.length];

    for (int i = 0; i &lt; children.getLength (); i++) {
      Element entryExit = (Element) children.item (i);
      int glyphID = Integer.parseInt (entryExit.getAttribute ("glyphID"));

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (glyphID == coverage.glyphs [j]) {
          covered = true;
          if (seen [j]) {
            warning ("glyph " + glyphID
                      + " has two entries in cursivePosFormat1"); }
          seen [j] = true;

          NodeList nl = entryExit.getChildNodes ();
          boolean entrySeen = false;
          boolean exitSeen = false;
	  for (int k = 0; k &lt; nl.getLength (); k++) {
            Element e = (Element) nl.item  (k);
            Block anchor = anchorTableFromXML (e, table, blockCache);
            int o;
            if ("entry".equals (e.getTagName ())) {
              entrySeen = true;
              o = 6 + 4*j + 0; }
            else {
              exitSeen = true;
              o = 6 + 4*j + 2; }
            me.setOffset (o, anchor); }
          if (! entrySeen) {
            me.setOffset (6 + 4*j, null); }
          if (! exitSeen) {
            me.setOffset (6 + 4*j + 2, null); }
          break; }}

      if (! covered) {
        warning ("glyph " + glyphID + " must be covered in cursivePosFormat1"); }}
    for (int j = 0; j &lt; seen.length; j++) {
      if (! seen [j]) {
        warning ("glyph " + coverage.glyphs [j]
                 + " covered but has not entryExit in cursivePosFormat1"); }}
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_3'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);

  int o = stOffset + 6;
  for (int i = 0; i &lt; 2 * getuint16 (stOffset + 4); i++) {
    if (getOffset (o) != 0) {
      anchorTableToXMLCount (stOffset + getOffset (o), counts); }
    o += 2; }
</code-fragment>

<code-fragment id='gpos.toXML_3'>
    coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);

    int o = stOffset + 6;
    for (int i = 0; i &lt; 2 * getuint16 (stOffset + 4); i++) {
      if (getOffset (o) != 0) {
        anchorTableToXML (conf, stOffset + getOffset (o), counts); }
      o += 2; }
</code-fragment>

<code-fragment id='gpos.toXMLEmit_3'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int[] glyphs = getCoveredGlyphs (coverageOffset);

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, coverageOffset, counts, "coverage", at);

    int o = stOffset + 6;
    for (int i = 0; i &lt; getuint16 (stOffset + 4); i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA", "" + glyphs[i]);
      conf.ch.startElement ("entryExit", at); {
        if (getOffset (o) != 0) {
          anchorTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  "entry", new AttributesImpl ()); }
        o += 2;
        if (getOffset (o) != 0) {
          anchorTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  "exit", new AttributesImpl ()); }
        o += 2;
        conf.ch.endElement ("entryExit"); }}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos_3'>
  <code-title>Execute GPOS 3 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int firstPos = curGlyph;

    int firstCoverageIndex = getCoverageIndex (gr.glyphAt (firstPos), coverageOffset);
    if (firstCoverageIndex == -1) {
      return lookupNotApplied; }

    int secondPos = curGlyph + 1;
    int secondGlyphID = gr.glyphAt (secondPos);

    while (secondGlyphID != -1
           &amp;&amp; (   lookupFlagCovers (lookupFlag, secondGlyphID))) {
      secondPos++;
      secondGlyphID = gr.glyphAt (secondPos); }

    if (secondGlyphID == -1) {
      return lookupNotApplied; }

    int secondCoverageIndex = getCoverageIndex (secondGlyphID, coverageOffset);
    if (secondCoverageIndex == -1) {
      return lookupNotApplied; }

    int firstAnchorOffset
         = getOffset (stOffset + 6 + firstCoverageIndex * 4 + 2);
    int secondAnchorOffset
         = getOffset (stOffset + 6 + secondCoverageIndex * 4);

    if (firstAnchorOffset == 0 || secondAnchorOffset == 0) {
       return lookupNotApplied; }

    int[] newPos = mergeAnchors (gr,
                                 firstPos, stOffset + firstAnchorOffset,
                                 secondPos, stOffset + secondAnchorOffset);

    if (listener != null) {
      listener.move (newPos [0], newPos [1]);
      listener.applyingSubtable (lookupIndex, gr, firstPos, "GPOS", stOffset); }

    return new LookupResult (true, firstPos + 1, 0); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos3_font1: basic tests</title>

          <para>Here is a simple test to start with:</para>

<aots:test-font id='gpos3_font1'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='3'>
	<cursiveAttachment format='1'>
        <entryExit glyphID='18'>
          <entry format='1' x='100' y='150'/>
          <exit  format='1' x='200' y='250'/>
        </entryExit>
        <entryExit glyphID='19'>
          <entry format='1' x='101' y='151'/>
          <exit  format='1' x='201' y='251'/>
        </entryExit>
	</cursiveAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <para>After execution, occurrences glyph 19 will have been
            moved, to have its origin at (99, 99) relative to the
            origin of the new position of the occurrence of glyph 18:</para>

          <aots:gpos-test
	   id='gpos3_test1a'
	   font='gpos3_font1'
	   inputs= '17,   18,   19,   17'
	   xdeltas=' 0,    0,-1401,    0'
	   ydeltas=' 0,    0,   99,    0'/>

	  <para>Here, there is an intervening glyph, so nothing
            should move::</para>

          <aots:gpos-test
	   id='gpos3_test1b'
	   font='gpos3_font1'
	   inputs= '17,   18,   17,   19,   17'
	   xdeltas=' 0,    0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>
        </section>

	<section>
          <title>gpos3_font2: lookupFlag</title>

	  <para>Glyph 21 is captured by lookupFlag:</para>

<aots:test-font id='gpos3_font2'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='21'/>
    </glyphClassDef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='3'>
	<cursiveAttachment format='1'>
	  <entryExit glyphID='18'>
	    <entry format='1' x='100' y='150'/>
	    <exit  format='1' x='200' y='250'/>
	  </entryExit>
	  <entryExit glyphID='19'>
	    <entry format='1' x='101' y='151'/>
	    <exit  format='1' x='201' y='251'/>
	  </entryExit>
	</cursiveAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <para>After execution, occurrences glyph 19 will have been
            moved, to have its origin at (99, 99) relative to the
            origin of the new position of the occurrence of glyph 18:</para>

          <aots:gpos-test
	   id='gpos3_lookupflag_1'
	   font='gpos3_font2'
	   inputs= '17,   18,   21,    19,   17'
	   xdeltas=' 0,    0,    0, -2901,    0'
	   ydeltas=' 0,    0,    0,    99,    0'/>

          <aots:gpos-test
	   id='gpos3_lookupflag_2'
	   font='gpos3_font2'
	   inputs= '17,   18,   21,   21,   21,    19,   17'
	   xdeltas=' 0,    0,    0,    0,    0, -5901,    0'
	   ydeltas=' 0,    0,    0,    0,    0,    99,    0'/>
        </section>

	<section>
          <title>gpos3_font3: boundary cases</title>

	  <para>Here we have a glyphs that have only an entry or only
 	  an exit:</para>

<aots:test-font id='gpos3_font3'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format="any">
      <class classID='1' glyphs='21'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='3'>
	<cursiveAttachment format='1'>
        <entryExit glyphID='18'>
          <entry format='1' x='100' y='150'/>
          <exit  format='1' x='200' y='250'/>
        </entryExit>
        <entryExit glyphID='19'>
          <entry format='1' x='101' y='151'/>
        </entryExit>
        <entryExit glyphID='20'>
          <exit  format='1' x='202' y='252'/>
        </entryExit>
	</cursiveAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

	  <para>The sequences 18 18, 18 19, 20 18 and 20 19 should
  	    trigger the cursive attachment:</para>


          <aots:gpos-test
	   id='gpos3_test3a'
	   font='gpos3_font3'
	   inputs= '17,   18,    18,   17'
	   xdeltas=' 0,    0, -1400,    0'
	   ydeltas=' 0,    0,   100,    0'/>

          <aots:gpos-test
	   id='gpos3_test3b'
	   font='gpos3_font3'
	   inputs= '17,   18,    19,   17'
           xdeltas=' 0,    0, -1401,    0'
	   ydeltas=' 0,    0,    99,    0'/>

          <aots:gpos-test
	   id='gpos3_test3c'
	   font='gpos3_font3'
	   inputs= '17,   20,    18,   17'
           xdeltas=' 0,    0, -1398,    0'
	   ydeltas=' 0,    0,   102,    0'/>

          <aots:gpos-test
	   id='gpos3_test3d'
	   font='gpos3_font3'
	   inputs= '17,   20,    19,  17'
           xdeltas=' 0,    0, -1399,   0'
	   ydeltas=' 0,    0,   101,   0'/>

	  <para>But the sequences 18 20, 19 18 and 19 20 should not:</para>

          <aots:gpos-test
	   id='gpos3_test3e'
	   font='gpos3_font3'
	   inputs= '17,   18,   20,   17'
	   xdeltas=' 0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0'/>

          <aots:gpos-test
	   id='gpos3_test3f'
	   font='gpos3_font3'
	   inputs= '17,   19,   18,   17'
           xdeltas=' 0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0'/>

          <aots:gpos-test
	   id='gpos3_test3g'
	   font='gpos3_font3'
	   inputs= '17,   19,   20,   17'
           xdeltas=' 0,    0,    0,    0'
           ydeltas=' 0,    0,    0,    0'/>

	  <para>Another boundary case is when the glyph run contains
	  the first glyph, but not the second (with or without glyphs
	  ignored by LookupFlag):</para>

          <aots:gpos-test
	   id='gpos3_test3h'
	   font='gpos3_font3'
	   inputs= '17,   18'
	   xdeltas=' 0,    0'
	   ydeltas=' 0,    0'/>

          <aots:gpos-test
	   id='gpos3_test3i'
	   font='gpos3_font3'
	   inputs= '17,   18,   21,   21,   21'
	   xdeltas=' 0,    0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 4: MarkToBase Attachment Positioning Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The MarkToBase attachment (MarkBasePos) subtable is used
          to position combining mark glyphs with respect to base
          glyphs. For example, the Arabic, Hebrew, and Thai scripts
          combine vowels, diacritical marks, and tone marks with base
          glyphs.</para>

        <para>In the MarkBasePos subtable, every mark glyph has an
          anchor point and is associated with a class of marks. Each
          base glyph then defines an anchor point for each class of
          marks it uses.</para>

        <para>For example, assume two mark classes: all marks
          positioned above base glyphs (Class 0), and all marks
          positioned below base glyphs (Class 1). In this case, each
          base glyph that uses these marks would define two anchor
          points, one for attaching the mark glyphs listed in Class 0,
          and one for attaching the mark glyphs listed in Class
          1.</para>

        <para>To identify the base glyph that combines with a mark,
          the text-processing client must look backward in the glyph
          string from the mark to the preceding base glyph. To combine
          the mark and base glyph, the client aligns their attachment
          points, positioning the mark with respect to the final pen
          point (advance) position of the base glyph.</para>

        <para>The MarkToBase Attachment subtable has one format:
          MarkBasePosFormat1. The subtable begins with a format
          identifier (PosFormat) and offsets to two Coverage tables:
          one that lists all the mark glyphs referenced in the
          subtable (MarkCoverage), and one that lists all the base
          glyphs referenced in the subtable (BaseCoverage).</para>

        <para>For each mark glyph in the MarkCoverage table, a record
          specifies its class and an offset to the Anchor table that
          describes the mark's attachment point (MarkRecord). A mark
          class is identified by a specific integer, called a class
          value. ClassCount specifies the total number of distinct
          mark classes defined in all the MarkRecords.</para>

        <para>The MarkBasePosFormat1 subtable also contains an offset
          to a MarkArray table, which contains all the MarkRecords
          stored in an array (MarkRecord) by MarkCoverage Index. A
          MarkArray table also contains a count of the defined
          MarkRecords (MarkCount). (For details about MarkArrays and
          MarkRecords, see the end of this chapter.)</para>

        <para>The MarkBasePosFormat1 subtable also contains an offset
          to a BaseArray table (BaseArray).</para>

        <otformat>
          <title>MarkBasePosFormat1 subtable: MarkToBase attachment point</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013;format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MarkCoverage</otfieldname>
            <otfielddesc>Offset to MarkCoverage table &#x2013; from beginning
              of MarkBasePos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseCoverage</otfieldname>
            <otfielddesc>Offset to BaseCoverage table &#x2013; from beginning
              of MarkBasePos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassCount</otfieldname>
            <otfielddesc>Number of classes defined for
              marks</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MarkArray</otfieldname>
            <otfielddesc>Offset to MarkArray table &#x2013; from beginning of
              MarkBasePos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseArray</otfieldname>
            <otfielddesc>Offset to BaseArray table &#x2013; from beginning of
              MarkBasePos subtable</otfielddesc>
          </otfield>
        </otformat>

        <para>The BaseArray table consists of an array (BaseRecord)
          and count (BaseCount) of BaseRecords. The array stores the
          BaseRecords in the same order as the BaseCoverage Index.
          Each base glyph in the BaseCoverage table has a
          BaseRecord.</para>

        <otformat>
          <title>BaseArray table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BaseCount</otfieldname>
            <otfielddesc>Number of BaseRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>BaseRecord [BaseCount]</otfieldname>
            <otfielddesc>Array of BaseRecords &#x2013; in order of BaseCoverage
              Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A BaseRecord declares one Anchor table for each mark
          class (including Class 0) identified in the MarkRecords of
          the MarkArray. Each Anchor table specifies one attachment
          point used to attach all the marks in a particular class to
          the base glyph. A BaseRecord contains an array of offsets to
          Anchor tables (BaseAnchor). The zero-based array of offsets
          defines the entire set of attachment points each base glyph
          uses to attach marks. The offsets to Anchor tables are
          ordered by mark class.</para>

        <blockquote>
          <para>Note: Anchor tables are not tagged with class value
            identifiers. Instead, the index value of an Anchor table
            in the array defines the class value represented by the
            Anchor table.</para>
        </blockquote>

        <para>Example 7 at the end of this chapter defines mark
          positioning above and below base glyphs with a
          MarkBasePosFormat1 subtable.</para>

        <otformat>
          <title>BaseRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BaseAnchor [ClassCount]</otfieldname>
            <otfielddesc>Array of offsets (one per class) to Anchor
              tables &#x2013; from beginning of BaseArray table
	      &#x2013; ordered by class &#x2013; zero-based</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The 'text-processing' client refered to in the fourth
          paragraph is misleading. What is really meant here is "the
          virtual machine that executes the GPOS program".</para>

	<para>The pointer to the details of MarkArrays and MarkRecords
	  should be hyperlinked.</para>

        <para>It is important to realize that a MarkToBase subtable
          applies to the mark glyph, not to the base glyph; the
          subtable will apply at a position in a glyph run only if the
          glyph occurrence at that position is covered by the
          MarkCoverage.</para>

        <para>It is unclear whether the mark glyph must also be
          defined as a mark glyph in GlyphClassDef in
          <ottable>GDEF</ottable>. The specification of GDEF says that
          the GDEF is optional, and hints that its content can be
          recreated from the GSUB and GPOS tables. Doing so opens a
          can of worms: it seems that all the glyphs listed in
          MarkCoverage of a MarkToBase subtable should be made part of
          class 3, and that all the BaseCoverage glyphs should be made
          part of class 1 or 2; but what if a glyph appears in the
          MarkCoverage of one subtable and in the BaseCoverage of
          another? The safest road seems to impose the presence of a
          GDEF table (at least whenever there is a MarkToBase table),
          the presence of a GlyphClassDef in it, and the constraint
          that all the glyphs in MarkCoverage be in class 3.</para>

        <para>The same question applies to the glyphs listed in the
          BaseCoverage. Again, we suggest that those glyphs should be
          required to be in class 1 or 2 in GlyphClassDef.</para>

        <para>The determination of the base glyph needs to be
          elaborated a little bit. In this document, we assume that
          the following was intended:</para>

        <blockquote>
          <para>The base glyph occurrence which may combine with the
            mark glyph occurrence is the closest preceeding occurrence
            of a glyph which does not belong to class 3 under the
            <ottable>GDEF</ottable> GlyphClassDef. To determine the
            base glyph occurrence, the MarkCoverage and BaseCoverage
            are not used (it is possible that this subtable is
            concerned only with some pairs of base/mark glyphs; that
            should not affect the determination of the base glyph to
            which the mark applies). If there is no base
            glyph occurrence before the current position (because
            there the current position is the first one in the glyph
            run, or all the preceeding occurrences are of mark
            glyphs), the lookup subtable does not apply. Having so
            determined the base glyph, the lookup subtable applies
            only if that base glyph is covered by BaseCoverage;
            otherwise processing continues with the next subtable in
            the lookup.</para>
        </blockquote>

        <para>The change to the glyph run should also be elaborated a
          bit. In this document, we assume that the following was
          intended:</para>

        <blockquote>
          <para>When it has been determined that the subtable applies
            to a base glyph occurrence and a mark glyph occurrence, the
            position of mark glyph occurrence is changed so that the
            anchor point of the mark glyph occurrence coincides with
            the relevant anchor point of the base glyph occurrence
            (that is, the anchor point for the mark class to which the
            mark glyph belongs). The positions of the other glyphs
            (including the glyph occurrences between the base glyph
            occurrence and the mark glyph occurrence) are
            unchanged.</para>
        </blockquote>

        <para>It is worth noting that the adjustement to the position
          of the mark glyph occurrence is a one-time deal. In other
          words, the coincidence of the anchor points is established
          at the time the lookup subtable is applied, but is not
          necessarily preserved by other lookps applied after this
          one.</para>

        <para>The case of multiple mark glyphs on a single base glyphs
          could be noted:</para>

        <blockquote>
          <para>Note: Consider a typical case of Latin diacritics,
            where the combining accents are mark glyphs, the letters
            are base glyphs, and a MarkToBase lookup is coded to place
            the accents just above the letters. For simplicity, we
            assume that there is a single class of mark glyphs. If the
            glyph run contains multiple accents that applies to a
            single letter, the net effect of the MarkToBase lookup is to
            move all the accents such that the letter anchor and all
            accents anchors coincide; the accents will
            visually collide. Typically, the font will also contain a
            MarkToMark feature, which will then space apart the
            accents, to achieve the desired result.</para>
        </blockquote>

	<para>The pattern matched by this subtable is B (L|NB)*
	  &#x25B6; M &#x25C0;, where:
	  <itemizedlist>
	    <listitem>
	      <para>B is {x | x &#x2208; BaseCoverage &#x2227;
		GDEF.GlyphClassDef (x) &#x2260; 3} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>NB is {x | GDEF.GlyphClassDef (x) = 3}</para>
	    </listitem>
	    <listitem>
	      <para>M is MarkCoverage &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action is to move the glyph matched by M. More
	  precisely, if m is the glyph matched by M and b is the glyph
	  matched by B, then m is moved such that its anchor
	  MarkArray.MarkRecord[MarkCoverage [m]].MarkAnchor coincides
	  with the anchor BaseArray.BaseRecord [BaseCoverage
	  [b]].BaseAnchor [MarkArray.MarkRecord[m].Class] of b.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>Since the BaseArray.BaseRecord array has exactly one
	element for each glyph covered by BaseCoverage, we do not
	explicitly represent that coverage, but instead record the
	glyphID with the <sgmltag>baseGlyph</sgmltag>
	element. Similarlly the MarkCoverage is folded in the
	<sgmltag>markGlyph</sgmltag> elements.</para>

<code-fragment id='schema'>
  <code-title>markToBaseAttachementTable</code-title>
  markToBaseAttachmentTable |=
    attribute format { "1" },
    element baseGlyph {
      attribute glyphID { text },
      element baseAnchor {
        attribute class { text },
        anchorTableOffset
      }*
    }*,
    element markGlyphAnchor {
      attribute glyphID { text },
      attribute class { text },
      anchorTableOffset
    }*

  standaloneMarkToBaseAttachmentTable =
    element markToBaseAttachmentTable { attribute id { text }, markToBaseAttachmentTable }

  markToBaseAttachmentTableOffset = attribute name { text } | markToBaseAttachmentTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  private Block markBasePosFormat1FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    NodeList glyphs = subtable.getChildNodes ();

    java.util.SortedMap&lt;Integer, Element> baseGlyphs
         = new java.util.TreeMap&lt;Integer, Element> ();
    java.util.SortedMap&lt;Integer, Element> markGlyphs
         = new java.util.TreeMap&lt;Integer, Element> ();

    int classCount = 0;
    for (int i = 0; i &lt; glyphs.getLength (); i++) {
      Element glyph = (Element) glyphs.item (i);
      if ("baseGlyph".equals (glyph.getTagName ())) {
        baseGlyphs.put (parseOneGlyph (glyph.getAttribute ("glyphID")),
                        glyph); }
      else if ("markGlyphAnchor".equals (glyph.getTagName ())) {
        classCount = Math.max (classCount,
                             Integer.parseInt (glyph.getAttribute ("class")) + 1);
        markGlyphs.put (parseOneGlyph (glyph.getAttribute ("glyphID")),
                        glyph); }}

    int baseCount = baseGlyphs.size ();
    int markCount = markGlyphs.size ();


    Integer[] b;

    b = new Integer [baseCount];
    baseGlyphs.keySet ().toArray (b);
    CoverageTableBlock baseCoverage = coverageFromGlyphs (b);

    b = new Integer [markCount];
    markGlyphs.keySet ().toArray (b);
    CoverageTableBlock markCoverage = coverageFromGlyphs (b);


    Block markArray = new Block (2 + 4 * markCount, markCount);
    markArray.setuint16 (0, markCount);
    int offset = 2;
    for (Element glyph : markGlyphs.values ()) {
      markArray.setuint16 (offset, Integer.parseInt (glyph.getAttribute ("class")));
      markArray.setOffset (offset + 2,
                           anchorTableFromXML (glyph, table, blockCache));
      offset += 4; }

    Block baseArray = new Block (2 + 2 * baseCount * classCount,
                                 baseCount * classCount);
    baseArray.setuint16 (0, baseCount);
    offset = 2;
    for (Element glyph : baseGlyphs.values ()) {
      NodeList anchors = glyph.getChildNodes ();
      boolean[] seen = new boolean [classCount];
      for (int i = 0; i &lt; classCount; i++) {
        seen [i] = false; }
      for (int i = 0; i &lt; anchors.getLength (); i++) {
        Element anchor = (Element) anchors.item (i);
        int cl = Integer.parseInt (anchor.getAttribute ("class"));
        seen [cl] = true;
        baseArray.setOffset (offset + cl*2,
	                     anchorTableFromXML (anchor, table, blockCache)); }
      for (int i = 0; i &lt; classCount; i++) {
        if (! seen [i]) {
          baseArray.setOffset (offset + i*2, null); }}
      offset += classCount * 2; }

    me = new Block (12, 4);
    me.setuint16 (0, 1);
    me.setOffset (2, markCoverage);
    me.setOffset (4, baseCoverage);
    me.setuint16 (6, classCount);
    me.setOffset (8, markArray);
    me.setOffset (10, baseArray);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_4'>
  int classCount = getuint16 (stOffset + 6);

  int baseArrayOffset = stOffset + getOffset (stOffset + 10);
  int baseCount = getuint16 (baseArrayOffset);
  int o = baseArrayOffset + 2;

  for (int i = 0; i &lt; baseCount; i++) {
    for (int c = 0; c &lt; classCount; c++) {
      anchorTableToXMLCount (baseArrayOffset + getOffset (o), counts);
      o += 2; }}

  int markArrayOffset = stOffset + getOffset (stOffset + 8);
  int markCount = getuint16 (markArrayOffset);
  o = markArrayOffset + 2;
  for (int i = 0; i &lt; markCount; i++) {
    o += 2;
    anchorTableToXMLCount (markArrayOffset + getOffset (o), counts);
    o += 2; }
</code-fragment>

<code-fragment id='gpos.toXML_4'>
    int classCount = getuint16 (stOffset + 6);

    int baseArrayOffset = stOffset + getOffset (stOffset + 10);
    int baseCount = getuint16 (baseArrayOffset);
    int o = baseArrayOffset + 2;

    for (int i = 0; i &lt; baseCount; i++) {
      for (int c = 0; c &lt; classCount; c++) {
        anchorTableToXML (conf, baseArrayOffset + getOffset (o), counts);
        o += 2; }}

    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markCount = getuint16 (markArrayOffset);
    o = markArrayOffset + 2;
    for (int i = 0; i &lt; markCount; i++) {
      o += 2;
      anchorTableToXML (conf, markArrayOffset + getOffset (o), counts);
      o += 2; }
</code-fragment>

<code-fragment id='gpos.toXMLEmit_4'>
    int classCount = getuint16 (stOffset + 6);

    int[] baseGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 4));
    int baseArrayOffset = stOffset + getOffset (stOffset + 10);
    int baseCount = getuint16 (baseArrayOffset);
    int o = baseArrayOffset + 2;
    for (int i = 0; i &lt; baseCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                       glyphToXML (conf, baseGlyphs[i]));
      conf.ch.startElement ("baseGlyph", at); {
        for (int c = 0; c &lt; classCount; c++) {
          at = new AttributesImpl ();
          at.addAttribute ("", "class", "class", "CDATA", "" + c);
          anchorTableOffsetToXML (conf, baseArrayOffset + getOffset (o), counts,
                                  "baseAnchor", at);
          o += 2; }
        conf.ch.endElement ("baseGlyph"); }}


    int[] markGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));
    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markCount = getuint16 (markArrayOffset);
    o = markArrayOffset + 2;
    for (int i = 0; i &lt; markCount; i++) {
      int markClass = getuint16 (o);
      o += 2;
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                       glyphToXML (conf, markGlyphs[i]));
      at.addAttribute ("", "class", "class", "CDTA", "" + markClass);
      anchorTableOffsetToXML (conf, markArrayOffset + getOffset (o), counts,
                              "markGlyphAnchor", at);
      o += 2; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos_4'>
  <code-title>Execute GPOS 4 subtable and return</code-title>
  { int markCoverageOffset = stOffset + getOffset (stOffset + 2);
    int baseCoverageOffset = stOffset + getOffset (stOffset + 4);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), markCoverageOffset) == -1) {
      return lookupNotApplied; }

    int basePos = curGlyph - 1;
    int baseGlyphID = gr.glyphAt (basePos);

    while (baseGlyphID != -1
           &amp;&amp; (   lookupFlagCovers (lookupFlag, baseGlyphID)
               || (   font.gdef != null
                   &amp;&amp; font.gdef.getGlyphClass (baseGlyphID) == 3))) {
      basePos--;
      baseGlyphID = gr.glyphAt (basePos); }

    if (   baseGlyphID == -1
        || getCoverageIndex (baseGlyphID, baseCoverageOffset) == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, basePos, inPos)) {
      return lookupNotApplied; }


    int classCount = getuint16 (stOffset + 6);
    int markCoverageIndex = getCoverageIndex (gr.glyphAt (inPos),
                                              markCoverageOffset);
    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markRecordOffset = markArrayOffset + 2 + 4 * markCoverageIndex;
    int markClass = getuint16 (markRecordOffset);
    int markAnchorOffset = markArrayOffset + getOffset (markRecordOffset + 2);

    int baseCoverageIndex = getCoverageIndex (gr.glyphAt (basePos),
                                              baseCoverageOffset);
    int baseArrayOffset = stOffset + getOffset (stOffset + 10);
    int baseRecordOffset =
          baseArrayOffset + 2 + 2 * (classCount * baseCoverageIndex
                                              + markClass);
    int baseAnchorOffset = baseArrayOffset + getOffset (baseRecordOffset);

    int[] newPos = mergeAnchors (gr,
                                 basePos, baseAnchorOffset,
                                 inPos, markAnchorOffset);

    if (listener != null) {
      listener.move (newPos [0], newPos [1]);
      listener.applyingSubtable (lookupIndex, gr, inPos, "GPOS", stOffset); }

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos4_simple</title>

          <para>Here is a simple test to start with: glyphs 17 and 18
          are base glyphs; glyphs 19 and 20 are mark glyphs. 19
          attaches to 18, to have its origin at (-100, -80) relative
          to the origin of the new position of the occurrence of glyph
          18 serving as a base.</para>

<aots:test-font id='gpos4_simple_1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format="any">
      <class classID='1' glyphs='17:18'/>
      <class classID='3' glyphs='19:20'/>
    </glyphClassDef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='4'>
	<markToBaseAttachment format='1'>
	  <baseGlyph glyphID='18'>
	    <baseAnchor class='0' format='1' x='100' y='150'/>
	  </baseGlyph>
	  <markGlyphAnchor glyphID='19' class='0' format='1' x='200' y='230'/>
	</markToBaseAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <para>Let&#x2019;s see that in action:</para>

          <aots:gpos-test
	   id='gpos4_simple_1'
	   font='gpos4_simple_1'
	   inputs= '17,   18,    19,   17'
	   xdeltas=' 0,    0, -1600,    0'
	   ydeltas=' 0,    0,   -80,    0'/>

          <para>In this test, the base glyph for the mark is not covered:</para>

          <aots:gpos-test
	   id='gpos4_simple_2'
	   font='gpos4_simple_1'
	   inputs= '17,   17,   19,   17'
           xdeltas=' 0,    0,    0,    0'
           ydeltas=' 0,    0,    0,    0'/>

          <para>In this test, there is no base glyph at all:</para>

          <aots:gpos-test
	   id='gpos4_simple_3'
	   font='gpos4_simple_1'
           inputs= '25,   25,   19,   17'
           xdeltas=' 0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0'/>

          <para>Let&#x2019;s have two occurrences of 19 on the same
          base, they should both be moved.</para>

          <aots:gpos-test
	   id='gpos4_simple_4'
	   font='gpos4_simple_1'
	   inputs= '17,   18,    19,    19,  17'
           xdeltas=' 0,    0, -1600, -3100,   0'
	   ydeltas=' 0,    0,   -80,   -80,   0'/>

	  <para>There can also be occurrences of other mark glyphs
	  between the mark being processed and the base glyph:</para>

          <aots:gpos-test
	   id='gpos4_simple_5'
	   font='gpos4_simple_1'
	   inputs= '17,   18,   20,    19,   17'
	   xdeltas=' 0,    0,    0, -3100,    0'
	   ydeltas=' 0,    0,    0,   -80,    0'/>

        </section>

	<section>
	  <title>gpos4_lookupflag</title>

	  <para>The interesting case of lookup flags is when there are
	  intervening non-marks between the base and the mark being
	  processed. But if we skip those, then we must skip all base
	  characters, and therefore should never find one for the
	  mark! Of course, this implies that lookupFlag on this kind
	  of lookup is not too useful.</para>

<aots:test-font id='gpos4_lookupflag_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format="any">
      <class classID='1' glyphs='17:18'/>
      <class classID='3' glyphs='19:20'/>
    </glyphClassDef>
    <markAttachClassDef format="any">
      <class classID='1' glyphs='19'/>  <!-- e.g. above -->
      <class classID='2' glyphs='20'/>  <!-- e.g. below -->
    </markAttachClassDef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='4' ignoreBaseGlyphs='yes'>
	<markToBaseAttachment format='1'>
	  <baseGlyph glyphID='18'>
	    <baseAnchor class='0' format='1' x='100' y='150'/>
	  </baseGlyph>
	  <markGlyphAnchor glyphID='19' class='0' format='1' x='200' y='230'/>
	</markToBaseAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <para>Let&#x2019;s see that in action:</para>

          <aots:gpos-test
	   id='gpos4_lookupflag_t1'
	   font='gpos4_lookupflag_f1'
	   inputs= '17,   18,   17,   19,   17'
	   xdeltas=' 0,    0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>

	  <para>Actually, there is another degenerate case, i.e. when
	  a covered mark glyph is excluded by lookupFlag.</para>

<aots:test-font id='gpos4_lookupflag_f2'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format="any">
      <class classID='1' glyphs='17:18'/>
      <class classID='3' glyphs='19:20'/>
    </glyphClassDef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='4' ignoreMarks='yes'>
	<markToBaseAttachment format='1'>
	  <baseGlyph glyphID='18'>
	    <baseAnchor class='0' format='1' x='100' y='150'/>
	  </baseGlyph>
	  <markGlyphAnchor glyphID='19' class='0' format='1' x='200' y='230'/>
	</markToBaseAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos4_lookupflag_t2'
	   font='gpos4_lookupflag_f2'
	   inputs= '17,   18,   19,   17'
           xdeltas=' 0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0'/>
	</section>

        <section>
          <title>gpos4_multiple_anchors</title>

          <para>Here is a slightly more complicated case. 17 and 18
          are still base glyphs, 19 through 22 are mark glyphs. The
          base glyphs each define two anchors. 19 and 21 attach to the
          first anchor and 20 and 22 attach to the second
          anchor.</para>

<aots:test-font id='gpos4_multiple_anchors_1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='17:18'/>
      <class classID='3' glyphs='19:22'/>
    </glyphClassDef>
  </GDEF>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='4'>
	<markToBaseAttachment format='1'>
	  <baseGlyph glyphID='17'>
	    <baseAnchor class='0' format='1' x='100' y='150'/>
	    <baseAnchor class='1' format='1' x='110' y='160'/>
	  </baseGlyph>
	  <baseGlyph glyphID='18'>
	    <baseAnchor class='0' format='1' x='120' y='170'/>
	    <baseAnchor class='1' format='1' x='130' y='180'/>
	  </baseGlyph>
	  <markGlyphAnchor glyphID='19' class='0' format='1' x='200' y='230'/>
	  <markGlyphAnchor glyphID='20' class='1' format='1' x='201' y='231'/>
	  <markGlyphAnchor glyphID='21' class='0' format='1' x='202' y='232'/>
	  <markGlyphAnchor glyphID='22' class='1' format='1' x='203' y='233'/>
	</markToBaseAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos4_multiple_anchors_1'
	   font='gpos4_multiple_anchors_1'
	   inputs= '17,    19,    20,    21,    22,  18,    19,    20,    21,    22'
	   xdeltas=' 0, -1600, -3091, -4602, -6093,   0, -1580, -3071, -4582, -6073'	   ydeltas=' 0,   -80,   -71,   -82,   -73,   0,   -60,   -51,   -62,   -53'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 5: MarkToLigature Attachment Positioning
        Subtable</title>

      <!--____________________________________________________________________-->
            <section role='specification'>
        <title>Specification</title>

        <para>The MarkToLigature attachment (MarkLigPos) subtable is
          used to position combining mark glyphs with respect to
          ligature base glyphs. With MarkToBase attachment, described
          previously, a single base glyph defines an attachment point
          for each class of marks. In contrast, MarkToLigature
          attachment describes ligature glyphs composed of several
          components that can each define an attachment point for each
          class of marks.</para>

        <para>As a result, a ligature glyph may have multiple base
          attachment points for one class of marks. The specific
          attachment point for a mark is defined by the ligature
          component that the subtable associates with the mark.</para>

        <para>The MarkLigPos subtable can be used to define multiple
          mark-to-ligature attachments. In the subtable, every mark
          glyph has an anchor point and is associated with a class of
          marks. Every ligature glyph specifies a two-dimensional
          array of data: each component in a ligature defines an array
          of anchor points, one for each class of marks.</para>

        <para>For example, assume two mark classes: all marks
          positioned above base glyphs (Class 0), and all marks
          positioned below base glyphs (Class 1). In this case, each
          component of a base ligature glyph may define two anchor
          points, one for attaching the mark glyphs listed in Class 0,
          and one for attaching the mark glyphs listed in Class 1.
          Alternatively, if the language system does not allow marks
          on the second component, the first ligature component may
          define two anchor points, one for each class of marks, and
          the second ligature component may define no anchor
          points.</para>

        <para>To position a combining mark using a MarkToLigature
          attachment subtable, the text-processing client must work
          backward from the mark to the preceding ligature glyph. To
          correctly access the subtables, the client must keep track
          of the component associated with the mark. Aligning the
          attachment points combines the mark and ligature.</para>

        <para>The MarkToLigature attachment subtable has one format:
          MarkLigPosFormat1. The subtable begins with a format
          identifier (PosFormat) and offsets to two Coverage tables
          that list all the mark glyphs (MarkCoverage) and Ligature
          glyphs (LigatureCoverage) referenced in the subtable.</para>

        <para>For each glyph in the MarkCoverage table, a MarkRecord
          specifies its class and an offset to the Anchor table that
          describes the mark's attachment point. A mark class is
          identified by a specific integer, called a class value.
          ClassCount records the total number of distinct mark classes
          defined in all MarkRecords.</para>

        <para>The MarkLigPosFormat1 subtable contains an offset,
          measured from the beginning of the subtable, to a MarkArray
          table, which contains all MarkRecords stored in an array
          (MarkRecord) by MarkCoverage Index. (For details about
          MarkArrays and MarkRecords, see the end of this
          chapter.)</para>

        <para>The MarkLigPosFormat1 subtable also contains an offset
          to a LigatureArray table (LigatureArray).</para>


        <otformat>
          <title>MarkLigPosFormat1 subtable: MarkToLigature attachment</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MarkCoverage</otfieldname>
            <otfielddesc>Offset to Mark Coverage table &#x2013; from beginning
              of MarkLigPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigatureCoverage</otfieldname>
            <otfielddesc>Offset to Ligature Coverage table &#x2013; from
              beginning of MarkLigPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassCount</otfieldname>
            <otfielddesc>Number of defined mark classes</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MarkArray</otfieldname>
            <otfielddesc>Offset to MarkArray table &#x2013; from beginning of
              MarkLigPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigatureArray</otfieldname>
            <otfielddesc>Offset to LigatureArray table &#x2013; from beginning
              of MarkLigPos subtable</otfielddesc>
          </otfield>
        </otformat>

        <para>The LigatureArray table contains a count (LigatureCount)
          and an array of offsets (LigatureAttach) to LigatureAttach
          tables. The LigatureAttach array lists the offsets to</para>

        <para>LigatureAttach tables, one for each ligature glyph
          listed in the LigatureCoverage table, in the same order as
          the LigatureCoverage Index.</para>

        <otformat>
          <title>LigatureArray table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LigatureCount</otfieldname>
            <otfielddesc>Number of LigatureAttach table
              offsets</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigatureAttach [LigatureCount]</otfieldname>
            <otfielddesc>Array of offsets to LigatureAttach
              tables &#x2013; from beginning of LigatureArray table &#x2013; ordered by
              LigatureCoverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>Each LigatureAttach table consists of an array
          (ComponentRecord) and count (ComponentCount) of the
          component glyphs in a ligature. The array stores the
          ComponentRecords in the same order as the components in the
          ligature. The order of the records also corresponds to the
          writing direction of the text. For text written left to
          right, the first component is on the left; for text written
          right to left, the first component is on the right.</para>

        <otformat>
          <title>LigatureAttach table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ComponentCount</otfieldname>
            <otfielddesc>Number of ComponentRecords in this
              ligature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>ComponentRecord [ComponentCount]</otfieldname>
            <otfielddesc>Array of Component records &#x2013; ordered in writing
              direction</otfielddesc>
          </otfield>
        </otformat>

        <para>A ComponentRecord, one for each component in the
          ligature, contains an array of offsets to the Anchor tables
          that define all the attachment points used to attach marks
          to the component (LigatureAnchor). For each mark class
          (including Class 0) identified in the MarkArray records, an
          Anchor table specifies the point used to attach all the
          marks in a particular class to the ligature base glyph,
          relative to the component.</para>

        <para>In a ComponentRecord, the zero-based LigatureAnchor
          array lists offsets to Anchor tables by mark class. If a
          component does not define an attachment point for a
          particular class of marks, then the offset to the
          corresponding Anchor table will be NULL.</para>

        <para>Example 8 at the end of this chapter shows a
          MarkLisPosFormat1 subtable used to attach mark accents to a
          ligature glyph in the Arabic script.</para>

        <otformat>
          <title>ComponentRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigatureAnchor [ClassCount]</otfieldname>
            <otfielddesc>Array of offsets (one per class) to Anchor
            tables &#x2013; from beginning of LigatureAttach table
            &#x2013; ordered by class &#x2013; NULL if a component
            does not have an attachment for a class &#x2013;
            zero-based array</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The 'text-processing' client refered to in the fifth
          paragraph is misleading. What is really meant here is "the
          virtual machine that executes the GPOS program".</para>

        <para>It is important to realize that a MarkToLigature subtable
          applies to the mark glyph, not to the ligature glyph; the
          subtable will apply at a position in a glyph run only if the
          glyph occurrence at that position is covered by the
          MarkCoverage.</para>

        <para>It is unclear whether the mark glyph must also be
          defined as a mark glyph in GlyphClassDef in
          <ottable>GDEF</ottable>. The specification of GDEF says that
          the GDEF is optional, and hints that its content can be
          recreated from the GSUB and GPOS tables. Doing so opens a
          can of worms: it seems that all the glyphs listed in
          MarkCoverage of a MarkToLigature subtable should be made part of
          class 3, and that all the LigatureCoverage glyphs should be made
          part of class 1 or 2; but what if a glyph appears in the
          MarkCoverage of one subtable and in the LigatureCoverage of
          another? The safest road seems to impose the presence of a
          GDEF table (at least whenever there is a MarkToLigature table),
          the presence of a GlyphClassDef in it, and the constraint
          that all the glyphs in MarkCoverage be in class 3.</para>

        <para>The same question applies to the glyphs listed in the
          LigatureCoverage. Again, we suggest that those glyphs should be
          required to be in class 1 or 2 in GlyphClassDef.</para>

        <para>The determination of the ligature glyph needs to be
          elaborated a little bit. In this document, we assume that
          the following was intended:</para>

        <blockquote>
          <para>The ligature glyph occurrence which may combine with the
            mark glyph occurrence is the closest preceeding occurrence
            of a glyph which does not belong to class 3 under the
            <ottable>GDEF</ottable> GlyphClassDef. To determine the
            ligature glyph occurrence, the MarkCoverage and LigatureCoverage
            are not used (it is possible that this subtable is
            concerned only with some pairs of ligature/mark glyphs; that
            should not affect the determination of the ligature glyph to
            which the mark applies).
            If there is no ligature
            glyph occurrence before the current position (because
            there the current position is the first one in the glyph
            run, or all the preceeding occurrences are of mark
            glyphs), the lookup subtable does not apply. Having so
            determined the ligature glyph, the lookup subtable applies
            only if that ligature glyph is covered by LigatureCoverage;
            otherwise processing continues with the next subtable in
            the lookup.</para>
        </blockquote>

        <para>The change to the glyph run should also be elaborated a
          bit. In this document, we assume that the following was
          intended:</para>

        <blockquote>
          <para>When it has been determined that the subtable applies
            to a ligature glyph occurrence and a mark glyph occurrence, the
            position of mark glyph occurrence is changed so that the
            anchor point of the mark glyph occurrence coincides with
            the relevant anchor point of the ligature glyph occurrence
            (that is, the anchor point for the mark class to which the
            mark glyph belongs). The positions of the other glyphs
            (including the glyph occurrences between the ligature glyph
            occurrence and the mark glyph occurrence) are
            unchanged.</para>
        </blockquote>

        <para>It is worth noting that the adjustement to the position
          of the mark glyph occurrence is a one-time deal. In other
          words, the coincidence of the anchor points is established
          at the time the lookup subtable is applied, but is not
          necessarily preserved by other lookps applied after this
          one.</para>

        <para>The case of multiple mark glyphs on a single ligature glyphs
          could be noted:</para>

        <blockquote>
          <para>Note: Consider a typical case of Latin diacritics,
            where the combining accents are mark glyphs, the letters
            are ligature glyphs, and a MarkToLigature lookup is coded to place
            the accents just above the letters. For simplicity, we
            assume that there is a single class of mark glyphs. If the
            glyph run contains multiple accents that applies to a
            single letter, the net effect of the MarkToLigature lookup is to
            move all the accents such that the letter anchor and all
            accents anchors coincide; the accents will
            visually collide. Typically, the font will also contain a
            MarkToMark feature, which will then space apart the
            accents, to achieve the desired result.</para>
        </blockquote>

	<para>The pattern matched by this subtable is B (L|NB)*
	  &#x25B6; M &#x25C0;, where:
	  <itemizedlist>
	    <listitem>
	      <para>B is {x | x &#x2208; LigatureCoverage &#x2227;
		GDEF.GlyphClassDef (x) &#x2260; 3} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>NB is {x | GDEF.GlyphClassDef (x) = 3}</para>
	    </listitem>
	    <listitem>
	      <para>M is MarkCoverage &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action is to move the glyph matched by M. More
	  precisely, if m is the glyph matched by M, b is the glyph
	  matched by B and c is the ligature component to which the
	  mark should be attached, then m is moved such that its anchor
	  MarkArray.MarkRecord[MarkCoverage [m]].MarkAnchor coincides
	  with the anchor LigatureArray.LigatureAttach [LigatureCoverage
	  [b]].ComponentRecord [c].LigatureAnchor
	  [MarkArray.MarkRecord[m].Class] of b. It is up to the client
	  to determine to which component the mark should be attached.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>markToLigatureAttachementTable</code-title>
  markToLigatureAttachmentTable |=
    attribute format { "1" },
    element ligGlyph {
      attribute glyphID { text },
      element ligComponent {
        attribute comp { text },
        element ligAnchor {
          attribute class { text },
          anchorTableOffset
        }*
      }*
    }*,
    element markGlyphAnchor {
      attribute glyphID { text },
      attribute class { text },
      anchorTableOffset
    }*

  standaloneMarkToLigatureAttachmentTable =
    element markToLigatureAttachmentTable { attribute id { text }, markToLigatureAttachmentTable }

  markToLigatureAttachmentTableOffset = attribute name { text } | markToLigatureAttachmentTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  private Block markLigPosFormat1FromXML (Element subtable, Element table,
                                          Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    NodeList glyphs = subtable.getChildNodes ();

    java.util.SortedMap&lt;Integer, Element> ligGlyphs
          = new java.util.TreeMap&lt;Integer, Element> ();
    java.util.SortedMap&lt;Integer, Element> markGlyphs
          = new java.util.TreeMap&lt;Integer, Element> ();

    int classCount = 0;
    for (int i = 0; i &lt; glyphs.getLength (); i++) {
      Element glyph = (Element) glyphs.item (i);
      if ("ligGlyph".equals (glyph.getTagName ())) {
        ligGlyphs.put (Integer.parseInt (glyph.getAttribute ("glyphID")),
                       glyph); }
      else if ("markGlyphAnchor".equals (glyph.getTagName ())) {
        classCount = Math.max (classCount,
                             Integer.parseInt (glyph.getAttribute ("class")) + 1);
        markGlyphs.put (Integer.parseInt (glyph.getAttribute ("glyphID")),
                        glyph); }}

    int ligCount = ligGlyphs.size ();
    int markCount = markGlyphs.size ();

    Integer[] b;

    b = new Integer [ligCount];
    ligGlyphs.keySet ().toArray (b);
    CoverageTableBlock ligCoverage = coverageFromGlyphs (b);

    b = new Integer [markCount];
    markGlyphs.keySet ().toArray (b);
    CoverageTableBlock markCoverage = coverageFromGlyphs (b);


    Block markArray = new Block (2 + 4 * markCount, markCount);
    markArray.setuint16 (0, markCount);
    int offset = 2;
    for (Element glyph : markGlyphs.values ()) {
      markArray.setuint16 (offset, Integer.parseInt (glyph.getAttribute ("class")));
      markArray.setOffset (offset + 2,
                           anchorTableFromXML (glyph, table, blockCache));
      offset += 4; }


    Block ligArray = new Block (2 + 2 * ligCount, ligCount);
    ligArray.setuint16 (0, ligCount);
    offset = 2;
    for (Element glyph : ligGlyphs.values ()) {
      NodeList components = glyph.getChildNodes ();
      int n = components.getLength () * classCount;

      Block ligAttach = new Block (2 + 2*n, n);
      ligArray.setOffset (offset, ligAttach);
      offset += 2;

      ligAttach.setuint16 (0, components.getLength ());
      for (int i = 0; i &lt; n; i++) {
        ligAttach.setuint16 (2 + 2*i, 0); }

      for (int i = 0; i &lt; components.getLength (); i++) {
        Element component = (Element) components.item (i);
        int comp = Integer.parseInt (component.getAttribute ("comp"));
        NodeList anchors = component.getChildNodes ();
        for (int j = 0; j &lt; anchors.getLength (); j++) {
          Element anchor = (Element) anchors.item (j);
          int cl = Integer.parseInt (anchor.getAttribute ("class"));
          ligAttach.setOffset (2 + 2 * (comp * classCount + cl),
                               anchorTableFromXML (anchor, table, blockCache)); }}}

    me = new Block (12, 4);
    me.setuint16 (0, 1);
    me.setOffset (2, markCoverage);
    me.setOffset (4, ligCoverage);
    me.setuint16 (6, classCount);
    me.setOffset (8, markArray);
    me.setOffset (10, ligArray);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_5'>
  int classCount = getuint16 (stOffset + 6);

  int ligatureArrayOffset = stOffset + getOffset (stOffset + 10);
  int ligatureCount = getuint16 (ligatureArrayOffset);
  int o = ligatureArrayOffset + 2;

  for (int i = 0; i &lt; ligatureCount; i++) {
    int ligatureAttachOffset = ligatureArrayOffset + getOffset (o);
    o += 2;
    int componentCount = getuint16 (ligatureAttachOffset);
    int oo = ligatureAttachOffset + 2;
    for (int comp = 0; comp &lt; componentCount; comp++) {
      for (int c = 0; c &lt; classCount; c++) {
        anchorTableToXMLCount (ligatureAttachOffset + getOffset (oo), counts);
        oo += 2; }}}

  int markArrayOffset = stOffset + getOffset (stOffset + 8);
  int markCount = getuint16 (markArrayOffset);
  o = markArrayOffset + 2;
  for (int i = 0; i &lt; markCount; i++) {
    o += 2;
    anchorTableToXMLCount (markArrayOffset + getOffset (o), counts);
    o += 2; }
</code-fragment>

<code-fragment id='gpos.toXML_5'>
    int classCount = getuint16 (stOffset + 6);

    int ligatureArrayOffset = stOffset + getOffset (stOffset + 10);
    int ligatureCount = getuint16 (ligatureArrayOffset);
    int o = ligatureArrayOffset + 2;

    for (int i = 0; i &lt; ligatureCount; i++) {
      int ligatureAttachOffset = ligatureArrayOffset + getOffset (o);
      o += 2;
      int componentCount = getuint16 (ligatureAttachOffset);
      int oo = ligatureAttachOffset + 2;
      for (int comp = 0; comp &lt; componentCount; comp++) {
        for (int c = 0; c &lt; classCount; c++) {
          anchorTableToXML (conf, ligatureAttachOffset + getOffset (oo), counts);
          oo += 2; }}}

    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markCount = getuint16 (markArrayOffset);
    o = markArrayOffset + 2;
    for (int i = 0; i &lt; markCount; i++) {
      o += 2;
      anchorTableToXML (conf, markArrayOffset + getOffset (o), counts);
      o += 2; }
</code-fragment>

<code-fragment id='gpos.toXMLEmit_5'>
    int classCount = getuint16 (stOffset + 6);

    int[] ligatureGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 4));
    int ligatureArrayOffset = stOffset + getOffset (stOffset + 10);
    int ligatureCount = getuint16 (ligatureArrayOffset);
    int o = ligatureArrayOffset + 2;
    for (int i = 0; i &lt; ligatureCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA", "" + ligatureGlyphs[i]);
      conf.ch.startElement ("ligGlyph", at); {
        int ligatureAttachOffset = ligatureArrayOffset + getOffset (o);
        o += 2;
        int componentCount = getuint16 (ligatureAttachOffset);
        int oo = ligatureAttachOffset + 2;
        for (int comp = 0; comp &lt; componentCount; comp++) {
          at = new AttributesImpl ();
          at.addAttribute ("", "comp", "comp", "CDATA", "" + comp);
          conf.ch.startElement ("ligComponent", at); {
            for (int c = 0; c &lt; classCount; c++) {
              at = new AttributesImpl ();
              at.addAttribute ("", "class", "class", "CDATA", "" + c);
              anchorTableOffsetToXML (conf, ligatureAttachOffset + getOffset (oo),
                                      counts, "ligAnchor", at);
              oo += 2; }
            conf.ch.endElement ("ligComponent"); }}
        conf.ch.endElement ("ligGlyph"); }}


    int[] markGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));
    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markCount = getuint16 (markArrayOffset);
    o = markArrayOffset + 2;
    for (int i = 0; i &lt; markCount; i++) {
      int markClass = getuint16 (o);
      o += 2;
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA", "" + markGlyphs[i]);
      at.addAttribute ("", "class", "class", "CDTA", "" + markClass);
      anchorTableOffsetToXML (conf, markArrayOffset + getOffset (o), counts,
                              "markGlyphAnchor", at);
      o += 2; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos_5'>
  <code-title>Execute GPOS 5 subtable and return</code-title>
  { int markCoverageOffset = stOffset + getOffset (stOffset + 2);
    int ligCoverageOffset = stOffset + getOffset (stOffset + 4);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), markCoverageOffset) == -1) {
      return lookupNotApplied; }

    int ligPos = curGlyph - 1;
    int ligGlyphID = gr.glyphAt (ligPos);

    while (ligGlyphID != -1
           &amp;&amp; (   lookupFlagCovers (lookupFlag, ligGlyphID)
               || (   font.gdef != null
                   &amp;&amp; font.gdef.getGlyphClass (ligGlyphID) == 3))) {
      ligPos--;
      ligGlyphID = gr.glyphAt (ligPos); }

    if (   ligGlyphID == -1
        || getCoverageIndex (ligGlyphID, ligCoverageOffset) == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, ligPos, inPos)) {
      return lookupNotApplied; }


    int classCount = getuint16 (stOffset + 6);
    int markCoverageIndex = getCoverageIndex (gr.glyphAt (inPos),
                                              markCoverageOffset);
    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markRecordOffset = markArrayOffset + 2 + 4 * markCoverageIndex;
    int markClass = getuint16 (markRecordOffset);
    int markAnchorOffset = markArrayOffset + getOffset (markRecordOffset + 2);

    int ligCoverageIndex = getCoverageIndex (gr.glyphAt (ligPos),
                                              ligCoverageOffset);
    int ligArrayOffset = stOffset + getOffset (stOffset + 10);
    int ligAttachOffset = ligArrayOffset
          + getOffset (ligArrayOffset + 2+2*ligCoverageIndex);


    int compRecordOffset = ligAttachOffset + 2
             + 2 * (classCount * gr.getLigComponent (inPos) + markClass);
    int ligAnchorOffset = ligAttachOffset + getOffset (compRecordOffset);

    int[] newPos = mergeAnchors (gr,
                                 ligPos, ligAnchorOffset,
                                 inPos, markAnchorOffset);

    if (listener != null) {
      listener.move (newPos [0], newPos [1]);
      listener.applyingSubtable (lookupIndex, gr, inPos, "GPOS", stOffset); }

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos5_font1: basic tests</title>

          <para>Here is a simple test to start with:</para>

<aots:test-font id='gpos5_font1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='17'/>
      <class classID='2' glyphs='18'/>
      <class classID='3' glyphs='19'/>
      <class classID='3' glyphs='20'/>
    </glyphClassDef>
  </GDEF>

  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>

    <lookupList>
      <lookup id='lookup.test' type='4' ignoreMarks="yes">
        <ligatureSubst format='1'>
          <coverage glyphs='30' format='any'/>
          <subst in='30 31' out='18'/>
        </ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>

  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='5'>
	<markToLigatureAttachment format='1'>
	  <ligGlyph glyphID='18'>
	    <ligComponent comp='0'>
	      <ligAnchor class='0' format='1' x='100' y='150'/>
	    </ligComponent>
	    <ligComponent comp='1'>
	      <ligAnchor class='0' format='1' x='101' y='151'/>
	    </ligComponent>
	  </ligGlyph>
	  <markGlyphAnchor glyphID='19' class='0' format='1' x='200' y='230'/>
	</markToLigatureAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <para>After execution, glyphs 30 and 31 are ligated into glyph 18; glyph 19 is attached to the first ligature component of 18 in the first test, and to the second component in the second test:</para>

          <aots:gpos-test
	   id='gpos5_test1a'
	   font='gpos5_font1'
	   inputs= '17,   30,   19,   31,   17'

           outputs='17,   18,   19,   17'
           attach= '-1,   -1,    0,   -1'
	   xdeltas=' 0,    0,-1600,    0'
	   ydeltas=' 0,    0,  -80,    0'/>

          <aots:gpos-test
	   id='gpos5_test1b'
	   font='gpos5_font1'
	   inputs= '17,   30,   31,   19,  17'

           outputs='17,   18,   19,   17'
           attach= '-1,   -1,    1,   -1'
           xdeltas=' 0,    0,-1599,    0'
	   ydeltas=' 0,    0,  -79,    0'/>
<!--

          <para>In this test, the base glyph for the mark is not covered:</para>

          <aots:gpos-test id='gpos4_test1b'
	  font='gpos4_font1'
	  script='latn' language='UNKN' features='test'>
            inputs= '17   17    19 17'
            xdeltas='0    0     0  0'
            ydeltas='0    0     0  0'

          </aots:gpos-test>

          <para>In this test, there is no base glyph at all:</para>

          <aots:gpos-test id='gpos4_test1c'
	  font='gpos4_font1'
	  script='latn' language='UNKN' features='test'>
            inputs= '25   25    19 17'
            xdeltas='0    0     0  0'
            ydeltas='0    0     0  0'

          </

          <para>Let's have two occurrences of 19 on the same
          base:</para>

          <aots:gpos-test id='gpos4_test1d'
	  font='gpos4_font1'
	  script='latn' language='UNKN' features='test'>
            inputs= '17   18    19   19  17'
            xdeltas='0    0  -100 -100   0'
            ydeltas='0    0   -80  -80   0'

          </
        </section>

        <section>
          <title>gpos4_font2: multiple anchors</title>

          <para>Here is a simple test to start with:</para>

<aots:test-font id='gpos4_font2'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
  <glyphClassdef>
    <class classID='1' glyphs='17'/>
    <class classID='1' glyphs='18'/>
    <class classID='3' glyphs='19'/>
    <class classID='3' glyphs='20'/>
    <class classID='3' glyphs='21'/>
    <class classID='3' glyphs='22'/>
  </glyphClassdef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <markBasePos id="lookup.test">
    <markBasePosFormat1>
      <baseGlyph glyphID='17'>
        <baseAnchor class='0' x='100' y='150'/>
        <baseAnchor class='1' x='110' y='160'/>
      </baseGlyph>
      <baseGlyph glyphID='18'>
        <baseAnchor class='0' x='120' y='170'/>
        <baseAnchor class='1' x='130' y='180'/>
      </baseGlyph>
      <markGlyph glyphID='19' class='0' x='200' y='230'/>
      <markGlyph glyphID='20' class='1' x='201' y='231'/>
      <markGlyph glyphID='21' class='0' x='202' y='232'/>
      <markGlyph glyphID='22' class='1' x='203' y='233'/>
    </markBasePosFormat1>
  </markBasePos>
  </GPOS>
</aots:test-font>

          <aots:gpos-test id='gpos4_test2a'
	  font='gpos4_font2'
	  script='latn' language='UNKN' features='test'>
            inputs= '17   19  20   21  22 18  19  20  21  22'
            xdeltas='0 -100 -91 -102 -93  0 -80 -71 -82 -73'
            ydeltas='0  -80 -71  -82 -73  0 -60 -51 -62 -53'

          </

-->

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 6: MarkToMark Attachment Positioning
        Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The MarkToMark attachment (MarkMarkPos) subtable is
          identical in form to the MarkToBase attachment subtable,
          although its function is different. MarkToMark attachment
          defines the position of one mark relative to another mark as
          when, for example, positioning tone marks with respect to
          vowel diacritical marks in Vietnamese.</para>

        <para>The attaching mark is Mark1, and the base mark being
          attached to is Mark2. In the MarkMarkPos subtable, every
          Mark1 glyph has an anchor attachment point and is associated
          with a class of marks. Each Mark2 glyph defines an anchor
          point for each class of marks. For example, assume two Mark1
          classes: all marks positioned to the left of Mark2 glyphs
          (Class 0), and all marks positioned to the right of Mark2
          glyphs (Class 1). Each Mark2 glyph that uses these marks
          defines two anchor points: one for attaching the Mark1
          glyphs listed in Class 0, and one for attaching the Mark1
          glyphs listed in Class 1.</para>

	<para>The Mark2 glyph that combines with a Mark1 glyph is the
	  glyph preceding the Mark1 glyph in glyph string order
	  (skipping glyphs according to LookupFlag). The subtable
	  applies precisely when that Mark2 glyph is covered by
	  Mark2Coverage. To combine the mark glyphs, the Mark1 glyph
	  is moved such that the relevant attachment points
	  coincide. The input context for MarkToBase, MarkToLigature
	  and MarkToMark positioning tables is the mark that is being
	  positioned. If a sequence contains several marks, a lookup
	  may act on it several times, to position them.</para>

        <para>The MarkToMark attachment subtable has one format:
          MarkMarkPosFormat1. The subtable begins with a format
          identifier (PosFormat) and offsets to two Coverage tables:
          one that lists all the Mark1 glyphs referenced in the
          subtable (Mark1Coverage), and one that lists all the Mark2
          glyphs referenced in the subtable (Mark2Coverage).</para>

        <para>For each mark glyph in the Mark1Coverage table, a
          MarkRecord specifies its class and an offset to the Anchor
          table that describes the mark's attachment point. A mark
          class is identified by a specific integer, called a class
          value. (For details about classes, see the chapter, Common
          Table Formats.) ClassCount specifies the total number of
          distinct mark classes defined in all the MarkRecords.</para>

        <para>The MarkMarkPosFormat1 subtable also contains two
          offsets, measured from the beginning of the subtable, to two
          arrays:</para>

        <itemizedlist>
          <listitem>
            <para>The MarkArray table contains all MarkRecords stored
              by Mark1Coverage Index in an array (MarkRecord). The
              MarkArray table also contains a count of the number of
              defined MarkRecords (MarkCount).</para>
          </listitem>
          <listitem>
            <para>The Mark2Array table consists of an array
              (Mark2Record) and count (Mark2Count) of
              Mark2Records.</para>
          </listitem>
        </itemizedlist>

        <para>For details about MarkArrays and MarkRecords, see the
          end of this chapter.</para>


        <otformat>
          <title>MarkMarkPosFormat1 subtable: MarkToMark attachment</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Mark1Coverage</otfieldname>
            <otfielddesc>Offset to Combining Mark Coverage table-from
              beginning of MarkMarkPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Mark2Coverage</otfieldname>
            <otfielddesc>Offset to Base Mark Coverage table-from
              beginning of MarkMarkPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassCount</otfieldname>
            <otfielddesc>Number of Combining Mark classes
              defined</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Mark1Array</otfieldname>
            <otfielddesc>Offset to MarkArray table for Mark1-from
              beginning of MarkMarkPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Mark2Array</otfieldname>
            <otfielddesc>Offset to Mark2Array table for Mark2-from
              beginning of MarkMarkPos subtable</otfielddesc>
          </otfield>
        </otformat>

        <para>The Mark2Array, shown next, contains one Mark2Record for
          each Mark2 glyph listed in the Mark2Coverage table. It
          stores the records in the same order as the Mark2Coverage
          Index.</para>

        <otformat>
          <title>Mark2Array table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Mark2Count</otfieldname>
            <otfielddesc>Number of Mark2 records</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>Mark2Record [Mark2Count]</otfieldname>
            <otfielddesc>Array of Mark2 records-in Coverage
              order</otfielddesc>
          </otfield>
        </otformat>

        <para>Each Mark2Record contains an array of offsets to Anchor
          tables (Mark2Anchor). The array of zero-based offsets,
          measured from the beginning of the Mark2Array table, defines
          the entire set of Mark2 attachment points used to attach
          Mark1 glyphs to a specific Mark2 glyph. The Anchor tables in
          the Mark2Anchor array are ordered by Mark1 class
          value.</para>

        <para>A Mark2Record declares one Anchor table for each mark
          class (including Class 0) identified in the MarkRecords of
          the MarkArray. Each Anchor table specifies one Mark2
          attachment point used to attach all the Mark1 glyphs in a
          particular class to the Mark2 glyph.</para>

        <para>Example 9 at the end of the chapter shows a
          MarkMarkPosFormat1 subtable for attaching one mark to
          another in the Arabic script.</para>

        <otformat>
          <title>Mark2Record</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Mark2Anchor [ClassCount]</otfieldname>
            <otfielddesc>Array of offsets (one per class) to Anchor
              tables-from beginning of Mark2Array table-zero-based
              array</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>The annotation of the Mark2Record field should probably
	  be "... in Mark2Coverage order".</para>

	<para>The pattern matched by this subtable is M2 L* &#x25B6;
	  M1 &#x25C0;, where:
	  <itemizedlist>
	    <listitem>
	      <para>M2 is {x | x &#x2208; Mark2Coverage &#x2227;
		GDEF.GlyphClassDef (x) = 3} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>M1 is Mark1Coverage &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action is to move the glyph matched by M1. More
	  precisely, if m1 is the glyph matched by M1, m2 is the glyph
	  matched by M2, then m1 is moved such that its anchor
	  Mark1Array.MarkRecord [MarkCoverage [m]].MarkAnchor coincides
	  with the anchor Mark2Array.Mark2Record [Mark2Coverage
	  [m2]].Mark2Anchor [Mark1Array.MarkRecord[m].Class] of m2.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>markToMarkAttachmentTable</code-title>
  markToMarkAttachmentTable |=
    attribute format { "1" },
    element mark2Glyph {
      attribute glyphID { text },
      element mark2Anchor {
        attribute class { text },
        anchorTableOffset
      }*
    }*,
    element mark1GlyphAnchor {
      attribute glyphID { text },
      attribute class { text },
      anchorTableOffset
    }*

  standaloneMarkToMarkAttachmentTable =
    element markToMarkAttachmentTable { attribute id { text }, markToMarkAttachmentTable }

  markToMarkAttachmentTableOffset = attribute name { text } | markToMarkAttachmentTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  private Block markMarkPosFormat1FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = null;

    NodeList glyphs = subtable.getChildNodes ();

    java.util.SortedMap&lt;Integer, Element> mark2Glyphs
            = new java.util.TreeMap&lt;Integer, Element> ();
    java.util.SortedMap&lt;Integer, Element> markGlyphs
            = new java.util.TreeMap&lt;Integer, Element> ();

    int classCount = 0;
    for (int i = 0; i &lt; glyphs.getLength (); i++) {
      Element glyph = (Element) glyphs.item (i);
      if ("mark2Glyph".equals (glyph.getTagName ())) {
        mark2Glyphs.put (parseOneGlyph (glyph.getAttribute ("glyphID")),
                         glyph); }
      else if ("mark1GlyphAnchor".equals (glyph.getTagName ())) {
        classCount = Math.max (classCount,
                             Integer.parseInt (glyph.getAttribute ("class")) + 1);
        markGlyphs.put (parseOneGlyph (glyph.getAttribute ("glyphID")),
                        glyph); }}

    int mark2Count = mark2Glyphs.size ();
    int markCount = markGlyphs.size ();

    Integer[] b;

    b = new Integer [mark2Count];
    mark2Glyphs.keySet ().toArray (b);
    CoverageTableBlock mark2Coverage = coverageFromGlyphs (b);

    b = new Integer [markCount];
    markGlyphs.keySet ().toArray (b);
    CoverageTableBlock markCoverage = coverageFromGlyphs (b);


    Block markArray = new Block (2 + 4 * markCount, markCount);
    markArray.setuint16 (0, markCount);
    int offset = 2;
    for (Element glyph : markGlyphs.values ()) {
      markArray.setuint16 (offset, Integer.parseInt (glyph.getAttribute ("class")));
      markArray.setOffset (offset + 2,
                           anchorTableFromXML (glyph, table, blockCache));
      offset += 4; }

    Block mark2Array = new Block (2 + 2 * mark2Count * classCount,
                                  mark2Count * classCount);
    mark2Array.setuint16 (0, mark2Count);
    offset = 2;
    for (Element glyph : mark2Glyphs.values ()) {
      NodeList anchors = glyph.getChildNodes ();
      for (int i = 0; i &lt; anchors.getLength (); i++) {
        Element anchor = (Element) anchors.item (i);
        int cl = Integer.parseInt (anchor.getAttribute ("class"));
        mark2Array.setOffset (offset + cl*2,
                              anchorTableFromXML (anchor, table, blockCache)); }
      offset += classCount * 2; }

    me = new Block (12, 4);
    me.setuint16 (0, 1);
    me.setOffset (2, markCoverage);
    me.setOffset (4, mark2Coverage);
    me.setuint16 (6, classCount);
    me.setOffset (8, markArray);
    me.setOffset (10, mark2Array);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.toXMLCount_6'>
  int classCount = getuint16 (stOffset + 6);

  int mark2ArrayOffset = stOffset + getOffset (stOffset + 10);
  int mark2Count = getuint16 (mark2ArrayOffset);
  int o = mark2ArrayOffset + 2;

  for (int i = 0; i &lt; mark2Count; i++) {
    for (int c = 0; c &lt; classCount; c++) {
      anchorTableToXMLCount (mark2ArrayOffset + getOffset (o), counts);
      o += 2; }}

  int mark1ArrayOffset = stOffset + getOffset (stOffset + 8);
  int mark1Count = getuint16 (mark1ArrayOffset);
  o = mark1ArrayOffset + 2;
  for (int i = 0; i &lt; mark1Count; i++) {
    o += 2;
    anchorTableToXMLCount (mark1ArrayOffset + getOffset (o), counts);
    o += 2; }
</code-fragment>

<code-fragment id='gpos.toXML_6'>
    int classCount = getuint16 (stOffset + 6);

    int mark2ArrayOffset = stOffset + getOffset (stOffset + 10);
    int mark2Count = getuint16 (mark2ArrayOffset);
    int o = mark2ArrayOffset + 2;

    for (int i = 0; i &lt; mark2Count; i++) {
      for (int c = 0; c &lt; classCount; c++) {
        anchorTableToXML (conf, mark2ArrayOffset + getOffset (o), counts);
        o += 2; }}

    int mark1ArrayOffset = stOffset + getOffset (stOffset + 8);
    int mark1Count = getuint16 (mark1ArrayOffset);
    o = mark1ArrayOffset + 2;
    for (int i = 0; i &lt; mark1Count; i++) {
      o += 2;
      anchorTableToXML (conf, mark1ArrayOffset + getOffset (o), counts);
      o += 2; }
</code-fragment>

<code-fragment id='gpos.toXMLEmit_6'>
    int classCount = getuint16 (stOffset + 6);

    int[] mark2Glyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 4));
    int mark2ArrayOffset = stOffset + getOffset (stOffset + 10);
    int mark2Count = getuint16 (mark2ArrayOffset);
    int o = mark2ArrayOffset + 2;
    for (int i = 0; i &lt; mark2Count; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                       glyphToXML (conf, mark2Glyphs[i]));
      conf.ch.startElement ("mark2Glyph", at); {
        for (int c = 0; c &lt; classCount; c++) {
          at = new AttributesImpl ();
          at.addAttribute ("", "class", "class", "CDATA", "" + c);
          anchorTableOffsetToXML (conf, mark2ArrayOffset + getOffset (o), counts,
                                  "mark2Anchor", at);
          o += 2; }
        conf.ch.endElement ("mark2Glyph"); }}


    int[] mark1Glyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));
    int mark1ArrayOffset = stOffset + getOffset (stOffset + 8);
    int mark1Count = getuint16 (mark1ArrayOffset);
    o = mark1ArrayOffset + 2;
    for (int i = 0; i &lt; mark1Count; i++) {
      int mark1Class = getuint16 (o);
      o += 2;
      at = new AttributesImpl ();
      at.addAttribute ("", "glyphID", "glyphID", "CDATA",
                       glyphToXML (conf, mark1Glyphs[i]));
      at.addAttribute ("", "class", "class", "CDTA", "" + mark1Class);
      anchorTableOffsetToXML (conf, mark1ArrayOffset + getOffset (o), counts,
                              "mark1GlyphAnchor", at);
      o += 2; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos_6'>
  <code-title>Execute GPOS 6 subtable and return</code-title>
  { int markCoverageOffset = stOffset + getOffset (stOffset + 2);
    int mark2CoverageOffset = stOffset + getOffset (stOffset + 4);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), markCoverageOffset) == -1) {
      return lookupNotApplied; }

    int mark2Pos = curGlyph - 1;
    int mark2GlyphID = gr.glyphAt (mark2Pos);

    while (mark2GlyphID != -1
           &amp;&amp; (   lookupFlagCovers (lookupFlag, mark2GlyphID))) {
      mark2Pos--;
      mark2GlyphID = gr.glyphAt (mark2Pos); }

    if (   mark2GlyphID == -1
        || getCoverageIndex (mark2GlyphID, mark2CoverageOffset) == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, mark2Pos, inPos)) {
      return lookupNotApplied; }

    int classCount = getuint16 (stOffset + 6);
    int markCoverageIndex = getCoverageIndex (gr.glyphAt (inPos),
                                              markCoverageOffset);
    int markArrayOffset = stOffset + getOffset (stOffset + 8);
    int markRecordOffset = markArrayOffset + 2 + 4 * markCoverageIndex;
    int markClass = getuint16 (markRecordOffset);
    int markAnchorOffset = markArrayOffset + getOffset (markRecordOffset + 2);

    int mark2CoverageIndex = getCoverageIndex (gr.glyphAt (mark2Pos),
                                              mark2CoverageOffset);
    int mark2ArrayOffset = stOffset + getOffset (stOffset + 10);
    int mark2RecordOffset =
          mark2ArrayOffset + 2 + 2 * (classCount * mark2CoverageIndex
                                              + markClass);
    int mark2AnchorOffset = mark2ArrayOffset + getOffset (mark2RecordOffset);

    int[] newPos = mergeAnchors (gr,
                                 mark2Pos, mark2AnchorOffset,
                                 inPos, markAnchorOffset);

    if (listener != null) {
      listener.move (newPos [0], newPos [1]);
      listener.applyingSubtable (lookupIndex, gr, inPos, "GPOS", stOffset); }

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos6_font1: basic tests</title>

          <para>Here is a simple test to start with:</para>

<aots:test-font id='gpos6_font1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='17'/>
      <class classID='3' glyphs='18'/>
      <class classID='3' glyphs='19'/>
      <class classID='3' glyphs='20'/>
    </glyphClassDef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='6'>
	<markToMarkAttachment  format='1'>
	  <mark2Glyph glyphID='18'>
	    <mark2Anchor class='0' format='1' x='100' y='150'/>
	  </mark2Glyph>
	  <mark1GlyphAnchor glyphID='19' class='0' format='1' x='200' y='230'/>
	</markToMarkAttachment>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>

          <para>After execution, occurrences glyph 19 will have been
            moved, to have its origin at (-100, -80) relative to the
            origin of the new position of the occurrence of glyph 18
            serving as a base:</para>

          <aots:gpos-test
	   id='gpos6_test1a'
	   font='gpos6_font1'
	   inputs= '17,   18,    19,   17'
	   xdeltas=' 0,    0, -1600,    0'
	   ydeltas=' 0,    0,   -80,    0'/>

          <para>In this test, the base glyph for the mark is not covered:</para>

          <aots:gpos-test
	   id='gpos6_test1b'
	   font='gpos6_font1'
	   inputs= '17,   17,   19,   17'
	   xdeltas=' 0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0'/>

          <para>In this test, there is no base glyph at all:</para>

          <aots:gpos-test
	   id='gpos6_test1c'
	   font='gpos6_font1'
	   inputs= '20,   20,   19,   17'
           xdeltas=' 0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0'/>

<!--
          <para>Let's have two occurrences of 19 on the same
          base:</para>

          <aots:gpos-test id='gpos6_test1d'
	  font='gpos6_font1'
	  script='latn' language='UNKN' features='test'>
            inputs= '17   18    19   19  17'
            xdeltas='0    0  -100 -100   0'
            ydeltas='0    0   -80  -80   0'

          </
-->
        </section>
<!--
        <section>
          <title>gpos6_font2: multiple anchors</title>

          <para>Here is a simple test to start with:</para>

<aots:test-font id='gpos6_font2'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
  <glyphClassdef>
    <class classID='3' glyphs='17'/>
    <class classID='3' glyphs='18'/>
    <class classID='3' glyphs='19'/>
    <class classID='3' glyphs='20'/>
    <class classID='3' glyphs='21'/>
    <class classID='3' glyphs='22'/>
  </glyphClassdef>
  </GDEF>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>
    <markMarkPos id="lookup.test">
    <markMarkPosFormat1>
      <mark2Glyph glyphID='17'>
        <mark2Anchor class='0' x='100' y='150'/>
        <mark2Anchor class='1' x='110' y='160'/>
      </mark2Glyph>
      <mark2Glyph glyphID='18'>
        <mark2Anchor class='0' x='120' y='170'/>
        <mark2Anchor class='1' x='130' y='180'/>
      </mark2Glyph>
      <markGlyph glyphID='19' class='0' x='200' y='230'/>
      <markGlyph glyphID='20' class='1' x='201' y='231'/>
      <markGlyph glyphID='21' class='0' x='202' y='232'/>
      <markGlyph glyphID='22' class='1' x='203' y='233'/>
    </markMarkPosFormat1>
  </markMarkPos>
  </GPOS>
</aots:test-font>

          <aots:gpos-test id='gpos6_test2a'
	  font='gpos6_font2'
	  script='latn' language='UNKN' features='test'>
            inputs= '17   19  20   21  22 18  19  20  21  22'
            xdeltas='0 -100 -91 -102 -93  0 -80 -71 -82 -73'
            ydeltas='0  -80 -71  -82 -73  0 -60 -51 -62 -53'

          </


        </section>
-->
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 7: Contextual Positioning Subtables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Contextual Positioning (ContextPos) subtable defines
          the most powerful type of glyph positioning lookup. It
          describes glyph positioning in context so a text-processing
          client can adjust the position of one or more glyphs within
          a certain pattern of glyphs. Each subtable describes one or
          more "input" glyph sequences and one or more positioning
          operations to be performed on that sequence.</para>

        <para>ContextPos subtables can have one of three formats,
          which closely mirror the formats used for contextual glyph
          substitution. One format applies to specific glyph sequences
          (Format 1), one defines the context in terms of glyph
          classes (Format 2), and the third format defines the context
          in terms of sets of glyphs (Format 3).</para>

        <para>All ContextPos subtables specify positioning data in a
          PosLookupRecord. A description of that record follows.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>See GSUB</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>PosLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All contextual positioning subtables specify the
          positioning data in a PosLookupRecord. Each record contains
          a SequenceIndex, which indicates where the positioning
          operation will occur in the glyph sequence. In addition, a
          LookupListIndex identifies the lookup to be applied at the
          glyph position specified by the SequenceIndex.</para>

        <para>The order in which lookups are applied to the entire
          glyph sequence, called the "design order," can be
          significant, so PosLookupRecord data should be defined
          accordingly.</para>

        <para>The contextual substitution subtables defined in
          Examples 10, 11, and 12 show PosLookupRecords.</para>

        <otformat>
          <title>PosLookupRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SequenceIndex</otfieldname>
            <otfielddesc>Index to input glyph sequence-first glyph =
              0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupListIndex</otfieldname>
            <otfielddesc>Lookup to apply to that
              position-zero-based</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Context Positioning Subtable: Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 1 defines the context for a glyph positioning
          operation as a particular sequence of glyphs. For example, a
          context could be &lt;To>, &lt;xyzabc>, &lt;!?*#@>, or any
          other glyph sequence.</para>

        <para>Within the context, Format 1 identifies particular glyph
          positions (not glyph indices) as the targets for specific
          adjustments. When a text-processing client locates a context
          in a string of text, it makes the adjustment by applying the
          lookup data defined for a targeted position at that
          location.</para>

        <para>For example, suppose that accent mark glyphs above
          lowercase x-height vowel glyphs must be lowered when an
          overhanging capital letter glyph precedes the vowel. When
          the client locates this context in the text, the subtable
          identifies the position of the accent mark and a lookup
          index. A lookup specifies a positioning action that lowers
          the accent mark over the vowel so that it does not collide
          with the overhanging capital.</para>

        <para>ContextPosFormat1 defines the context in two places. A
          Coverage table specifies the first glyph in the input
          sequence, and a PosRule table identifies the remaining
          glyphs. To describe the context used in the previous
          example, the Coverage table lists the glyph index of the
          first component of the sequence (the overhanging capital),
          and a PosRule table defines indices for the lowercase
          x-height vowel glyph and the accent mark.</para>

        <para>A single ContextPosFormat1 subtable may define more than
          one context glyph sequence. If different context sequences
          begin with the same glyph, then the Coverage table should
          list the glyph only once because all first glyphs in the
          table must be unique. For example, if three contexts each
          start with an "s" and two start with a "t," then the
          Coverage table will list one "s" and one "t."</para>

        <para>For each context, a PosRule table lists all the glyphs,
          in order, that follow the first glyph. The table also
          contains an array of PosLookupRecords that specify the
          positioning lookup data for each glyph position (including
          the first glyph position) in the context.</para>

        <para>All the PosRule tables defining contexts that begin with
          the same first glyph are grouped together and defined in a
          PosRuleSet table. For example, the PosRule tables that
          define the three contexts that begin with an "s" are grouped
          in one PosRuleSet table, and the PosRule tables that define
          the two contexts that begin with a "t" are grouped in a
          second PosRuleSet table. Each unique glyph listed in the
          Coverage table must have a PosRuleSet table that defines all
          the PosRule tables for a covered glyph.</para>

        <para>To locate a context glyph sequence, the text-processing
          client searches the Coverage table each time it encounters a
          new text glyph. If the glyph is covered, the client reads
          the corresponding PosRuleSet table and examines each PosRule
          table in the set to determine whether the rest of the
          context defined there matches the subsequent glyphs in the
          text. If the context and text string match, the client finds
          the target glyph position, applies the lookup for that
          position, and completes the positioning action.</para>

        <para>A ContextPosFormat1 subtable contains a format
          identifier (PosFormat), an offset to a Coverage table
          (Coverage), a count of the number of PosRuleSets that are
          defined (PosRuleSetCount), and an array of offsets to the
          PosRuleSet tables (PosRuleSet). As mentioned, one PosRuleSet
          table must be defined for each glyph listed in the Coverage
          table.</para>

        <para>In the PosRuleSet array, the PosRuleSet tables are
          ordered in the Coverage Index order. The first PosRuleSet in
          the array applies to the first GlyphID listed in the
          Coverage table, the second PosRuleSet in the array applies
          to the second GlyphID listed in the Coverage table, and so
          on.</para>

        <otformat>
          <title>ContextPosFormat1 subtable: Simple context positioning</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table-from beginning of
              ContextPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosRuleSetCount</otfieldname>
            <otfielddesc>Number of PosRuleSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>PosRuleSet [PosRuleSetCount]</otfieldname>
            <otfielddesc>Array of offsets to PosRuleSet tables-from
              beginning of ContextPos subtable-ordered by Coverage
              Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A PosRuleSet table consists of an array of offsets to
          PosRule tables (PosRule), ordered by preference, and a count
          of the PosRule tables defined in the set
          (PosRuleCount).</para>

        <otformat>
          <title>PosRuleSet table: All contexts beginning with the
            same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosRuleCount</otfieldname>
            <otfielddesc>Number of PosRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>PosRule [PosRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to PosRule tables-from
              beginning of PosRuleSet-ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

        <para>A PosRule table consists of a count of the glyphs to be
          matched in the input context sequence (GlyphCount),
          including the first glyph in the sequence, and an array of
          glyph indices that describe the context (Input). The
          Coverage table specifies the index of the first glyph in the
          context, and the Input array begins with the second glyph in
          the context sequence. As a result, the first index position
          in the array is specified with the number one (1), not zero
          (0). The Input array lists the indices in the order the
          corresponding glyphs appear in the text. For text written
          from right to left, the right-most glyph will be first;
          conversely, for text written from left to right, the
          left-most glyph will be first.</para>

        <para>A PosRule table also contains a count of the positioning
          operations to be performed on the input glyph sequence
          (PosCount) and an array of PosLookupRecords
          (PosLookupRecord). Each record specifies a position in the
          input glyph sequence and a LookupList index to the
          positioning lookup to be applied there. The array should
          list records in design order, or the order the lookups
          should be applied to the entire glyph sequence.</para>

        <para>Example 10 at the end of this chapter demonstrates glyph
          kerning in context with a ContextPosFormat1 subtable.</para>

        <otformat>
          <title>PosRule subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the Input glyph
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosCount</otfieldname>
            <otfielddesc>Number of PosLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Input [GlyphCount-1]</otfieldname>
            <otfielddesc>Array of input GlyphIDs-starting with the
              second glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PosLookupRecord [PosCount]</otfieldname>
            <otfielddesc>Array of positioning lookups-in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>


	<para>The pattern matched by the PosRule table t = PosRuleSet
	  [m].PosRule [n] is &#x25B6;
	  I<subscript>0</subscript> L* I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is t.GlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]}
	      &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is {t.Input [k-1]}
	      &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A PosRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>gpos7_1_font1: simple case</title>

          <para>Let's start with a simple test that matches the sequence 18,
            19, 20. At each position, we then apply a LookupType 1
            which increases xPosition of the glyph by 100. </para>

<aots:test-font id="gpos7_1_font1">
  <base-font name="base.otf"/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id='lookup.single' type='1'>
	<singlePos format='2'>
	  <value glyph='18' xPlacement='100'/>
	  <value glyph='19' xPlacement='200'/>
	  <value glyph='20' xPlacement='300'/>
	</singlePos>
      </lookup>

      <lookup id='lookup.test' type='7'>
	<contextual format='1'>
	  <coverage glyphs='18' format='any'/>
	  <pattern in='18 19 20'>
	    <apply pos='0' lookup='lookup.single'/>
	    <apply pos='1' lookup='lookup.single'/>
	    <apply pos='2' lookup='lookup.single'/>
	  </pattern>
	</contextual>
      </lookup>
    </lookupList>
  </GPOS>
</aots:test-font>


          <aots:gpos-test
	   id='gpos7_1_test1a'
	   font='gpos7_1_font1'
	   inputs= '17,   18,   19,   20,   21'
	   xdeltas=' 0,  100,  200,  300,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>

          <para>Here is a test case on the same font that involves incomplete
            matches of input sequence:</para>

          <aots:gpos-test
	   id='gpos7_1_test1b'
	   font='gpos7_1_font1'
	   inputs= '17,   18,   17,   18,   19,   17'
	   xdeltas=' 0,    0,    0,    0,    0,    0'
	   ydeltas=' 0,    0,    0,    0,    0,    0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Context Positioning Subtable: Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 2, more flexible than Format 1, describes
          class-based context positioning. For this format, a specific
          integer, called a class value, must be assigned to each
          glyph in all context glyph sequences. Contexts are then
          defined as sequences of class values. This subtable may
          define more than one context.</para>

        <para>To clarify the notion of class-based context rules,
          suppose that certain sequences of three glyphs need special
          kerning. The glyph sequences consist of an uppercase glyph
          that overhangs on the right side, a punctuation mark glyph,
          and then a quote glyph. In this case, the set of uppercase
          glyphs would constitute one glyph class (Class1), the set of
          punctuation mark glyphs would constitute a second glyph
          class (Class 2), and the set of quote mark glyphs would
          constitute a third glyph class (Class 3). The input context
          might be specified with a context rule (PosClassRule) that
          describes "the set of glyph strings that form a sequence of
          three glyph classes, one glyph from Class 1, followed by one
          glyph from Class 2, followed by one glyph from Class
          3."</para>

        <para>Each ContextPosFormat2 subtable contains an offset to a
          class definition table (ClassDef), which defines the class
          values of all glyphs in the input contexts that the subtable
          describes. Generally, a unique ClassDef will be declared in
          each instance of the ContextPosFormat2 subtable that is
          included in a font, even though several Format 2 subtables
          may share ClassDef tables. Classes are exclusive sets; a
          glyph cannot be in more than one class at a time. The output
          glyphs that replace the glyphs in the context sequence do
          not need class values because they are specified elsewhere
          by GlyphID.</para>

        <para>The ContextPosFormat2 subtable also contains a format
          identifier (PosFormat) and defines an offset to a Coverage
          table (Coverage). For this format, the Coverage table lists
          indices for the complete set of glyphs (not glyph classes)
          that may appear as the first glyph of any class-based
          context. In other words, the Coverage table contains the
          list of glyph indices for all the glyphs in all classes that
          may be first in any of the context class sequences. For
          example, if the contexts begin with a Class 1 or Class 2
          glyph, then the Coverage table will list the indices of all
          Class 1 and Class 2 glyphs.</para>

        <para>A ContextPosFormat2 subtable also defines an array of
          offsets to the PosClassSet tables (PosClassSet), along with
          a count (including Class0) of the PosClassSet tables
          (PosClassSetCnt). In the array, the PosClassSet tables are
          ordered by ascending class value (from 0 to PosClassSetCnt -
          1).</para>

        <para>A PosClassSet array contains one offset for each glyph
          class, including Class 0. PosClassSets are not explicitly
          tagged with a class value; rather, the index value of the
          PosClassSet in the PosClassSet array defines the class that
          a PosClassSet represents.</para>

        <para>For example, the first PosClassSet listed in the array
          contains all the PosClassRules that define contexts
          beginning with Class 0 glyphs, the second PosClassSet
          contains all PosClassRules that define contexts beginning
          with Class 1 glyphs, and so on. If no PosClassRules begin
          with a particular class (that is, if a PosClassSet contains
          no PosClassRules), then the offset to that particular
          PosClassSet in the PosClassSet array will be set to
          NULL.</para>


        <otformat>
          <title>ContextPosFormat2 subtable: Class-based context glyph positioning</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table-from beginning of
              ContextPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ClassDef</otfieldname>
            <otfielddesc>Offset to ClassDef table-from beginning of
              ContextPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosClassSetCnt</otfieldname>
            <otfielddesc>Number of PosClassSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>PosClassSet [PosClassSetCnt]</otfieldname>
            <otfielddesc>Array of offsets to PosClassSet tables-from
              beginning of ContextPos subtable-ordered by class-may be
              NULL</otfielddesc>
          </otfield>
        </otformat>

        <para>All the PosClassRules that define contexts beginning
          with the same class are grouped together and defined in a
          PosClassSet table. Consequently, the PosClassSet table
          identifies the class of a context's first component.</para>

        <para>A PosClassSet enumerates all the PosClassRules that
          begin with a particular glyph class. For instance,
          PosClassSet0 represents all the PosClassRules that describe
          contexts starting with Class 0 glyphs, and PosClassSet1
          represents all the PosClassRules that define contexts
          starting with Class 1 glyphs.</para>

        <para>Each PosClassSet table consists of a count of the
          PosClassRules defined in the PosClassSet (PosClassRuleCnt)
          and an array of offsets to PosClassRule tables
          (PosClassRule). The PosClassRule tables are ordered by
          preference in the PosClassRule array of the
          PosClassSet.</para>

        <otformat>
          <title>PosClassSet table: All contexts beginning with the same class</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosClassRuleCnt</otfieldname>
            <otfielddesc>Number of PosClassRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>PosClassRule [PosClassRuleCnt]</otfieldname>
            <otfielddesc>Array of offsets to PosClassRule tables-from
              beginning of PosClassSet-ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

        <para>For each context, a PosClassRule table contains a count
          of the glyph classes in a given context (GlyphCount),
          including the first class in the context sequence. A class
          array lists the classes, beginning with the second class,
          that follow the first class in the context. The first class
          listed indicates the second position in the context
          sequence.</para>

        <blockquote>
          <para>Note: Text order depends on the writing direction of
            the text. For text written from right to left, the
            right-most glyph will be first. Conversely, for text
            written from left to right, the left-most glyph will be
            first.</para>
        </blockquote>

        <para>The values specified in the Class array are those
          defined in the ClassDef table. For example, consider a
          context consisting of the sequence: Class 2, Class 7, Class
          5, Class 0. The Class array will read: Class[0] = 7,
          Class[1] = 5, and Class[2] = 0. The first class in the
          sequence, Class 2, is defined by the index into the
          PosClassSet array of offsets. The total number and sequence
          of glyph classes listed in the Class array must match the
          total number and sequence of glyph classes contained in the
          input context.</para>

        <para>A PosClassRule also contains a count of the positioning
          operations to be performed on the context (PosCount) and an
          array of PosLookupRecords (PosLookupRecord) that supply the
          positioning data. For each position in the context that
          requires a positioning operation, a PosLookupRecord
          specifies a LookupList index and a position in the input
          glyph class sequence where the lookup is applied. The
          PosLookupRecord array lists PosLookupRecords in design
          order, or the order in which lookups are applied to the
          entire glyph sequence.</para>

        <para>Example 11 at the end of this chapter demonstrates a
          ContextPosFormat2 subtable that uses glyph classes to modify
          accent positions in glyph strings.</para>

        <otformat>
          <title>PosClassRule table: One class context definition</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs to be matched</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosCount</otfieldname>
            <otfielddesc>Number of PosLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class [GlyphCount-1]</otfieldname>
            <otfielddesc>Array of classes-beginning with the second
              class-to be matched to the input glyph
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PosLookupRecord [PosCount]</otfieldname>
            <otfielddesc>Array of positioning lookups-in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>The pattern matched by the PosClassRule table t = PosClassSet
	  [m].PosClassRule [n] is
	  &#x25B6; I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is t.GlyphCount</para>
	    </listitem>

	    <listitem>
	      <para>I<subscript>0</subscript> is (Coverage &#x2229;
	      ClassDef [m]) &#x2216; LookupFlag</para>
	    </listitem>

	    <listitem>
	      <para>I<subscript>k</subscript> is ClassDef [t.Class
	      [k-1]] &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubClassRule table does not directly modify the glyph
	run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>See GSUB</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Context Positioning Subtable: Format 3</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 3, coverage-based context positioning, defines a
          context rule as a sequence of coverages. Each position in
          the sequence may specify a different Coverage table for the
          set of glyphs that matches the context pattern. With Format
          3, the glyph sets defined in the different Coverage tables
          may intersect, unlike Format 2 which specifies fixed class
          assignments for the lookup (they cannot be changed at each
          position in the context sequence) and exclusive classes (a
          glyph cannot be in more than one class at a time).</para>

        <para>For example, consider an input context that contains an
          uppercase glyph (position 0), followed by any narrow
          uppercase glyph (position 1), and then another uppercase
          glyph (position 2). This context requires three Coverage
          tables, one for each position:</para>

        <itemizedlist>
          <listitem>
            <para>In position 0, the first position, the Coverage
              table lists the set of all uppercase glyphs.</para>
          </listitem>
          <listitem>
            <para>In position 1, the second position, the Coverage
              table lists the set of all narrow uppercase glyphs,
              which is a subset of the glyphs listed in the Coverage
              table for position 0. </para>
          </listitem>
          <listitem>
            <para>In position 2, the Coverage table lists the set of
              all uppercase glyphs again.</para>
          </listitem>
        </itemizedlist>

        <para>Note: Both position 0 and position 2 can use the same
          Coverage table.</para>

        <para>Unlike Formats 1 and 2, this format defines only one
          context rule at a time. It consists of a format identifier
          (PosFormat), a count of the number of glyphs in the sequence
          to be matched (GlyphCount), and an array of Coverage offsets
          that describe the input context sequence (Coverage).</para>

        <para>Note: The Coverage tables listed in the Coverage array
          must be listed in text order according to the writing
          direction. For text written from right to left, the
          right-most glyph will be first. Conversely, for text written
          from left to right, the left-most glyph will be
          first.</para>

        <para>The subtable also contains a count of the positioning
          operations to be performed on the input Coverage sequence
          (PosCount) and an array of PosLookupRecords
          (PosLookupRecord) in design order, or the order in which
          lookups are applied to the entire glyph sequence.</para>

        <para>Example 12 at the end of this chapter changes the
          positions of math sign glyphs in math equations with a
          ContextPosFormat3 subtable.</para>

        <otformat>
          <title>ContextPosFormat3 subtable: Coverage-based context glyph positioning</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the input
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosCount</otfieldname>
            <otfielddesc>Number of PosLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [GlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to Coverage tables-from
              beginning of ContextPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+2n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PosLookupRecord [PosCount]</otfieldname>
            <otfielddesc>Array of positioning lookups-in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>The pattern matched by this subtable is &#x25B6;
	  I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is GlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>i</subscript> is
		Coverage [i] &#x2216; LookupFlag.</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>

      </section>
      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 8: Chaining Contextual Positioning Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Chaining Contextual Positioning
          subtable(ChainContextPos)describes glyph positioning in
          context with an ability to look back and/or look ahead in
          the sequence of glyphs. The design of the Chaining
          Contextual Positioning subtable is parallel to that of the
          Contextual Positioning subtable, including the availability
          of three formats.</para>

        <para>To specify the context, the coverage table lists the
          first glyph in the input sequence, and the ChainPosRule
          subtable defines the rest. Once a covered glyph is found at
          position i, the client reads the corresponding
          ChainPosRuleSet table and examines each table to determine
          if it matches the surrounding glyphs in the text. There is a
          match if the string &lt;backtrack sequence>+&lt;input
          sequence>+&lt;input sequence>+&lt;lookahead sequence> matches
          with the glyphs at position i - BacktrackGlyphCount in the
          text.</para>

        <para>If there is a match, then the client finds the target
          glyphs for positioning and performs the operations. Please
          note that (just like in the ContextPosFormat1 subtable)
          these lookups are required to operate within the range of
          text from the covered glyph to the end of the input
          sequence. No positioning operations can be defined for the
          backtracking sequence or the lookahead sequence.</para>

	<para>To clarify the ordering of glyph arrays for input,
	  backtrack and lookahead sequences, the following
	  illustration is provided. Input sequence match begins at i
	  where the input sequence match begins. The backtrack
	  sequence is ordered beginning at i-1 and increases in offset
	  value as one moves away from i. The lookahead sequence
	  begins after the input sequence and increases in logical
	  order.</para>

<literallayout>
Logical order        a   b   c   d   e   f   g   h   i   j
                                     i
Input sequence                       0   1
Backtrack sequence   3   2   1   0
Lookahead sequence                           0   1   2   3
</literallayout>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>In all three formats, the sequences are represented by
	  arrays. The order in those arrays is <emphasis>away from the
	  current position</emphasis>. In other words, if
	  <emphasis>i</emphasis> is the current position, then the
	  first element of the backtrack array is matched against the
	  glyph at position <emphasis>i-1</emphasis> (ignoring glyphs
	  covered by LookupFlag, as usual), and the last element of
	  the backtrack array is matched against the glyph at position
	  <emphasis>i - BacktrackGlyphCount</emphasis>. The first
	  element of the lookahead array is matched against the glyph
	  at position <emphasis>i + InputGlyphCount</emphasis>, and
	  the last element in that array is matched against the glyph
	  as position <emphasis>i + InputGlyphCount +
	  LookaheadGlyphCount - 1</emphasis>.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Chaining Context Positioning Format 1: Simple Chaining
        Context Glyph Positioning</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This Format is identical to Format 1 of Context
          Positioning lookup except that the PosRule table is replaced
          with a ChainPosRule table. (Correspondingly, the
          ChainPosRuleSet table differs from the PosRuleSet table only
          in that it lists offsets to ChainPosRule subtables instead
          of PosRule tables; and the ChainContextPosFormat1 subtable
          lists offsets to ChainPosRuleSet subtables instead of
          PosRuleSet subtables.)</para>

        <otformat>
          <title>ChainContextPosFormat1 subtable: Simple context
            positioning</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table-from beginning of
              ContextPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainPosRuleSetCount</otfieldname>
            <otfielddesc>Number of ChainPosRuleSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainPosRuleSet [ChainPosRuleSetCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainPosRuleSet tables-from
              beginning of ContextPos subtable-ordered by Coverage
              Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A ChainPosRuleSet table consists of an array of offsets
          to ChainPosRule tables (ChainPosRule), ordered by
          preference, and a count of the ChainPosRule tables defined
          in the set (ChainPosRuleCount).</para>

        <otformat>
          <title>ChainPosRuleSet table: All contexts beginning with
            the same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainPosRuleCount</otfieldname>
            <otfielddesc>Number of ChainPosRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainPosRule [ChainPosRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainPosRule tables-from
              beginning of ChainPosRuleSet-ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>ChainPosRule subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the backtrack
              sequence (number of glyphs to be matched before the
              first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Backtrack [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of backtracking GlyphID's (to be
              matched before the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the input sequence
              (includes the first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Input [InputGlyphCount-1]</otfieldname>
            <otfielddesc>Array of input GlyphIDs (start with second
              glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the look ahead
              sequence (number of glyphs to be matched after the input
              sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>LookAhead [LookAheadGlyphCount]</otfieldname>
            <otfielddesc>Array of lookahead GlyphID's (to be matched
              after the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosCount</otfieldname>
            <otfielddesc>Number of PosLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PosLookupRecord [PosCount]</otfieldname>
            <otfielddesc>Array of PosLookupRecords (in design
              order)</otfielddesc>
          </otfield>
        </otformat>
      </section>

       <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>The pattern matched by the ChainPosRule table t = ChainPosRuleSet
	  [m].ChainPosRule [n] is

	  B<subscript>b-1</subscript> L* ... L* B<subscript>0</subscript>
          &#x25B6; I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;
          L* A<subscript>0</subscript> L*
	  ... L* A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is t.BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is t.InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is t.LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is {t.Backtrack [k]} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is {t.Input[k-1]} &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is {t.LookAhead[k]} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current
	  position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

     <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Chaining Context Positioning Format 2: Class-based
        Chaining Context Glyph Positioning</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This lookup Format is parallel to the Context
          Positioning format 2, with PosClassSet subtable changed to
          ChainPosClassSet subtable, and PosClassRule subtable changed
          to ChainPosClassRule subtable.</para>

        <para>To chain contexts, three classes are used in the glyph
          ClassDef table: Backtrack ClassDef, Input ClassDef, and
          Lookahead ClassDef.</para>


        <otformat>
          <title>ChainContextPosFormat2 subtable: Chaining class-based context glyph positioning</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table-from beginning of
              ChainContextPos subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BacktrackClassDef</otfieldname>
            <otfielddesc>Offset to ClassDef table containing backtrack
              sequence context-from beginning of ChainContextPos
              subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>InputClassDef</otfieldname>
            <otfielddesc>Offset to ClassDef table containing input
              sequence context-from beginning of ChainContextPos
              subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookaheadClassDef</otfieldname>
            <otfielddesc>Offset to ClassDef table containing lookahead
              sequence context-from beginning of ChainContextPos
              subtable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainPosClassSetCnt</otfieldname>
            <otfielddesc>Number of ChainPosClassSet
              tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainPosClassSet [ChainPosClassSetCnt]</otfieldname>
            <otfielddesc>Array of offsets to ChainPosClassSet
              tables-from beginning of ChainContextPos
              subtable-ordered by input class-may be
              NULL</otfielddesc>
          </otfield>
        </otformat>

        <para>All the ChainPosClassRules that define contexts
          beginning with the same class are grouped together and
          defined in a ChainPosClassSet table. Consequently, the
          ChainPosClassSet table identifies the class of a context's
          first component.</para>


        <otformat>
          <title>ChainPosClassSet table: All contexts beginning with the same class</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainPosClassRuleCnt</otfieldname>
            <otfielddesc>Number of ChainPosClassRule
              tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainPosClassRule [ChainPosClassRuleCnt]</otfieldname>
            <otfielddesc>Array of offsets to ChainPosClassRule
              tables-from beginning of ChainPosClassSet-ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>ChainPosClassRule subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the backtrack
              sequence (number of glyphs to be matched before the
              first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Backtrack [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of backtracking classes(to be matched
              before the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Total number of classes in the input sequence
              (includes the first class)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Input [InputGlyphCount-1]</otfieldname>
            <otfielddesc>Array of input classes(start with second
              class; to be matched with the input glyph
              sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Total number of classes in the look ahead
              sequence (number of classes to be matched after the
              input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookAhead [LookAheadGlyphCount]</otfieldname>
            <otfielddesc>Array of lookahead classes(to be matched
              after the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosCount</otfieldname>
            <otfielddesc>Number of PosLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PosLookupRecord [ChainPosCount]</otfieldname>
            <otfielddesc>Array of PosLookupRecords (in design
              order)</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>The pattern matched by the ChainPosClassRule table t = ChainPosClassSet [m].ChainPosRule [n] is

	  B<subscript>b-1</subscript> L* ... L* B<subscript>0</subscript>
          &#x25B6; I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;
          L* A<subscript>0</subscript> L*
	  ... L* A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is t.BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is t.InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is t.LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is BacktrackClassDef
	      [t.Backtrack [k]] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is (Coverage &#x2229;
	      InputClassDef [m]) &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is InputClassDef
	      [t.Input [k-1]] &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is LookAheadClassDef
	      [t.LookAhead [k]] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current
	  position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

        <para>See GSUB.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Chaining Context Positioning Format 3: Coverage-based Chaining
        Context Glyph Positioning</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 3 defines a chaining context rule as a sequence
          of Coverage tables. Each position in the sequence may define
          a different Coverage table for the set of glyphs that
          matches the context pattern. With Format 3, the glyph sets
          defined in the different Coverage tables may intersect,
          unlike Format 2 which specifies fixed class assignments
          (identical for each position in the backtrack, input, or
          lookahead sequence) and exclusive classes (a glyph cannot be
          in more than one class at a time).</para>

        <blockquote>
          <para>Note: The order of the Coverage tables listed in the
            Coverage array must follow the writing direction. For text
            written from right to left, then the right-most glyph will
            be first. Conversely, for text written from left to right,
            the left-most glyph will be first.</para>
        </blockquote>

        <para>The subtable also contains a count of the positioning
          operations to be performed on the input Coverage sequence
          (PosCount) and an array of PosLookupRecords
          (PosLookupRecord) in design order: that is, the order in
          which lookups should be applied to the entire glyph
          sequence.</para>

          <otformat>
            <title>ChainContextPosFormat3 subtable: Coverage-based chaining context glyph positioning</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier-format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the backtracking
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in
              backtracking sequence, in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in input
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [InputGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in input
              sequence, in glyph sequence order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in lookahead
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [LookaheadGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in
              lookahead sequence, in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>PosCount</otfieldname>
            <otfielddesc>Number of PosLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2+p+2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>PosLookupRecord [PosCount]</otfieldname>
            <otfielddesc>Array of PosLookupRecords, in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>It is probably worth noting that InputGlyphCount should
          be non-zero, and that BacktrackGlyphCount and
          LookaheadGlyphCount can be zero.</para>

        <para>It is unclear whether the PosCount can be 0. At first
          it seems that such a subtable is not interesting, since it
          does nothing. On the other hand, this could be useful to
          prevent the activation of following subtables. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The three fields that hold arrays of offsets to
	  coverages have the same name. We assume that their names are
	  Backtrack, Input and Lookahead.</para>

	<para>The pattern matched by this subtable is
          B<subscript>b-1</subscript> L* ... L*
          B<subscript>0</subscript> L* &#x25B6;
	  I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;
          L* A<subscript>0</subscript> L* ... L*
          A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is Backtrack
	      [k] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is
		Input [k] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is Lookahead
	      [k] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 9: Extension Positioning</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This lookup provides a mechanism whereby any other
          lookup type's subtables are stored at a 32-bit offset
          location in the <ottable>GPOS</ottable> table. This is
          needed if the total size of the subtables exceeds the 16-bit
          limits of the various other offsets in the
          <ottable>GPOS</ottable> table. In this specification, the
          subtable stored at the 32-bit offset location is termed the
          "extension" subtable.</para>

        <otformat>
          <title>ExtensionPosFormat1 subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>PosFormat</otfieldname>
            <otfielddesc>Format identifier. Set to 1.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>ExtensionLookupType</otfieldname>
            <otfielddesc>Lookup type of subtable referenced by
              ExtensionOffset (i.e. the extension
              subtable).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ExtensionOffset</otfieldname>
            <otfielddesc>Offset to the extension subtable, of lookup
              type ExtensionLookupType, relative to the start of the
              ExtensionPosFormat1 subtable.</otfielddesc>
          </otfield>
        </otformat>

        <para>ExtensionLookupType must be set to any lookup type other
          than 9. All subtables in a LookupType 9 lookup must have the
          same ExtensionLookupType. All offsets in the extension
          subtables are set in the usual way, i.e. relative to the
          extension subtables themselves</para>

        <para>When an OpenType layout engine encounters a LookupType 9
          Lookup table, it shall:</para>

        <itemizedlist>
          <listitem>
            <para>Proceed as though the Lookup table's LookupType
              field were set to the ExtensionLookupType of the
              subtables.</para>
          </listitem>
          <listitem>
            <para>Proceed as though each extension subtable referenced
              by ExtensionOffset replaced the LookupType 9 subtable
              that referenced it.</para>
          </listitem>
        </itemizedlist>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>This subtable does not match a pattern by itself, nor
	  does it have an action by itself.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

	<para>See GSUB</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gpos9_font1: basic tests</title>

          <para>In this series, we have a simple adjustment of one of
            the Value fields.</para>

          <para>Our first test adjusts the xPlacement of glyphs 18 and 20 by
            -200.</para>

<aots:test-font id='gpos9_font1'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='9'>
	<extensionPos format='1'>
	  <ext type='1' name='singlepos'/>
	</extensionPos>
      </lookup>
    </lookupList>

    <singlePosTable id='singlepos' format='1'>
      <coverage glyphs='18 20' format='any'/>
      <value xPlacement='-200'/>
    </singlePosTable>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos9_test1'
	   font='gpos9_font1'
	   inputs= '17,   18,   19,   20,   21'
	   xdeltas=' 0, -200,    0, -200,    0'
	   ydeltas=' 0,    0,    0,    0,    0'/>

	  <para>Let&#x2019;s have multiple subtables.</para>

<aots:test-font id='gpos9_font2'>
  <base-font name='base.otf'/>
  <GPOS major='1' minor='0'>
    <code-include linkend='testfonts.gpos.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='9'>
	<extensionPos format='1'>
	  <ext type='1' name='singlepos'/>
	</extensionPos>
	<extensionPos format='1'>
	  <ext type='1' name='singlepos2'/>
	</extensionPos>
      </lookup>
    </lookupList>

    <singlePosTable id='singlepos' format='1'>
      <coverage glyphs='18 20' format='any'/>
      <value xPlacement='-200'/>
    </singlePosTable>

    <singlePosTable id='singlepos2' format='1'>
      <coverage glyphs='19 21' format='any'/>
      <value xPlacement='-300'/>
    </singlePosTable>
  </GPOS>
</aots:test-font>

          <aots:gpos-test
	   id='gpos9_test2'
	   font='gpos9_font2'
	   inputs= '17,   18,   19,   20,   21,   17'
	   xdeltas=' 0, -200, -300, -200, -300,    0'
	   ydeltas=' 0,    0,    0,    0,    0,    0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Shared Tables: ValueRecord, Anchor Table, and MarkArray</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Several lookup subtables described earlier in this
          chapter refer to one or more of the same tables for
          positioning data: ValueRecord, Anchor table, and MarkArray.
          For easy reference, those shared tables are described
          here.</para>

        <para>Example 14 at the end of the chapter uses a ValueFormat
          table and ValueRecord to specify positioning values in
          <ottable>GPOS</ottable>.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>ValueRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para><ottable>GPOS</ottable> subtables use ValueRecords to
          describe all the variables and values used to adjust the
          position of a glyph or set of glyphs. A ValueRecord may
          define any combination of X and Y values (in design units)
          to add to (positive values) or subtract from (negative
          values) the placement and advance values provided in the
          font. A ValueRecord also may contain an offset to a Device
          table for each of the specified values. If a ValueRecord
          specifies more than one value, the values should be listed
          in the order shown in the ValueRecord definition.</para>

        <para>The text-processing client must be aware of the flexible
          and multi-dimensional nature of ValueRecords in the
          <ottable>GPOS</ottable> table. Because the
          <ottable>GPOS</ottable> table uses ValueRecords for many
          purposes, the sizes and contents of ValueRecords may vary
          from subtable to subtable.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>XPlacement</otfieldname>
            <otfielddesc>Horizontal adjustment for placement-in design
                  units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>YPlacement</otfieldname>
            <otfielddesc>Vertical adjustment for placement-in design
                  units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>XAdvance</otfieldname>
            <otfielddesc>Horizontal adjustment for advance-in design
                  units (only used for horizontal writing)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>YAdvance</otfieldname>
            <otfielddesc>Vertical adjustment for advance-in design units
                  (only used for vertical writing)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>XPlaDevice</otfieldname>
            <otfielddesc>Offset to Device table for horizontal
                  placement-measured from beginning of PosTable (may
                  be NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>YPlaDevice</otfieldname>
            <otfielddesc>Offset to Device table for vertical
                  placement-measured from beginning of PosTable (may
                  be NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>XAdvDevice</otfieldname>
            <otfielddesc>Offset to Device table for horizontal
                  advance-measured from beginning of PosTable (may be
                  NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>YAdvDevice</otfieldname>
            <otfielddesc>Offset to Device table for vertical
                  advance-measured from beginning of PosTable (may be
                  NULL)</otfielddesc>
          </otfield>
        </otformat>

        <para>A data format (ValueFormat), usually declared at the
          beginning of each <ottable>GPOS</ottable> subtable, defines
          the types of positioning adjustment data that ValueRecords
          specify. Usually, the same ValueFormat applies to every
          ValueRecord defined in the particular
          <ottable>GPOS</ottable> subtable.</para>

        <para>The ValueFormat determines whether the
          ValueRecords:</para>

        <itemizedlist>
          <listitem>
            <para>Apply to placement, advance, or both.</para>
          </listitem>
          <listitem>
            <para>Apply to the horizontal position (X coordinate), the
              vertical position (Y coordinate), or both.</para>
          </listitem>
          <listitem>
            <para>May refer to one or more Device tables for any of
              the specified values.</para>
          </listitem>
        </itemizedlist>

        <para>Each one-bit in the ValueFormat corresponds to a field
          in the ValueRecord and increases the size of the ValueRecord
          by 2 bytes. A ValueFormat of 0x0000 corresponds to an empty
          ValueRecord, which indicates no positioning changes.</para>

        <para>To identify the fields in each ValueRecord, the
          ValueFormat uses the bit settings shown below. To specify
          multiple fields with a ValueFormat, the bit settings of the
          relevant fields are added with a logical OR
          operation.</para>

        <para>For example, to adjust the left-side bearing of a glyph,
          the ValueFormat will be 0x0001, and the ValueRecord will
          define the XPlacement value. To adjust the advance width of
          a different glyph, the ValueFormat will be 0x0004, and the
          ValueRecord will describe the XAdvance value. To adjust both
          the XPlacement and XAdvance of a set of glyphs, the
          ValueFormat will be 0x0005, and the ValueRecord will specify
          both values in the order they are listed in the ValueRecord
          definition.</para>

        <table>
          <title>ValueFormat bit enumeration (indicates which fields
            are present)</title>
          <tgroup cols='3'>
            <colspec colwidth="7pc"/>
            <colspec colwidth="9pc"/>
            <colspec colwidth="14pc"/>
            <thead>
              <row>
                <entry>Mask</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0x0001</entry>
                <entry>XPlacement</entry>
                <entry>Includes horizontal adjustment for
                  placement</entry>
              </row>
              <row>
                <entry>0x0002</entry>
                <entry>YPlacement</entry>
                <entry>Includes vertical adjustment for
                  placement</entry>
              </row>
              <row>
                <entry>0x0004</entry>
                <entry>XAdvance</entry>
                <entry>Includes horizontal adjustment for
                  advance</entry>
              </row>
              <row>
                <entry>0x0008</entry>
                <entry>YAdvance</entry>
                <entry>Includes vertical adjustment for
                  advance</entry>
              </row>
              <row>
                <entry>0x0010</entry>
                <entry>XPlaDevice</entry>
                <entry>Includes horizontal Device table for
                  placement</entry>
              </row>
              <row>
                <entry>0x0020</entry>
                <entry>YPlaDevice</entry>
                <entry>Includes vertical Device table for
                  placement</entry>
              </row>
              <row>
                <entry>0x0040</entry>
                <entry>XAdvDevice</entry>
                <entry>Includes horizontal Device table for
                  advance</entry>
              </row>
              <row>
                <entry>0x0080</entry>
                <entry>YAdvDevice</entry>
                <entry>Includes vertical Device table for
                  advance</entry>
              </row>
              <row>
                <entry>0xF000</entry>
                <entry>Reserved</entry>
                <entry>For future use</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>None</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>


<code-fragment id='schema'>
  <code-title>valueRecord</code-title>
  valueRecord =
    attribute xPlacement { text }?,
    attribute yPlacement { text }?,
    attribute xAdvance { text }?,
    attribute yAdvance { text }?
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='table.methods'>
  public int valueSize (int valueFormat) {
    int size = 0;

    if ((valueFormat &amp; 0x001) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x002) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x004) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x008) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x010) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x020) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x040) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x080) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x100) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x200) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x400) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x800) != 0) {
      size += 2; }

    return size;
  }

  public Value parseValue (Element value) {
    Value v = new Value ();

    if (value == null) {
      return v; }

    String xPlacement = value.getAttribute ("xPlacement");
    if (xPlacement != null &amp;&amp; ! "".equals (xPlacement)) {
      v.format |= 0x001;
      v.xPlacement = Integer.parseInt (xPlacement); }

    String yPlacement = value.getAttribute ("yPlacement");
    if (yPlacement != null &amp;&amp; ! "".equals (yPlacement)) {
      v.format |= 0x002;
      v.yPlacement = Integer.parseInt (yPlacement); }

    String xAdvance = value.getAttribute ("xAdvance");
    if (xAdvance != null &amp;&amp; ! "".equals (xAdvance)) {
      v.format |= 0x004;
      v.xAdvance = Integer.parseInt (xAdvance); }

    String yAdvance = value.getAttribute ("yAdvance");
    if (yAdvance != null &amp;&amp; ! "".equals (yAdvance)) {
      v.format |= 0x008;
      v.yAdvance = Integer.parseInt (yAdvance); }

    String s = value.getAttribute ("format");
    if (s != null &amp;&amp; ! "".equals (s)) {
      int f = Integer.parseInt (s);
      if ((v.format &amp; ~f) != 0) {
        warning ("specified value format ('" + s + "') does not cover actual format"); }
      v.format = f; }

    return v;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Value'>
package com.adobe.aots.opentype;

  public class Value {
    public int format;
    public int xPlacement;
    public int yPlacement;
    public int xAdvance;
    public int yAdvance;

    public Value () {
      super ();
      format = 0;
      xPlacement = 0;
      yPlacement = 0;
      xAdvance = 0;
      yAdvance = 0; }
  }
</code-fragment>


<code-fragment package='com.adobe.aots.opentype' class='ValueRecord'>
  <code-title>ValueRecord class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

public class ValueRecord {
  public int xPlacement = 0;
  public int yPlacement = 0;
  public int xAdvance = 0;
  public int yAdvance = 0;

  public static int getSize (int valueFormat) {
    int size = 0;
    if ((valueFormat &amp; 0x001) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x002) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x004) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x008) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x010) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x020) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x040) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x080) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x100) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x200) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x400) != 0) {
      size += 2; }
    if ((valueFormat &amp; 0x800) != 0) {
      size += 2; }

    return size;
  }

  public boolean isNull () {
    return (   (xPlacement == 0) &amp;&amp; (yPlacement == 0)
            &amp;&amp; (xAdvance == 0) &amp;&amp; (yAdvance == 0));
  }

  public void toXML (AttributesImpl at) {
   if (xPlacement != 0) {
     at.addAttribute ("", "xPlacement", "xPlacement", "CDATA", "" + xPlacement); }
   if (yPlacement != 0) {
     at.addAttribute ("", "yPlacement", "yPlacement", "CDATA", "" + yPlacement); }
   if (xAdvance != 0) {
     at.addAttribute ("", "xAdvance", "xAdvance", "CDATA", "" + xAdvance); }
   if (yAdvance != 0) {
     at.addAttribute ("", "yAdvance", "yAdvance", "CDATA", "" + yAdvance); }
  }


  public ValueRecord fromBinary (Table table, int offset, int valueFormat) {
    if ((valueFormat &amp; 0x001) != 0) {
      xPlacement = table.getint16 (offset);
      offset += 2; }
    if ((valueFormat &amp; 0x002) != 0) {
      yPlacement = table.getint16 (offset);
      offset += 2; }
    if ((valueFormat &amp; 0x004) != 0) {
      xAdvance = table.getint16 (offset);
      offset += 2; }
    if ((valueFormat &amp; 0x008) != 0) {
      yAdvance = table.getint16 (offset);
      offset += 2; }
    if ((valueFormat &amp; 0x010) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x020) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x040) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x080) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x100) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x200) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x400) != 0) {
      offset += 2; }
    if ((valueFormat &amp; 0x800) != 0) {
      offset += 2; }

    return this;
  }
}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Anchor Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A <ottable>GPOS</ottable> table uses anchor points to
        position one glyph with respect to another. Each glyph defines
        an anchor point, and the text-processing client attaches the
        glyphs by aligning their corresponding anchor points.</para>

        <para>To describe an anchor point, an Anchor table can use one
        of three formats. The first format uses design units to
        specify a location for the anchor point. The other two formats
        refine the location of the anchor point using contour points
        (Format 2) or Device tables (Format 3).</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>anchorTable</code-title>
  standaloneAnchorTable =
    element anchorTable { attribute id { text }, anchorTable }

  anchorTableOffset = attribute name { text } | anchorTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  public Block anchorTableFromXML (Element t,
                                   Element table,
			           Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    Block me = null;

    String format = t.getAttribute ("format");

    if ("1".equals (format)) {
      me = anchorTableFormat1FromXML (t, table, blockCache); }
    else if ("2".equals (format)) {
      me = anchorTableFormat2FromXML (t, table, blockCache); }
    else if ("3".equals (format)) {
      me = anchorTableFormat3FromXML (t, table, blockCache); }
    else {
      /* cannot get there on valid document */
      throw new InvalidFontException
                      ("invalid anchor table format (" + format + ")"); }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gpos.methods'>
  public void anchorTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
    if (counts [offset] > 1) {
      return; }

    switch (getuint16 (offset)) {
      <code-include linkend='LayoutTable.anchorTableToXMLCount.cases'/> }
  }

  public void anchorTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute ("", "name", "name", "CDATA",
                       "anchorTable_" + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      anchorTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void anchorTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] > 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "id", "id", "CDATA",
                       "anchorTable_" + Integer.toHexString (offset));
      anchorTableToXMLEmit (conf, offset, counts, "anchorTable", at);
      counts [offset] = 0; }

    switch (getuint16 (offset)) {
      <code-include linkend='LayoutTable.anchorTableToXML.cases'/> }
  }

  public void anchorTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
                                    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute ("", "format", "format", "CDATA", "" + getuint16 (offset));
    switch (getuint16 (offset)) {
      <code-include linkend='LayoutTable.anchorTableToXMLEmit.cases'/> }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gpos.methods'>
  <code-title>Merge two anchors</code-title>
  public int[] mergeAnchors (GlyphRun gr,
                             int pos1, int offset1,
                             int pos2, int offset2) {

    int a1x = getint16 (offset1 + 2);
    int a1y = getint16 (offset1 + 4);
    int a2x = getint16 (offset2 + 2);
    int a2y = getint16 (offset2 + 4);
    int x1 = gr.getXPos (pos1);
    int y1 = gr.getYPos (pos1);

    int[] newPos = {x1 + a1x - a2x, y1 + a1y - a2y};

    gr.move (pos2, newPos[0], newPos[1]);

    return newPos;
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Anchor Table: Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>AnchorFormat1 consists of a format identifier
          (AnchorFormat) and a pair of design unit coordinates
          (XCoordinate and YCoordinate) that specify the location of
          the anchor point. This format has the benefits of small size
          and simplicity, but the anchor point cannot be hinted to
          adjust its position for different device resolutions.</para>

        <para>Example 15 at the end of this chapter uses
          AnchorFormat1.</para>

        <otformat>
          <title>AnchorFormat1 table: Design units only</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>AnchorFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>XCoordinate</otfieldname>
            <otfielddesc>Horizontal value-in design
              units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>YCoordinate</otfieldname>
            <otfielddesc>Vertical value-in design units</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>anchorTable, format 1</code-title>
  anchorTable |=
    attribute format { "1" },
    attribute x { text },
    attribute y { text }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  public Block anchorTableFormat1FromXML (Element t,
                                          Element table,
				          Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (6, 0);
    me.setuint16 (0, 1);
    me.setint16 (2, Integer.parseInt (t.getAttribute ("x")));
    me.setint16 (4, Integer.parseInt (t.getAttribute ("y")));

    return me;
  }
</code-fragment>

      </section>
      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.anchorTableToXMLEmit.cases'>
  case 1: {
    int x = getint16 (offset + 2);
    at.addAttribute ("", "x", "x", "CDATA", "" + x);

    int y = getint16 (offset + 4);
    at.addAttribute ("", "y", "y", "CDATA", "" + y);

    conf.ch.element (element, at);
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Anchor Table: Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Like AnchorFormat1, AnchorFormat2 specifies a format
          identifier (AnchorFormat) and a pair of design unit
          coordinates for the anchor point (Xcoordinate and
          Ycoordinate).</para>

        <para>For fine-tuning the location of the anchor point,
          AnchorFormat2 also provides an index to a glyph contour
          point (AnchorPoint) that is on the outline of a glyph
          (AnchorPoint). Hinting can be used to move the AnchorPoint.
          In the rendered text, the AnchorPoint will provide the final
          positioning data for a given ppem size.</para>

        <para>Example 16 at the end of this chapter uses
          AnchorFormat2.</para>

        <otformat>
          <title>AnchorFormat2 table: Design units plus contour
            point</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>AnchorFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>XCoordinate</otfieldname>
            <otfielddesc>Horizontal value-in design
              units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>YCoordinate</otfieldname>
            <otfielddesc>Vertical value-in design units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>AnchorPoint</otfieldname>
            <otfielddesc>Index to glyph contour point</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>anchorTable, format 2</code-title>
  anchorTable |=
    attribute format { "2" },
    attribute x { text },
    attribute y { text },
    attribute point { text }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  public Block anchorTableFormat2FromXML (Element t,
                                          Element table,
				          Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (8, 0);
    me.setuint16 (0, 2);
    me.setint16 (2, Integer.parseInt (t.getAttribute ("x")));
    me.setint16 (4, Integer.parseInt (t.getAttribute ("y")));
    me.setuint16 (6, Integer.parseInt (t.getAttribute ("point")));

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.anchorTableToXMLEmit.cases'>
  case 2: {
    int x = getint16 (offset + 2);
    at.addAttribute ("", "x", "x", "CDATA", "" + x);

    int y = getint16 (offset + 4);
    at.addAttribute ("", "y", "y", "CDATA", "" + y);

    int point = getuint16 (offset + 6);
    at.addAttribute ("", "point", "point", "CDATA", "" + point);

    conf.ch.element (element, at);
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Anchor Table: Format 3</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Like AnchorFormat1, AnchorFormat3 specifies a format
          identifier (AnchorFormat) and locates an anchor point
          (Xcoordinate and Ycoordinate). And, like AnchorFormat 2, it
          permits fine adjustments to the coordinate values. However,
          AnchorFormat3 uses Device tables, rather than a contour
          point, for this adjustment.</para>

        <para>With a Device table, a client can adjust the position of
          the anchor point for any font size and device resolution.
          AnchorFormat3 can specify offsets to Device tables for the
          the X coordinate (XDeviceTable) and the Y coordinate
          (YDeviceTable). If only one coordinate requires adjustment,
          the offset to the Device table may be set to NULL for the
          other coordinate.</para>

        <para>Example 17 at the end of the chapter shows an
          AnchorFormat3 table.</para>

        <otformat>
          <title>AnchorFormat3 table: Design units plus Device
            tables</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>AnchorFormat</otfieldname>
            <otfielddesc>Format identifier-format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>XCoordinate</otfieldname>
            <otfielddesc>Horizontal value-in design
              units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>YCoordinate</otfieldname>
            <otfielddesc>Vertical value-in design units</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>XDeviceTable</otfieldname>
            <otfielddesc>Offset to Device table for X coordinate- from
              beginning of Anchor table (may be NULL)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>YDeviceTable</otfieldname>
            <otfielddesc>Offset to Device table for Y coordinate- from
              beginning of Anchor table (may be NULL)</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>anchorTable, format 3</code-title>
  anchorTable |=
    attribute format { "3" },
    attribute x { text },
    attribute y { text },
    element xDeviceTable { deviceTableOffset }?,
    element yDeviceTable { deviceTableOffset }?
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gpos.methods'>
  public Block anchorTableFormat3FromXML (Element t,
                                          Element table,
				          Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (10, 0);
    me.setuint16 (0, 3);
    me.setint16 (2, Integer.parseInt (t.getAttribute ("x")));
    me.setint16 (4, Integer.parseInt (t.getAttribute ("y")));

    Element child = (Element) t.getFirstChild ();
    if (child != null &amp;&amp; "xDeviceTable".equals (child.getTagName ())) {
      me.setOffset (6, deviceTableFromXML (child, table, blockCache));
      child = (Element) child.getNextSibling (); }
    else {
      me.setOffset (6, null); }

    if (child != null &amp;&amp; "yDeviceTable".equals (child.getTagName ())) {
      me.setOffset (8, deviceTableFromXML (child, table, blockCache));
      child = (Element) child.getNextSibling (); }
    else {
      me.setOffset (8, null); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='LayoutTable.anchorTableToXMLCount.cases'>
  case 3: {
    if (getOffset (offset + 6) != 0) {
      deviceTableToXMLCount (getOffset (offset, 8), counts); }
    if (getOffset (offset + 8) != 0) {
      deviceTableToXMLCount (getOffset (offset, 10), counts); }
    break; }
</code-fragment>

<code-fragment id='LayoutTable.anchorTableToXML.cases'>
  case 3: {
    if (getOffset (offset + 6) != 0) {
      deviceTableToXML (conf, getOffset (offset, 6), counts); }
    if (getOffset (offset + 8) != 0) {
      deviceTableToXML (conf, getOffset (offset, 8), counts); }
    break; }
</code-fragment>

<code-fragment id='LayoutTable.anchorTableToXMLEmit.cases'>
  case 3: {
    int x = getint16 (offset + 2);
    at.addAttribute ("", "x", "x", "CDATA", "" + x);

    int y = getint16 (offset + 4);
    at.addAttribute ("", "y", "y", "CDATA", "" + y);

    conf.ch.startElement (element, at); {
      if (getOffset (offset + 6) != 0) {
        at = new AttributesImpl ();
        deviceTableOffsetToXML (conf, getOffset (offset, 6),
                                counts, "xDeviceTable", at); }

      if (getOffset (offset + 8) != 0) {
        at = new AttributesImpl ();
        deviceTableOffsetToXML (conf, getOffset (offset, 8),
                                counts, "yDeviceTable", at); }

      conf.ch.endElement (element); }
    break; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Mark Array</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>The MarkArray table defines the class and the anchor
          point for a mark glyph. Three <ottable>GPOS</ottable>
          subtables &#x2013; MarkToBase, MarkToLigature, and
          MarkToMark Attachment &#x2013; use the MarkArray table to
          specify data for attaching marks.</para>

        <para>The MarkArray table contains a count of the number of
          mark records (MarkCount) and an array of those records
          (MarkRecord). Each mark record defines the class of the mark
          and an offset to the Anchor table that contains data for the
          mark.</para>

        <para>A class value can be 0 (zero), but the MarkRecord must
          explicitly assign that class value (this differs from the
          ClassDef table, in which all glyphs not assigned class
          values automatically belong to Class 0). The
          <ottable>GPOS</ottable> subtables that refer to MarkArray
          tables use the class assignments for indexing zero-based
          arrays that contain data for each mark class.</para>

        <para>In Example 18 at the end of the chapter, a MarkArray
          table and two MarkRecords define two mark classes.</para>

        <otformat>
          <title>MarkArray table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>MarkCount</otfieldname>
            <otfielddesc>Number of MarkRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>MarkRecord [MarkCount]</otfieldname>
            <otfielddesc>Array of MarkRecords &#x2013; in Coverage
              order</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>MarkRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class</otfieldname>
            <otfielddesc>Class defined for this mark</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>MarkAnchor</otfieldname>
            <otfielddesc>Offset to Anchor table &#x2013; from beginning of
              MarkArray table</otfielddesc>
          </otfield>
        </otformat>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>GPOS Subtable Examples</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The rest of this chapter describes examples of all the
          <ottable>GPOS</ottable> subtable formats, including each of
          the three formats available for contextual positioning. All
          the examples reflect unique parameters described below, but
          the samples provide a useful reference for building
          subtables specific to other situations.</para>

        <para>All the examples have three columns showing hex data,
          source, and comments.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 1: GPOS Header Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 1 shows a typical <ottable>GPOS</ottable> Header
          table definition with offsets to a ScriptList, FeatureList,
          and LookupList.</para>


        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GPOSHeader</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheGPOSHeader</otexsrc>
            <otexcom>GPOSHeader table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00010000</otexdata>
            <otexsrc>0x00010000</otexsrc>
            <otexcom>Version</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>TheScriptList</otexsrc>
            <otexcom>offset to ScriptList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001E</otexdata>
            <otexsrc>TheFeatureList</otexsrc>
            <otexcom>offset to FeatureList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>TheLookupList</otexsrc>
            <otexcom>offset to LookupList table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 2: SinglePosFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 2 uses the SinglePosFormat1 subtable to lower
          the Y placement of subscript glyphs in a font. The
          LowerSubscriptsSubTable defines one Coverage table, called
          LowerSubscriptsCoverage, which lists one range of glyph
          indices for the numeral/numeric subscript glyphs. The
          subtable's ValueFormat setting indicates that the
          ValueRecord specifies only the YPlacement value, lowering
          each subscript glyph by 80 design units.</para>


        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SinglePosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LowerSubscriptsSubTable</otexsrc>
            <otexcom>SinglePos subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>LowerSubscriptsCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>0x0002</otexsrc>
            <otexcom>ValueFormat, YPlacement,Value[0], move Y
                  position down</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFB0</otexdata>
            <otexsrc>-80</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LowerSubscriptsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>01B3</otexdata>
            <otexsrc>ZeroSubscriptGlyphID</otexsrc>
            <otexcom>Start, first glyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>01BC</otexdata>
            <otexsrc>NineSubscriptGlyphID</otexsrc>
            <otexcom>End, last glyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3: SinglePosFormat2 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This example uses a SinglePosFormat2 subtable to adjust
          the spacing of three dash glyphs by different amounts. The
          em dash spacing changes by 10 units, the en dash spacing
          changes by 25 units, and spacing of the standard dash
          changes by 50 units.</para>
        <para>The DashSpacingSubTable contains one Coverage table with
          three dash glyph indices, plus an array of ValueRecords, one
          for each covered glyph. The ValueRecords use the same
          ValueFormat to modify the XPlacement and XAdvance values of
          each glyph. The ValueFormat bit setting of 0x0005 is
          produced by adding the XPlacement and XAdvance bit
          settings.</para>


        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SinglePosFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DashSpacingSubTable</otexsrc>
            <otexcom>SinglePos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>DashSpacingCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>0x0005</otexsrc>
            <otexcom>ValueFormat for XPlacement and XAdvance</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ValueCount Value[0], for dash glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>50</otexsrc>
            <otexcom>XPlacement</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>50</otexsrc>
            <otexcom>XAdvance Value[1], for en dash glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0019</otexdata>
            <otexsrc>25</otexsrc>
            <otexcom>XPlacement</otexcom>
          </otexline>
          <otexline>
            <otexdata>0019</otexdata>
            <otexsrc>25</otexsrc>
            <otexcom>XAdvance Value[2], for em dash glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>10</otexsrc>
            <otexcom>XPlacement</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>10</otexsrc>
            <otexcom>XAdvanc</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DashSpacingCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>004F</otexdata>
            <otexsrc>DashGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0125</otexdata>
            <otexsrc>EnDashGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0129</otexdata>
            <otexsrc>EmDashGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4: PairPosFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 4 uses a PairPosFormat1 subtable to kern two
          glyph pairs - "Po" and "To" - by adjusting the XAdvance of
          the first glyph and the XPlacement of the second glyph. Two
          ValueFormats are defined, one for each glyph. The subtable
          contains a Coverage table that lists the index of the first
          glyph in each pair. It also contains an offset to a PairSet
          table for each covered glyph.</para>
        <para>A PairSet table defines an array of PairValueRecords to
          specify all the glyph pairs that contain a covered glyph as
          their first component. In this example, the PPairSet table
          has one PairValueRecord that identifies the second glyph in
          the "Po" pair and two ValueRecords, one for the first glyph
          and one for the second. The TPairSet table also has one
          PairValueRecord that lists the second glyph in the "To" pair
          and two ValueRecords, one for each glyph.</para>


        <otexample>
          <title>Example 4</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairPosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairKerningSubTable</otexsrc>
            <otexcom>PairPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>001E</otexdata>
            <otexsrc>PairKerningCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>0x0004</otexsrc>
            <otexcom>ValueFormat1 XAdvance only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>0x0001</otexsrc>
            <otexcom>ValueFormat2 XPlacement only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>PairSetCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>PPairSetTable</otexsrc>
            <otexcom>PairSet[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0016</otexdata>
            <otexsrc>TPairSetTable</otexsrc>
            <otexcom>PairSet[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairSetTable</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PPairSetTable</otexsrc>
            <otexcom>PairSet table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PairValueCount, one pair in set
                  PairValueRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0059</otexdata>
            <otexsrc>LowercaseOGlyphID</otexsrc>
            <otexcom>SecondGlyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFE2</otexdata>
            <otexsrc>-30</otexsrc>
            <otexcom>Value 1, XAdvance adjustment for first
                  glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFEC</otexdata>
            <otexsrc>-20</otexsrc>
            <otexcom>Value 2, XPlacement adjustment for second
                  glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairSetTable</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairSetTable</otexsrc>
            <otexcom>PairSet table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PairValueCount one pair in set
                  PairValueRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0059</otexdata>
            <otexsrc>LowercaseOGlyphID</otexsrc>
            <otexcom>SecondGlyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFD8</otexdata>
            <otexsrc>-40</otexsrc>
            <otexcom>Value1 XAdvance adjustment for first
                  glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFE7</otexdata>
            <otexsrc>-25</otexsrc>
            <otexcom>Value 2 XPlacement adjustment for second
                  glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairKerningCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>002D</otexdata>
            <otexsrc>UppercasePGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>UppercaseTGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 5: PairPosFormat2 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The PairPosFormat2 subtable in this example defines
          pairs composed of two glyph classes. Two ClassDef tables are
          defined, one for each glyph class. The first glyph in each
          pair is in a class of lowercase glyphs with diagonal shapes
          (v, w, y), defined Class1 in the LowercaseClassDef table.
          The second glyph in each pair is in a class of punctuation
          glyphs (comma and period), defined in Class1 in the
          PunctuationClassDef table. The Coverage table only lists the
          indices of the glyphs in the LowercaseClassDef table since
          they occupy the first position in the pairs.</para>
        <para>The subtable defines two Class1Records for the classes
          defined in LowecaseClassDef, including Class0. Each record,
          in turn, defines a Class2Record for each class defined in
          PunctuationClassDef, including Class0. The Class2Records
          specify the positioning adjustments for the glyphs.</para>
        <para>The pairs are kerned by reducing the XAdvance of the
          first glyph by 50 design units. Because no positioning
          change applies to the second glyph, its ValueFormat2 is set
          to 0, to indicate that Value2 is empty for each pair.</para>
        <para>Since no pairs begin with Class0 or Class2 glyphs, all
          the ValueRecords referenced in Class1Record[0] contain
          values of 0 or are empty. However, Class1Record[1] does
          define an XAdvance value in its Class2Record[1] for kerning
          all pairs that contain a Class1 glyph followed by a Class2
          glyph.</para>


        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PairPosFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PunctKerningSubTable</otexsrc>
            <otexcom>PairPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>PunctKerningCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>0x0004</otexsrc>
            <otexcom>ValueFormat1 XAdvance only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>ValueFormat2 no ValueRecord for second
                  glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0022</otexdata>
            <otexsrc>LowercaseClassDef</otexsrc>
            <otexcom>offset to ClassDef1 table for first class in
                  pair</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>PunctuationClassDef</otexsrc>
            <otexcom>offset to ClassDef2 table for second class in
                  pair</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class1Count</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class2Count Class1Record[0], no contexts begin
                  with Class0 Class2Record[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Value1- no change for first glyph, Value2 no
                  ValueRecord for second glyph Class2Record[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Value1- no change for first glyph, Value2 no
                  ValueRecord for second glyph Class1Record[1], for
                  contexts beginning with Class1 Class2Record[0] no
                  contexts with Class0 as second glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Value1-no change for first glyph, Value2-no
                  ValueRecord for second glyph Class2Record[1]contexts
                  with Class1 as second glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFCE</otexdata>
            <otexsrc>-50</otexsrc>
            <otexcom>Value1- move punctuation glyph left, Value2- no
                  ValueRecord for second glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PunctKerningCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>LowercaseVGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0047</otexdata>
            <otexsrc>LowercaseWGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0049</otexdata>
            <otexsrc>LowercaseYGlyphID</otexsrc>
            <otexcom>GlyphArray[2</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LowercaseClassDef</otexsrc>
            <otexcom>ClassDef table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassRangeCount ClassRangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>LowercaseVGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0047</otexdata>
            <otexsrc>LowercaseWGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class ClassRangeRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0049</otexdata>
            <otexsrc>LowercaseYGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0049</otexdata>
            <otexsrc>LowercaseYGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Clas</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PunctuationClassDef</otexsrc>
            <otexcom>ClassDef table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>ClassRangeCount ClassRangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>006A</otexdata>
            <otexsrc>PeriodPunctGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>006B</otexdata>
            <otexsrc>CommaPunctGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 6: CursivePosFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>In Example 6, the Urdu language system uses a
          CursivePosFormat1 subtable to attach glyphs along a diagonal
          baseline that descends from right to left. Two glyphs are
          defined with attachment data and listed in the Coverage
          table-the Kaf and Ha glyphs. For each glyph, the subtable
          contains an EntryExitRecord that defines offsets to two
          Anchor tables, an entry attachment point, and an exit
          attachment point. Each Anchor table defines X and Y
          coordinate values. To render Urdu down and diagonally, the
          entry point's Y coordinate is above the baseline and the
          exit point's Y coordinate is located below the
          baseline.</para>


        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CursivePosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DiagonalWritingSubTable</otexsrc>
            <otexcom>CursivePos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>DiagonalWritingCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>EntryExitCount EntryExitRecord[0] for Kaf
                  glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0016</otexdata>
            <otexsrc>KafEntryAnchor</otexsrc>
            <otexcom>offset to EntryAnchor table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>KafExitAnchor</otexsrc>
            <otexcom>offset to ExitAnchor table EntryExitRecord[1]
                  for Ha glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0022</otexdata>
            <otexsrc>HaEntryAnchor</otexsrc>
            <otexcom>offset to EntryAnchor table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>HaExitAnchor</otexsrc>
            <otexcom>offset to ExitAnchor tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DiagonalWritingCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0203</otexdata>
            <otexsrc>KafGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>027E</otexdata>
            <otexsrc>HaGlyphID</otexsrc>
            <otexcom>GlyphArray[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>KafEntryAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>05DC</otexdata>
            <otexsrc>1500</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>44</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata>KafExitAnchor</otexdata>
            <otexsrc>Anchor</otexsrc>
            <otexcom>table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFEC</otexdata>
            <otexsrc>-20</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HaEntryAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>05DC</otexdata>
            <otexsrc>1500</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>44</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>HaExitAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFEC</otexdata>
            <otexsrc>-20</otexsrc>
            <otexcom>Ycoordinate</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 7: MarkBasePosFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The MarkBasePosFormat1 subtable in Example 7 defines one
          Arabic base glyph, Tah, and two Arabic mark glyphs: a
          fathatan mark above the base glyph, and a kasra mark below
          the base glyph. The BaseGlyphsCoverage table lists the base
          glyph, and the MarkGlyphsCoverage table lists the mark
          glyphs.</para>
        <para>Each mark is also listed in the MarkArray, along with
          its attachment point data and a mark Class value. The
          MarkArray defines two mark classes: Class0 consists of marks
          located above base glyphs, and Class1 consists of marks
          located below base glyphs.</para>
        <para>The BaseArray defines attachment data for base glyphs.
          In this array, one BaseRecord is defined for the Tah glyph
          with offsets to two BaseAnchor tables, one for each class of
          marks. AboveBaseAnchor defines an attachment point for marks
          placed above the Tah base glyph, and BelowBaseAnchor defines
          an attachment point for marks placed below it.</para>


        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkBasePosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkBaseAttachSubTable</otexsrc>
            <otexcom>MarkBasePos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>MarkGlyphsCoverage</otexsrc>
            <otexcom>offset to MarkCoverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>BaseGlyphsCoverage</otexsrc>
            <otexcom>offset to BaseCoverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>MarkGlyphsArray</otexsrc>
            <otexcom>offset to MarkArray table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>BaseGlyphsArray</otexsrc>
            <otexcom>offset to BaseArray tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkGlyphsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0333</otexdata>
            <otexsrc>fathatanMarkGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>033F</otexdata>
            <otexsrc>kasraMarkGlyphID</otexsrc>
            <otexcom>GlyphArray[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseGlyphsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0190</otexdata>
            <otexsrc>tahBaseGlyphID</otexsrc>
            <otexcom>GlyphArray[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkArray</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkGlyphsArray</otexsrc>
            <otexcom>MarkArray table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>MarkCount MarkRecord[0] in CoverageIndex
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Class, for marks over base</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>fathatanMarkAnchor</otexsrc>
            <otexcom>offset to Anchor table MarkRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class, for marks under</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>kasraMarkAnchor</otexsrc>
            <otexcom>offset to Anchor tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>fathatanMarkAnchor</otexsrc>
            <otexcom>Anchor table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>015A</otexdata>
            <otexsrc>346</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF9E</otexdata>
            <otexsrc>-98</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>kasraMarkAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0105</otexdata>
            <otexsrc>261</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0058</otexdata>
            <otexsrc>88</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseArray</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BaseGlyphsArray</otexsrc>
            <otexcom>BaseArray table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>BaseCount BaseRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>AboveBaseAnchor</otexsrc>
            <otexcom>BaseAnchor[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>BelowBaseAnchor</otexsrc>
            <otexcom>BaseAnchor[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AboveBaseAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>033E</otexdata>
            <otexsrc>830</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0640</otexdata>
            <otexsrc>1600</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BelowBaseAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>033E</otexdata>
            <otexsrc>830</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFAD</otexdata>
            <otexsrc>-83</otexsrc>
            <otexcom>Ycoordinate</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 8: MarkLigPosFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 8 uses the MarkLigPosFormat1 subtable to attach
          marks to a ligature glyph in the Arabic script. The
          hypothetical ligature is composed of three glyph components:
          a Lam (initial form), a meem (medial form), and a jeem
          (medial form). Accent marks are defined for the first two
          components: the sukun accent is positioned above lam, and
          the kasratan accent is placed below meem.</para>
        <para>The LigGlyphsCoverage table lists the ligature glyph and
          the MarkGlyphsCoverage table lists the two accent marks.
          Each mark is also listed in the MarkArray, along with its
          attachment point data and a mark Class value. The MarkArray
          defines two mark classes: Class0 consists of marks located
          above base glyphs, and Class1 consists of marks located
          below base glyphs.</para>
        <para>The LigGlyphsArray has an offset to one LigatureAttach
          table for the covered ligature glyph. This table, called
          LamWithMeemWithJeemLigAttach, defines a count and array of
          the component glyphs in the ligature. Each ComponentRecord
          defines offsets to two Anchor tables, one for each mark
          class.</para>
        <para>In the example, the first glyph component, lam,
          specifies a high attachment point for positioning accents
          above, but does not specify a low attachment point for
          placing accents below. The second glyph component, meem,
          defines a low attachment point for placing accents below,
          but not above. The third component, jeem, has no attachment
          points since the example defines no accents for it.</para>

        <otexample>
          <title>Example 8</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkLigPosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkLigAttachSubTable</otexsrc>
            <otexcom>MarkLigPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>MarkGlyphsCoverage</otexsrc>
            <otexcom>offset to MarkCoverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>LigGlyphsCoverage</otexsrc>
            <otexcom>offset to LigatureCoverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>MarkGlyphsArray</otexsrc>
            <otexcom>offset to MarkArray table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>LigGlyphsArray</otexsrc>
            <otexcom>offset to LigatureArray tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkGlyphsCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>033C</otexdata>
            <otexsrc>sukunMarkGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>033F</otexdata>
            <otexsrc>kasratanMarkGlyphID</otexsrc>
            <otexcom>GlyphArray[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigGlyphsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0234</otexdata>
            <otexsrc>LamWithMeemWithJeem</otexsrc>
            <otexcom>LigatureGlyphID GlyphArray[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkArray</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkGlyphsArray</otexsrc>
            <otexcom>MarkArray table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>MarkCount MarkRecord[0] in CoverageIndex
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Class, for marks above components</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>sukunMarkAnchor</otexsrc>
            <otexcom>offset to Anchor table MarkRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class, for marks below components</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>kasratanMarkAnchor</otexsrc>
            <otexcom>offset to Anchor tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>sukunMarkAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>015A</otexdata>
            <otexsrc>346</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF9E</otexdata>
            <otexsrc>-98</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>kasratanMarkAnchor</otexsrc>
            <otexcom>Anchor table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0105</otexdata>
            <otexsrc>261</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>01E8</otexdata>
            <otexsrc>488</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigatureArray</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigGlyphsArray</otexsrc>
            <otexcom>LigatureArray table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LigatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>LamWithMeemWithJeemLigAttach</otexsrc>
            <otexcom>offset to LigatureAttach tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigatureAttach</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LamWithMeemWithJeemLigAttach</otexsrc>
            <otexcom>LigatureAttach
                  table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ComponentCount ComponentRecord[0] Right-to-Left
                  text order</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>AboveLamAnchor</otexsrc>
            <otexcom>offset to LigatureAnchor table ordered by mark
                  class value for Class0 marks (above)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to LigatureAnchor table no attachment
                  points for Class1 marks ComponentRecor[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to LigatureAnchor table no attachment
                  points for Class0 marks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>BelowMeemAnchor</otexsrc>
            <otexcom>offset to LigatureAnchor table for Class1 marks
                  (below) ComponentRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to LigatureAnchor table no attachment
                  points for Class0 marks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to LigatureAnchor table no attachment
                  points for Class1 mark</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AboveLamAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0271</otexdata>
            <otexsrc>625</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0708</otexdata>
            <otexsrc>1800</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>BelowMeemAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0178</otexdata>
            <otexsrc>376</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FE90</otexdata>
            <otexsrc>-368</otexsrc>
            <otexcom>Ycoordinate</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 9: MarkMarkPosFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The MarkMarkPosFormat1 subtable in Example 9 defines two
          Arabic marks glyphs. The hanza mark, the base mark (Mark2),
          is identified in the Mark2GlyphsCoverage table. The damma
          mark, the attaching mark (Mark1), is defined in the
          Mark1GlyphsCoverage table.</para>
        <para>Each Mark1 glyph is also listed in the Mark1Array, along
          with its attachment point data and a mark Class value. The
          Mark1GlyphsArray defines one mark class, Class0, that
          consists of marks located above Mark2 base glyphs. The
          Mark1GlyphsArray contains an offset to a dammaMarkAnchor
          table to specify the coordinate of the damma mark's
          attachment point.</para>
        <para>The Mark2GlyphsArray table defines a count and an array
          of Mark2Records, one for each covered Mark2 base glyph. Each
          record contains an offset to a Mark2Anchor table for each
          Mark1 class. One Anchor table, AboveMark2Anchor, specifies a
          coordinate value for attaching the damma mark above the
          hanza base mark.</para>

        <otexample>
          <title>Example 9</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkMarkPosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkMarkAttachSubTable</otexsrc>
            <otexcom>MarkMarkPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>Mark1GlyphsCoverage</otexsrc>
            <otexcom>offset to Mark1Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>Mark2GlyphsCoverage</otexsrc>
            <otexcom>offset to Mark2Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>ClassCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>Mark1GlyphsArray</otexsrc>
            <otexcom>offset to Mark1Array table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0024</otexdata>
            <otexsrc>Mark2GlyphsArray</otexsrc>
            <otexcom>offset to Mark2Array tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Mark1GlyphsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0296</otexdata>
            <otexsrc>dammaMarkGlyphID</otexsrc>
            <otexcom>GlyphArray[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Mark2GlyphsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0289</otexdata>
            <otexsrc>hanzaMarkGlyphID</otexsrc>
            <otexcom>GlyphArray[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkArray</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Mark1GlyphsArray</otexsrc>
            <otexcom>MarkArray table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>MarkCount MarkRecord[0] in CoverageIndex
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Class for marks above base mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>dammaMarkAnchor</otexsrc>
            <otexcom>offset to Anchor tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>dammaMarkAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>00BD</otexdata>
            <otexsrc>189</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF99</otexdata>
            <otexsrc>-103</otexsrc>
            <otexcom>YCoordinat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Mark2Array</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Mark2GlyphsArray</otexsrc>
            <otexcom>Mark2Array table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Mark2Count Mark2Record[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>AboveMark2Anchor</otexsrc>
            <otexcom>offset to Anchor table[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AboveMark2Anchor</otexsrc>
            <otexcom>Anchor table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>00DD</otexdata>
            <otexsrc>221</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>012D</otexdata>
            <otexsrc>301</otexsrc>
            <otexcom>Ycoordinate</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 10: ContextPosFormat1 Subtable and
        PosLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 10 uses a ContextPosFormat1 subtable to adjust
          the spacing between three Arabic glyphs in a word. The
          context is the glyph sequence (from right to left): heh
          (initial form), thal (final form), and heh (isolated form).
          In the rendered word, the first two glyphs are connected,
          but the last glyph (the isolated form of heh), is separate.
          This subtable reduces the amount of space between the last
          glyph and the rest of the word.</para>
        <para>The subtable contains a WordCoverage table that lists
          the first glyph in the word, heh (initial), and one
          PosRuleSet table, called WordPosRuleSet, that defines all
          contexts beginning with this covered glyph.</para>
        <para>The WordPosRuleSet contains one PosRule that describes a
          word context of three glyphs and identifies the second and
          third glyphs (the first glyph is identified by the
          WordPosRuleSet). When a text-processing client locates this
          context in text, it applies a SinglePos lookup (not shown in
          the example) at position 2 to reduce the spacing between the
          glyphs.</para>


        <otexample>
          <title>Example 10</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ContextPosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MoveHehInSubtable</otexsrc>
            <otexcom>ContextPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>WordCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosRuleSetCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>WordPosRuleSet</otexsrc>
            <otexcom>offset to PosRuleSet[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordCoverage</otexsrc>
            <otexcom>Coverage table offset</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>02A6</otexdata>
            <otexsrc>hehInitialGlyphID</otexsrc>
            <otexcom>GlyphArray[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosRuleSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordPosRuleSet</otexsrc>
            <otexcom>PosRuleSet table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosRuleCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>WordPosRule</otexsrc>
            <otexcom>Offset to PosRule[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordPosRule</otexsrc>
            <otexcom>PosRule table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>02DD</otexdata>
            <otexsrc>thalFinalGlyphID</otexsrc>
            <otexcom>Input[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>02C6</otexdata>
            <otexsrc>hehIsolatedGlyphID</otexsrc>
            <otexcom>Input[0] PosLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 11: ContextPosFormat2 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The ContextPosFormat2 subtable in Example 11 defines
          context strings for five glyph classes: Class1 consists of
          uppercase glyphs that overhang and create a wide open space
          on their right side; Class2 consists of uppercase glyphs
          that overhang and create a narrow space on their right side;
          Class3 contains lowercase x-height vowels; and Class4
          contains accent glyphs placed over the lowercase vowels. The
          rest of the glyphs in the font fall into Class0.</para>
        <para>The MoveAccentsSubtable defines two similar context
          strings. The first consists of a Class1 uppercase glyph
          followed by a Class3 lowercase vowel glyph with a Class4
          accent glyph over the vowel. When this context is found in
          the text, the client lowers the accent glyph over the vowel
          so that it does not collide with the overhanging glyph
          shape. The second context consists of a Class2 uppercase
          glyph, followed by a Class3 lowercase vowel glyph with a
          Class4 accent glyph over the vowel. When this context is
          found in the text, the client increases the advance width of
          the uppercase glyph to expand the space between it and the
          accented vowel.</para>
        <para>The MoveAccents subtable defines a MoveAccentsCoverage
          table that identifies the first glyphs in the two contexts
          and offsets to five PosClassSet tables, one for each class
          defined in the ClassDef table. Since no contexts begin with
          Class0, Class3, or Class4 glyphs, the offsets to the
          PosClassSet tables for these classes are NULL.
          PosClassSet[1] defines all contexts beginning with Class1
          glyphs; it is called UCWideOverhangPosClass1Set.
          PosClassSet[2] defines all contexts beginning with Class2
          glyphs, and it is called
          UCNarrowOverhangPosClass1Set.</para>
        <para>Each PosClassSet defines one PosClassRule. The
          UCWideOverhangPosClass1Set uses the
          UCWideOverhangPosClassRule to specify the first context. The
          first class in this context string is identified by the
          PosClassSet that includes a PosClassRule, in this case
          Class1. The PosClassRule table lists the second and third
          classes in the context as Class3 and Class4. A SinglePos
          Lookup (not shown) lowers the accent glyph in position 3 in
          the context string.</para>
        <para>The UCNarrowOverhangPosClass1Set defines the
          UCNarrowOverhangPosClassRule for the second context. This
          PosClassRule is identical to the UCWideOverhangPosClassRule,
          except that the first class in the context string is a
          Class2 lowercase glyph. A SinglePos Lookup (not shown)
          increases the advance width of the overhanging uppercase
          glyph in position 0 in the context string.</para>


        <otexample>
          <title>Example 11</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ContextPosFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MoveAccentsSubtable</otexsrc>
            <otexcom>ContextPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>MoveAccentsCoverage</otexsrc>
            <otexcom>Offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>MoveAccentsClassDef</otexsrc>
            <otexcom>Offset to ClassDef</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>5</otexsrc>
            <otexcom>PosClassSetCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>PosClassSet[0], no contexts begin with Class0
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0060</otexdata>
            <otexsrc>UCWideOverhangPosClass1Set</otexsrc>
            <otexcom>PosClassSet[1] contexts beginning with Class1
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0070</otexdata>
            <otexsrc>UCNarrowOverhangPosClass2Set</otexsrc>
            <otexcom>PosClassSet[2] context beginning with Class2
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>PosClassSet[3], no contexts begin with Class3
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>PosClassSet[4], no contexts begin with Class4
                  glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MoveAccentsCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>5</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0029</otexdata>
            <otexsrc>UppercaseFGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>UppercasePGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0037</otexdata>
            <otexsrc>UppercaseTGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0039</otexdata>
            <otexsrc>UppercaseVGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003A</otexdata>
            <otexsrc>UppercaseWGlyphID</otexsrc>
            <otexcom>GlyphArray[4</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MoveAccentsClassDef</otexsrc>
            <otexcom>ClassDef table definition defines five classes = 0 (all
                  else), 1 (T, V, W: UCUnderhang), 2 (F, P:
                  UCOverhang), 3 (a, e, I, o, u: LCVowels), 4 (tilde,
                  umlaut)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>ClassFormat, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>10</otexsrc>
            <otexcom>ClassRangeCount ClassRangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0029</otexdata>
            <otexsrc>UppercaseFGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0029</otexdata>
            <otexsrc>UppercaseFGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class ClassRangeRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>UppercasePGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>UppercasePGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class ClassRangeRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0037</otexdata>
            <otexsrc>UppercaseTGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0037</otexdata>
            <otexsrc>UppercaseTGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class ClassRangeRecord[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0039</otexdata>
            <otexsrc>UppercaseVGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>003A</otexdata>
            <otexsrc>UppercaseWGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class ClassRangeRecord[4]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>LowercaseAGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>LowercaseAGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRangeRecord[5]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>LowercaseEGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>LowercaseEGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRangeRecord[6]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>LowercaseIGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>LowercaseIGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRangeRecord[7]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0051</otexdata>
            <otexsrc>LowercaseOGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0051</otexdata>
            <otexsrc>LowercaseOGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRangeRecord[8]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0056</otexdata>
            <otexsrc>LowercaseUGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>0056</otexdata>
            <otexsrc>LowercaseUGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRangeRecord[9]</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F5</otexdata>
            <otexsrc>TildeAccentGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F6</otexdata>
            <otexsrc>UmlautAccentGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>Clas</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosClassSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>UCWideOverhangPosClass1Set</otexsrc>
            <otexcom>PosClassSet table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosClassRuleCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>UCWideOverhangPosClassRule</otexsrc>
            <otexcom>PosClassRule[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosClassRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>UCWideOverhangPosClassRule</otexsrc>
            <otexcom>PosClassRule table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class[1], lowercase vowel</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>Class[2], accent PosLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex, lower the accen</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosClassSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>UCNarrowOverhangPosClass2Set</otexsrc>
            <otexcom>PosClassSet table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosClassRuleCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>UCNarrowOverhangPosClassRule</otexsrc>
            <otexcom>PosClassRule[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosClassRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>UCNarrowOverhangPosClassRule</otexsrc>
            <otexcom>PosClassRule table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class[1], lowercase vowel</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>Class[2], accent PosLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex increase overhang advance
                  width</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 12: ContextPosFormat3 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 12 uses a ContextPosFormat3 subtable to lower
          the position of math signs in math equations consisting of a
          lowercase descender or x-height glyph, a math sign glyph,
          and any lowercase glyph. Format3 is better to use for this
          context than the class-based Format2 because the sets of
          covered glyphs for positions 0 and 2 overlap.</para>
        <para>The LowerMathSignsSubtable contains offsets to three
          Coverage tables (XhtDescLCCoverage, MathSignCoverage, and
          LCCoverage), one for each position in the context glyph
          string. When the client finds the context in the text
          stream, it applies the PosLookupRecord data at position 1
          and repositions the math sign.</para>

        <otexample>
          <title>Example 12</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ContextPosFormat3</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LowerMathSignsSubtable</otexsrc>
            <otexcom>ContextPos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosLookup</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>XhtDescLCCoverage</otexsrc>
            <otexcom>Offset to Coverage[0] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>003C</otexdata>
            <otexsrc>MathSignCoverage</otexsrc>
            <otexcom>Offset to Coverage[1] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0044</otexdata>
            <otexsrc>LCCoverage</otexsrc>
            <otexcom>Offset to Coverage[2] table
                  PosLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListInde</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>XhtDescLCCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>20</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>LCaGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0035</otexdata>
            <otexsrc>LCcGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0037</otexdata>
            <otexsrc>LCeGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0039</otexdata>
            <otexsrc>LCgGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>LCiGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003C</otexdata>
            <otexsrc>LCjGlyphID</otexsrc>
            <otexcom>GlyphArray[5]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003F</otexdata>
            <otexsrc>LCmGlyphID</otexsrc>
            <otexcom>GlyphArray[6]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>LCnGlyphID</otexsrc>
            <otexcom>GlyphArray[7]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>LCoGlyphID</otexsrc>
            <otexcom>GlyphArray[8]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>LCpGlyphID</otexsrc>
            <otexcom>GlyphArray[9]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0043</otexdata>
            <otexsrc>LCqGlyphID</otexsrc>
            <otexcom>GlyphArray[10]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0044</otexdata>
            <otexsrc>LCrGlyphID</otexsrc>
            <otexcom>GlyphArray[11]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0045</otexdata>
            <otexsrc>LCsGlyphID</otexsrc>
            <otexcom>GlyphArray[12]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>LCtGlyphID</otexsrc>
            <otexcom>GlyphArray[13]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0047</otexdata>
            <otexsrc>LCuGlyphID</otexsrc>
            <otexcom>GlyphArray[14]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0048</otexdata>
            <otexsrc>LCvGlyphID</otexsrc>
            <otexcom>GlyphArray[15]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0049</otexdata>
            <otexsrc>LCwGlyphID</otexsrc>
            <otexcom>GlyphArray[16]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>LCxGlyphID</otexsrc>
            <otexcom>GlyphArray[17]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004B</otexdata>
            <otexsrc>LCyGlyphID</otexsrc>
            <otexcom>GlyphArray[18]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004C</otexdata>
            <otexsrc>LCzGlyphID</otexsrc>
            <otexcom>GlyphArray[19</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MathSignCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>011E</otexdata>
            <otexsrc>EqualsSignGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>012D</otexdata>
            <otexsrc>PlusSignGlyphID</otexsrc>
            <otexcom>GlyphArray[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LCCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>LCaGlyphID</otexsrc>
            <otexcom>Start</otexcom>
          </otexline>
          <otexline>
            <otexdata>004C</otexdata>
            <otexsrc>LCzGlyphID</otexsrc>
            <otexcom>End</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 13: PosLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The PosLookupRecord in Example 13 identifies a lookup to
          apply at the second glyph position in a context glyph
          string.</para>


        <otexample>
          <title>Example 13</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosLookupRecord</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>PosLookupRecord</otexsrc>
            <otexcom>0] PosLookupRecord
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex for second glyph position</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex, apply this lookup to second
                  glyph position</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 14: ValueFormat Table and ValueRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 14 demonstrates how to specify positioning
          values in the <ottable>GPOS</ottable> table. Here, a
          SinglePosFormat1 subtable defines the ValueFormat and
          ValueRecord. The ValueFormat bit setting of 0x0099 says that
          the corresponding ValueRecord contains values for a glyph's
          XPlacement and YAdvance. Device tables specify pixel
          adjustments for these values at font sizes from 11 ppem to
          15 ppem.</para>

        <otexample>
          <title>Example 14</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SinglePosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>OnesSubtable</otexsrc>
            <otexcom>SinglePos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>Cov</otexsrc>
            <otexcom>Offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0099</otexdata>
            <otexsrc>0x0099</otexsrc>
            <otexcom>ValueFormat, for XPlacement, YAdvance,
                  XPlaDevice, YAdvaDevice Value</otexcom>
          </otexline>
          <otexline>
            <otexdata>0050</otexdata>
            <otexsrc>80</otexsrc>
            <otexcom>Xplacement value</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D2</otexdata>
            <otexsrc>210</otexsrc>
            <otexcom>Yadvance value</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>XPlaDeviceTable</otexsrc>
            <otexcom>Offset to XPlaDevice table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>YAdvDeviceTable</otexsrc>
            <otexcom>Offset to YAdvDevice tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Cov</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>00C8</otexdata>
            <otexsrc>200</otexsrc>
            <otexcom>Start, first glyph ID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D1</otexdata>
            <otexsrc>209</otexsrc>
            <otexcom>End, last glyph ID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageInde</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>XPlaDeviceTable</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000B</otexdata>
            <otexsrc>11</otexsrc>
            <otexcom>StartSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>EndSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>DeltaFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 11ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>5540</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppem by 1 pixe</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>YAdvDeviceTable</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000B</otexdata>
            <otexsrc>11</otexsrc>
            <otexcom>StartSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>EndSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>DeltaFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 11ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>5540</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppem by 1 pixel</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 15: AnchorFormat1 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 15 illustrates an Anchor table for the damma
          mark glyph in the Arabic script. Format1 is used to specify
          X and Y coordinate values in design units.</para>


        <otexample>
          <title>Example 15</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>dammaMarkAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>00BD</otexdata>
            <otexsrc>189</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>FF99</otexdata>
            <otexsrc>-103</otexsrc>
            <otexcom>YCoordinate</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 16: AnchorFormat2 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 16 shows an AnchorFormat2 table for an
          attachment point placed above a base glyph. With this
          format, the coordinate value for the Anchor depends on the
          final position of a specific contour point on the base glyph
          after hinting. The coordinates are specified in design
          units.</para>


        <otexample>
          <title>Example 16</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AboveBaseAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0142</otexdata>
            <otexsrc>322</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0384</otexdata>
            <otexsrc>900</otexsrc>
            <otexcom>Ycoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>000D</otexdata>
            <otexsrc>13</otexsrc>
            <otexcom>AnchorPoint glyph contour point index</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 17: AnchorFormat3 Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 17 shows an AnchorFormat3 table that specifies
          an attachment point above a base glyph. Device tables modify
          the X and Y coordinates of the Anchor for the point size and
          resolution of the output font. Here, the Device tables
          define pixel adjustments for font sizes from 12 ppem to 17
          ppem.</para>


        <otexample>
          <title>Example 17</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AnchorFormat3</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AboveBaseAnchor</otexsrc>
            <otexcom>Anchor table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>AnchorFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0117</otexdata>
            <otexsrc>279</otexsrc>
            <otexcom>XCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>0515</otexdata>
            <otexsrc>1301</otexsrc>
            <otexcom>YCoordinate</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>XDevice</otexsrc>
            <otexcom>offset to DeviceTable for X coordinate (may be
                  NULL)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>YDevice</otexsrc>
            <otexcom>offset to Device table for Y coordinate (may be
                  NULL</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>XDevice</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>12</otexsrc>
            <otexcom>StartSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0011</otexdata>
            <otexsrc>17</otexsrc>
            <otexcom>EndSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>DeltaFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>1111</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>increase 16ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>2200</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>increase 17ppem by 1 pixe</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DeviceTableFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>YDevice</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>12</otexsrc>
            <otexcom>StartSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0011</otexdata>
            <otexsrc>17</otexsrc>
            <otexcom>EndSize</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>DeltaFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>1111</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>increase 16ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>2200</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>increase 17ppem by 1 pixel</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 18: MarkArray Table and MarkRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 18 shows a MarkArray table with class and
          attachment point data for two accent marks, a grave and a
          cedilla. Two MarkRecords are defined, one for each covered
          mark glyph. The first MarkRecord assigns a mark class value
          of 0 to accents placed above base glyphs, such as the grave,
          and has an offset to a graveMarkAnchor table. The second
          MarkRecord assigns a mark class value of 1 for all accents
          positioned below base glyphs, such as the cedilla, and has
          an offset to a cedillaMarkAnchor table.</para>


        <otexample>
          <title>Example 18</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkArray</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MarkGlyphsArray</otexsrc>
            <otexcom>MarkArray table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>MarkCount MarkRecord[0] for first mark in
                  MarkCoverage table, grave</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>Class, for marks placed above base
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>graveMarkAnchor</otexsrc>
            <otexcom>offset to Anchor table MarkRecord[1] for second
                  mark in MarkCoverage table = cedilla</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class, for marks placed below base
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>cedillaMarkAnchor</otexsrc>
            <otexcom>offset to Anchor table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.GSUB' web:index='yes'>
    <title>GSUB - The Glyph Substitution Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Glyph Substitution table (<ottable>GSUB</ottable>)
          contains information for substituting glyphs to render the
          scripts and language systems supported in a font. Many
          language systems require glyph substitutes. For example, in
          the Arabic script, the glyph shape that depicts a particular
          character varies according to its position in a word or text
          string (see figure 1). In other language systems, glyph
          substitutes are aesthetic options for the user, such as the
          use of ligature glyphs in the English language (see Figure
          2)</para>

        <figure>
          <title>Figure 1: Isolated, initial, medial, and final forms
            of the Arabic character HAH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fig3a.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Figure 2. Two Latin glyphs and their associated
            ligature</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fig3b.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Many fonts use limited character encoding standards that
          map glyphs to characters one-to-one, assigning a glyph to
          each character code value in a font. Multiple character
          codes cannot be mapped to a single glyph, as needed for
          ligature glyphs, and multiple glyphs cannot be mapped to a
          single character code, as needed to decompose a ligature
          into its component glyphs.</para>

        <para>To supply glyph substitutes, font developers must assign
          different character codes to the glyphs, or they must create
          additional fonts or character sets. To access these glyphs,
          users must bear the burden of switching between character
          codes, character sets, or fonts.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The term "limited character encoding standards" in the
          first sentence is somewhat misleading. Unicode for example
          can hardly be considered a "limited" standard. May a better
          formulation for the first sentence may be: "Character
          standards typically encode characters but not glyphs; at the
          same time, fonts typically map from one character to one
          glyph."</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Substituting Glyphs with OpenType</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The OpenType <ottable>GSUB</ottable> table fully
          supports glyph substitution. To access glyph substitutes,
          <ottable>GSUB</ottable> maps from the glyph index or indices
          defined in a cmap table to the glyph index or indices of the
          glyph substitutes. For example, if a font has three
          alternative forms of an ampersand glyph, the cmap table
          associates the ampersand's character code with only one of
          these glyphs. In <ottable>GSUB</ottable>, the indices of the
          other ampersand glyphs are then referenced by this one
          index.</para>

        <para>The text-processing client uses the
          <ottable>GSUB</ottable> data to manage glyph substitution
          actions. <ottable>GSUB</ottable> identifies the glyphs that
          are input to and output from each glyph substitution action,
          specifies how and where the client uses glyph substitutes,
          and regulates the order of glyph substitution operations.
          Any number of substitutions can be defined for each script
          or language system represented in a font.</para>

        <para>The <ottable>GSUB</ottable> table supports six types of glyph
          substitutions that are widely used in international
          typography:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>single substitution</emphasis> replaces
              a single glyph with another single glyph. This is used
              to render positional glyph variants in Arabic and
              vertical text in the Far East (see Figure 3)</para>

            <figure>
              <title>Figure 3. Alternative forms of parentheses used
                when positioning Kanji vertically</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fig3c.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para>A <emphasis>multiple substitution</emphasis>
              replaces a single glyph with more than one glyph. This
              is used to specify actions such as ligature
              decomposition (see Figure 4)</para>

            <figure>
              <title>Figure 4. Decomposing a Latin ligature glyph into
                its individual glyph components</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fig3d.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para>An <emphasis>alternate substitution</emphasis>
              identifies functionally equivalent but different looking
              forms of a glyph. These glyphs are often referred to as
              aesthetic alternatives. For example, a font might have
              five different glyphs for the ampersand symbol, but one
              would have a default glyph index in the cmap table. The
              client could use the default glyph or substitute any of
              the four alternatives (see Figure 5)</para>

            <figure>
              <title>Figure 5. Alternative ampersand glyphs in a
                font</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fig3e.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para>A <emphasis>ligature substitution</emphasis>
              replaces several glyph indices with a single glyph
              index, as when an Arabic ligature glyph replaces a
              string of separate glyphs (see Figure 6). When a string
              of glyphs can be replaced with a single ligature glyph,
              the first glyph is substituted with the ligature. The
              remaining glyphs in the string are deleted, this
              includes those glyphs that are skipped as a result of
              lookup flags.</para>

            <figure>
              <title>Figure 6. Three Arabic glyphs and their
                associated ligature glyph</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="fig3f.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para><emphasis>Contextual substitution</emphasis>, the
              most powerful type, describes glyph substitutions in
              context &#x2013; that is, a substitution of one or more glyphs
              within a certain pattern of glyphs. Each substitution
              describes one or more input glyph sequences and one or
              more substitutions to be performed on that sequence.
              Contextual substitutions can be applied to specific
              glyph sequences, glyph classes, or sets of
              glyphs.</para>
          </listitem>

          <listitem>
            <para><emphasis>Chaining contextual
                substitution</emphasis>, extends the capabilities of
              contextual substitution. With this, one or more
              substitutions can be performed on one or more glyphs
              within a pattern of glyphs (input sequence), by chaining
              the input sequence to a 'backtrack' and/or 'lookahead'
              sequence. Each such substitution can be applied in three
              formats to handle glyphs, glyph classes or glyph sets in
              the input sequence. Each of these formats can describe
              one or more of the backtrack, input and lookahead
              sequences.</para>
          </listitem>

	  <listitem>
	    <para><emphasis>Reverse Chaining contextual single
		substitution</emphasis>, allows one glyph to be
		substituted with another by chaining input glyph to a
		backtrack and/or lookahead sequence. The
		difference between this and other lookup types is that
		processing of input glyph sequence goes from end to
		start.</para>
	  </listitem>
        </itemizedlist>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The model presented in the first paragraph is too
          restrictive; it suggests that only glyphs which are the
          target of cmap tables can be substituted. The proposed
          change is replace the second sentence by: "After characters
          have been mapped to glyphs through the cmap table, the glyph
          run are modified using data in the GSUB table."</para>

        <para>After the list of supported glyph substitutions, it may
          be worth adding a paragraph: "A seventh type of glyph
          substitution (<emphasis>extension substitution</emphasis>)
          does not increase the functionality but is sometimes
          necessary for large GSUB tables.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Table Organization</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>GSUB</ottable> table begins with a header
          that defines offsets to a ScriptList, a FeatureList, and a
          LookupList (see Figure 3g):</para>

        <itemizedlist>
          <listitem>
            <para>The ScriptList identifies all the scripts and
              language systems in the font that use glyph
              substitutes.</para>
          </listitem>
          <listitem>
            <para>The FeatureList defines all the glyph substitution
              features required to render these scripts and language
              systems.</para>
          </listitem>
          <listitem>
            <para>The LookupList contains all the lookup data needed
              to implement each glyph substitution feature.</para>
          </listitem>
        </itemizedlist>

        <para>For a detailed discussion of ScriptLists, FeatureLists,
          and LookupLists, see the chapter Common Table Formats</para>

        <figure>
          <title>Figure 7. High-level organization of <ottable>GSUB</ottable>
          table</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="fig3g.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>This organization helps text-processing clients to
          easily locate the features and lookups that apply to a
          particular script or language system. To access <ottable>GSUB</ottable>
          information, clients should use the following
          procedure:</para>

        <orderedlist>
          <listitem>
            <para>Locate the current script in the
              <ottable>GSUB</ottable> ScriptList table.</para>
          </listitem>
          <listitem>
            <para>If the language system is known, search the script
              for the correct LangSys table; otherwise, use the
              script's default language system (DefaultLangSys
              table).</para>
          </listitem>
          <listitem>
            <para>The LangSys table provides index numbers into the
              <ottable>GSUB</ottable> FeatureList table to access a
              required feature and a number of additional
              features.</para>
          </listitem>
          <listitem>
            <para>Inspect the FeatureTag of each feature, and select
              the features to apply to an input glyph string. Each
              feature provides an array of index numbers into the
              <ottable>GSUB</ottable> LookupList table.</para>
          </listitem>
          <listitem>
            <para>Assemble all lookups from the set of chosen
              features, and apply the lookups in the order given in
              the LookupList table.</para>
          </listitem>
        </orderedlist>

        <para>Lookup data is defined in one or more subtables that
          define the specific conditions, type, and results of a
          substitution action used to implement a feature. All
          subtables in a lookup must be of the same LookupType, as
          listed in the LookupType Enumeration table:</para>

        <table>
          <title>LookupType Enumeration table for glyph
            substitution</title>

          <tgroup cols='3'>
            <colspec colwidth="3pc"/>
            <colspec colwidth="11pc"/>
            <colspec colwidth="16pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>1</entry>
                <entry>Single</entry>
                <entry>Replace one glyph with one glyph </entry>
              </row>

              <row>
                <entry>2</entry>
                <entry>Multiple</entry>
                <entry>Replace one glyph with more than one
                  glyph</entry>
              </row>

              <row>
                <entry>3</entry>
                <entry>Alternate</entry>
                <entry>Replace one glyph with one of many
                  glyphs</entry>
              </row>

              <row>
                <entry>4</entry>
                <entry>Ligature</entry>
                <entry>Replace multiple glyphs with one glyph</entry>
              </row>

              <row>
                <entry>5</entry>
                <entry>Context</entry>
                <entry>Replace one or more glyphs in context</entry>
              </row>

              <row>
                <entry>6</entry>
                <entry>Chaining Context</entry>
                <entry>Replace one or more glyphs in chained
                  context</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Extension Substitution</entry>
                <entry>Extension mechanism for other substitutions
                  (i.e. this excludes the Extension type substitution
                  itself)</entry>
              </row>
	      <row>
		<entry>8</entry>
		<entry>Reverse chaining context single</entry>
		<entry>Applied in reverse order, replace single glyph
		in chaining context</entry>
	      </row>
              <row>
                <entry>9+</entry>
                <entry>Reserved</entry>
                <entry>For future use</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <para>Each LookupType subtable has one or more formats. The
          "best" format depends on the type of substitution and the
          resulting storage efficiency. When glyph information is best
          presented in more than one format, a single lookup may
          define more than one subtable, as long as all the subtables
          are for the same LookupType. For example, within a given
          lookup, a glyph index array format may best represent one
          set of target glyphs, whereas a glyph index range format may
          be better for another set.</para>

        <para>A series of substitution operations on the same glyph or
          string requires multiple lookups, one for each separate
          action. Each lookup is given a different array number in the
          LookupList table and is applied in the LookupList
          order.</para>

        <para>During text processing, a client applies a lookup to
          each glyph in the string before moving to the next lookup. A
          lookup is finished for a glyph after the client locates the
          target glyph or glyph context and performs a substitution,
          if specified. To move to the "next" glyph, the client will
          typically skip all the glyphs that participated in the
          lookup operation: glyphs that were substituted as well as
          any other glyphs that formed a context for the
          operation.</para>

        <para>In the case of chained contextual lookups, glyphs
          comprising backtrack and lookahead sequences may participate
          in more than one context.</para>

        <para>The rest of this chapter describes the
          <ottable>GSUB</ottable> header and the subtables defined for
          each <ottable>GSUB</ottable> LookupType. Examples at the end
          of this page illustrate each of the five LookupTypes,
          including the three formats available for contextual
          substitutions.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>Last sentence: the occurrence of 'five' should be
          replaced by 'seven'.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>GSUB lookup types</code-title>
  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "1" | "singleSubst" },
    element singleSubst { singleSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "2" | "multipleSubst" },
    element multipleSubst { multipleSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "3" | "alternateSubst" },
    element alternateSubst { alternateSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "4" | "ligatureSubst" },
    element ligatureSubst { ligatureSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "5" | "contextual" },
    element contextual { contextualTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "6" | "chainingContextual" },
    element chainingContextual { chainingContextualTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { "7" | "extensionSubst" },
    element extensionSubst { extensionTableOffset }*
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>GSUB header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>GSUB</ottable> table begins with a header
          that contains a version number for the table (Version) and
          offsets to a three tables: ScriptList, FeatureList, and
          LookupList. For descriptions of each of these tables, see
          the chapter, Common Table Formats. Example 1 at the end of
          this chapter shows a <ottable>GSUB</ottable> Header table
          definition.</para>

        <otformat>
          <title>GSUB Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the <ottable>GSUB</ottable>
              table &#x2013; initially set to 0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ScriptList</otfieldname>
            <otfielddesc>Offset to ScriptList table &#x2013; from beginning of
              <ottable>GSUB</ottable> table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>FeatureList</otfieldname>
            <otfielddesc>Offset to FeatureList table &#x2013; from beginning of
              <ottable>GSUB</ottable> table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookupList</otfieldname>
            <otfielddesc>Offset to LookupList table &#x2013; from beginning of
              <ottable>GSUB</ottable> table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>There is a typo in the first sentence "... to a three
          tables:..."</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>GSUB table</code-title>
GSUB =
  element GSUB {
    attribute major { "1" },
    attribute minor { "0" },
    element scriptList { scriptListTableOffset },
    element featureList { featureListTableOffset },
    element lookupList { GSUBlookupListTableOffset },

    (  standaloneScriptListTable
     | standaloneScriptTable
     | standaloneLangSysTable
     | standaloneFeatureListTable
     | standaloneFeatureTable
     | standaloneGSUBLookupListTable
     | standaloneGSUBLookupTable
     | standaloneSingleSubstTable
     | standaloneMultipleSubstTable
     | standaloneAlternateSubstTable
     | standaloneLigatureSubstTable
     | standaloneContextualTable
     | standaloneChainingContextualTable
     | standaloneExtensionTable
     | standaloneCoverageTable
     | standaloneClassDefTable
     | standaloneDeviceTable)*
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gsub.methods'>
  public void fromXML (Element t)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block> blockCache = new HashMap&lt;Element, Block> ();
    NodeList l = t.getChildNodes ();

    Block me = new Block (10, 3);
    me.setFixed (0, 1, 0);

    Map&lt;String, Integer> lookupIndices = new HashMap&lt;String, Integer> ();
    Block b1 = lookupListTableFromXML ((Element) l.item (2),
                                       t, blockCache,
                                       lookupIndices);

    Map&lt;String, Integer> featureIndices = new HashMap&lt;String, Integer> ();
    Block b2 = featureListTableFromXML ((Element) l.item (1),
                                        t, blockCache,
                                        lookupIndices, featureIndices);

    Block b3 = scriptListTableFromXML ((Element) l.item (0),
                                       t, blockCache,
                                       featureIndices);

    me.setOffset (4, b3);
    me.setOffset (6, b2);
    me.setOffset (8, b1);
    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] counts = new int [data.length];
    for (int i = 0; i &lt; counts.length; i++) {
      counts [i] = 0; }

    scriptListTableToXMLCount (getOffset (4), counts);
    featureListTableToXMLCount (getOffset (6), counts);
    lookupListTableToXMLCount (getOffset (8), counts);

    if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 1; }}
    if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 2; }}
    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);

    conf.ch.startElement ("GSUB", at); {

      scriptListTableOffsetToXML (conf, getOffset (4), counts,
                                  "scriptList", new AttributesImpl ());
      featureListTableOffsetToXML (conf, getOffset (6), counts,
                                   "featureList", new AttributesImpl ());
      lookupListTableOffsetToXML (conf, getOffset (8), counts,
                                  "lookupList", new AttributesImpl ());

      scriptListTableToXML (conf, getOffset (4), counts);
      featureListTableToXML (conf, getOffset (6), counts);
      lookupListTableToXML (conf, getOffset (8), counts);
      conf.ch.endElement ("GSUB"); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We have a class that represents a
          <ottable>GSUB</ottable> table and provides the appropriate
          operations.</para>

<code-fragment package='com.adobe.aots.opentype' class='Gsub'>
  <code-title>GSUB Class</code-title>
package com.adobe.aots.opentype;

import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Gsub extends LookupTable {

  <code-include linkend='gsub_globals_1'/>

  public Gsub () {
    super (Tag.GSUB, null);
  }

  public Gsub (Font font) {
    super (Tag.GSUB, font);
  }

  public int[] getTableVersion () {
    return getFixed (0);
  }

  <code-include linkend='gsub.methods' title='GSUB methods'/>
}
</code-fragment>

        <para>The base class of Gsub defines a number of abstract
          methods to access the ScriptList, the FeatureList and the
          LookupList:</para>

<code-fragment id='gsub.methods'>
  <code-title>Methods to find ScriptList, FeatureList and LookupList</code-title>
  int getScriptListOffset () {
    return getOffset (4);
  }

  int getFeatureListOffset () {
    return getOffset (6);
  }

  int getLookupListOffset () {
    return getOffset (8);
  }
</code-fragment>

        <para>The most basic operation is to apply a given lookup
          subtable to a given position in a glyph run. This method
          returns -1 if the subtable does not apply (i.e. its context
          pattern does not match the glyph run), or the position of
          first glyph following context pattern match.</para>

<code-fragment id='gsub.methods'>
  <code-title>Method to apply a GSUB subtable to a glyph</code-title>
  public LookupResult applyLookupSubtable (int lookupIndex, int lookupType, int lookupFlag,
                                int stOffset, GlyphRun gr, int curGlyph)
    throws InvalidFontException {

    switch (lookupType) {
      case 1: { <code-include linkend='gsub_1'/> }
      case 2: { <code-include linkend='gsub_2'/> }
      case 3: { <code-include linkend='gsub_3'/> }
      case 4: { <code-include linkend='gsub_4'/> }
      case 5: { return applyContextualLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      case 6: { return applyChainingContextualLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      case 7: { return applyExtensionLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      default: {
        throw new InvalidFontException ("GSUB -" + lookupType + "-"); }}
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>


        <para>Our test framework for <ottable>GSUB</ottable>
          transformations is to apply a set of features to a glyphrun
          tagged with a script and a language.</para>

<code-fragment package='com.adobe.aots.opentype' class='GsubTester'>
  <code-title>GsubTest class</code-title>
  package com.adobe.aots.opentype;

  <code-include linkend='test_imports'/>

  public class GsubTester {

    <code-include linkend='test_methods'/>

    public static void main (String[] args) {
      try {
        String testName = "anonymousTest";
	URL fontURL = null;
	Font font = null;
	long script = Tag.string2tag ("latn");
	long language = Tag.string2tag ("DFLT");
	long[] features = null;
        int[] inputs = null;
	int[] expected = null;
	int traceDepth = 3;
	String svgTraceOutput = null;
	String textTraceOutput = null;

        for (int i = 0; i &lt; args.length; i++) {
          if ("-testname".equals (args [i])) {
	    i++;
	    testName = args [i]; }

	  if ("-font".equals (args [i])) {
	    i++;
	    fontURL = new File (args [i]).getAbsoluteFile ().toURL ();
	    font = new Font ();
	    font.fromBinary (fontURL); }

	  if ("-script".equals (args [i])) {
	    i++;
	    script = Tag.string2tag (args [i]); }

	  if ("-language".equals (args [i])) {
	    i++;
	    language = Tag.string2tag (args [i]); }

	  if ("-features".equals (args [i])) {
	    i++;
	    features = Tag.string2tags (args [i]); }

	  if ("-glyphs".equals (args [i])) {
	    i++;
	    inputs = parseIntList (args [i]); }

	  if ("-expected".equals (args [i])) {
	    i++;
	    expected = parseIntList (args [i]); }

	  if ("-tracedepth".equals (args [i])) {
	    i++;
	    traceDepth = Integer.parseInt (args [i]); }

	  if ("-trace=svg".equals (args [i])) {
	    i++;
	    svgTraceOutput = args [i]; }

	  if ("-trace=text".equals (args [i])) {
	    i++;
	    textTraceOutput = args [i]; }}

        LookupTableListener listener = null;
        if (svgTraceOutput != null) {
          SVGLookupTableListener l = new SVGLookupTableListener (traceDepth);
          java.io.PrintStream out
            = new java.io.PrintStream (new java.io.FileOutputStream (svgTraceOutput));
          l.init (font, fontURL, out, false, false);
          font.gsub.setLookupTableListener (l);
          listener = l; }
        else if (textTraceOutput != null) {
          LookupTableListener l = new TextLookupTableListener (traceDepth);
          java.io.PrintStream out
            = new java.io.PrintStream (new java.io.FileOutputStream (textTraceOutput));
          l.init (font, fontURL, out, false);
          font.gsub.setLookupTableListener (l);
          listener = l; }

        GlyphRunImpl gr = new GlyphRunImpl ();
        gr.glyphs = inputs;
        gr.totGlyphs = inputs.length;

        font.gsub.applyFeatures (script, language, features, gr);

        if (listener != null) {
          listener.shutdown (); }

        if (expected != null) {
          boolean pass = compareIntLists (expected, gr.glyphs, gr.glyphCount ()) ;
          if (pass == false) {
            System.err.print ("Wanted: ");
            for (int i = 0; i &lt; expected.length; i++) {
              System.err.print (" " + expected [i]); }
            System.err.println ();
            System.err.print ("Actual: ");
            for (int i = 0; i &lt; gr.glyphCount (); i++) {
              System.err.print (" " + gr.glyphs [i]); }
            System.err.println (); }

          reportStatus (testName, pass); }}

      catch (Exception e) {
        System.out.println ("Exception: " + e.getMessage ());
        e.printStackTrace (); }
    }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

        <code-fragment id='gsub.methods'>
          <code-title>GSUB Validation Method</code-title> public void
          validate () { }
        </code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 1: Single Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Single substitution (SingleSubst) subtables tell a
          client to replace a single glyph with another glyph. The
          subtables can be either of two formats. Both formats require
          two distinct sets of glyph indices: one that defines input
          glyphs (specified in the Coverage table), and one that
          defines the output glyphs. Format 1 requires less space than
          Format 2, but it is less flexible.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>None.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>Our generic format for single substitions describes the mapping one  substitution at a time.</para>

<code-fragment id='schema'>
  <code-title>singleSubstTable</code-title>
  singleSubstTable |=
    attribute format { "any" },
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneSingleSubstTable =
    element singleSubstTable { attribute id { text }, singleSubstTable }

  singleSubstTableOffset = attribute name { text } | singleSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

        <para>A single substitution represented as a sequence of
        <sgmltag>subst</sgmltag> elements is equivalent to a single
        single substitution represented with single format 2 subtable,
        with those substs as its children.</para>

<code-fragment id='gsub.methods'>
  <code-title>Compile GSUB 1 subtable</code-title>
  private Block singleSubstLookupFromXML (Element lookupSubtable,
                                          Element table,
                                          Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute ("format");
    if ("1".equals (format)) {
      return singleSubstFormat1FromXML (lookupSubtable, table, blockCache); }
    if ("2".equals (format) || "any".equals (format)) {
      return singleSubstFormat2FromXML (lookupSubtable, table, blockCache); }

    /*cannot get here with valid instance*/
    throw new InvalidFontException (
      "invalid single substitution format (" + format + ")");
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.toXMLCount_1'>
  <code-title>Count references for GSUB 1 subtable</code-title>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gsub.toXMLCount_1_1'/>; break; }
    case 2: { <code-include linkend='gsub.toXMLCount_1_2'/>; break; }}
</code-fragment>

<code-fragment id='gsub.toXML_1'>
  <code-title>Emit references for GSUB 1 subtable</code-title>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gsub.toXML_1_1'/>; break; }
    case 2: { <code-include linkend='gsub.toXML_1_2'/>; break; }}
</code-fragment>

<code-fragment id='gsub.toXMLEmit_1'>
  <code-title>Emit GSUB 1 subtable</code-title>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend='gsub.toXMLEmit_1_1'/>; break; }
    case 2: { <code-include linkend='gsub.toXMLEmit_1_2'/>; break; }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Both subtable formats start with the same field, the
          uint16 SubstFormat, so that we can distinguish them.</para>

<code-fragment id='gsub_1'>
  <code-title>Execute GSUB 1 subtable and return</code-title>
  { int substFormat = getuint16 (stOffset);
    switch (substFormat) {
      case 1: { <code-include linkend='gsub_1_1'/> }
      case 2: { <code-include linkend='gsub_1_2'/> }
      default: {
        throw new InvalidFontException ("GSUB 1/-" + substFormat + "-"); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

<code-fragment id='validate_gsub_1'>
  <code-title>GSUB 1 subtable validation</code-title>
  ensureAvailableBytes (gsub, 0, 2);
  int substFormat = getuint16 (stOffset);
  switch (substFormat) {
    case 1: { <code-include linkend='validate_gsub_1_1'/>; break; }
    case 2: { <code-include linkend='validate_gsub_1_2'/>; break; }
    default: reportError ("GSUB Subtable at offset " + stOffset
                          + " has an invalid SubstFormat ("
                          + substFormat + ")"); }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Single Substitution Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 1 calculates the indices of the output glyphs,
          which are not explicitly defined in the subtable. To
          calculate an output glyph index, Format 1 adds a constant
          delta value to the input glyph index. For the substitutions
          to occur properly, the glyph indices in the input and output
          ranges must be in the same order. This format does not use
          the Coverage Index that is returned from the Coverage
          table.</para>

        <para>The SingleSubstFormat1 subtable begins with a format
          identifier (SubstFormat) of 1. An offset references a
          Coverage table that specifies the indices of the input
          glyphs. DeltaGlyphID is the constant value added to each
          input glyph index to calculate the index of the
          corresponding output glyph.</para>

        <para>Example 2 at the end of this chapter uses Format 1 to
          replace standard numerals with lining numerals.</para>

        <otformat>
          <title>SingleSubstFormat1 subtable: Calculated output glyph
            indices</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>DeltaGlyphID</otfieldname>
            <otfielddesc>Add to original GlyphID to get substitute
              GlyphID</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>I cannot figure out what the third sentence of the first
          paragraph really says. It it phrased as a requirement on the
          way the lookup is built, yet it seems to describe a property
          that follows from the nature of GSUB 1/1
          lookups. Recommendation: remove it for the
          specification.</para>

        <para>In the spirit of cmaps subtable format 4, the arithmetic
          on the glyph index should probably be performed modulo
          65536. Recommendation: make that explicit.</para>

	<para>The pattern matched by this subtable is &#x25B6; C
	  &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C; if the id of that glyph is g, then the
	  replacement glyph has id (g+DeltaGlyphId) % 0xffff.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Single substitution format 1 type</code-title>
  singleSubstTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset },
    element delta {
      attribute v { text }
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gsub.methods'>
  <code-title>Compile GSUB 1/1 subtable</code-title>
  private Block singleSubstFormat1FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Element coverageNode = (Element)subtable.getFirstChild ();
    Element deltaNode = (Element) coverageNode.getNextSibling ();
    String deltaValue = deltaNode.getAttribute ("v");

    Block coverage = coverageFromXML (coverageNode, table, blockCache);
    int delta = Integer.parseInt (deltaValue);

    Block me = new Block (6, 1);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setint16  (4, delta);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.toXMLCount_1_1'>
  <code-title>Count references for GSUB 1/1 subtable</code-title>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gsub.toXML_1_1'>
  <code-title>Emit references for GSUB 1/1 subtable</code-title>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gsub.toXMLEmit_1_1'>
  <code-title>Emit GSUB 1/1 subtable</code-title>
  int coverageOffset = stOffset + getOffset (stOffset + 2);

  at = new AttributesImpl ();
  coverageTableOffsetToXML (conf, coverageOffset, counts, "coverage", at);

  at = new AttributesImpl ();
  at.addAttribute ("", "v", "v", "CDATA", "" + getint16 (stOffset + 4));
  conf.ch.element ("delta", at);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gsub_1_1'>
  <code-title>Execute GSUB 1/1 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), coverageOffset) == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int deltaGlyphId = getint16 (stOffset + 4);
    int newGlyphId = (gr.glyphAt (inPos) + deltaGlyphId) &amp; 0xffff;
    if (listener != null) {
      listener.replace (gr.glyphAt (inPos), newGlyphId);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, "GSUB", stOffset); }
    gr.replace (inPos, newGlyphId);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

	<section>
	  <title>gsub1_1_simple</title>

	  <para>Our first test is fairly simple. It translates glyphs 18
	  and 19 by 5, to get glyphs 23 and 24:</para>

<aots:test-font id='gsub1_1_simple_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='1'>
	<singleSubst format='1'>
	  <coverage glyphs='18 19' format='any'/>
	  <delta v='5'/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub1_1_simple_t1' font='gsub1_1_simple_f1'
	   inputs= '17, 18, 19, 20, 21'
	   outputs='17, 23, 24, 20, 21'/>
	</section>

	<section>
	  <title>gsub1_1_lookupflag</title>

	  <para>Our second test case exercises LookupFlag. The trick
	  to have a glyph which is both in the collection defined by
	  LookupFlag and transformed. Since LookupFlag takes
	  precedence over Coverage, the glyph should not be
	  transformed. In addition, looking at the step by step
	  execution of the lookup over the glyphrun, one should see
	  that there is a single lookup application for this glyph and
	  the next glyph (which is transformed). While the font may
	  seem at first improperly built, it could be that the
	  Coverage is shared with another table.</para>

<aots:test-font id='gsub1_1_lookupflag_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='1'>
	<singleSubst format='1'>
	  <coverage glyphs='18 19' format='any'/>
	  <delta v='5'/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub1_1_lookupflag_t1' font='gsub1_1_lookupflag_f1'
	   inputs= '17, 18, 19, 20, 21'
	   outputs='17, 18, 24, 20, 21'/>
	</section>

	<section>
	  <title>gsub1_1_modulo</title>

	  <para>An interesting test case involves exercising the
	  "modulo" nature of the glyph computation, since it is not
          explicit in the specification. In a modulo arithmetic
          system, there are two cases to consider: when the sum of two
          numbers goes over the base (overflow); and when the sum of
          two (signed) numbers goes below 0 (underflow). Our test font
          includes one feature, with two lookups and all their
          subtables in format 1</para>

	  <para>The behaviour of the test feature is:</para>

	  <table>
	    <title>Test feature</title>

	    <tgroup cols='5'>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <thead>
		<row>
		  <entry>Input glyph</entry>
		  <entry>Lookup 1</entry>
		  <entry>Intermediate glyph</entry>
		  <entry>Lookup 2</entry>
		  <entry>Output glyph</entry>
		</row>
	      </thead>
	      <tbody>
              <row>
		<entry>21</entry>
		<entry>subtable 1: +32766</entry>
		<entry>32787</entry>
		<entry>subtable 3: -32764</entry>
		<entry>23</entry>
		</row>
		<row>
		  <entry>22</entry>
		  <entry>subtable 1: +32766</entry>
		  <entry>32788</entry>
		  <entry>subtable 4: +32766 (overflow)</entry>
		  <entry>18</entry>
		</row>
		<row>
		  <entry>19</entry>
		  <entry>subtable 2: -32766 (underflow)</entry>
		  <entry>32789</entry>
		  <entry>subtable 5: +32764 (overflow)</entry>
		  <entry>17</entry>
		</row>
		<row>
		  <entry>20</entry>
		  <entry>subtable 2: -32766 (underflow)</entry>
		  <entry>32790</entry>
		  <entry>subtable 6: -32766</entry>
		  <entry>24</entry>
		</row>
		<row>
		  <entry>anything else</entry>
		  <entry>unchanged</entry>
		  <entry></entry>
		  <entry></entry>
		  <entry></entry>
		</row>
		<row>
		  <entry></entry>
		  <entry></entry>
		  <entry>anything else</entry>
		  <entry>unchanged</entry>
		  <entry></entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>This test case is a bit contrived, because the base font
          on which we apply it does not have pairs of glyphs such that
          one can be reached from the other via a legal DeltaGlyphID
          value involving an overflow or underflow. Instead, we do
          that in two steps (hence the two lookups). The intermediate
          glyph is not in the font, but the first and third
          transformations above help us validate that the program
          under test does not care about that.</para>

<aots:test-font id='gsub1_1_modulo_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <scriptList>
      <script tag='latn'>
	<defaultLangSys>
	  <featureIndex name='feature.test'/>
	</defaultLangSys>
      </script>
    </scriptList>

    <featureList>
      <feature id='feature.test' tag='test'>
	<lookupIndex name="lookup.test.1"/>
	<lookupIndex name="lookup.test.2"/>
      </feature>
    </featureList>

    <lookupList>
      <lookup  id='lookup.test.1' type='1'>
	<singleSubst format='1'>
	  <coverage glyphs="21 22" format='any'/>
	  <delta v='32766'/>
	</singleSubst>
	<singleSubst format='1'>
	  <coverage glyphs="19 20" format='any'/>
	  <delta v='-32766'/>
	</singleSubst>
      </lookup>

      <lookup id='lookup.test.2' type='1'>
	<singleSubst format='1'>
	  <coverage glyphs="32787" format='any'/>
	  <delta v='-32764'/>
	</singleSubst>
	<singleSubst format='1'>
	  <coverage glyphs="32788" format='any'/>
	  <delta v='32766'/>
	</singleSubst>
	<singleSubst format='1'>
	  <coverage glyphs="32789" format='any'/>
	  <delta v='32764'/>
	</singleSubst>
	<singleSubst format='1'>
	  <coverage glyphs="32790" format='any'/>
	  <delta v='-32766'/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub1_1_modulo_t1' font='gsub1_1_modulo_f1'
	   inputs= '17, 18, 19, 20, 21, 22, 23, 24'
	   outputs='17, 18, 17, 24, 23, 18, 23, 24'/>

	  <para>Translated to characters (for use with InDesign), the
          string "0123456789" gets translated to "0107616789".</para>

	</section>
      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

        <para>Remembering our general discussion of lookupFlag
          [insert link here], we have a warning-level message if the
          coverage table includes any glyph that is also covered by
          lookupFlag.</para>

<code-fragment id='validate_gsub_1_1'>
  <code-title>Validate GSUB 1/1 subtable</code-title>
  ensureAvailableBytes (stOffset, 6);
  markByteRange (stOffset, 6, FRAGMENT_TYPE_GSUB_1_1);
  int coverageOffset = stOffset + getuint16 (stOffset + 2);
  validateCoverageTable (coverageOffset);
  warnIfCoverageOverlapsLookupFlag (lookupFlag, gsub, coverageOffset);
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Single Substitution Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 2 is more flexible than Format 1, but requires
          more space. It provides an array of output glyph indices
          (Substitute) explicitly matched to the input glyph indices
          specified in the Coverage table.</para>

        <para>The SingleSubstFormat2 subtable specifies a format
          identifier (SubstFormat), an offset to a Coverage table that
          defines the input glyph indices, a count of output glyph
          indices in the Substitute array (GlyphCount), and a list of
          the output glyph indices in the Substitute array
          (Substitute).</para>

        <para>The Substitute array must contain the same number of
          glyph indices as the Coverage table. To locate the
          corresponding output glyph index in the Substitute array,
          this format uses the Coverage Index returned from the
          Coverage table.</para>

        <para>Example 3 at the end of this chapter uses Format 2 to
          substitute vertically oriented glyphs for horizontally
          oriented glyphs.</para>

        <otformat>
          <title>SingleSubstFormat2 subtable: Specified output glyph
            indices</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of GlyphIDs in the Substitute
              array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Substitute [GlyphCount]</otfieldname>
            <otfielddesc>Array of substitute GlyphIDs &#x2013; ordered by
              Coverage Index</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>To adopt a consistent language, the third paragraph should
          be changed to "The Coverage index of the input glyph is used to
          index the Susbtitute array and GlyphCount must equal the number of
          covered glyphs."</para>

	<para>The pattern matched by this subtable is &#x25B6; C
	  &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C by the corresponding glyph in the Substitute
	  array.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Single substitution format 2 type</code-title>
  singleSubstTable |=
    attribute format { "2" },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gsub.methods'>
  private Block singleSubstFormat2FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if (! "coverage".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (subtable.getChildNodes (), "in"); }
    else {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    int[] replacement = new int [coverage.glyphs.length];
    for (int i = 0; i &lt; replacement.length; i++) {
      replacement [i] = -1; }

    NodeList children = subtable.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element subst = (Element) children.item (i);
      int[] in = getGlyphs (subst.getAttribute ("in"));
      int[] out = getGlyphs (subst.getAttribute ("out"));

      if (in.length != 1) {
        warning ("subst in singleSubstFormat2 must have 'in' attribute "
                 + " with exactly 1 glyph"); }
      if (out.length != 1) {
        warning ("subst in singleSubstFormat2 must have 'out' attribute "
                 + " with exactly 1 glyph"); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          replacement [j] = out [0];
          covered = true;
          break; }}

      if (covered == false) {
        warning ("in glyph '" + in [0]
                 + "' must be covered in singleSubstFormat2"); }}

    for (int j = 0; j &lt; replacement.length; j++) {
      if (replacement [j] == -1) {
        warning ("covered glyph " + coverage.glyphs [j]
                 + " not replaced in singleSubstFormat1"); }}

    me = new Block (6 + 2 * coverage.glyphs.length, 1);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setint16  (4, coverage.glyphs.length);


    for (int i = 0; i &lt; replacement.length; i++) {
      me.setGlyphID (6 + 2*i, replacement [i]); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.toXMLCount_1_2'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gsub.toXML_1_2'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id='gsub.toXMLEmit_1_2'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int glyphCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; glyphCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "in", "in", "CDATA",
                       glyphToXML (conf, glyphs [i]));
      at.addAttribute ("", "out", "out", "CDATA",
                       glyphToXML (conf, getuint16 (stOffset + 6 + 2*i)));
      conf.ch.element ("subst", at); }
</code-fragment>
     </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gsub_1_2'>
  <code-title>Execute GSUB 1/2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci  == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int oldGlyphId = gr.glyphAt (inPos);
    int newGlyphId = getGlyphID (stOffset + 6 + 2*ci);

    if (listener != null) {
      listener.replace (oldGlyphId, newGlyphId);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, "GSUB", stOffset); }

    gr.replace (inPos, newGlyphId);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gsub1_2_simple</title>

          <para>A simple test to start. Glyph 18 has coverage index 0,
            and is replaced by glyph 22; glyph 20 has coverage index 1,
            and is replaced by glyph 25.</para>

<aots:test-font id='gsub1_2_simple_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>

    <lookupList>
      <lookup id="lookup.test" type='1'>
	<singleSubst format='2'>
	  <coverage glyphs='18 20' format='any'/>
	  <subst in="18" out="22"/>
	  <subst in="20" out="25"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub1_2_simple_t1' font='gsub1_2_simple_f1'
	   inputs= '17, 18, 19, 20, 21'
	   outputs='17, 22, 19, 25, 21'/>
        </section>

        <section>
          <title>gsub1_2_lookupflag</title>

          <para>Our second tests exercises LookupFlag, which captures
          glyph 18. In order to isolate the behaviour of LookupFlag,
          we need to make sure that glyph 18 is covered by the lookup
          itself.</para>

<aots:test-font id='gsub1_2_lookupflag_f1'>
  <base-font name='base.otf'/>

  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs='yes' type='1'>
	<singleSubst format='2'>
	  <coverage glyphs='18 20' format='any'/>
	  <subst in="18" out="22"/>
	  <subst in="20" out="25"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub1_2_lookupflag_t1' font='gsub1_2_lookupflag_f1'
	   inputs= '17, 18, 19, 20, 21'
	   outputs='17, 18, 19, 25, 21'/>
        </section>

      </section>

      <!--____________________________________________________________________-->
      <section role='validation'>
        <title>Validation</title>

<code-fragment id='validate_gsub_1_2'>
  <code-title>Validate GSUB 1/2 subtable</code-title>
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>LookupType 2: Multiple Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Multiple Substitution (MultipleSubst) subtable
          replaces a single glyph with more than one glyph, as when
          multiple glyphs replace a single ligature. The subtable has
          a single format: MultipleSubstFormat1. The subtable
          specifies a format identifier (SubstFormat), an offset to a
          Coverage table that defines the input glyph indices, a count
          of offsets in the Sequence array (SequenceCount), and an
          array of offsets to Sequence tables that define the output
          glyph indices (Sequence). The Sequence table offsets are
          ordered by the Coverage Index of the input glyphs. </para>

        <para>For each input glyph listed in the Coverage table, a
          Sequence table defines the output glyphs. Each Sequence
          table contains a count of the glyphs in the output glyph
          sequence (GlyphCount) and an array of output glyph indices
          (Substitute).</para>

        <blockquote>
          <para>Note: The order of the output glyph indices depends on
            the writing direction of the text. For text written left
            to right, the left-most glyph will be first glyph in the
            sequence. Conversely, for text written right to left, the
            right-most glyph will be first. </para>
        </blockquote>

        <para>The use of multiple substitution for deletion of an
          input glyph is prohibited. GlyphCount should always be
          greater than 0.</para>

        <para>Example 4 at the end of this chapter shows how to
          replace a single ligature with three glyphs.</para>

        <otformat>
          <title>MultipleSubstFormat1 subtable: Multiple output glyphs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SequenceCount</otfieldname>
            <otfielddesc>Number of Sequence table offsets in the
              Sequence array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Sequence [SequenceCount]</otfieldname>
            <otfielddesc>Array of offsets to Sequence tables &#x2013; from
              beginning of Substitution table &#x2013; ordered by Coverage
              Index</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>Sequence table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of GlyphIDs in the Substitute array.
              This should always be greater than 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Substitute [GlyphCount]</otfieldname>
            <otfielddesc>String of GlyphIDs to
              substitute</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>To adopt a consistent language, the last sentence of the
          first paragraph should be changed to: "The Coverage index of
          the input glyph is used to index the Sequence array and
          SequenceCount must equal the number of covered glyphs. The
          entries in the Sequence array cannot be NULL."</para>

	<para>The pattern matched by this subtable is &#x25B6; C
	  &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C by the Substitute sequence of glyphs in the
	  corresponding Sequence table, in the order in which they
	  appear in that array.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a multiple substitution, but instead
	  would prefer the compiler to figure out the best
	  representation.:</para>

<code-fragment id='schema'>
  <code-title>MultipleSubst type</code-title>
  multipleSubstTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneMultipleSubstTable =
    element multipleSubstTable { attribute id { text }, multipleSubstTable }

  multipleSubstTableOffset = attribute name { text } | multipleSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gsub.methods'>
  private Block multipleSubstFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if ("coverage".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }
    else {
      coverage = coverageFromXML (subtable.getChildNodes (), "in"); }


    int[][] replacement = new int [coverage.glyphs.length][];
    for (int i = 0; i &lt; replacement.length; i++) {
      replacement [i] = new int [0]; }

    NodeList children = subtable.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element subst = (Element) children.item (i);
      int[] in = getGlyphs (subst.getAttribute ("in"));
      int[] out = getGlyphs (subst.getAttribute ("out"));

      if (in.length != 1) {
        warning ("subst in multipleSubstFormat1 must have 'in' attribute "
                 + " with exactly 1 glyph"); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          replacement [j] = out;
          covered = true;
          break; }}

      if (covered == false) {
        warning ("in glyph '" + in [0]
                 + "' must be covered in multipleSubstFormat1"); }}

    me = new Block (6 + 2 * coverage.glyphs.length, 1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setint16  (4, coverage.glyphs.length);

    for (int i = 0; i &lt; coverage.glyphs.length; i++) {
      Block sequenceTable = new Block (2 + 2 * replacement [i].length, 0);
      sequenceTable.setuint16 (0, replacement [i].length);
      for (int g = 0; g &lt; replacement [i].length; g++) {
        sequenceTable.setGlyphID (2 + 2*g, replacement [i][g]); }
      me.setOffset (6 + 2*i, sequenceTable); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.toXMLCount_2'>
  /* nothing */
</code-fragment>

<code-fragment id='gsub.toXML_2'>
  /* nothing */
</code-fragment>

<code-fragment id='gsub.toXMLEmit_2'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int sequenceCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; sequenceCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "in", "in", "CDATA",
                       glyphToXML (conf, glyphs [i]));

      int sequenceOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      StringBuilder s = new StringBuilder ();
      for (int g = 0; g &lt; getuint16 (sequenceOffset); g++) {
        glyphToXML (conf, s, getuint16 (sequenceOffset + 2 + 2*g)); }
      at.addAttribute ("", "out", "out", "CDATA", s.toString ());
      conf.ch.element ("subst", at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='gsub_2'>
  <code-title>Execute GSUB 2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int sequenceOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int oldGlyphId = gr.glyphAt (inPos);
    int glyphCount = getuint16 (sequenceOffset);
    int [] newGlyphIds = new int [glyphCount];
    for (int g = 0; g &lt; glyphCount; g++) {
      newGlyphIds [g] = getGlyphID (sequenceOffset + 2 +  2*g); }

    if (listener != null) {
      listener.replace (oldGlyphId, newGlyphIds);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, "GSUB", stOffset); }
    gr.replace (inPos, newGlyphIds);

    return new LookupResult (true, inPos + glyphCount, glyphCount - 1); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>gsub2_1_simple</title>

          <para>Our first test is simple. It replaces glyph 18 by glyphs
            20, 21 and 22.</para>

<aots:test-font id='gsub2_1_simple_f1'>
  <base-font name='base.otf'/>

  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='2'>
	<multipleSubst format='1'>
	  <coverage glyphs='18' format='any'/>
	  <subst in='18' out='20 21 22'/>
	</multipleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub2_1_simple_t1' font='gsub2_1_simple_f1'
	   inputs= '17, 18, 19'
	   outputs='17, 20, 21, 22, 19'/>

          <para>This lookup type has the unique property of increasing
            the size of the glyph run. In implementation in which
            glyphs in a glyph run are identified by indices, one must
            be careful to adjust indices as needed. For example, the
            upper bound of a loop that processes all (or some of) the
            glyphs in a glyph run needs to be adjusted if a multiple
            lookup is applied. This test tries to verify this by
            having an occurrence of glyph 18 (the last one) such that
            its indice after other occurrences are replaced is bigger
            than the original index of the last glyph.</para>

          <aots:gsub-test
	   id='gsub2_1_simple_t2' font='gsub2_1_simple_f1'
	   inputs= '17, 18, 19, 18'
	   outputs='17, 20, 21, 22, 19, 20, 21, 22'/>
        </section>

        <section>
          <title>gsub2_1_multiple_sequences</title>

          <para>Our next test verifies that multiple sequences are correctly
            interpreted.</para>

<aots:test-font id='gsub2_1_multiple_sequences_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='2'>
	<multipleSubst format='1'>
	  <coverage glyphs='18 19' format='any'/>
	  <subst in='18' out='20 21'/>
	  <subst in='19' out='22 23'/>
	</multipleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub2_1_multiple_sequences_t1' font='gsub2_1_multiple_sequences_f1'
	   inputs= '17, 18,     19,     17'
	   outputs='17, 20, 21, 22, 23, 17'/>
        </section>

        <section>
          <title>gsub2_1_lookupflag</title>

          <para>Our next test verifies that LookupFlag is correctly
            interpreted.</para>

<aots:test-font id='gsub2_1_lookupflag_f1'>
  <base-font name='base.otf'/>

  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='2' ignoreBaseGlyphs='yes'>
	<multipleSubst format='1'>
	  <coverage glyphs='18 19' format='any'/>
	  <subst in='18' out='20 21'/>
	  <subst in='19' out='22 23'/>
	</multipleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub2_1_lookupflag_t1' font='gsub2_1_lookupflag_f1'
	   inputs= '17, 18, 19,     17'
	   outputs='17, 18, 22, 23, 17'/>
        </section>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>LookupType 3: Alternate Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>An Alternate Substitution (AlternateSubst) subtable
        identifies any number of aesthetic alternatives from which a
        user can choose a glyph variant to replace the input
        glyph. For example, if a font contains four variants of the
        ampersand symbol, the cmap table will specify the index of one
        of the four glyphs as the default glyph index, and an
        AlternateSubst subtable will list the indices of the other
        three glyphs as alternatives. A text-processing client would
        then have the option of replacing the default glyph with any
        of the three alternatives. </para>

        <para>The subtable has one format: AlternateSubstFormat1. The
        subtable contains a format identifier (SubstFormat), an offset
        to a Coverage table containing the indices of glyphs with
        alternative forms (Coverage), a count of offsets to
        AlternateSet tables (AlternateSetCount), and an array of
        offsets to AlternateSet tables (AlternateSet).</para>

        <para>For each glyph, an AlternateSet subtable contains a
        count of the alternative glyphs (GlyphCount) and an array of
        their glyph indices (Alternate). Because all the glyphs are
        functionally equivalent, they can be in any order in the
        array.</para>

        <para>Example 5 at the end of this chapter shows how to
        replace the default ampersand glyph with alternative
        glyphs.</para>

        <otformat>
          <title>AlternateSubstFormat1 subtable: Alternative output
          glyphs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>AlternateSetCount</otfieldname>
            <otfielddesc>Number of AlternateSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>AlternateSet
            [AlternateSetCount]</otfieldname> <otfielddesc>Array of
            offsets to AlternateSet tables &#x2013; from beginning of
            Substitution table &#x2013; ordered by Coverage
            Index</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>AlternateSet table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of GlyphIDs in the Alternate
              array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Alternate [GlyphCount]</otfieldname>
            <otfielddesc>Array of alternate GlyphIDs &#x2013; in arbitrary
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>To adopt a consistent language, the following should be added
          to the second paragraph: "The Coverage index of the input glyph is
          used to index the AlternateSet array and AlternateSetCount must
          equal the number of glyphs covered by Coverage."</para>

        <para>The specification fails to say if an element of the
          AlternateSet array can be null. We assume it cannot. This can be
          added after the sentence above: "The entries in the AlternateSet
          array cannot be NULL."</para>

        <para>The specification fails to say if the GlyphCount of an
          AlternateSet table can be 0. We assume it cannot, and this
          can be made clear by adding this sentence to the third paragraph:
          "GlyphCount cannot be 0."</para>

	<para>The pattern matched by this subtable is &#x25B6; C
	  &#x25C0; where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage &#x2216; LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C by one of the glyphs in the Alternate array
	  corresponding to the replaced glyph. The mechanism by which
	  the client indicates which of those glyphs is used is not
	  specified.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a alternate substitution, but instead
	  would prefer the compiler to figure out the best
	  representation.:</para>

<code-fragment id='schema'>
  <code-title>AlternateSubst type</code-title>
  alternateSubstTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneAlternateSubstTable =
    element alternateSubstTable { attribute id { text }, alternateSubstTable }

  alternateSubstTableOffset = attribute name { text } | alternateSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gsub.methods'>
  private Block alternateSubstFormat1FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if ("subst".equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (subtable.getChildNodes (), "in"); }
    else {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }


    int[][] alternates = new int [coverage.glyphs.length][];
    for (int i = 0; i &lt; alternates.length; i++) {
      alternates [i] = new int [0]; }

    NodeList children = subtable.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element subst = (Element) children.item (i);
      int[] in = getGlyphs (subst.getAttribute ("in"));
      int[] out = getGlyphs (subst.getAttribute ("out"));

      if (in.length != 1) {
        warning ("subst in alternateSubstFormat1 must have 'in' attribute "
                 + " with exactly 1 glyph"); }

      if (out.length == 0) {
        warning ("subst in alternateSubstFormat1 must have 'out' attribute "
                 + " with at least 1 glyph"); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          alternates [j] = out;
          covered = true;
          break; }}

      if (covered == false) {
        warning ("in glyph '" + in [0]
                 + "' must be covered in alternateSubstFormat1"); }}

    me = new Block (6 + 2 * coverage.glyphs.length, 1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setint16  (4, coverage.glyphs.length);

    for (int i = 0; i &lt; coverage.glyphs.length; i++) {
      Block alternateSetTable = new Block (2 + 2 * alternates [i].length, 0);
      alternateSetTable.setuint16 (0, alternates [i].length);
      for (int g = 0; g &lt; alternates [i].length; g++) {
        alternateSetTable.setGlyphID (2 + 2*g, alternates [i][g]); }
      me.setOffset (6 + 2*i, alternateSetTable); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.toXMLCount_3'>
  coverageTableToXMLCount (getOffset (stOffset, 2), counts);
  /* nothing */
</code-fragment>

<code-fragment id='gsub.toXML_3'>
  coverageTableToXML (conf, getOffset (stOffset, 2), counts);
  /* nothing */
</code-fragment>

<code-fragment id='gsub.toXMLEmit_3'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int sequenceCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, coverageOffset, counts, "coverage", at);

    for (int i = 0; i &lt; sequenceCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute ("", "in", "in", "CDATA", glyphToXML (conf, glyphs [i]));

      int sequenceOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      StringBuilder s = new StringBuilder ();
      for (int g = 0; g &lt; getuint16 (sequenceOffset); g++) {
        glyphToXML (conf, s, getuint16 (sequenceOffset + 2 + 2*g)); }
      at.addAttribute ("", "out", "out", "CDATA", s.toString ());
      conf.ch.element ("subst", at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>The nature of this feature is requires that it takes
          some input, namely which alternate glyph to use. Various
          applications will choose different methods, depending on
          their needs, so the method we use here should not be taken
          as implied by the specification.</para>

        <para>To help our testing, we want to have some deterministic
          method, yet we want to have a way to reach all alternate
          glyphs. We maintain a table that records for each
          AlternateSet table the alternate to use in the next
          application. On the first application, the glyph is not
          replaced, on the second application, it is replaced by the
          first alternate; when all alternates have been used, we
          restart the cycle.</para>

<code-fragment id='gsub_globals_1'>
  <code-title>GSUB private members</code-title>
  java.util.Map&lt;Integer, Integer> alternateMap
       = new java.util.HashMap&lt;Integer, Integer> ();
</code-fragment>


<code-fragment id='gsub_3'>
  <code-title>Execute GSUB 3 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int alternateSetOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int glyphCount = getuint16 (alternateSetOffset);

    int alternate = -1;
    Integer o = alternateMap.get (alternateSetOffset);
    if (o != null) {
      alternate = o.intValue (); }

    if (alternate != -1) {
      int oldGlyphId = gr.glyphAt (inPos);
      int newGlyphId = getGlyphID (alternateSetOffset + 2 + 2*alternate);

      if (listener != null) {
        listener.replace (oldGlyphId, newGlyphId);
        listener.applyingSubtable (lookupIndex, gr, curGlyph, "GSUB", stOffset); }
      gr.replace (inPos, newGlyphId); }

    alternate++;
    if (alternate == glyphCount) {
      alternate = -1; }
    alternateMap.put (alternateSetOffset,
                      alternate);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>gsub3_1_simple</title>

          <para>Let&#x2019;s start with a simple test that replaces
          glyph 18 by glyphs 20, 21 or 22.</para>

<aots:test-font id='gsub3_1_simple_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='3'>
	<alternateSubst format='1'>
	  <coverage glyphs='18' format='any'/>
	  <subst in='18' out='20 21 22'/>
	</alternateSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub3_1_simple_t1' font='gsub3_1_simple_f1'
	   inputs ='17, 18, 17, 18, 17, 18, 17, 18, 17, 18, 17, 18, 17'
	   outputs='17, 18, 17, 20, 17, 21, 17, 22, 17, 18, 17, 20, 17'
           select ='-1,  0, -1,  1, -1,  2, -1,  3, -1,  0, -1,  1, -1'/>
        </section>

        <section>
          <title>gsub3_1_multiple</title>

          <para>A slightly more complicated case with two alternate
            sets: 18 can be replaced by 20 or 21, and 19 can be replaced by 22
            or 23.</para>

<aots:test-font id='gsub3_1_multiple_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='3'>
	<alternateSubst format='1'>
	  <coverage glyphs='18 19' format='any'/>
	  <subst in='18' out='20 21'/>
	  <subst in='19' out='22 23'/>
	</alternateSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub3_1_multiple_t1' font='gsub3_1_multiple_f1'
	   inputs ='17, 18, 18, 18, 18, 19, 19, 19, 19, 17'
	   outputs='17, 18, 20, 21, 18, 19, 22, 23, 19, 17'
	   select ='-1,  0,  1,  2,  0,  0,  1,  2,  0, -1'/>
        </section>

        <section>
          <title>gsub3_1_lookupflag</title>

          <para>Let&#x2019;s add a LookupFlag to skip glyph 18.</para>

<aots:test-font id='gsub3_1_lookupflag_f1'>
  <base-font name='base.otf'/>

  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='18'/>
    </glyphClassDef>
  </GDEF>

  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' ignoreBaseGlyphs='yes' type='3'>
	<alternateSubst format='1'>
	  <coverage glyphs='18 19' format='any'/>
	  <subst in='18' out='20 21'/>
	  <subst in='19' out='22 23'/>
	</alternateSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub3_1_lookupflag_t1' font='gsub3_1_lookupflag_f1'
	   inputs ='17, 18, 18, 18, 19, 19, 19, 19, 17'
	   outputs='17, 18, 18, 18, 19, 22, 23, 19, 17'
	   select ='-1, -1, -1, -1,  0,  1,  2,  0, -1'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>LookupType 4: Ligature Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Ligature Substitution (LigatureSubst) subtable
          identifies ligature substitutions where a single glyph
          replaces multiple glyphs. One LigatureSubst subtable can
          specify any number of ligature substitutions.</para>

        <para>The subtable uses a single format: LigatureSubstFormat1.
          It contains a format identifier (SubstFormat), a Coverage
          table offset (Coverage), a count of the ligature sets
          defined in this table (LigSetCount), and an array of offsets
          to LigatureSet tables (LigatureSet). The Coverage table
          specifies only the index of the first glyph component of
          each ligature set.</para>

        <otformat>
          <title>LigatureSubstFormat1 subtable: All ligature
            substitutions in a script</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LigSetCount</otfieldname>
            <otfielddesc>Number of LigatureSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigatureSet [LigSetCount]</otfieldname>
            <otfielddesc>Array of offsets to LigatureSet tables
              &#x2013; from beginning of Substitution table &#x2013;
              ordered by Coverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A LigatureSet table, one for each covered glyph,
          specifies all the ligature strings that begin with the
          covered glyph. For example, if the Coverage table lists the
          glyph index for a lowercase &#x201c;f,&#x201d; then a
          LigatureSet table will define the &#x201c;ffl,&#x201d;
          &#x201c;fl,&#x201d; &#x201c;ffi,&#x201d; &#x201c;fi,&#x201d;
          and &#x201c;ff&#x201d; ligatures. If the Coverage table also
          lists the glyph index for a lowercase &#x201c;e,&#x201d;
          then a different LigatureSet table will define the
          &#x201c;etc&#x201d; ligature.</para>

        <para>A LigatureSet table consists of a count of the ligatures
          that begin with the covered glyph (LigatureCount) and an
          array of offsets to Ligature tables, which define the glyphs
          in each ligature (Ligature). The order in the Ligature
          offset array defines the preference for using the ligatures.
          For example, if the &#x201c;ffl&#x201d; ligature is
          preferable to the &#x201c;ff&#x201d; ligature, then the
          Ligature array would list the offset to the
          &#x201c;ffl&#x201d; Ligature table before the offset to the
          &#x201c;ff&#x201d; Ligature table. </para>


        <otformat>
          <title>LigatureSet table: All ligatures beginning with the
          same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LigatureCount</otfieldname>
            <otfielddesc>Number of Ligature tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Ligature [LigatureCount]</otfieldname>
            <otfielddesc>Array of offsets to Ligature tables &#x2013;
              from beginning of LigatureSet table &#x2013; ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

        <para>For each ligature in the set, a Ligature table specifies
          the GlyphID of the output ligature glyph (LigGlyph); a count
          of the total number of component glyphs in the ligature,
          including the first component (CompCount); and an array of
          GlyphIDs for the components (Component). The array starts
          with the second component glyph (array index = 1) in the
          ligature because the first component glyph is specified in
          the Coverage table.</para>

        <para>Note: The Component array lists GlyphIDs according to
        the writing direction of the text. For text written right to
        left, the right-most glyph will be first. Conversely, for text
        written left to right, the left-most glyph will be
        first.</para>

        <para>Example 6 at the end of this chapter shows how to
        replace a string of glyphs with a single ligature.</para>


        <otformat>
          <title>Ligature table: Glyph components for one
          ligature</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>LigGlyph</otfieldname>
            <otfielddesc>GlyphID of ligature to
              substitute</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CompCount</otfieldname>
            <otfielddesc>Number of components in the
              ligature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Component [CompCount-1]</otfieldname>
            <otfielddesc>Array of component GlyphIDs &#x2013; start with the
              second component &#x2013; ordered in writing
              direction</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>To adopt a consistent language, the last sentence of the
          second paragraph should be replaced by: "The Coverage index of the
          first input glyph is used to index the LigatureSet array and
          LigSetCount must equal the number of glyphs covered by
          Coverage."</para>

        <para>The specification fails to say if an element of the
          LigatureSet array can be null. We assume it cannot. This can be
          added after the sentence above: "The entries in the LigatureSet
          array cannot be NULL."</para>

        <para>It is unclear whether the LigatureCount of a LigatureSet
          table can be 0. We assume that
          LigatureCount must be at least 1 and recommend that it be spelled
          out in the specification.</para>

        <para>It is unclear whether the CompCount of a Ligature table can
          be 0 or 1. The value 0 is most certainly illegal (since a
          Ligature table is used in the context of a first glyph
          match). While the value 1 could be accepted, this would amount to
          a one for one substitution, which is probably better handled by a
          Single Substitution lookup. Therefore, we assume that CompCount
          must be 2 or more, and recommend that it be spelled out in the
          specification.</para>

	<para>The pattern matched by the Ligature table t = LigatureSet
	  [m].Ligature [n] is &#x25B6; L<subscript>0</subscript> L*
	  L<subscript>1</subscript> L* ... L*
	  L<subscript>i-1</subscript> &#x25C0;, where:
	  <itemizedlist>
	    <listitem>
	      <para>i is t.CompCount</para>
	    </listitem>
	    <listitem>
	      <para>L<subscript>0</subscript> is {Coverage[m]}
	      &#x2216; LookupFlag</para>
	    </listitem>

	    <listitem>
	      <para>L<subscript>k</subscript> is {t.Component [k-1]} &#x2216; LookupFlag,
	      for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this Ligature table is to replace the entire
	  input sequence by the glyph t.LigGlyph.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>LigatureSubst type</code-title>
  ligatureSubstTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneLigatureSubstTable =
    element ligatureSubstTable { attribute id { text }, ligatureSubstTable }

  ligatureSubstTableOffset = attribute name { text } | ligatureSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='gsub.methods'>
  private Block ligatureSubstFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block> blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (! "subst".equals (firstChild.getTagName ()))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList substs = subtable.getChildNodes ();
    int substsCount = substs.getLength ();

    int [][] in  = new int [substsCount] [];
    int []   out = new int [substsCount];

    for (int i = 0; i &lt; substsCount; i++) {
      Element subst = (Element) substs.item (i);
      in [i] = getGlyphs (subst.getAttribute ("in"));
      out [i] = parseOneGlyph (subst.getAttribute ("out")); }

    if (coverage == null) {
      int [] coveredGlyphs = new int [substsCount];
      int count = 0;
      for (int i = 0; i &lt; substsCount; i++) {
         int glyph = in [i][0];
         boolean addIt = true;
         for (int j = 0; j &lt; count; j++) {
           if (glyph == coveredGlyphs [j]) {
             addIt = false;
             break; }}
         if (addIt) {
           coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }


    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyphs [g]
      int nodeCount = 0;

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block ligatureSetTable = new Block (2 + 2*nodeCount, nodeCount);
      int zz = 0;
      ligatureSetTable.setuint16 (0, nodeCount);
      me.setOffset (6 + 2*g, ligatureSetTable);

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {

          Block ligatureTable = new Block (4 + 2 *(in[j].length - 1), 0);
          ligatureTable.setGlyphID (0, out [j]);
          ligatureTable.setuint16  (2, in [j].length);
          for (int k = 1; k &lt; in [j].length; k++) {
            ligatureTable.setGlyphID (4 + 2*(k-1), in [j][k]); }

          ligatureSetTable.setOffset (2 + 2*zz, ligatureTable);
          zz++; }}}

    return me;
  }

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='gsub.toXMLCount_4'>
  /* nothing */
</code-fragment>

<code-fragment id='gsub.toXML_4'>
  /* nothing */
</code-fragment>

<code-fragment id='gsub.toXMLEmit_4'>
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int sequenceCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; sequenceCount; i++) {
      int ligatureSetOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      int ligatureCount = getuint16 (ligatureSetOffset);

      for (int l = 0; l &lt; ligatureCount; l++) {
        int ligatureOffset = ligatureSetOffset + getOffset (ligatureSetOffset + 2 + 2*l);
	int compCount = getuint16 (ligatureOffset + 2);

        at = new AttributesImpl ();

        StringBuilder s = new StringBuilder ();
	glyphToXML (conf, s, glyphs [i]);
        for (int g = 0; g &lt; compCount - 1; g++) {
          glyphToXML (conf, s, getuint16 (ligatureOffset + 4 + 2*g)); }
        at.addAttribute ("", "in", "in", "CDATA", s.toString ());

        at.addAttribute ("", "out", "out", "CDATA",
                         glyphToXML (conf, getuint16 (ligatureOffset)));

        conf.ch.element ("subst", at); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching for
          a single ligature. When this procedure is called, it is
          known that the glyph run matched
          L<subscript>0</subscript> and that L<subscript>0</subscript>
          is at <varname>inPos</varname>. If the glyph run does not
          match the rest of the ligature, then this procedure returns
          null. Otherwise, it returns an array of the glyph run
          positions that where matched, i.e. the positions of
          L<subscript>0</subscript>, L<subscript>1</subscript>,
          &#x2026;</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: L<subscript>0</subscript> is
          recorded in the Coverage of the subtable, and
          L<subscript>1</subscript>, &#x2026; are recorded in a
          Ligature table; essentially this procedure takes care of one
          Ligature table.</para>

<code-fragment id='gsub.methods'>
  <code-title>Procedure to match one GSUB 4 ligature</code-title>

  int[] matchOneLigature (GlyphRun gr, int inPos, int ligatureOffset,
                          int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int compCount = getuint16 (ligatureOffset + 2);
    int [] matchedPositions = new int [compCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; compCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getGlyphID (ligatureOffset + 4 + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    return matchedPositions;
  }
</code-fragment>

    <para>With that in place, we can now implement the full
    subtable.</para>

<code-fragment id='gsub_4'>
  <code-title>Execute GSUB 4 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int ligatureSetOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int ligatureCount = getuint16 (ligatureSetOffset);

    for (int l = 0; l &lt; ligatureCount; l++) {
      int ligatureOffset
        = ligatureSetOffset + getOffset (ligatureSetOffset + 2 + 2*l);

      int [] matchedPositions
        = matchOneLigature (gr, inPos, ligatureOffset,
                            lookupIndex, lookupFlag);

      if (   matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions [matchedPositions.length-1])) {
        int nextPosition = matchedPositions [matchedPositions.length - 1] + 1;
        int newGlyphId = getGlyphID (ligatureOffset);
        if (listener != null) {
          int[] oldGlyphIds = new int [matchedPositions.length];
          for (int i = 0; i &lt; matchedPositions.length; i++) {
            oldGlyphIds [i] = gr.glyphAt (matchedPositions [i]); }
          listener.replace (oldGlyphIds, newGlyphId);
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     "GSUB", ligatureOffset); }
        gr.replace (matchedPositions, newGlyphId);
        nextPosition = nextPosition - matchedPositions.length + 1;
        return new LookupResult (true, nextPosition,
                                 -(matchedPositions.length -1)); }}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>gsub4_1_simple</title>

          <para>Let&#x2019;s start with a simple test that replaces
          glyphs 18, 19, and 20 by glyph 23.</para>

<aots:test-font id='gsub4_1_simple_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='4'>
	<ligatureSubst format='1'>
	  <coverage glyphs='18' format='any'/>
	  <subst in='18 19 20' out='23'/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub4_1_simple_t1' font='gsub4_1_simple_f1'
	   inputs ='17, 18, 19, 20, 17, 18, 19, 22, 20'
	   outputs='17, 23,         17, 18, 19, 22, 20'/>
        </section>

        <section>
          <title>gsub4_1_lookupflag</title>

          <para>Let&#x2019;s add LookupFlag in a straightforward way;
          in addition to the change above, glyph 24 is skipped.</para>

<aots:test-font id='gsub4_1_lookupflag_f1'>
  <base-font name='base.otf'/>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='24'/>
    </glyphClassDef>
  </GDEF>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' ignoreBaseGlyphs='yes' type='4'>
	<ligatureSubst format='1'>
	  <coverage glyphs='18' format='any'/>
	  <subst in='18 19 20' out='23'/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <para>In the glyph run, we inject glyph 24 just before, in the
            middle (one or more occurrences), and after the input pattern
            match. If one observes the glyph run after each lookup
            application, one should see:</para>
<literallayout>
 *17  24  18  24  19  24  24  20  24  17  18  19  22  20
  17 *24  18  24  19  24  24  20  24  17  18  19  22  20
  17  24  23  24  24  24 *24  17  18  19  22  20
  17  24  23  24  24  24  24 *17  18  19  22  20
  17  24  23  24  24  24  24  17 *18  19  22  20
  17  24  23  24  24  24  24  17  18 *19  22  20
  17  24  23  24  24  24  24  17  18  19 *22  20
  17  24  23  24  24  24  24  17  18  19  22 *20
  17  24  23  24  24  24  24  17  18  19  22  20
</literallayout>

          <para>Note that the first match is on the first occurrence of
            glyph 24, and that it covers the glyph run up to glyph 20; the
            next lookup application is at the occurrence of glyph 24 just
            following glyph 20.</para>

          <aots:gsub-test
	   id='gsub4_1_lookupflag_t1' font='gsub4_1_lookupflag_f1'
	   inputs ='17, 24, 18, 24, 19, 24, 24, 20, 24, 17, 18, 19, 22, 20'
	   outputs='17, 24, 23, 24,     24, 24,     24, 17, 18, 19, 22, 20'/>
        </section>

        <section>
          <title>gsub4_1_multiple_ligatures</title>


          <para>Let&#x2019;s verify what happens when multiple
          ligatures are present. Let&#x2019;s have (18, 19, 20) go to
          23, and then (18, 19) go to 24. Note that the first ligature
          is more specific than the second one.</para>

<aots:test-font id='gsub4_1_multiple_ligatures_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='4'>
	<ligatureSubst format='1'>
	  <coverage glyphs='18' format='any'/>
	  <subst in='18 19 20' out='23'/>
	  <subst in='18 19'    out='24'/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub4_1_multiple_ligatures_t1' font='gsub4_1_multiple_ligatures_f1'
	   inputs ='17, 18, 19, 20, 17, 18, 19, 22, 20'
	   outputs='17, 23,         17, 24,     22, 20'/>

          <para>Let&#x2019;s invert the order of those two ligatures,
          to make the second one more specific (and see that it never
          applies).</para>

<aots:test-font id='gsub4_1_multiple_ligatures_f2'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='4'>
	<ligatureSubst format='1'>
	  <coverage glyphs='18' format='any'/>
	  <subst in='18 19'    out='24'/>
	  <subst in='18 19 20' out='23'/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub4_1_multiple_ligatures_t2' font='gsub4_1_multiple_ligatures_f2'
	   inputs ='17, 18, 19, 20, 17, 18, 19, 22, 20'
	   outputs='17, 24,     20, 17, 24,     22, 20'/>
        </section>

        <section>
          <title>gsub4_1_multiple_ligsets</title>

          <para>Moving on to multiple ligature sets. (18, 19) goes to 23 and
            (20, 19) goes to 24.</para>

<aots:test-font id='gsub4_1_multiple_ligsets_f1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id='lookup.test' type='4'>
	<ligatureSubst format='1'>
	  <coverage glyphs='18 20' format='any'/>
	  <subst in='18 19' out='23'/>
	  <subst in='20 19' out='24'/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub4_1_multiple_ligsets_t1' font='gsub4_1_multiple_ligsets_f1'
	   inputs ='17, 18, 19, 21, 20, 19, 22'
	   outputs='17, 23,     21, 24,     22'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>LookupType 5: Contextual Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Contextual Substitution (ContextSubst) subtable
          defines the most powerful type of glyph substitution lookup:
          it describes glyph substitutions in context that replace one
          or more glyphs within a certain pattern of glyphs.</para>

        <para>ContextSubst subtables can be any of three formats that
          define a context in terms of a specific sequence of glyphs,
          glyph classes, or glyph sets. Each format can describe one
          or more input glyph sequences and one or more substitutions
          for each sequence.</para>

        <para>All three formats of ContextSubst subtables specify
          substitution data in a SubstLookupRecord. A description of
          that record follows.</para>

        <otformat>
          <title>SubstLookupRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SequenceIndex</otfieldname>
            <otfielddesc>Index into current glyph sequence &#x2013; first glyph
              = 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupListIndex</otfieldname>
            <otfielddesc>Lookup to apply to that
              position &#x2013; zero-based</otfielddesc>
          </otfield>
        </otformat>

        <para>The SequenceIndex in a SubstLookupRecord must take into
          consideration the order in which lookups are applied to the
          entire glyph sequence. Because multiple substitutions may
          occur per context, the SequenceIndex and LookupListIndex
          refer to the glyph sequence after the text-processing client
          has applied any previous lookups. In other words, the
          SequenceIndex identifies the location for the substitution
          at the time that the lookup is to be applied. For example,
          consider an input glyph sequence of four glyphs. The first
          glyph does not have a substitute, but the middle two glyphs
          will be replaced with a ligature, and a single glyph will
          replace the fourth glyph:</para>

        <itemizedlist>
          <listitem>
            <para>The first glyph is in position 0. No lookups will be
            applied at position 0, so no SubstLookupRecord is
            defined.</para>
          </listitem>
          <listitem>
            <para>The SubstLookupRecord defined for the ligature
            substitution specifies the SequenceIndex as position 1,
            which is the position of the first-glyph component in the
            ligature string. After the ligature replaces the glyphs in
            positions 1 and 2, however, the input glyph sequence
            consists of only three glyphs, not the original
            four.</para>
          </listitem>
          <listitem>
            <para>To replace the last glyph in the sequence, the
            SubstLookupRecord defines the SequenceIndex as position 2
            instead of position 3. This position reflects the effect
            of the ligature substitution applied before this single
            substitution. </para>
          </listitem>
        </itemizedlist>

        <para>Note: this example assumes that the LookupList
          specifies the ligature substitution lookup before the single
          substitution lookup.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>Contextual Lookup are fundamentally the same thing in
	GSUB and GPOS. The only differences are the numeric values of
	the types (5 in GSUB, 7 in GPOS), and the LookupList against
	which the lookup indices in the SubstLookupRecord are
	resolved. It would be a great simplification for the users of
	the specification if there was a single descrription of
	Contextual subtables. The same applies to Chaining Contextual
	subtables.</para>

	<para>The interaction between the LookupFlag of a contextual
	lookup and the LookupFlag of the lookup(s) it invokes is not
	very well defined. For example, if the contextual lookup does
	not skip other any glyphs, but it invokes a lookup that
	ignores some glyphs, should those be ignored?</para>

        <para>The description of the SubstLookupRecord used to be in
        another place in version 1.25, after the description of
        lookups 5 and 6, I believe. As it stands, it is parts of the
        LookupType 5 description, which is a bit misleading since
        it&#x2019;s also used in type 6. Recommendation: restore it in
        its own section.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>It is difficult to find a format-independent description
	of a contextual substitution, so we do not have one for now.</para>

	<para>Here is the boiler plate:</para>

<code-fragment id='schema'>
  <code-title>Coverage tables</code-title>
  standaloneContextualTable =
    element contextualTable { attribute id { text }, contextualTable }

  contextualTableOffset = attribute name { text } | contextualTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  <code-title>Compile singlePos lookups</code-title>
  protected Block contextLookupFromXML (Element lookupSubtable,
                                        Element table,
                                        Map&lt;Element, Block> blockCache,
					Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute ("format");
    if ("1".equals (format)) {
      return contextLookupFormat1FromXML (lookupSubtable, table,
                                          blockCache, lookupIndices); }
    if ("2".equals (format)) {
      return contextLookupFormat2FromXML (lookupSubtable, table,
                                          blockCache, lookupIndices); }
    if ("3".equals (format)) {
      return contextLookupFormat3FromXML (lookupSubtable, table,
                                          blockCache, lookupIndices); }

    /* cannot get here with a valid document */
    throw new InvalidFontException (
      "invalid contextual lookup format (" + format + ")");
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void contextualLookupToXMLCount (int stOffset, int[] counts) {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend='contextualLookup.toXMLCount_1'/>; break; }
      case 2: { <code-include linkend='contextualLookup.toXMLCount_2'/>; break; }
      case 3: { <code-include linkend='contextualLookup.toXMLCount_3'/>; break; }}
  }

  public void contextualLookupToXML (DecompilerConfig conf,
                                     int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend='contextualLookup.toXML_1'/>; break; }
      case 2: { <code-include linkend='contextualLookup.toXML_2'/>; break; }
      case 3: { <code-include linkend='contextualLookup.toXML_3'/>; break; }}
  }

  public void contextualLookupToXMLEmit (DecompilerConfig conf,
                                         int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    AttributesImpl at;
    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend='contextualLookup.toXMLEmit_1'/>; break; }
      case 2: { <code-include linkend='contextualLookup.toXMLEmit_2'/>; break; }
      case 3: { <code-include linkend='contextualLookup.toXMLEmit_3'/>; break; }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>As usual, all subtable formats start with the same
          field, the uint16 SubstFormat, which we use to
          dispatch:</para>

<code-fragment id='lookuptable.methods'>
  <code-title>?</code-title>
  public LookupResult applyContextualLookupSubtable
                          (int lookupIndex, int lookupType, int lookupFlag,
                           int stOffset, GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    int substFormat = getuint16 (stOffset);

    switch (substFormat) {
      case 1: { <code-include linkend='contextualLookup_format1'/> }
      case 2: { <code-include linkend='contextualLookup_format2'/> }
      case 3: { <code-include linkend='contextualLookup_format3'/> }
      default:
        throw new InvalidFontException ("GSUB 5/-" + substFormat + "-"); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Context Substitution Format 1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 1 defines the context for a glyph substitution
          as a particular sequence of glyphs. For example, a context
          could be &lt;xyz>, &lt;holiday>, &lt;!?*#@>, or any other glyph
          sequence.</para>

        <para>Within a context sequence, Format 1 identifies
          particular glyph positions (not glyph indices) as the
          targets for specific substitutions. When a text-processing
          client locates a context in a string of text, it finds the
          lookup data for a targeted position and makes a substitution
          by applying the lookup data at that location.</para>

        <para>For example, if a client is to replace the glyph string
          &lt;abc> with its reverse glyph string &lt;cba>, the input
          context is defined as the glyph sequence, &lt;abc>, and the
          lookups defined for the context are (1) &#x201c;a&#x201d; to
          &#x201c;c&#x201d; and (2) &#x201c;c&#x201d; to
          &#x201c;a&#x201d;. When a client encounters the context
          &lt;abc>, the lookups are performed in the order stored.
          First, &#x201c;c&#x201d; is substituted for
          &#x201c;a&#x201d; resulting in &lt;cbc>. Second,
          &#x201c;a&#x201d; is substituted for the &#x201c;c&#x201d;
          that has not yet been touched, resulting in &lt;cba>.</para>

        <para>To specify a context, a Coverage table lists the first
          glyph in the sequence, and a SubRule table identifies the
          remaining glyphs. To describe the >abc&lt; context used in
          the previous example, the Coverage table lists the glyph
          index of the first component of the sequence &#2013; the
          &#x201c;a&#x201d; glyph. A SubRule table defines indices for
          the &#x201c;b&#x201d; and &#x201c;c&#x201d; glyphs. </para>

        <para>A single ContextSubstFormat1 subtable may define more
          than one context glyph sequence. If different context
          sequences begin with the same glyph, then the Coverage table
          should list the glyph only once because all glyphs in the
          table must be unique. For example, if three contexts each
          start with an &#x201c;s&#x201d; and two start with a
          &#x201c;t,&#x201d; then the Coverage table will list one
          &#x201c;s&#x201d; and one &#x201c;t.&#x201d;</para>

        <para>For each context, a SubRule table lists all the glyphs
          that follow the first glyph. The table also contains an
          array of SubstLookupRecords that specify the substitution
          lookup data for each glyph position (including the first
          glyph position) in the context.</para>

        <para>All of the SubRule tables defining contexts that begin
          with the same first glyph are grouped together and defined
          in a SubRuleSet table. For example, the SubRule tables that
          define the three contexts that begin with an
          &#x201c;s&#x201d; are grouped in one SubRuleSet table, and
          the SubRule tables that define the two contexts that begin
          with a &#x201c;t&#x201d; are grouped in a second SubRuleSet
          table. Each glyph listed in the Coverage table must have a
          SubRuleSet table defining all the SubRule tables that apply
          to a covered glyph.</para>

          <para>To locate a context glyph sequence, the
          text-processing client searches the Coverage table each time
          it encounters a new text glyph. If the glyph is covered, the
          client reads the corresponding SubRuleSet table and examines
          each SubRule table in the set to determine whether the rest
          of the context matches the subsequent glyphs in the text. If
          the context and text string match, the client finds the
          target glyph positions, applies the lookups for those
          positions, and completes the substitutions.</para>

          <para>A ContextSubstFormat1 subtable contains a format
          identifier (SubstFormat), an offset to a Coverage table
          (Coverage), a count of defined SubRuleSets
          (SubRuleSetCount), and an array of offsets to the SubRuleSet
          tables (SubRuleSet). As mentioned, one SubRuleSet table must
          be defined for each glyph listed in the Coverage
          table.</para>

          <para>In the SubRuleSet array, the SubRuleSet table offsets
          are ordered in the Coverage Index order. The first
          SubRuleSet in the array applies to the first GlyphID listed
          in the Coverage table, the second SubRuleSet in the array
          applies to the second GlyphID listed in the Coverage table,
          and so on.</para>


        <otformat>
            <title>ContextSubstFormat1 subtable: Simple context glyph
            substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubRuleSetCount</otfieldname>
            <otfielddesc>Number of SubRuleSet tables &#x2013; must equal
              GlyphCount in Coverage table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubRuleSet [SubRuleSetCount]</otfieldname>
            <otfielddesc>Array of offsets to SubRuleSet tables
              &#x2013; from beginning of Substitution table &#x2013; ordered by
              Coverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A SubRuleSet table consists of an array of offsets to
          SubRule tables (SubRule), ordered by preference, and a count
          of the SubRule tables defined in the set (SubRuleCount). The
          order in the SubRule array can be critical. Consider two
          contexts, &lt;abc> and &lt;abcd>. If &lt;abc> is first in
          the SubRule array, all instances of &lt;abc> in the
          text &#x2013; including all instances of &lt;abcd> &#x2013; will be
          changed. If &lt;abcd> comes first in the array, however,
          only &lt;abcd> sequences will be changed, without affecting
          any instances of &lt;abc>.</para>


        <otformat>
            <title>SubRuleSet table: All contexts beginning with the
            same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubRuleCount</otfieldname>
            <otfielddesc>Number of SubRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubRule [SubRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to SubRule tables &#x2013; from
              beginning of SubRuleSet table &#x2013; ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

          <para>A SubRule table consists of a count of the glyphs to
          be matched in the input context sequence (GlyphCount),
          including the first glyph in the sequence, and an array of
          glyph indices that describe the context (Input). The
          Coverage table specifies the index of the first glyph in the
          context, and the Input array begins with the second glyph
          (array index = 1) in the context sequence.</para>

          <blockquote>
            <para>Note: The Input array lists the indices in the order
            the corresponding glyphs appear in the text. For text
            written from right to left, the right-most glyph will be
            first; conversely, for text written from left to right,
            the left-most glyph will be first.</para>
          </blockquote>

          <para>A SubRule table also contains a count of the
          substitutions to be performed on the input glyph sequence
          (SubstCount) and an array of SubstitutionLookupRecords
          (SubstLookupRecord). Each record specifies a position in the
          input glyph sequence and a LookupListIndex to the
          substitution lookup that is applied at that position. The
          array should list records in design order, or the order the
          lookups should be applied to the entire glyph
          sequence.</para>

        <otformat>
            <title>SubRule table: One simple context definition</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in input glyph
              sequence &#x2013; includes the first glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Input [GlyphCount-1]</otfieldname>
            <otfielddesc>Array of input GlyphIDs &#x2013; start with second
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords &#x2013; in design
              order</otfielddesc>
          </otfield>
        </otformat>

          <para>Example 7 at the end of the chapter shows how to use
          the ContextSubstFormat1 subtable to replace a sequence of
          three glyphs with a sequence preferred for the French
          language system.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>Second paragraph: "... locates a context in a string of
          text, ..." shoud be replaced by "... locates a context in a
          string of glyphs, ...".</para>

        <para>In the fourth paragraph the '&lt;' and '&gt;' around the
          first literal context are inverted.</para>


        <para>To adopt a consistent language, the last paragraph
          before the ContextSubtFormat1 table, and the last sentence
          of the previous paragraph, should be replaced by: "The
          Coverage index of the first input glyph is used to index the
          SubRuleSet array and SubRuleSetCount must equal the number
          of glyphs covered by Coverage. The entries in the SubRuleSet
          array cannot be NULL."</para>

        <para>It is unclear whether the SubRuleCount of a SubRuleSet
          table can be 0. We assume that SubRuleCount must be at least
          1 and recommend that it be spelled out in the
          specification.</para>

        <para>It is unclear whether the GlyphCount of a SubRule can be
          0 or 1. The value 0 is most certainly illegal (since a
          SubRule table is used in the context of a first glyph
          match). We assume that the value 1 is legal (because it
          makes sense for a similar LookupType 6 subtable), eventhough
          it is difficult to exhibit an interesting use of that
          case.</para>

        <para>It is unclear whether the SubstCount of a SubRule can be
          0. At first it seems that such a SubRule could be removed,
          since it does nothing. On the other hand, this could be
          useful to prevent the activation of following SubRules; e.g.
          if one wanted the sequence &lt;abc&gt; modified, but not the
          sequence &lt;abcd&gt;. The recommendation is to explicitly
          mention that case as permitted.</para>

	<para>The pattern matched by the SubRule table t = SubRuleSet
	  [m].SubRule [n] is &#x25B6;
	  I<subscript>0</subscript> L* I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is t.GlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]}
	      &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is {t.Input [k-1]}
	      &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Contextual substitution format 1 type</code-title>
  contextualTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element pattern {
      attribute in { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block contextLookupFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block> blockCache,
					     Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList rules = subtable.getChildNodes ();
    int rulesCount = rules.getLength ();

    int [][] in  = new int [rulesCount] [];

    for (int i = 0; i &lt; rulesCount; i++) {
      Element rule = (Element) rules.item (i);
      in [i] = getGlyphs (rule.getAttribute ("in")); }

    if (coverage == null) {
      int [] coveredGlyphs = new int [rulesCount];
      int count = 0;
      for (int i = 0; i &lt; rulesCount; i++) {
        int glyph = in [i][0];
        boolean addIt = true;
        for (int j = 0; j &lt; count; j++) {
          if (glyph == coveredGlyphs [j]) {
            addIt = false;
            break; }}
        if (addIt) {
          coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }


    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyphs [g]
      int nodeCount = 0;
      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block subRuleSetTable = new Block (2 + 2*nodeCount, nodeCount);
      subRuleSetTable.setuint16 (0, nodeCount);
      nodeCount = 0;
      me.setOffset (6 + 2*g, subRuleSetTable);

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {

          Element rule = (Element) rules.item (j);
          NodeList substs = rule.getChildNodes ();
          int substCount = substs.getLength ();

          Block subRuleTable = new Block (4 + 2 * (in[j].length - 1) +
                                          4 * substCount, 0);
          subRuleSetTable.setOffset (2 + 2*(nodeCount++), subRuleTable);
          subRuleTable.setuint16 (0, in[j].length);
          subRuleTable.setuint16 (2, substCount);

          for (int k = 1; k &lt; in[j].length; k++) {
            subRuleTable.setGlyphID (4 + 2*(k-1), in [j][k]); }

	  subLookupsFromXML (substCount, substs,
	                    subRuleTable, 4 + 2*(in[j].length-1),
			    lookupIndices); }}}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='contextualLookup.toXMLCount_1'>
  /* nothing */
</code-fragment>

<code-fragment id='contextualLookup.toXML_1'>
  /* nothing */
</code-fragment>

<code-fragment id='contextualLookup.toXMLEmit_1'>
    int posRuleSetCount = getuint16 (stOffset + 4);
    int[] coveredGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));

    for (int i = 0; i &lt; posRuleSetCount; i++) {
      int posRuleSetOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      int posRuleCount = getuint16 (posRuleSetOffset);
      for (int j = 0; j &lt; posRuleCount; j++) {
        int posRuleOffset = posRuleSetOffset + getOffset (posRuleSetOffset + 2 + 2*j);
        int glyphCount = getuint16 (posRuleOffset);
        StringBuilder s = new StringBuilder ();
	glyphToXML (conf, s, coveredGlyphs [i]);
        for (int g = 0; g &lt; glyphCount - 1; g++) {
          glyphToXML (conf, s, getuint16 (posRuleOffset + 4 + 2*g)); }

        at = new AttributesImpl ();
        at.addAttribute ("", "in", "in", "CDATA", s.toString ());
        conf.ch.startElement ("pattern", at); {
          subLookupsToXML (conf, getuint16 (posRuleOffset + 2),
                           posRuleOffset + 4 + 2*(glyphCount-1));
          conf.ch.endElement ("pattern"); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>This subtable is very similar to a Ligature Substitution
          subtable. The matched patterns are the same. The difference
          is in the replacement; in a Ligature Substitution, the
          matched glyphs are replaced by a specific glyph, whereas in
          this subtable, SubstLookupRecords are invoked.</para>

        <para>We start with a procedure that performs the matching for
          a single sub rule. When this procedure is called, it is
          known that the glyph run matched
          L<subscript>0</subscript> and that L<subscript>0</subscript>
          is at <varname>inPos</varname>. If the glyph run does not
          match the rest of the sub rule, then this procedure returns
          null. Otherwise, it returns an array of the glyph run
          positions that where matched, i.e. the positions of
          L<subscript>0</subscript>, L<subscript>1</subscript>,
          &#x2026;</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: L<subscript>0</subscript> is
          recorded in the coverage of the subtable, and
          L<subscript>1</subscript>, &#x2026; are recorded in SubRule
          table; essentially this procedure takes care of one SubRule
          table.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Procedure to match one GSUB 5/1 sub rule</code-title>

  int[] matchOneRule (GlyphRun gr, int inPos, int ruleOffset,
                         int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int glyphCount = getuint16 (ruleOffset);
    int [] matchedPositions = new int [glyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; glyphCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getuint16 (ruleOffset + 4 + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

        <para>The only complication is the determination of the
          position of the next glyph to process. The next glyph is the
          one following L<subscript>n-1</subscript>. Before the
          SubstLookupRecords are applied, we know the position of that
          glyph, but it can modified by the SubstLookupRecords. We
          could arrange for the application of the SubstLookupRecords
          to indicate how many glyphs are inserted or deleted, but
          this would complicate that code. Instead, we rely on the
          property that the SubstLookupRecords cannot modify glyphs
          outside of the matched pattern: in particular, we know that
          none of the glyphs following L<subscript>n-1</subscript> in
          the glyph run are modified, and therefore that their number
          does not change.</para>

<code-fragment id='contextualLookup_format1'>
  <code-title>Execute contextual lookup subtable, format 1, and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int ruleSetOffset = stOffset + getuint16 (stOffset + 6 + ci*2);
    int ruleCount = getuint16 (ruleSetOffset);

    for (int s = 0; s &lt; ruleCount; s++) {
      int ruleOffset = ruleSetOffset +  getOffset (ruleSetOffset + 2 + 2*s);

      int[] matchedPositions
        = matchOneRule (gr, inPos, ruleOffset, lookupIndex, lookupFlag);

      if (matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions [matchedPositions.length-1])) {

        int glyphCount = getuint16 (ruleOffset);
        int applyCount = getuint16 (ruleOffset + 2);
        int applyOffset = ruleOffset + 4 + 2*(glyphCount-1);
        if (listener != null) {
           listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                      Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions,
                                applyCount, applyOffset); }}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>


        <section>
          <title>context1_simple</title>

          <para>Let&#x2019;s start with a simple test that matches the
          sequence 20, 21, 22. At each position, we then apply a
          our standard sublookups.</para>

<aots:context-test-font id='context1_simple_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 21 22'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id='context1_simple_t1' font='context1_simple_f1'
	   inputs ='00,  20,   21,   22,   00'
	   outputs='00,  60,   61,   62,   00'
	   xdeltas=' 0,  20,   20,   20,    0'
           ydeltas=' 0,   0,    0,    0,    0'/>

          <para>Here is a test case on the same font that involves incomplete
	  matches of input sequence:</para>

          <aots:context-test id='context1_simple_t2' font='context1_simple_f1'
            inputs ='00,  20,  00,  20,  21,  00'
	    outputs='00,  20,  00,  20,  21,  00'
            xdeltas='0,    0,   0,   0,   0,   0'
            ydeltas='0,    0,   0,   0,   0,   0'/>

	  <para>When applying a sublookup, that must be done as the
	  position given by the contextual lookup, not to all possible
	  positions in the matched input or beyond:</para>

<aots:context-test-font id='context1_simple_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 20 20'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id='context1_simple_t3' font='context1_simple_f2'
            inputs ='00,  20,   20,   20,   20,   20,   00'
	    outputs='00,  20,   60,   20,   20,   20,   00'
            xdeltas='0,    0,   20,    0,    0,    0,    0'
            ydeltas='0,    0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>context1_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
            processed after a contextual lookup it applied. The lookup
            matches the sequence 20, 20  and applies the standard
	    sublookups to the first occurrence of 20.</para>

<aots:context-test-font id='context1_next_glyph_f1'>
  <lookup id='lookup.test' type='contextual'>
	<contextual format='1'>
	  <pattern in='20 20'>
	    <apply pos='0' lookup='lookup.single'/>
	  </pattern>
	</contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_next_glyph_t1' font='context1_next_glyph_f1'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  60,   20,   60,   20,   20,   00'
	   xdeltas='0,   20,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>

        </section>

        <section>
          <title>context1_boundary</title>

          <para>We test the boundary case of SubstCount equal to
	  0.</para>

<aots:context-test-font id='context1_boundary_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 20'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_boundary_t1' font='context1_boundary_f1'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  20,   20,   20,   20,   20,   00'
	   xdeltas='0,    0,    0,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>

          <para>Another boundary case is when GlyphCount is 1.</para>

<aots:context-test-font id='context1_boundary_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_boundary_t2' font='context1_boundary_f2'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  60,   60,   60,   60,   60,   00'
	   xdeltas='0,   20,   20,   20,   20,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>
	</section>

        <section>
          <title>context1_multiple_subrules</title>

          <para>The next two tests ensure that the subrules of
          subruleset are applied in the prescribed order. In the first
          one, the matched sequences are 20, 21, 22, with the standard
          sublookups applied on 20, and 20, 21, with the standard
          sublookups applied on 21.</para>

<aots:context-test-font id='context1_multiple_subrules_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 21 22'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
	<pattern in='20 21'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_multiple_subrules_t1'
	   font='context1_multiple_subrules_f1'
	   inputs ='00,  20,   21,   22,   00,   20,   21,   00'
	   outputs='00,  60,   21,   22,   00,   20,   61,   00'
	   xdeltas=' 0,  20,    0,    0,    0,    0,   20,    0'
	   ydeltas=' 0,   0,    0,    0,    0,    0,    0,    0'/>

          <para>In the next test, we just invert the order of two
	  subrules.</para>

<aots:context-test-font id='context1_multiple_subrules_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 21'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
	<pattern in='20 21 22'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_multiple_subrules_t2'
	   font='context1_multiple_subrules_f2'
	   inputs ='00,  20,   21,   22,   00,   20,   21,   00'
	   outputs='00,  20,   61,   22,   00,   20,   61,   00'
	   xdeltas=' 0,   0,   20,    0,    0,    0,   20,    0'
	   ydeltas=' 0,   0,    0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>context1_successive</title>

          <para>In this test, we verify the case described in the
          SubstLookupRecord section. This applies to GSUB contextual
          lookups only. The matched sequence is 20 21 22 23. Glyphs 21
          and 22 are replaced by glyph 61 and glyph 23 is replaced by
          glyph 63. The difficult part is that the lookup that
          replaces 22 is applied at position 2, which is counted after
          the ligature substitution is applied.</para>

<aots:context-test-font id='context1_successive_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 21 22 23'>
	  <apply pos='1' lookup='lookup.double'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_successive_t1' font='context1_successive_f1'
	   inputs ='00,  20,   21,   22,  23,   00'
	   outputs='00,  20,   61,        63,   00'
	   xdeltas=' 0,   0,   20,   20,   0,    0'
	   ydeltas=' 0,   0,    0,    0,   0,    0'/>
        </section>

        <section>
          <title>context1_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
          sequence is 20 21 22, with standard sublookups applied at
          all three positions.</para>

<aots:context-test-font id='context1_lookupflag_f1'>
  <lookup id='lookup.test' type='contextual' ignoreMarks='yes'>
    <contextual format='1'>
	<pattern in='20 21 22'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>


	  <aots:context-test
	   id='context1_lookupflag_t1' font='context1_lookupflag_f1'
	   inputs ='00,  20,  90,  21,  91,  92,  22,   00'
	   outputs='00,  60,  90,  61,  91,  92,  62,   00'
	   xdeltas='0,   20,   0,  20,   0,   0,  20,    0'
	   ydeltas='0,    0,   0,   0,   0,   0,   0,    0'/>

	  <para>The interaction between LookupFlag of the contextal
	  substitution and LookupFlag of the sublookups is not very
	  clear. It is certainly desired that any glyph covered by
	  the contextual substitution LookupFlag be invisible to the
	  sublookups; what is unclear is whether this is achieved by
	  constraining legal fonts, or whether OpenType engines have
	  to enforce that behavior. Here is a font that does have
	  consistent LookupFlag, and it should behave properly with
	  all layout engines.</para>

<aots:context-test-font id='context1_lookupflag_f2'>
  <lookup id='lookup.test' type='contextual' ignoreMarks='yes'>
    <contextual format='1'>
	<pattern in='20 21 22'>
	  <apply pos='1' lookup='lookup.double.nomarks'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_lookupflag_t2' font='context1_lookupflag_f2'
	   inputs ='00,  20,  90,  21,  91,  92,  22,   00'
	   outputs='00,  20,  90,  61,  91,  92,        00'
	   xdeltas='0,    0,   0,  20,   0,   0,   0,    0'
	   ydeltas='0,    0,   0,   0,   0,   0,   0,    0'/>
        </section>

        <section>
          <title>context1_expansion</title>

          <para>As we have noted in multiple substitution lookups, the
          glyph run can be expanded. While a chaining lookup does not
          be itself perform that operation, it may invoke a multiple
          substitution lookup.</para>

<aots:context-test-font id='context1_expansion_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='1'>
	<pattern in='20 21 22'>
	  <apply pos='1' lookup='lookup.multiple'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context1_expansion_t1' font='context1_expansion_f1'
	   inputs ='00,  20,  21,            22,  00'
	   outputs='00,  20,  61,  62,  63,  22,  00'
	   xdeltas='0,    0,   0,             0,   0'
	   ydeltas='0,    0,   0,             0,   0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Context Substitution Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 2, a more flexible format than Format 1,
          describes class-based context substitution. For this format,
          a specific integer, called a class value, must be assigned
          to each glyph component in all context glyph
          sequences. Contexts are then defined as sequences of glyph
          class values. More than one context may be defined at a
          time.</para>

        <para>For example, suppose that a swash capital glyph should
          replace each uppercase letter glyph that is preceded by a
          space glyph and followed by a lowercase letter glyph (a
          glyph sequence of space &#x2013; uppercase &#x2013;
          lowercase). The set of uppercase glyphs would constitute one
          glyph class (Class 1), the set of lowercase glyphs would
          constitute a second class (Class 2), and the space glyph
          would constitute a third class (Class 3). The input context
          might be specified with a context rule (called a
          SubClassRule) that describes &#x201c;the set of glyph strings that
          form a sequence of three glyph classes, one glyph from Class
          3, followed by one glyph from Class 1, followed by one glyph
          from Class 2.&#x201d;</para>

        <para>Each ContextSubstFormat2 subtable contains an offset
          to a class definition table (ClassDef), which defines the
          glyph class values of all input contexts. Generally, a
          unique ClassDef table will be declared in each instance of
          the ContextSubstFormat2 table that is included in a font,
          even though several Format 2 tables could share ClassDef
          tables. Class assignments are fixed (the same for each
          position in the context), and classes are exclusive (a glyph
          cannot be in more than one class at a time). The output
          glyphs that replace the glyphs in the context sequences do
          not need class values because they are specified elsewhere
          by GlyphID.</para>

          <para>The ContextSubstFormat2 subtable also contains a
          format identifier (SubstFormat) and defines an offset to a
          Coverage table (Coverage). For this format, the Coverage
          table lists indices for the complete set of unique glyphs
          (not glyph classes) that may appear as the first glyph of
          any class-based context. In other words, the Coverage table
          contains the list of glyph indices for all the glyphs in all
          classes that may be first in any of the context class
          sequences. For example, if the contexts begin with a Class 1
          or Class 2 glyph, then the Coverage table will list the
          indices of all Class 1 and Class 2 glyphs.</para>

          <para>A ContextSubstFormat2 subtable also defines an array
          of offsets to the SubClassSet tables (SubClassSet) and a
          count of the SubClassSet tables (SubClassSetCnt). The array
          contains one offset for each class (including Class 0) in
          the ClassDef table. In the array, the class value defines an
          offset's index position, and the SubClassSet offsets are
          ordered by ascending class value (from 0 to SubClassSetCnt -
          1).</para>

          <para>For example, the first SubClassSet listed in the array
          contains all contexts beginning with Class 0 glyphs, the
          second SubClassSet contains all contexts beginning with
          Class 1 glyphs, and so on. If no contexts begin with a
          particular class (that is, if a SubClassSet contains no
          SubClassRule tables), then the offset to that particular
          SubClassSet in the SubClassSet array will be set to
          NULL.</para>

        <otformat>
            <title>ContextSubstFormat2 subtable: Class-based context
            glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table &#x2013; from beginning
              of Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubClassSetCnt</otfieldname>
            <otfielddesc>Number of SubClassSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubClassSet [SubClassSetCnt]</otfieldname>
            <otfielddesc>Array of offsets to SubClassSet tables
              &#x2013; from beginning of Substitution table &#x2013;
              ordered by class &#x2013; may be NULL</otfielddesc>
          </otfield>
        </otformat>

          <para>Each context is defined in a SubClassRule table, and
          all SubClassRules that specify contexts beginning with the
          same class value are grouped in a SubClassSet
          table. Consequently, the SubClassSet containing a context
          identifies a context's first class component.</para>

          <para>Each SubClassSet table consists of a count of the
          SubClassRule tables defined in the SubClassSet
          (SubClassRuleCnt) and an array of offsets to SubClassRule
          tables (SubClassRule). The SubClassRule tables are ordered
          by preference in the SubClassRule array of the
          SubClassSet.</para>

        <otformat>
            <title>SubClassSet subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubClassRuleCnt</otfieldname>
            <otfielddesc>Number of SubClassRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubClassRule [SubClassRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to SubClassRule tables &#x2013; from
              beginning of SubClassSet &#x2013; ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

          <para>For each context, a SubClassRule table contains a
          count of the glyph classes in the context sequence
          (GlyphCount), including the first class. A Class array lists
          the classes, beginning with the second class (array index =
          1), that follow the first class in the context.</para>

          <blockquote>
            <para>Note: Text order depends on the writing direction of
            the text. For text written from right to left, the
            right-most class will be first. Conversely, for text
            written from left to right, the left-most class will be
            first.</para>
          </blockquote>

          <para>The values specified in the Class array are the values
          defined in the ClassDef table. For example, a context
          consisting of the sequence &#x201c;Class 2, Class 7, Class 5, Class
          0&#x201d; will produce a Class array of 7,5,0. The first class in
          the sequence, Class 2, is identified in the
          ContextSubstFormat2 table by the SubClassSet array index of
          the corresponding SubClassSet.</para>

          <para>A SubClassRule also contains a count of the
          substitutions to be performed on the context (SubstCount)
          and an array of SubstLookupRecords (SubstLookupRecord) that
          supply the substitution data. For each position in the
          context that requires a substitution, a SubstLookupRecord
          specifies a LookupList index and a position in the input
          glyph sequence where the lookup is applied. The
          SubstLookupRecord array lists SubstLookupRecords in design
          order &#x2013; that is, the order in which lookups should be applied
          to the entire glyph sequence.</para>


        <otformat>
            <title>SubClassRule table: Context definition for one
            class</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Total number of classes specified for the
              context in the rule &#x2013; includes the first
              class</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class [GlyphCount-1]</otfieldname>
            <otfielddesc>Array of classes &#x2013; beginning with the second
              class &#x2013; to be matched to the input glyph class
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of Substitution lookups &#x2013; in design
              order</otfielddesc>
          </otfield>
        </otformat>

          <para>Example 8 at the end of this chapter uses Format 2 to
          substitute Arabic mark glyphs for base glyphs of different
          heights.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>In the third paragraph, the possibility of sharing of a
          class definition is too restrictive: a class definition
          could be used in a LookupType 6, for example. The
          recommendation is to replace "Generally" by "Typically", and
          the part of the sentence starting with "even though" by
          "but in general, a class definition can be used in multiple
          lookups."</para>

        <para>In the description of the Coverage in the fourth
          paragraph, the sentences starting with "In other words," are
          a bit misleading: the coverage may contain more or less than
          the union of the classes that have non-NULL SubClassSet
          offsets. This can be useful when the class definition is
          shared by multiple lookups. The recommendation is to replace
          the fouth paragraph by: "The ContextSubstFormat2 subtable
          also contains a format identifier (SubstFormat) and defines
          an offset to a Coverage table (Coverage). The lookup will
          apply only if the current glyph is covered by Coverage.
          Typically, the coverage is the union of the classes that
          appear as the first class of any context; for example, if
          the contexts begin with classes 1 and 2, then the Coverage
          will be exactly the glyphs in classes 1 and 2. However, this
          is not mandatory; in particular, it may be useful to have a
          Coverage which is a subset of those glyphs."</para>

        <para>To adopt a more consistent language, in the fifth
          paragraph, the sentences following the first should be
          replaced by: "The class of the first input glyph under
          ClassDef is used to index the SubClassSet array and
          SubClassSetCnt must equal the number of classes defined by
          ClassDef (including class 0)."</para>

        <para>It is unclear whether the SubClassRuleCnt of a
          SubClassSet table can be 0. We assume that SubRuleCount must
          be at least 1 and recommend that it be spelled out in the
          specification.</para>

        <para>It is unclear whether the GlyphCount of a SubClassRule
          can be 0 or 1. The value 0 is most certainly illegal (since
          a SubClassRule table is used in the context of a first glyph
          match). We assume that the value 1 is legal (because it
          makes sense for a similar LookupType 6 subtable), eventhough
          it is difficult to exhibit an interesting use of that
          case.</para>

        <para>It is unclear whether the SubstCount of a SubClassRule
          can be 0. At first it seems that such a SubClassRule could
          be removed, since it does nothing. On the other hand, this
          could be useful to prevent the activation of following
          SubClassRules; e.g. if one wanted the sequence &lt;1 2 3&gt;
          modified, but not the sequence &lt;1 2 3 4&gt;. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The pattern matched by the SubClassRule table t = SubClassSet
	  [m].SubClassRule [n] is
	  &#x25B6; I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is t.GlyphCount</para>
	    </listitem>

	    <listitem>
	      <para>I<subscript>0</subscript> is (Coverage &#x2229;
	      ClassDef [m]) &#x2216; LookupFlag</para>
	    </listitem>

	    <listitem>
	      <para>I<subscript>k</subscript> is ClassDef [t.Class
	      [k-1]] &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubClassRule table does not directly modify the glyph
	run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Contextual substitution format 2</code-title>
  contextualTable |=
    attribute format { "2" },
    element coverage { coverageTableOffset }?,
    element classDef { classDefTableOffset },
    element pattern {
      attribute in { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block contextLookupFormat2FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block> blockCache,
					     Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;

    Element firstChild = (Element) subtable.getFirstChild ();
    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    ClassdefTableBlock inputClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    NodeList classPatterns = subtable.getChildNodes ();

    if (coverage == null) {
      System.err.println ("implicit coverage in contextSubstFormat2 not yet supported"); }


    me = new Block (8 + 2*inputClassdef.classCount,
                    2 + inputClassdef.classCount);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setOffset (4, inputClassdef);
    me.setuint16 (6, inputClassdef.classCount);

    for (int c = 0; c &lt; inputClassdef.classCount; c++) {

      // count how many classPatterns start with class c
      int count = 0;
      for (int j = 0; j &lt; classPatterns.getLength (); j++) {
        Element classPattern = (Element) classPatterns.item (j);
        int[] classes = parseIntList (classPattern.getAttribute ("in"));
        if (classes [0] == c) {
          count++; }}

      if (count == 0) {
        me.setOffset (8 + 2*c, null); }

      else {
        Block subClassSet = new Block (2 + 2*count, count);
        me.setOffset (8 + 2*c, subClassSet);
        subClassSet.setuint16 (0, count);

        count = 0;
        for (int j = 0; j &lt; classPatterns.getLength (); j++) {
          Element classPattern = (Element) classPatterns.item (j);
          int[] classes = parseIntList (classPattern.getAttribute ("in"));
          if (classes [0] == c) {

            NodeList applies = classPattern.getChildNodes ();
            int applyCount = applies.getLength ();

            Block subClassRule = new Block (4 + 2 * (classes.length - 1)
                                            + 4 * applyCount,
                                            0);

            subClassSet.setOffset (2 + 2*(count++), subClassRule);
            subClassRule.setuint16 (0, classes.length);
            subClassRule.setuint16 (2, applyCount);
            for (int k = 1; k &lt; classes.length; k++) {
              subClassRule.setuint16 (4 + 2*(k-1), classes [k]); }

            subLookupsFromXML (applyCount, applies,
                              subClassRule, 4 + 2*(classes.length-1),
			      lookupIndices); }}}}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='contextualLookup.toXMLCount_2'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 4), counts);
</code-fragment>

<code-fragment id='contextualLookup.toXML_2'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 4), counts);
</code-fragment>

<code-fragment id='contextualLookup.toXMLEmit_2'>
    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, stOffset + getOffset (stOffset + 2), counts,
                              "coverage", at);

    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 4), counts,
                              "classDef", at);

    int classSetCount = getuint16 (stOffset + 6);
    for (int c = 0; c &lt; classSetCount; c++) {
      int xx = getOffset (stOffset + 8 + 2*c);
      if (xx != 0) {
        int classSetOffset = stOffset + xx;

        int classRuleCount = getuint16 (classSetOffset);
        for (int r = 0; r &lt; classRuleCount; r++) {
          int classRuleOffset = classSetOffset
                                + getOffset (classSetOffset + 2 + 2*r);

          at = new AttributesImpl ();

          int glyphCount = getuint16 (classRuleOffset);
          StringBuilder s = new StringBuilder ();
          s.append ("" + c);
          for (int g = 0; g &lt; glyphCount - 1; g++) {
            s.append (" " + getuint16 (classRuleOffset + 4 + 2*g)); }
          at.addAttribute ("", "in", "in", "CDATA", s.toString ());

          conf.ch.startElement ("pattern", at); {
            subLookupsToXML (conf, getuint16 (classRuleOffset + 2),
                             classRuleOffset + 4 + 2*(glyphCount-1));
          conf.ch.endElement ("pattern"); }}}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching for
          a single SubClassRule. When this procedure is called, it is
          known that the glyph run match L<subscript>0</subscript>
          and that L<subscript>0</subscript> is at
          <varname>inPos</varname>. If the glyph run does not match
          the rest of the SubClassRule, then this procedure returns
          null. Otherwise, it returns an array of the glyph run
          positions that where matched, i.e. the positions of
          L<subscript>0</subscript>, L<subscript>1</subscript>,
          &#x2026;</para>


<code-fragment id='lookuptable.methods'>
  <code-title>Procedure to match one GSUB 5/2 sub class rule</code-title>
  int[] matchOneClassRule (GlyphRun gr, int inPos,
                           int classRuleOffset, int classOffset,
                           int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int glyphCount = getuint16 (classRuleOffset);
    int[] matchedPositions = new int [glyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int g = 1; g &lt; glyphCount; g++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (   classIndex (gr.glyphAt (inPos), classOffset)
          != getuint16 (classRuleOffset + 4 + 2*(g-1))) {
        return null; }

      matchedPositions [g] = inPos;
      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

<code-fragment id='contextualLookup_format2'>
  <code-title>Execute contextual lookup subtable, format 2, and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int classDefOffset = stOffset + getOffset (stOffset + 4);
    int inPos = curGlyph;

    if (-1 == getCoverageIndex (gr.glyphAt (inPos), coverageOffset)) {
      return lookupNotApplied; }

    int cl = classIndex (gr.glyphAt (inPos), classDefOffset);
    if (cl > getuint16 (stOffset + 6) - 1) {
      return lookupNotApplied; }
    int classSetOffset = getOffset (stOffset + 8 + 2*cl);
    if (classSetOffset == 0) {
      return lookupNotApplied; }
    classSetOffset += stOffset;
    int classRuleCnt = getuint16 (classSetOffset);

    for (int i = 0; i &lt; classRuleCnt; i++) {
      int classRuleOffset
        = classSetOffset + getOffset (classSetOffset + 2 + 2*i);
      int glyphCount = getuint16 (classRuleOffset);

      int[] matchedPositions
        = matchOneClassRule (gr, inPos,
                             classRuleOffset, classDefOffset,
                             lookupIndex, lookupFlag);

      if (matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions [matchedPositions.length-1])) {
        int applyCount = getuint16 (classRuleOffset + 2);
        int applyOffset = classRuleOffset + 4 + 2*(glyphCount-1);
        if (listener != null) {
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions,
                                applyCount, applyOffset); }}
    return lookupNotApplied; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>context2_simple: simple case</title>

          <para>Let&#x2019;s start with a simple test that matches the
          sequence [1=20], [2=21], [3=22]. At each position, we then apply a
          our standard sublookups.</para>

<aots:context-test-font id='context2_simple_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	</classDef>

	<pattern in='1 2 3'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_simple_t1' font='context2_simple_f1'
	   inputs ='00,  20,   21,   22,   00'
	   outputs='00,  60,   61,   62,   00'
	   xdeltas='0,   20,   20,   20,    0'
	   ydeltas='0,    0,    0,    0,    0'/>

          <para>Here is a test case on the same font that involves partial
          matches input sequence:</para>

          <aots:context-test
	   id='context2_simple_t2' font='context2_simple_f1'
	   inputs ='00,  20,  00,  20,  21,  00'
	   outputs='00,  20,  00,  20,  21,  00'
	   xdeltas='0,    0,   0,   0,   0,   0'
	   ydeltas='0,    0,   0,   0,   0,   0'/>

	  <para>When applying a sublookup, that must be done as the
	  position given by the contextual lookup, not to all possible
	  positions in the matched input or beyond:</para>

<aots:context-test-font id='context2_simple_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	</classDef>
	<pattern in='1 1 1'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_simple_t3' font='context2_simple_f2'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  20,   60,   20,   20,   20,   00'
	   xdeltas='0,    0,   20,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>context2_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
	  processed after a contextual lookup it applied. The lookup
	  matches the sequence 20, 20  and applies the standard
	  sublookups to the first occurrence of 20.</para>

<aots:context-test-font id='context2_next_glyph_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	</classDef>
	<pattern in='1 1'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_next_glyph_t1' font='context2_next_glyph_f1'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  60,   20,   60,   20,   20,   00'
	   xdeltas='0,   20,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>

        </section>

        <section>
          <title>context2_boundary</title>

          <para>We test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id='context2_boundary_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	</classDef>
	<pattern in='1 1'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_boundary_t1' font='context2_boundary_f1'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  20,   20,   20,   20,   20,   00'
	   xdeltas='0,    0,    0,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>

          <para>Another boundary case is when GlyphCount is 1.</para>

<aots:context-test-font id='context2_boundary_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	</classDef>
	<pattern in='1'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

	  <aots:context-test
	   id='context2_boundary_t2' font='context2_boundary_f2'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  60,   60,   60,   60,   60,   00'
	   xdeltas='0,   20,   20,   20,   20,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>
	</section>


        <section>
          <title>context2_multiple_subrules</title>

          <para>The next two tests ensure that the subrules of
          subruleset are applied in the prescribed order. In the first
          one, the matched sequences are 20, 21, 22, with the standard
          sublookups applied on 20, and 20, 21, with the standard
          sublookups applied on 21.</para>

<aots:context-test-font id='context2_multiple_subrules_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	</classDef>
	<pattern in='1 2 3'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
	<pattern in='1 2'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

	  <aots:context-test
	   id='context2_multiple_subrules_t1'
	   font='context2_multiple_subrules_f1'
	   inputs ='00,  20,   21,   22,   00,   20,   21,   00'
	   outputs='00,  60,   21,   22,   00,   20,   61,   00'
	   xdeltas='0,   20,    0,    0,    0,    0,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0,    0'/>

          <para>In the next test, we just invert the order of two
	  subrules.</para>

<aots:context-test-font id='context2_multiple_subrules_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	</classDef>
	<pattern in='1 2'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
	<pattern in='1 2 3'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_multiple_subrules_t2'
	   font='context2_multiple_subrules_f2'
	   inputs ='00,  20,   21,   22,   00,   20,   21,   00'
	   outputs='00,  20,   61,   22,   00,   20,   61,   00'
	   xdeltas='0,    0,   20,    0,    0,    0,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>context2_successive</title>

          <para>In this test, we verify the case described in the
          SubstLookupRecord section. This applies to GSUB contextual
          lookups only. The matched sequence is 20 21 22 23. Glyphs 21
          and 22 are replaced by glyph 61 and glyph 23 is replaced by
          glyph 63. The difficult part is that the lookup that
          replaces 22 is applied at position 2, which is counted after
          the ligature substitution is applied.</para>

<aots:context-test-font id='context2_successive_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	  <class classID='4' glyphs='23'/>
	</classDef>
	<pattern in='1 2 3 4'>
	  <apply pos='1' lookup='lookup.double'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_successive_t1' font='context2_successive_f1'
	   inputs ='00,  20,   21,   22,  23,   00'
	   outputs='00,  20,   61,        63,   00'
	   xdeltas='0,    0,   20,   20,   0,    0'
	   ydeltas='0,    0,    0,    0,   0,    0'/>
        </section>

        <section>
          <title>context2_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
          sequence is 20 21 22, with standard sublookups applied at
          all three positions.</para>

<aots:context-test-font id='context2_lookupflag_f1'>
  <lookup id='lookup.test' type='contextual' ignoreMarks='yes'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	</classDef>
	<pattern in='1 2 3'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_lookupflag_t1' font='context2_lookupflag_f1'
	   inputs ='00,  20,  90,  21,  91,  92,  22,   00'
	   outputs='00,  60,  90,  61,  91,  92,  62,   00'
	   xdeltas='0,   20,   0,  20,   0,   0,  20,    0'
	   ydeltas='0,    0,   0,   0,   0,   0,   0,    0'/>

	  <para>The interaction between LookupFlag of the contextal
	  substitution and LookupFlag of the sublookups is not very
	  clear. It is certainly desired that any glyph covered by
	  the contextual substitution LookupFlag be invisible to the
	  sublookups; what is unclear is whether this is achieved by
	  constraining legal fonts, or whether OpenType engines have
	  to enforce that behavior. Here is a font that does have
	  consistent LookupFlag, and it should behave properly with
	  all layout engines.</para>

<aots:context-test-font id='context2_lookupflag_f2'>
  <lookup id='lookup.test' type='contextual' ignoreMarks='yes'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	</classDef>
	<pattern in='1 2 3'>
	  <apply pos='1' lookup='lookup.double.nomarks'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_lookupflag_t2' font='context2_lookupflag_f2'
	   inputs ='00,  20,  90,  21,  91,  92,  22,   00'
	   outputs='00,  20,  90,  61,  91,  92,        00'
	   xdeltas='0,    0,   0,  20,   0,   0,   0,    0'
	   ydeltas='0,    0,   0,   0,   0,   0,   0,    0'/>
        </section>

        <section>
          <title>context2_expansion</title>

          <para>As we have noted in multiple substitution lookups, the
          glyph run can be expanded. While a chaining lookup does not
          be itself perform that operation, it may invoke a multiple
          substitution lookup.</para>

<aots:context-test-font id='context2_expansion_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage glyphs='20' format='any'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20'/>
	  <class classID='2' glyphs='21'/>
	  <class classID='3' glyphs='22'/>
	</classDef>
	<pattern in='1 2 3'>
	  <apply pos='1' lookup='lookup.multiple'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_expansion_t1' font='context2_expansion_f1'
	   inputs ='00,  20,  21,            22,  00'
	   outputs='00,  20,  61,  62,  63,  22,  00'
	   xdeltas='0,    0,   0,             0,   0'
	   ydeltas='0,    0,   0,             0,   0'/>
        </section>

        <section>
          <title>context2_classes</title>

          <para>So far, we have used a fairly simple class definition,
          with one glyph per class. Time to do something a bit more
          fancy, with a format 2 Class Definition. Note that the
          coverage of the subtable does not include all the glyphs in
          class 1 (the first class in the input pattern), glyph 22 is
          left out.</para>

<aots:context-test-font id='context2_classes_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='2'>
	<coverage format='any' glyphs='20 21'/>
	<classDef format='any'>
	  <class classID='1' glyphs='20 21 22'/>
	  <class classID='2' glyphs='26 27 28 29'/>
	  <class classID='3' glyphs='24'/>
	</classDef>
	<pattern in='1 2 2 3'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_classes_t1' font='context2_classes_f1'
	   inputs ='00, 20, 26, 28, 24, 00, 21, 27, 26, 24, 00, 22, 27, 26, 24'
	   outputs='00, 20, 66, 28, 24, 00, 21, 67, 26, 24, 00, 22, 27, 26, 24'
	   xdeltas=' 0,  0, 20,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0'
	   ydeltas=' 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0'/>

          <para>So far, the covered glyphs have been in a single
            class. Let&#x2019;s use two SubClassSets, by adding [3] [2] [1]
            as an input sequence.This time, we include glyph 22 in the
            coverage.</para>

<aots:context-test-font id='context2_classes_f2'>
  <lookup id='lookup.test' type='contextual'>
	<contextual format='2'>
	  <coverage format='any' glyphs='20 21 22 24'/>
	  <classDef format='any'>
	    <class classID='1' glyphs='20 21 22'/>
	    <class classID='2' glyphs='26 27 28 29'/>
	    <class classID='3' glyphs='24'/>
	  </classDef>
	  <pattern in='1 2 2 3'>
	    <apply pos='1' lookup='lookup.single'/>
	  </pattern>
	  <pattern in='3 3 2 1'>
	    <apply pos='2' lookup='lookup.single'/>
	  </pattern>
	</contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context2_classes_t2' font='context2_classes_f2'
	   inputs ='00, 22, 27, 26, 24, 00, 24, 24, 29, 22, 00, 22, 27, 26, 24'
	   outputs='00, 22, 67, 26, 24, 00, 24, 24, 69, 22, 00, 22, 67, 26, 24'
	   xdeltas=' 0,  0, 20,  0,  0,  0,  0,  0, 20,  0,  0,  0, 20,  0,  0'
	   ydeltas=' 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Context Substitution Format 3</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 3, coverage-based context substitution, defines
          a context rule as a sequence of coverage tables. Each
          position in the sequence may define a different Coverage
          table for the set of glyphs that matches the context
          pattern. With Format 3, the glyph sets defined in the
          different Coverage tables may intersect, unlike Format 2
          which specifies fixed class assignments (identical for each
          position in the context sequence) and exclusive classes (a
          glyph cannot be in more than one class at a time).</para>

        <para>For example, consider an input context that contains a
          lowercase glyph (position 0), followed by an uppercase glyph
          (position 1), either a lowercase or numeral glyph (position
          2), and then either a lowercase or uppercase vowel (position
          3). This context requires four Coverage tables, one for each
          position:</para>

        <itemizedlist>
          <listitem>
            <para>In position 0, the Coverage table lists the set of
              lowercase glyphs.</para>
          </listitem>
          <listitem>
            <para>In position 1, the Coverage table lists the set of
              uppercase glyphs.</para>
          </listitem>
          <listitem>
            <para>In position 2, the Coverage table lists the set of
              lowercase and numeral glyphs, a superset of the glyphs
              defined in the Coverage table for position 0.</para>
          </listitem>
          <listitem>
            <para>In position 3, the Coverage table lists the set of
              lowercase and uppercase vowels, a subset of the glyphs
              defined in the Coverage tables for both positions 0 and
              1.</para>
          </listitem>
          </itemizedlist>

        <para>Unlike Formats 1 and 2, this format defines only one
          context rule at a time. It consists of a format identifier
          (SubstFormat), a count of the glyphs in the sequence to be
          matched (GlyphCount), and an array of Coverage offsets that
          describe the input context sequence (Coverage).</para>


        <blockquote>
          <para>Note: The order of the Coverage tables listed in the
            Coverage array must follow the writing direction. For text
            written from right to left, then the right-most glyph will
            be first. Conversely, for text written from left to right,
            the left-most glyph will be first.</para>
        </blockquote>

        <para>The subtable also contains a count of the
          substitutions to be performed on the input Coverage sequence
          (SubstCount) and an array of SubstLookupRecords
          (SubstLookupRecord) in design order &#x2013; that is, the order in
          which lookups should be applied to the entire glyph
          sequence.</para>


        <para>Example 9 at the end of this chapter substitutes swash
          glyphs for two out of three glyphs in a sequence.</para>


        <otformat>
          <title>ChainContextSubstFormat3 subtable: Coverage-based
            context glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the input glyph
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [GlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to Coverage table &#x2013; from
              beginning of Substitution table &#x2013; in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords &#x2013; in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>It's probably worth noting that GlyphCount should be
          non-zero.</para>

        <para>It is unclear whether the SubstCount can be 0. At first
          it seems that such a subtable is not interesting, since it
          does nothing. On the other hand, this could be useful to
          prevent the activation of following subtables. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The pattern matched by this subtable is &#x25B6;
	  I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is GlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>i</subscript> is
		Coverage [i] &#x2216; LookupFlag.</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Contextual substitution format 3 type</code-title>
  contextualTable |=
    attribute format { "3" },
    element coverage { coverageTableOffset }*,
    subLookups
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block contextLookupFormat3FromXML (Element subtable, Element table,
                                            Map&lt;Element, Block> blockCache,
					    Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    NodeList coverages = subtable.getElementsByTagName ("coverage");
    int glyphCount = coverages.getLength ();

    NodeList applies = subtable.getElementsByTagName ("apply");
    int substCount = applies.getLength ();

    me = new Block (6 + 2*glyphCount + 4*substCount, glyphCount);
    me.setuint16 (0, 3);
    me.setuint16 (2, glyphCount);
    me.setuint16 (4, substCount);

    for (int i = 0; i &lt; glyphCount; i++) {
      Element coverage = (Element) coverages.item (i);
      me.setOffset (6 + 2*i, coverageFromXML (coverage, table, blockCache)); }

    subLookupsFromXML (substCount, applies, me, 6 + 2*glyphCount, lookupIndices);

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='contextualLookup.toXMLCount_3'>
  for (int c = 0; c &lt; getuint16 (stOffset + 2); c++) {
    coverageTableToXMLCount (stOffset + getOffset (stOffset + 6 + 2*c),
                             counts); }
</code-fragment>

<code-fragment id='contextualLookup.toXML_3'>
  for (int c = 0; c &lt; getuint16 (stOffset + 2); c++) {
    coverageTableToXML (conf, stOffset + getOffset (stOffset + 6 + 2*c),
                        counts); }
</code-fragment>

<code-fragment id='contextualLookup.toXMLEmit_3'>
    int glyphCount = getuint16 (stOffset + 2);
    for (int c = 0; c &lt; glyphCount; c++) {
      at = new AttributesImpl ();
      coverageTableOffsetToXML (conf, stOffset + getOffset (stOffset + 6 + 2*c),
                                counts, "coverage", at); }

    subLookupsToXML (conf, getuint16 (stOffset + 4), stOffset + 6 + 2*glyphCount);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='contextualLookup_format3'>
  <code-title>Execute contextual lookup subtable, format 3, and return</code-title>
  { int glyphCount = getuint16 (stOffset + 2);
    int inPos = curGlyph;
    int [] matchedPositions = new int [glyphCount];

    for (int i = 0; i &lt; glyphCount; i++) {
      if (i != 0) {
        while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
          inPos++; }}

      if (-1 == getCoverageIndex (gr.glyphAt (inPos),
                                  stOffset + getOffset (stOffset + 6 + 2*i))) {
        return lookupNotApplied; }

      matchedPositions [i] = inPos;
      inPos++; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph,
          matchedPositions [matchedPositions.length-1])) {
      return lookupNotApplied; }

    int applyCount = getuint16 (stOffset + 4);
    int applyOffset = stOffset + 6 + 2*glyphCount;
    if (listener != null) {
      listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                 Tag.tag2string (tag), stOffset); }

    return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>context3_simple</title>

          <para>Let&#x2019;s start with a simple test that matches the
	  sequence [0=20] [1=21] [2=22]. At each position, we then
	  apply our standard sublookups.</para>

<aots:context-test-font id='context3_simple_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<coverage glyphs='21' format='any'/>
	<coverage glyphs='22' format='any'/>
	<apply pos='0' lookup='lookup.single'/>
	<apply pos='1' lookup='lookup.single'/>
	<apply pos='2' lookup='lookup.single'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_simple_t1' font='context3_simple_f1'
	   inputs ='00, 20, 21, 22, 00'
	   outputs='00, 60, 61, 62, 00'
	   xdeltas=' 0, 20, 20, 20,  0'
	   ydeltas=' 0,  0,  0,  0,  0'/>

          <para>Here is a test case on the same font that involves partial
            matches input sequence:</para>

          <aots:context-test
	   id='context3_simple_t2' font='context3_simple_f1'
	   inputs ='00, 20, 00, 20, 21, 00, 20, 21, 22, 00'
	   outputs='00, 20, 00, 20, 21, 00, 60, 61, 62, 00'
	   xdeltas=' 0,  0,  0,  0,  0,  0, 20, 20, 20,  0'
	   ydeltas=' 0,  0,  0,  0,  0,  0,  0,  0,  0,  0'/>
        </section>

        <section>
          <title>context3_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
          processed after a Type 5 lookup it applied. The lookup
          matches the sequence 20, 20, and applies the standard
          sublookups.</para>

<aots:context-test-font id='context3_next_glyph_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<coverage glyphs='20' format='any'/>
	<apply pos='0' lookup='lookup.single'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_next_glyph_t1' font='context3_next_glyph_f1'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  60,   20,   60,   20,   20,   00'
	   xdeltas='0,   20,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>context3_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id='context3_boundary_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<coverage glyphs='20' format='any'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_boundary_t1' font='context3_boundary_f1'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  20,   20,   20,   20,   20,   00'
	   xdeltas='0,    0,    0,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>

          <para>Another boundary case is when GlyphCount is 1 (it is
          less interesting than in the other Type 5 subtable formats,
          but we may as well include it anyway).</para>

<aots:context-test-font id='context3_boundary_f2'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<apply pos='0' lookup='lookup.single'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_boundary_t2' font='context3_boundary_f2'
	   inputs ='00,  20,   20,   20,   20,   20,   00'
	   outputs='00,  60,   60,   60,   60,   60,   00'
	   xdeltas='0,   20,   20,   20,   20,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0,    0'/>
        </section>


        <section>
          <title>context3_successive</title>

          <para>In this test, we verify the case described in the
	  SubstLookupRecord section. The matched sequence is 18 19
	  20 21. Glyphs 19 and 20 are replaced by glyph 23 and glyph
	  21 is replaced by glyph 24. The difficult part is that the
	  lookup that replaces 21 by 24 is applied at position 2,
	  which is counted after the ligature substitution is
	  applied.</para>

<aots:context-test-font id='context3_successive_f1'>
  <lookup id='lookup.test' type='contextual'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<coverage glyphs='21' format='any'/>
	<coverage glyphs='22' format='any'/>
	<coverage glyphs='23' format='any'/>

	<apply pos='1' lookup='lookup.double'/>
	<apply pos='2' lookup='lookup.single'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_successive_t1' font='context3_successive_f1'
	   inputs ='00,  20,   21,   22,  23,   00'
	   outputs='00,  20,   61,        63,   00'
	   xdeltas='0,    0,   20,   20,   0,    0'
	   ydeltas='0,    0,    0,    0,   0,    0'/>
        </section>

        <section>
          <title>context3_lookupflag</title>

          <para>Our next test case involves lookupFlag. The input sequence
	  is 18 19 20, and at each position the glyphID is increased by
	  4. Glyph 26 is covered by lookupFlag.</para>

<aots:context-test-font id='context3_lookupflag_f1'>
  <lookup id='lookup.test' type='contextual' ignoreMarks='yes'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<coverage glyphs='21' format='any'/>
	<coverage glyphs='22' format='any'/>

	<apply pos='0' lookup='lookup.single'/>
	<apply pos='1' lookup='lookup.single'/>
	<apply pos='2' lookup='lookup.single'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_lookupflag_t1' font='context3_lookupflag_f1'
	   inputs ='00,  20,  90,  21,  91,  92,  22,   00'
	   outputs='00,  60,  90,  61,  91,  92,  62,   00'
	   xdeltas='0,   20,   0,  20,   0,   0,  20,    0'
	   ydeltas='0,    0,   0,   0,   0,   0,   0,    0'/>

	  <para>The interaction between LookupFlag of the contextal
	  substitution and LookupFlag of the sublookups is not very
	  clear. It is certainly desired that any glyph covered by
	  the contextual substitution LookupFlag be invisible to the
	  sublookups; what is unclear is whether this is achieved by
	  constraining legal fonts, or whether OpenType engines have
	  to enforce that behavior. Here is a font that does have
	  consistent LookupFlag, and it should behave properly with
	  all layout engines.</para>

<aots:context-test-font id='context3_lookupflag_f2'>
  <lookup id='lookup.test' type='contextual' ignoreMarks='yes'>
    <contextual format='3'>
	<coverage glyphs='20' format='any'/>
	<coverage glyphs='21' format='any'/>
	<coverage glyphs='22' format='any'/>

	<apply pos='1' lookup='lookup.double.nomarks'/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='context3_lookupflag_t2' font='context3_lookupflag_f2'
	   inputs ='00,  20,  90,  21,  91,  92,  22,   00'
	   outputs='00,  20,  90,  61,  91,  92,        00'
	   xdeltas='0,    0,   0,  20,   0,   0,   0,    0'
	   ydeltas='0,    0,   0,   0,   0,   0,   0,    0'/>

	</section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 6: Chaining Contextual Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Chaining Contextual Substitution subtable
          (ChainContextSubst) describes glyph substitutions in context
          with an ability to look back and/or look ahead in the
          sequence of glyphs. The design of the Chaining Contextual
          Substitution subtable is parallel to that of the Contextual
          Substitution subtable, including the availability of three
          formats for handling sequences of glyphs, glyph classes, or
          glyph sets. Each format can describe one or more backtrack,
          input, and lookahead sequences and one or more substitutions
          for each sequence.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>In all three formats, the sequences are represented by
	  arrays. The order in those arrays is <emphasis>away from the
	  current position</emphasis>. In other words, if
	  <emphasis>i</emphasis> is the current position, then the
	  first element of the backtrack array is matched against the
	  glyph at position <emphasis>i-1</emphasis> (ignoring glyphs
	  covered by LookupFlag, as usual), and the last element of
	  the backtrack array is matched against the glyph at position
	  <emphasis>i - BacktrackGlyphCount</emphasis>. The first
	  element of the lookahead array is matched against the glyph
	  at position <emphasis>i + InputGlyphCount</emphasis>, and
	  the last element in that array is matched against the glyph
	  as position <emphasis>i + InputGlyphCount +
	  LookaheadGlyphCount - 1</emphasis>.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a chaining contextual
	  substitution, but instead would prefer the compiler to
	  figure out the best representation.:</para>

<code-fragment id='schema'>
  <code-title>ChainingContextualSubst type</code-title>
  chainingContextualTable |=
    attribute format { "any" },
    element subst {
      attribute in { text },
      attribute out { text },
      subLookups
    }*

  standaloneChainingContextualTable =
    element chainingContextualTable {
      attribute id { text },
      chainingContextualTable
    }

  chainingContextualTableOffset = attribute name { text }
    | chainingContextualTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  <code-title>Compile chainingContextualSubst lookups</code-title>
  protected Block chainingLookupFromXML (Element lookupSubtable,
                                         Element table,
                                         Map&lt;Element, Block> blockCache,
					 Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute ("format");
    if ("1".equals (format)) {
      return chainingLookupFormat1FromXML (lookupSubtable, table,
                                             blockCache, lookupIndices); }
    if ("2".equals (format)) {
      return chainingLookupFormat2FromXML (lookupSubtable, table,
                                             blockCache, lookupIndices); }
    if ("3".equals (format)) {
      return chainingLookupFormat3FromXML (lookupSubtable, table,
                                             blockCache, lookupIndices); }
    /* cannot get there with a valid document */
    throw new InvalidFontException
            ("invalid format for contextual chaining lookup (" + format + ")");
}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void chainingLookupToXMLCount (int stOffset, int[] counts) {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend='chainingLookup.toXMLCount_1'/>; break; }
      case 2: { <code-include linkend='chainingLookup.toXMLCount_2'/>; break; }
      case 3: { <code-include linkend='chainingLookup.toXMLCount_3'/>; break; }}
  }

  public void chainingLookupToXML (DecompilerConfig conf,
                                   int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend='chainingLookup.toXML_1'/>; break; }
      case 2: { <code-include linkend='chainingLookup.toXML_2'/>; break; }
      case 3: { <code-include linkend='chainingLookup.toXML_3'/>; break; }}
  }

  public void chainingLookupToXMLEmit (DecompilerConfig conf,
                                       int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    AttributesImpl at;

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend='chainingLookup.toXMLEmit_1'/>; break; }
      case 2: { <code-include linkend='chainingLookup.toXMLEmit_2'/>; break; }
      case 3: { <code-include linkend='chainingLookup.toXMLEmit_3'/>; break; }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>As usual, all subtable formats start with the same
          field, the uint16 SubstFormat, which we use to
          dispatch:</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Execute GSUB 6 subtable and return</code-title>
  public LookupResult applyChainingContextualLookupSubtable
                          (int lookupIndex, int lookupType, int lookupFlag,
                           int stOffset, GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    int substFormat = getuint16 (stOffset);

    switch (substFormat) {
      case 1: { <code-include linkend='chainingLookup_format1'/> }
      case 2: { <code-include linkend='chainingLookup_format2'/> }
      case 3: { <code-include linkend='chainingLookup_format3'/> }
      default:
        throw new InvalidFontException ("GSUB 6/-" + substFormat + "-"); }}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Chaining Context Substitution Format 1: Simple Chaining
        Context Glyph Substitution</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 1 defines the context for a glyph substitution
          as a particular sequence of glyphs. For example, a context
          could be &lt;xyz>, &lt;holiday>, &lt;!?*#@>, or any other glyph
          sequence.</para>

        <para>Within a context sequence, Format 1 identifies
          particular glyph positions (not glyph indices) as the
          targets for specific substitutions. When a text-processing
          client locates a context in a string of text, it finds the
          lookup data for a targeted position and makes a substitution
          by applying the lookup data at that location.</para>

        <para>To specify the context, the coverage table lists the
          first glyph in the input sequence, and the ChainSubRule
          subtable defines the rest. Once a covered glyph is found at
          position i, the client reads the corresponding
          ChainSubRuleSet table and examines each table to determine
          if it matches the surrounding glyphs in the text. There is a
          match if the string &lt;backtrack sequence> + &lt;covered
          glyph> + &lt;input sequence>+&lt;lookahead sequence> matches
          with the glyphs at position i - BacktrackGlyphCount in the
          text.</para>

	<para>To clarify the ordering of glyph arrays for input,
	  backtrack and lookahead sequences, the following
	  illustration is provided. Input sequence match begins at i
	  where the input sequence match begins. The backtrack
	  sequence is ordered beginning at i - 1 and increases in
	  offset value as one moves away from i. The lookahead
	  sequence begins after the input sequence and increases in
	  logical order.</para>

<literallayout>
Logical order      - a  b  c  d  e  f  g  h  i  j
                                 i
Input sequence -                 0  1
Backtrack sequence - 3  2  1  0
Lookahead sequence -                   0  1  2  3
</literallayout>


        <para>If there is a match, then the client finds the target
          glyph positions for substitutions and completes the
          substitutions. Please note that (just like in the
          ContextSubstFormat1 subtable) these lookups are required to
          operate within the range of text from the covered glyph to
          the end of the input sequence. No substitutions can be
          defined for the backtracking sequence or the lookahead
          sequence.</para>

        <para>Once the substitutions are complete, the client should
          move to the glyph position <emphasis>immediately following
            the matched input sequence</emphasis> and resume the
          lookup process from there.</para>

        <para>A single ChainContextSubstFormat1 subtable may define
          more than one context glyph sequence. If different context
          sequences begin with the same glyph, then the Coverage table
          should list the glyph only once because all glyphs in the
          table must be unique. For example, if three contexts each
          start with an "s" and two start with a "t," then the
          Coverage table will list one "s" and one "t."</para>

        <para>All of the ChainSubRule tables defining contexts that
          begin with the same first glyph are grouped together and
          defined in a ChainSubRuleSet table. For example, the
          ChainSubRule tables that define the three contexts that
          begin with an "s" are grouped in one ChainSubRuleSet table,
          and the ChainSubRule tables that define the two contexts
          that begin with a "t" are grouped in a second
          ChainSubRuleSet table. Each glyph listed in the Coverage
          table must have a ChainSubRuleSet table defining all the
          ChainSubRule tables that apply to a covered glyph.</para>


        <para>A ChainContextSubstFormat1 subtable contains a format
          identifier (SubstFormat), an offset to a Coverage table
          (Coverage), a count of defined ChainSubRuleSets
          (ChainSubRuleSetCount), and an array of offsets to the
          ChainSubRuleSet tables (ChainSubRuleSet). As mentioned, one
          ChainSubRuleSet table must be defined for each glyph listed
          in the Coverage table.</para>

        <para>In the ChainSubRuleSet array, the ChainSubRuleSet
          table offsets are ordered in the Coverage Index order. The
          first ChainSubRuleSet in the array applies to the first
          GlyphID listed in the Coverage table, the second
          ChainSubRuleSet in the array applies to the second GlyphID
          listed in the Coverage table, and so on.</para>

        <otformat>
          <title>ChainContextSubstFormat1 subtable: Simple context
            glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubRuleSetCount</otfieldname>
            <otfielddesc>Number of ChainSubRuleSet tables &#x2013; must equal
              GlyphCount in Coverage table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubRuleSet [ChainSubRuleSetCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubRuleSet tables
              &#x2013; from beginning of Substitution table &#x2013;
              ordered by Coverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A ChainSubRuleSet table consists of an array of
          offsets to ChainSubRule tables (ChainSubRule), ordered by
          preference, and a count of the ChainSubRule tables defined
          in the set (ChainSubRuleCount).</para>

        <para>The order in the ChainSubRule array can be
          critical. Consider two contexts, &lt;abc> and &lt;abcd>. If
          &lt;abc> is first in the ChainSubRule array, all instances
          of &lt;abc> in the text &#x2013; including all instances of
          &lt;abcd> &#x2013; will be changed. If &lt;abcd> comes first in the
          array, however, only &lt;abcd> sequences will be changed,
          without affecting any instances of &lt;abc>.</para>

        <otformat>
            <title>ChainSubRuleSet table: All contexts beginning with
            the same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubRuleCount</otfieldname>
            <otfielddesc>Number of ChainSubRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubRule [ChainSubRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubRule tables &#x2013; from
              beginning of ChainSubRuleSet table &#x2013; ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

        <para>A ChainSubRule table consists of a count of the glyphs
          to be matched in the backtrack, input, and lookahead context
          sequences, including the first glyph in each sequence, and
          an array of glyph indices that describe each portion of the
          contexts. The Coverage table specifies the index of the
          first glyph in each context, and each array begins with the
          second glyph (array index = 1) in the context
          sequence.</para>

        <blockquote>
          <para>Note: All arrays list the indices in the order the
            corresponding glyphs appear in the text. For text written
            from right to left, the right-most glyph will be first;
            conversely, for text written from left to right, the
            left-most glyph will be first.</para>
        </blockquote>

        <para>A ChainSubRule table also contains a count of the
          substitutions to be performed on the input glyph sequence
          (SubstCount) and an array of SubstitutionLookupRecords
          (SubstLookupRecord). Each record specifies a position in the
          input glyph sequence and a LookupListIndex to the
          substitution lookup that is applied at that positon. The
          array should list records in design order, or the order the
          lookups should be applied to the entire glyph
          sequence.</para>

        <otformat>
          <title>ChainSubRule subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the backtrack
              sequence (number of glyphs to be matched before the
              first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Backtrack [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of backtracking GlyphID's (to be
              matched before the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the input sequence
              (includes the first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Input [InputGlyphCount-1]</otfieldname>
            <otfielddesc>Array of input GlyphIDs (start with second
              glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the look ahead
              sequence (number of glyphs to be matched after the input
              sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>LookAhead [LookAheadGlyphCount]</otfieldname>
            <otfielddesc>Array of lookahead GlyphID's (to be matched
              after the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8+n+m+p</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords (in design
              order)</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>Second paragraph: "... locates a context in a string of
          text, ..." shoud be replaced by "... locates a context in a
          string of glyphs, ...". Similarly, in the third paragraph,
          replace the last word, "text", by "gyph string".</para>

        <para>Third paragraph, second sentence: add "ChainSubRule" in
          "examines each table".</para>

        <para>To a consistent language, the last paragraph before the
          ChainContextSubtFormat1 table, and the last sentence of the
          previous paragraph, should be replaced by: "The Coverage
          index of the first input glyph is used to index the
          ChainSubRuleSet array and ChainSubRuleSetCount must equal
          the number of glyphs covered by Coverage. The entries in the
          ChainSubRuleSet array cannot be NULL."</para>

        <para>The paragraph describing the impact of the order in the
          ChainSubRule array is a bit misleading. The recommendation
          is to change the last two sentences by "If &lt;abc> is first
          in the ChainSubRule array, the corresponding ChainSubRule
          subtable will be applied first to all instances of &lt;abc>
          in the glyph string &#x2013; including all instances of
          &lt;abcd> &#x2013;. If &lt;abcd> comes first in the array,
          the corresponding ChainSubRule subtable will be applied
          applied first to all instances of &lt;abcd>."</para>


        <para>It is unclear whether the ChainSubRuleCount of a
          ChainSubRuleSet table can be 0. We assume that
          ChainSubRuleCount must be at least 1 and recommend that it
          be spelled out in the specification.</para>

        <para>It is unclear whether the InputGlyphCount of a
          ChainSubRule can be 0 or 1. The value 0 is most certainly
          illegal (since a ChainSubRule table is used in the context
          of a first glyph match). We assume that the value 1 is
          legal, eventhough it is difficult to exhibit an interesting
          use of that case.</para>

        <para>It is unclear whether the SubstCount of a SubRule can be
          0. At first it seems that such a SubRule could be removed,
          since it does nothing. On the other hand, this could be
          useful to prevent the activation of following SubRules; e.g.
          if one wanted the sequence &lt;abc&gt; modified, but not the
          sequence &lt;abcd&gt;.  The recommendation is to explicitly
          mention that case as permitted.</para>

        <para>There is a little ambiguity about the next glyph to
          process: consider the case where some glyphs captured by
          LookupFlag are present between the input glyphs and the
          lookahead glyphs. Should the processing continue with the
          first glyph following with input glyphs, i.e. with the first
          glyph captured by LookupFlag, or should it continue with the
          first lookahead glyph? Whether this matters depends quite on
          bit whether the LookupFlag of a context substitution is
          inherited (either by definition or by constraint on the
          valid font files), and therefore whether a lookup in
          SubstLookupRecord can or cannot change those glyphs.</para>


	<para>The pattern matched by the ChainSubRule table t = ChainSubRuleSet
	  [m].ChainSubRule [n] is

	  B<subscript>b-1</subscript> L* ... L* B<subscript>0</subscript>
          &#x25B6; I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;
          L* A<subscript>0</subscript> L*
	  ... L* A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is t.BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is t.InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is t.LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is {t.Backtrack [k]} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is {t.Input[k-1]} &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is {t.LookAhead[k]} &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current
	  position.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Chaining contextual substitution format 1 type</code-title>
  chainingContextualTable |=
    attribute format { "1" },
    element coverage { coverageTableOffset }?,
    element pattern {
      attribute back { text },
      attribute in { text },
      attribute ahead { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block chainingLookupFormat1FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block> blockCache,
                                              Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList rules = subtable.getChildNodes ();
    int rulesCount = rules.getLength ();

    int [] firstGlyphs = new int [rulesCount];
    for (int i = 0; i &lt; rulesCount; i++) {
      Element rule = (Element) rules.item (i);
      firstGlyphs [i] = getGlyphs (rule.getAttribute ("in")) [0]; }

    if (coverage == null) {
      int [] coveredGlyphs = new int [rulesCount];
      int count = 0;
      for (int i = 0; i &lt; rulesCount; i++) {
        int glyph = firstGlyphs [i];
        boolean addIt = true;
        for (int j = 0; j &lt; count; j++) {
          if (glyph == coveredGlyphs [j]) {
            addIt = false;
            break; }}
        if (addIt) {
          coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }

    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyph [g]
      int nodeCount = 0;
      for (int j = 0; j &lt; rulesCount; j++) {
        if (firstGlyphs [j] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block subRuleSetTable = new Block (2 + 2*nodeCount, nodeCount);
      subRuleSetTable.setuint16 (0, nodeCount);
      nodeCount = 0;
      me.setOffset (6 + 2*g, subRuleSetTable);

      for (int j = 0; j &lt; rulesCount; j++) {
        if (firstGlyphs [j] == coverage.glyphs [g]) {

          Element rule = (Element) rules.item (j);
          int [] backtrack = getGlyphs (rule.getAttribute ("back"));
          int [] in        = getGlyphs (rule.getAttribute ("in"));
          int [] lookahead = getGlyphs (rule.getAttribute ("ahead"));

          NodeList substs = rule.getChildNodes ();
          int substCount = substs.getLength ();

          Block subRuleTable = new Block (  2 + 2 * backtrack.length
                                          + 2 + 2 * (in.length - 1)
                                          + 2 + 2 * lookahead.length
                                          + 2 + 4 * substCount, 0);
          subRuleSetTable.setOffset (2 + 2* (nodeCount++),
                                          subRuleTable);
          int offset = 0;
          subRuleTable.setuint16 (offset, backtrack.length);
          offset += 2;
          for (int k = backtrack.length - 1; k >= 0; k--) {
            subRuleTable.setGlyphID (offset, backtrack [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, in.length);
          offset += 2;
          for (int k = 1; k &lt; in.length; k++) {
            subRuleTable.setGlyphID (offset, in [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, lookahead.length);
          offset += 2;
          for (int k = 0; k &lt; lookahead.length; k++) {
            subRuleTable.setGlyphID (offset, lookahead [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, substCount);
          offset += 2;

	  offset += subLookupsFromXML (substCount, substs, subRuleTable, offset,
				      lookupIndices); }}}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='chainingLookup.toXMLCount_1'>
  /* nothing */
</code-fragment>

<code-fragment id='chainingLookup.toXML_1'>
  /* nothing */
</code-fragment>

<code-fragment id='chainingLookup.toXMLEmit_1'>
    int ruleSetCount = getuint16 (stOffset + 4);
    int[] coveredGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));

    for (int ruleSet = 0; ruleSet &lt; ruleSetCount; ruleSet++) {
      int ruleSetOffset = stOffset + getOffset (stOffset + 6 + 2*ruleSet);
      int ruleCount = getuint16 (ruleSetOffset);

      for (int rule = 0; rule &lt; ruleCount; rule++) {
        int o = ruleSetOffset + getOffset (ruleSetOffset + 2 + 2*rule);
        at = new AttributesImpl ();

        { int backGlyphCount = getuint16 (o);
          o += 2;
          o += (backGlyphCount - 1) * 2;
          StringBuilder s = new StringBuilder ();
          for (int g = 0; g &lt; backGlyphCount; g++) {
            glyphToXML (conf, s, getuint16 (o));
            o -= 2; }
          o += (backGlyphCount + 1) * 2;
          at.addAttribute ("", "back", "back", "CDATA", s.toString ()); }

        { int inGlyphCount = getuint16 (o);
          o += 2;
          StringBuilder s = new StringBuilder ();
          glyphToXML (conf, s, coveredGlyphs [ruleSet]);
          for (int g = 0; g &lt; inGlyphCount - 1; g++) {
            glyphToXML (conf, s, getuint16 (o));
            o += 2; }
          at.addAttribute ("", "in", "in", "CDATA", s.toString ()); }

        { int aheadGlyphCount = getuint16 (o);
          o += 2;
	  StringBuilder s = new StringBuilder ();
          for (int g = 0; g &lt; aheadGlyphCount; g++) {
	    glyphToXML (conf, s, getuint16 (o));
            o += 2; }
          at.addAttribute ("", "ahead", "ahead", "CDATA", s.toString ()); }

        conf.ch.startElement ("pattern", at); {
          int subCount = getuint16 (o);
          o += 2;
          subLookupsToXML (conf, subCount, o);
          conf.ch.endElement ("pattern"); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching of
          a single sub rule. When this procedure is called, it is
          known that the glyph run matched
          I<subscript>0</subscript> and that I<subscript>0</subscript>
          is at <varname>inPos</varname>. If the rest of the pattern
          (i.e. the glyphs in the subrule) is not matched, then this
          procedure returns <varname>null</varname>. Otherwise, it
          returns an array of the glyph run positions for the input
          glyphs, i.e. the positions of I<subscript>0</subscript>,
          I<subscript>1</subscript>, &#x2026;</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: I<subscript>0</subscript> is
          recorded in the Coverage of the subtable, and
          I<subscript>1</subscript>, &#x2026; are recorded in a
          ChainSubRule table; essentially this procedure takes care of
          one ChainSubRule table.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to match one GSUB 6/1 ChainSubRule</code-title>
  int[] matchOneChainRule (GlyphRun gr, int inPos, int ruleOffset,
                              int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int backtrackGlyphCount = getuint16 (ruleOffset);
    int inputGlyphCount = getuint16 (ruleOffset + 2
                                     + 2*backtrackGlyphCount);
    int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                         + 2*backtrackGlyphCount
                                         + 2*(inputGlyphCount - 1));

    int backPos = inPos - 1;
    for (int b = 0;  b &lt; backtrackGlyphCount; b++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (backPos))) {
        backPos--; }

      if (gr.glyphAt (backPos) != getGlyphID (ruleOffset + 2 + 2*b)) {
        return null; }

      backPos--; }


    int [] matchedPositions = new int [inputGlyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; inputGlyphCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getGlyphID (ruleOffset + 4
                                           + 2*backtrackGlyphCount + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    for (int l = 0; l &lt; lookaheadGlyphCount; l++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getGlyphID (ruleOffset + 6
                                           + 2*backtrackGlyphCount
                                           + 2*(inputGlyphCount-1) + 2*l)) {
        return null; }

      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

<code-fragment id='chainingLookup_format1'>
  <code-title>Execute GSUB 6/1 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int ruleSetOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int ruleCount = getuint16 (ruleSetOffset);

    for (int s = 0; s &lt; ruleCount; s++) {
      int ruleOffset = ruleSetOffset + getOffset (ruleSetOffset + 2 + 2*s);

      int [] matchedPositions
        = matchOneChainRule (gr, inPos, ruleOffset,
                                lookupIndex, lookupFlag);

      if (matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions[matchedPositions.length-1])) {
        int backtrackGlyphCount = getuint16 (ruleOffset);
        int inputGlyphCount = getuint16 (ruleOffset + 2
                                         + 2*backtrackGlyphCount);
        int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                             + 2*backtrackGlyphCount
                                             + 2*(inputGlyphCount -1));
        int applyCountOffset = ruleOffset + 6
                                    + 2*backtrackGlyphCount
                                    + 2*(inputGlyphCount - 1)
                                    + 2*lookaheadGlyphCount;
        int applyCount = getuint16 (applyCountOffset);
        int applyOffset = applyCountOffset + 2;
        if (listener != null) {
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }}

    return lookupNotApplied; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>chaining1_simple</title>

          <para>A simple test to start.</para>

<aots:context-test-font id='chaining1_simple_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20' in='21 22' ahead='23'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_simple_t1' font='chaining1_simple_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   62,   23,   00'
	   xdeltas='0,    0,   20,   20,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Our next set of tests verifies partial matches. It
	  uses slightly more complicated pattern: 20 21 : 22 23 24 :
	  25 26, with a standard sublookup applied on 22.</para>

<aots:context-test-font id='chaining1_simple_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20 21' in='22 23 24' ahead='25 26'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <para>First, let&#x2019;s verify that the substitution works:</para>

          <aots:context-test
	   id='chaining1_simple_t2' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25,  26,  00'
	   outputs='00, 20,  21,  62,  23,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,  20,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Partial match on the lookahead:</para>

          <aots:context-test
	   id='chaining1_simple_t3' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25,  00,  00'
	   outputs='00, 20,  21,  22,  23,  24,  25,  00,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough for the lookahead:</para>

          <aots:context-test
	   id='chaining1_simple_t4' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25'
	   outputs='00, 20,  21,  22,  23,  24,  25'
	   xdeltas='0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0'/>

          <para>No glyphs at all for lookahead:</para>

          <aots:context-test
	   id='chaining1_simple_t5' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24'
	   outputs='00, 20,  21,  22,  23,  24'
	   xdeltas='0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0'/>

          <para>Partial match on backtrack:</para>

          <aots:context-test
	   id='chaining1_simple_t6' font='chaining1_simple_f2'
	   inputs ='00, 00,  21,  22,  23,  24,  25,  26,  00'
	   outputs='00, 00,  21,  22,  23,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough for the backtrack:</para>

          <aots:context-test
	   id='chaining1_simple_t7' font='chaining1_simple_f2'
	   inputs =' 21,  22,  23,  24,  25,  26,  00'
	   outputs=' 21,  22,  23,  24,  25,  26,  00'
	   xdeltas='  0,   0,   0,   0,   0,   0,   0'
	   ydeltas='  0,   0,   0,   0,   0,   0,   0'/>

          <para>No glyphs for backtrack at all:</para>

          <aots:context-test
	   id='chaining1_simple_t8' font='chaining1_simple_f2'
	   inputs ='22,  23,  24,  25,  26,  00'
	   outputs='22,  23,  24,  25,  26,  00'
	   xdeltas=' 0,   0,   0,   0,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0'/>

          <para>Partial match on the input:</para>

          <aots:context-test
	   id='chaining1_simple_t9' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22,  00,  24,  25,  26,  00'
	   outputs='00, 20,  21,  22,  00,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough glyphs for the input:</para>

          <aots:context-test
	   id='chaining1_simple_t10' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22,  23'
	   outputs='00, 20,  21,  22,  23'
	   xdeltas='0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0'/>

          <para>Only the first glyph of input matches:</para>

          <aots:context-test
	   id='chaining1_simple_t11' font='chaining1_simple_f2'
	   inputs ='00, 20,  21,  22'
	   outputs='00, 20,  21,  22'
	   xdeltas='0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0'/>
        </section>

        <section>
          <title>chaining1_next_glyph</title>

          <para>The next test makes sure that after a match, the next glyph
	  being processed follows the input part of the pattern match, not
	  the lookahead part. To do this, we extend the coverage of
	  the lookup to include glyph 23, and add a ChainSubRule that
	  matches glyph 23 alone.</para>

<aots:context-test-font id='chaining1_next_glyph_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20' in='21 22' ahead='23'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
	<pattern back='' in='23' ahead=''>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_next_glyph_t1' font='chaining1_next_glyph_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   62,   63,   00'
	   xdeltas='0,    0,   20,   20,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

        </section>

        <section>
          <title>chaining1_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id='chaining1_boundary_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20' in='21 22' ahead='23'>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_boundary_t1' font='chaining1_boundary_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   21,   22,   23,   00'
	   xdeltas='0,    0,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: InputGlyphCount is 1.</para>

<aots:context-test-font id='chaining1_boundary_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20' in='21' ahead='22 23'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_boundary_t2' font='chaining1_boundary_f2'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   22,   23,   00'
	   xdeltas='0,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: BacktrackGlyphCount is 0.</para>

<aots:context-test-font id='chaining1_boundary_f3'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='' in='21' ahead='22 23'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_boundary_t3' font='chaining1_boundary_f3'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   22,   23,   00'
	   xdeltas='0,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

	  <para>Boundary case: AheadGlyphCount is 0.</para>

<aots:context-test-font id='chaining1_boundary_f4'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20 21' in='22' ahead=''>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

	  <aots:context-test
	   id='chaining1_boundary_t4' font='chaining1_boundary_f4'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   21,   62,   23,   00'
	   xdeltas='0,    0,    0,   20,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>chaining1_multiple_subrules</title>

          <para>This next two tests ensure that the ChainSubRules of a
	  ChainSubRuleSet are applied in order. In the first test,
	  the first context pattern is 20 : 21 22 : 23 24
	  and the second is 20 : 21 22 : 23.</para>

<aots:context-test-font id='chaining1_multiple_subrules_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20' in='21 22' ahead='23 24'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
	<pattern back='20' in='21 22' ahead='23'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_multiple_subrules_t1' font='chaining1_multiple_subrules_f1'
	   inputs ='00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00'
	   outputs='00,  20,  61,  22,  23,  24,  00,  20,  21,  62,  23,  00'
	   xdeltas=' 0,   0,  20,   0,   0,   0,   0,   0,   0,  20,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Next, we invert the order of two ChainSubRules:</para>

<aots:context-test-font id='chaining1_multiple_subrules_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='20' in='21 22' ahead='23'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
	<pattern back='20' in='21 22' ahead='23 24'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_multiple_subrules_t2' font='chaining1_multiple_subrules_f2'
	   inputs ='00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00'
	   outputs='00,  20,  21,  62,  23,  24,  00,  20,  21,  62,  23,  00'
	   xdeltas=' 0,   0,   0,  20,   0,   0,   0,   0,   0,  20,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0'/>
        </section>

        <section>
          <title>chaining1_successive</title>

          <para>In this test, we verify the case described in the
	  SubstLookupRecord section. The matched sequence is 18 19 20
	  21. Glyphs 19 and 20 are replaced by glyph 23 and glyph 21 is
	  replaced by glyph 24. The difficult part is that the lookup that
	  replaces 21 by 24 is applied at position 2, which is counted after
	  the ligature substitution is applied.</para>

<aots:context-test-font id='chaining1_successive_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='1'>
	<pattern back='25' in='20 21 22 23' ahead='24'>
	  <apply pos='1' lookup='lookup.double'/>
	  <apply pos='2' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_successive_t1' font='chaining1_successive_f1'
	   inputs ='00,  25,  20,   21,   22,   23,   24,  00'
	   outputs='00,  25,  20,   61,         63,   24,  00,'
	   xdeltas='0,    0,   0,   20,   20,    0,    0,   0,'
	   ydeltas='0,    0,   0,    0,    0,    0,    0,   0,'/>
        </section>

        <section>
          <title>chaining1_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
	  sequence is 18 : 19 20 : 21, and at each position the
	  glyphID is increased by 4. Glyph 26 is covered by
	  lookupFlag.</para>

<aots:context-test-font id='chaining1_lookupflag_f1'>
  <lookup id='lookup.test' type='chainingContextual' ignoreMarks='yes'>
    <chainingContextual format='1'>
	<pattern back='20 21' in='22 23 24' ahead='25 26'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining1_lookupflag_t1' font='chaining1_lookupflag_f1'
	   inputs ='00, 20, 90, 21, 91, 22, 92, 23, 93, 94, 24, 90, 25, 91, 26, 00'
	   outputs='00, 20, 90, 21, 91, 22, 92, 63, 93, 94, 24, 90, 25, 91, 26, 00'
	   xdeltas=' 0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0'
	   ydeltas=' 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0'/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Chaining Context Substitution Format 2: Class-based Chaining
        Context Glyph Substitution</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 2 describes class-based chaining context
          substitution. For this format, a specific integer, called a
          class value, must be assigned to each glyph component in all
          context glyph sequences. Contexts are then defined as
          sequences of glyph class values. More than one context may
          be defined at a time.</para>

        <para>To chain contexts, three classes are used in the glyph
          ClassDef table: Backtrack ClassDef, Input ClassDef, and
          Lookahead ClassDef.</para>

        <para>The ChainContextSubstFormat2 subtable also contains a
          format identifier (SubstFormat) and defines an offset to a
          Coverage table (Coverage). For this format, the Coverage
          table lists indices for the complete set of unique glyphs
          (not glyph classes) that may appear as the first glyph of
          any class-based context. In other words, the Coverage table
          contains the list of glyph indices for all the glyphs in all
          classes that may be first in any of the context class
          sequences. For example, if the contexts begin with a Class 1
          or Class 2 glyph, then the Coverage table will list the
          indices of all Class 1 and Class 2 glyphs.</para>

        <para>A ChainContextSubstFormat2 subtable also defines an
          array of offsets to the ChainSubClassSet tables
          (ChainSubClassSet) and a count of the ChainSubClassSet
          tables (ChainSubClassSetCnt). The array contains one offset
          for each class (including Class 0) in the ClassDef table. In
          the array, the class value defines an offset's index
          position, and the ChainSubClassSet offsets are ordered by
          ascending class value (from 0 to ChainSubClassSetCnt -
          1).</para>

        <para>If no contexts begin with a particular class (that is,
          if a ChainSubClassSet contains no ChainSubClassRule tables),
          then the offset to that particular ChainSubClassSet in the
          ChainSubClassSet array will be set to NULL.</para>

        <otformat>
          <title>ChainContextSubstFormat2 subtable: Class-based
            chaining context glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table &#x2013; from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BacktrackClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table containing
              backtrack sequence data &#x2013; from beginning of Substitution
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>InputClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table containing
              input sequence data &#x2013; from beginning of Substitution
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookaheadClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table containing
              lookahead sequence data &#x2013; from beginning of Substitution
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubClassSetCnt</otfieldname>
            <otfielddesc>Number of ChainSubClassSet
              tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubClassSet [ChainSubClassSetCnt]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubClassSet tables
              &#x2013; from beginning of Substitution table &#x2013;
              ordered by input class &#x2013; may be
              NULL</otfielddesc>
          </otfield>
        </otformat>

        <para>Each context is defined in a ChainSubClassRule table,
          and all ChainSubClassRules that specify contexts beginning
          with the same class value are grouped in a ChainSubClassSet
          table. Consequently, the ChainSubClassSet containing a
          context identifies a context's first class component.</para>

        <para>Each ChainSubClassSet table consists of a count of the
          ChainSubClassRule tables defined in the ChainSubClassSet
          (ChainSubClassRuleCnt) and an array of offsets to
          ChainSubClassRule tables (ChainSubClassRule). The
          ChainSubClassRule tables are ordered by preference in the
          ChainSubClassRule array of the ChainSubClassSet.</para>

        <otformat>
          <title>ChainSubClassSet subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubClassRuleCnt</otfieldname>
            <otfielddesc>Number of ChainSubClassRule
              tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubClassRule [ChainSubClassRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubClassRule tables
              &#x2013; from beginning of ChainSubClassSet &#x2013;
              ordered by preference</otfielddesc>
          </otfield>
        </otformat>

        <para>For each context, a ChainSubClassRule table contains a
          count of the glyph classes in the context sequence
          (GlyphCount), including the first class. A Class array lists
          the classes, beginning with the second class (array index =
          1), that follow the first class in the context.</para>

        <blockquote>
          <para>Note: Text order depends on the writing direction of
            the text. For text written from right to left, the
            right-most class will be first. Conversely, for text
            written from left to right, the left-most class will be
            first.</para>
        </blockquote>

        <para>The values specified in the Class array are the values
          defined in the ClassDef table. The first class in the
          sequence, Class 2, is identified in the
          ChainContextSubstFormat2 table by the ChainSubClassSet array
          index of the corresponding ChainSubClassSet.</para>

        <para>A ChainSubClassRule also contains a count of the
          substitutions to be performed on the context (SubstCount)
          and an array of SubstLookupRecords (SubstLookupRecord) that
          supply the substitution data. For each position in the
          context that requires a substitution, a SubstLookupRecord
          specifies a LookupList index and a position in the input
          glyph sequence where the lookup is applied. The
          SubstLookupRecord array lists SubstLookupRecords in design
          order &#x2013; that is, the order in which lookups should be applied
          to the entire glyph sequence.</para>

        <otformat>
          <title>ChainSubClassRule table: Chaining context definition
            for one class</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the backtrack
              sequence (number of glyphs to be matched before the
              first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Backtrack [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of backtracking classes(to be matched
              before the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Total number of classes in the input sequence
              (includes the first class)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Input [InputGlyphCount-1]</otfieldname>
            <otfielddesc>Array of input classes(start with second
              class; to be matched with the input glyph
              sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Total number of classes in the look ahead
              sequence (number of classes to be matched after the
              input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookAhead [LookAheadGlyphCount]</otfieldname>
            <otfielddesc>Array of lookahead classes(to be matched
              after the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8+n+m+p</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords (in design
              order)</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>The first two paragraphs are somewhat contradictory. The
          recommendation is to replace them by "Format 2 describes
          class-based chaining context substitution. Three class
          definitions are used: one for backtrack sequences
          (BacktrackClassDef), one for input sequences
          (InputClassDef), and one for lookahead sequences
          (LookaheadClassDef). Contexts are then defined as sequences
          of glyph class values, interpreted with respect to the
          corresponding class definitions. More than one context may
          be defined at a time."</para>

        <para>In the description of the Coverage in the third
          paragraph, the sentences starting with "In other words," are
          a bit misleading: the coverage may contain more or less than
          the union of the classes that have non-NULL ChainSubClassSet
          offsets. This can be useful when the class definition is
          shared by multiple lookups. The recommendation is to replace
          the third paragraph by: "The ChainContextSubstFormat2
          subtable also contains a format identifier (SubstFormat) and
          defines an offset to a Coverage table (Coverage). The lookup
          will apply only if the current glyph is covered by Coverage.
          Typically, the coverage is the union of the classes that
          appear as the first class of the input sequence of any
          context; for example, if the input sequences of the contexts
          begin with classes 1 and 2, then the Coverage will be
          exactly the glyphs in classes 1 and 2. However, this is not
          mandatory; in particular, it may be useful to have a
          Coverage which is a subset of those glyphs."</para>

        <para>To adopt a more consistent language, in the fourth
          paragraph, the sentences following the first should be
          replaced by: "The class of the first input glyph under
          InputClassDef is used to index the ChainSubClassSet array and
          ChainSubClassSetCnt must equal the number of classes defined by
          InputClassDef (including class 0)."</para>

        <para>It is unclear whether the ChainSubClassRuleCnt of a
          ChainSubClassSet table can be 0. We assume that
          ChainSubRuleCount must be at least 1 and recommend that it
          be spelled out in the specification.</para>

        <para>It is unclear whether the InputGlyphCount of a ChainSubClassRule
          can be 0 or 1. The value 0 is most certainly illegal (since
          a SubClassRule table is used in the context of a first glyph
          match). We assume that the value 1 is legal (because it
          makes sense for a similar LookupType 6 subtable), eventhough
          it is difficult to exhibit an interesting use of that
          case.</para>

        <para>It is unclear whether the BacktrackGlyphCount and
          Lookaheadglyphcount can be 0. We assume they can be, and
          recommend it be spelled out in the specification.</para>

        <para>It is unclear whether the SubstCount of a ChainSubClassRule
          can be 0. At first it seems that such a ChainSubClassRule could
          be removed, since it does nothing. On the other hand, this
          could be useful to prevent the activation of following
          ChainSubClassRules; e.g. if one wanted the sequence &lt;1 2 3&gt;
          modified, but not the sequence &lt;1 2 3 4&gt;. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The pattern matched by the ChainSubClassRule table t = ChainSubClassSet [m].ChainSubRule [n] is

	  B<subscript>b-1</subscript> L* ... L* B<subscript>0</subscript>
          &#x25B6; I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;
          L* A<subscript>0</subscript> L*
	  ... L* A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is t.BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is t.InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is t.LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is BacktrackClassDef
	      [t.Backtrack [k]] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is (Coverage &#x2229;
	      InputClassDef [m]) &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is InputClassDef
	      [t.Input [k-1]] &#x2216; LookupFlag, for k > 0</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is LookAheadClassDef
	      [t.LookAhead [k]] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current
	  position.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Chaining contextual substitution format 2</code-title>
  chainingContextualTable |=
    attribute format { "2" },
    element coverage { coverageTableOffset }?,
    element backClassDef { classDefTableOffset },
    element inClassDef { classDefTableOffset },
    element aheadClassDef { classDefTableOffset },
    element pattern {
      attribute back { text },
      attribute in { text },
      attribute ahead { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block chainingLookupFormat2FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block> blockCache,
					      Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;

    Element firstChild = (Element) subtable.getFirstChild ();
    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    ClassdefTableBlock backtrackClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    ClassdefTableBlock inputClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    ClassdefTableBlock lookaheadClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    NodeList classPatterns = subtable.getChildNodes ();

    if (coverage == null) {
      System.err.println ("implicit coverage in chainingContextSubstFormat2 not yet supported"); }


    me = new Block (12 + 2*inputClassdef.classCount,
                    4 + inputClassdef.classCount);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setOffset (4, backtrackClassdef);
    me.setOffset (6, inputClassdef);
    me.setOffset (8, lookaheadClassdef);
    me.setuint16 (10, inputClassdef.classCount);

    for (int c = 0; c &lt; inputClassdef.classCount; c++) {

      // count how may classPatterns start with class c
      int count = 0;
      for (int j = 0; j &lt; classPatterns.getLength (); j++) {
        Element classPattern = (Element) classPatterns.item (j);
        int[] classes = parseIntList (classPattern.getAttribute ("in"));
        if (classes [0] == c) {
          count++; }}

      if (count == 0) {
        me.setOffset (12 + 2*c, null); }

      else {
        Block subClassSet = new Block (2 + 2*count, count);
        me.setOffset (12 + 2*c, subClassSet);
        subClassSet.setuint16 (0, count);

        count = 0;
        for (int j = 0; j &lt; classPatterns.getLength (); j++) {
          Element classPattern = (Element) classPatterns.item (j);
          int[] inClasses = parseIntList (classPattern.getAttribute ("in"));
          if (inClasses [0] == c) {
            int[] backtrackClasses
                     = parseIntList (classPattern.getAttribute ("back"));
            int[] lookaheadClasses
                     = parseIntList (classPattern.getAttribute ("ahead"));
            NodeList applies = classPattern.getChildNodes ();
            int applyCount = applies.getLength ();

            Block subClassRule = new Block (  2 + 2 * backtrackClasses.length
                                            + 2 + 2 * (inClasses.length - 1)
                                            + 2 + 2 * lookaheadClasses.length
                                            + 2 + 4 * applyCount,
                                            0);

            subClassSet.setOffset (2 + 2*(count++), subClassRule);

            int offset = 0;
            subClassRule.setuint16 (offset, backtrackClasses.length);
            offset += 2;
            for (int k = backtrackClasses.length - 1; k >= 0; k--) {
              subClassRule.setuint16 (offset, backtrackClasses [k]);
              offset += 2; }
            subClassRule.setuint16 (offset, inClasses.length);
            offset += 2;
            for (int k = 1; k &lt; inClasses.length; k++) {
              subClassRule.setuint16 (offset, inClasses [k]);
              offset += 2; }
            subClassRule.setuint16 (offset, lookaheadClasses.length);
            offset += 2;
            for (int k = 0; k &lt; lookaheadClasses.length; k++) {
              subClassRule.setuint16 (offset, lookaheadClasses [k]);
              offset += 2; }

            subClassRule.setuint16 (offset, applyCount);
            offset += 2;

	    offset += subLookupsFromXML (applyCount, applies, subClassRule, offset,
					lookupIndices); }}}}
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='chainingLookup.toXMLCount_2'>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 4), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 6), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 8), counts);
</code-fragment>

<code-fragment id='chainingLookup.toXML_2'>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 4), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 6), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 8), counts);
</code-fragment>

<code-fragment id='chainingLookup.toXMLEmit_2'>
    int setCount = getuint16 (stOffset + 10);

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, stOffset + getOffset (stOffset + 2), counts,
                              "coverage", at);
    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 4), counts,
                              "backClassDef", at);
    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 6), counts,
                              "inClassDef", at);
    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 8), counts,
                              "aheadClassDef", at);


    for (int set = 0; set &lt; setCount; set++) {
      int x = getOffset (stOffset + 12 + 2*set);
      if (x != 0) {
        int setOffset = stOffset + x;
        int ruleCount = getuint16 (setOffset);

        for (int rule = 0; rule &lt; ruleCount; rule++) {
          int o = setOffset + getOffset (setOffset + 2 + 2*rule);
          at = new AttributesImpl ();

          { int backGlyphCount = getuint16 (o);
            o += 2;
            o += (backGlyphCount - 1) * 2;
            StringBuilder s = new StringBuilder ();
            for (int g = 0; g &lt; backGlyphCount; g++) {
              s.append (" " + getuint16 (o));
              o -= 2; }
            o += (backGlyphCount + 1) * 2;
            at.addAttribute ("", "back", "back", "CDATA",
                             s.toString ()); }

          { int inGlyphCount = getuint16 (o);
            o += 2;
            StringBuilder s = new StringBuilder ();
            s.append ("" + set);
            for (int g = 0; g &lt; inGlyphCount - 1; g++) {
              s.append (" " + getuint16 (o));
              o += 2; }
            at.addAttribute ("", "in", "in", "CDATA",
                             s.toString ()); }

          { int aheadGlyphCount = getuint16 (o);
            o += 2;
            StringBuilder s = new StringBuilder ();
            for (int g = 0; g &lt; aheadGlyphCount; g++) {
              s.append (" " + getuint16 (o));
              o += 2; }
            at.addAttribute ("", "ahead", "ahead", "CDATA",
                             s.toString ()); }

          conf.ch.startElement ("pattern", at); {
            int posCount = getuint16 (o);
            o += 2;
            subLookupsToXML (conf, posCount, o);
            conf.ch.endElement ("pattern"); }}}}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching of
          a single sub rule. When this procedure is called, it is
          known that the glyph run matched
          I<subscript>0</subscript> and that I<subscript>0</subscript>
          is at <varname>inPos</varname>. If the rest of the pattern
          (i.e. the glyphs in the subrule) is not matched, then this
          procedure returns <varname>null</varname>. Otherwise, it
          returns an array of the glyph run positions for the input
          glyphs, i.e. the positions of I<subscript>0</subscript>,
          I<subscript>1</subscript>, &#x2026;</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: I<subscript>0</subscript> is
          recorded in the Coverage of the subtable, and
          I<subscript>1</subscript>, &#x2026; are recorded in a
          ChainSubClassRule table; essentially this procedure takes
          care of one ChainSubClassRule table.</para>

<code-fragment id='lookuptable.methods'>
  <code-title>Method to match one GSUB 6/2 ChainSubClassRule</code-title>
  int[] matchOneChainClassRule (GlyphRun gr, int inPos,
                                int ruleOffset,
                                int backtrackClassDefOffset,
                                int inputClassDefOffset,
                                int lookaheadClassDefOffset,
                                 int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int backtrackGlyphCount = getuint16 (ruleOffset);
    int inputGlyphCount = getuint16 (ruleOffset + 2
                                     + 2*backtrackGlyphCount);
    int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                         + 2*backtrackGlyphCount
                                         + 2*(inputGlyphCount - 1));

    int backPos = inPos - 1;
    for (int b = 0; b &lt; backtrackGlyphCount; b++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (backPos))) {
        backPos--; }

      if (   classIndex (gr.glyphAt (backPos), backtrackClassDefOffset)
          != getuint16 (ruleOffset + 2 + 2*b)) {
        return null; }

      backPos--; }

    int [] matchedPositions = new int [inputGlyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; inputGlyphCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (   classIndex (gr.glyphAt (inPos), inputClassDefOffset)
          != getuint16 (ruleOffset + 4
                        + 2*backtrackGlyphCount + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    for (int l = 0; l &lt; lookaheadGlyphCount; l++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (   classIndex (gr.glyphAt (inPos), lookaheadClassDefOffset)
          != getGlyphID (ruleOffset + 6
                         + 2*backtrackGlyphCount
                         + 2*(inputGlyphCount-1) + 2*l)) {
        return null; }

      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

<code-fragment id='chainingLookup_format2'>
  <code-title>Execute format 2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    if (-1 == getCoverageIndex (gr.glyphAt (inPos), coverageOffset)) {
      return lookupNotApplied; }

    int backtrackClassDefOffset = stOffset + getOffset (stOffset + 4);
    int inputClassDefOffset = stOffset + getOffset (stOffset + 6);
    int lookaheadClassDefOffset = stOffset + getOffset (stOffset + 8);

    int cl = classIndex (gr.glyphAt (inPos), inputClassDefOffset);
    if (cl > getuint16 (stOffset + 10) - 1) {
      return lookupNotApplied; }
    int ruleSetOffset = getOffset (stOffset + 12 + 2*cl);
    if (ruleSetOffset == 0) {
      return lookupNotApplied; }
    ruleSetOffset += stOffset;
    int ruleCount = getuint16 (ruleSetOffset);

    for (int s = 0; s &lt; ruleCount; s++) {
      int ruleOffset
        = ruleSetOffset + getOffset (ruleSetOffset + 2 + 2*s);

      int [] matchedPositions
        = matchOneChainClassRule (gr, inPos, ruleOffset,
                                     backtrackClassDefOffset,
                                     inputClassDefOffset,
                                     lookaheadClassDefOffset,
                                     lookupIndex, lookupFlag);

      if (   matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions[matchedPositions.length-1])) {
        int backtrackGlyphCount = getuint16 (ruleOffset);
        int inputGlyphCount = getuint16 (ruleOffset + 2
                                         + 2*backtrackGlyphCount);
        int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                             + 2*backtrackGlyphCount
                                             + 2*(inputGlyphCount -1));
        int applyCountOffset = ruleOffset + 6
                                    + 2*backtrackGlyphCount
                                    + 2*(inputGlyphCount - 1)
                                    + 2*lookaheadGlyphCount;
        int applyCount = getuint16 (applyCountOffset);
        int applyOffset = applyCountOffset + 2;
        if (listener != null) {
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>chaining2_simple</title>

          <para>A simple test to start.</para>

<code-fragment id='chaining2.classes'>
        <coverage format='any' glyphs='20:26'/>
	<backClassDef format='any'>
	  <class classID='20' glyphs='20'/>
	  <class classID='21' glyphs='21'/>
	  <class classID='22' glyphs='22'/>
	  <class classID='23' glyphs='23'/>
	  <class classID='24' glyphs='24'/>
	  <class classID='25' glyphs='25'/>
	  <class classID='26' glyphs='26'/>
	</backClassDef>
	<inClassDef format='any'>
	  <class classID='20' glyphs='20'/>
	  <class classID='21' glyphs='21'/>
	  <class classID='22' glyphs='22'/>
	  <class classID='23' glyphs='23'/>
	  <class classID='24' glyphs='24'/>
	  <class classID='25' glyphs='25'/>
	  <class classID='26' glyphs='26'/>
	</inClassDef>
	<aheadClassDef format='any'>
	  <class classID='20' glyphs='20'/>
	  <class classID='21' glyphs='21'/>
	  <class classID='22' glyphs='22'/>
	  <class classID='23' glyphs='23'/>
	  <class classID='24' glyphs='24'/>
	  <class classID='25' glyphs='25'/>
	  <class classID='26' glyphs='26'/>
	</aheadClassDef>
</code-fragment>


<aots:context-test-font id='chaining2_simple_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
      <code-include linkend='chaining2.classes'/>
      <pattern back='20' in='21 22' ahead='23'>
	<apply pos='0' lookup='lookup.single'/>
	<apply pos='1' lookup='lookup.single'/>
      </pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_simple_t1' font='chaining2_simple_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   62,   23,   00'
	   xdeltas='0,    0,   20,   20,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Our next set of tests verifies partial matches. It
            uses slightly more complicated pattern: 20 21 : 22 23 24 :
            25 26, with a standard sublookup applied on 22.</para>

<aots:context-test-font id='chaining2_simple_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
	<chainingContextual format='2'>
	  <code-include linkend='chaining2.classes'/>
	  <pattern back='20 21' in='22 23 24' ahead='25 26'>
	    <apply pos='0' lookup='lookup.single'/>
	  </pattern>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <para>First, let&#x2019;s verify that the substitution works:</para>

          <aots:context-test
	   id='chaining2_simple_t2' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25,  26,  00'
	   outputs='00, 20,  21,  62,  23,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,  20,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Partial match on the lookahead:</para>

          <aots:context-test
	   id='chaining2_simple_t3' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25,  00,  00'
	   outputs='00, 20,  21,  22,  23,  24,  25,  00,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough for the lookahead:</para>

          <aots:context-test
	   id='chaining2_simple_t4' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25'
	   outputs='00, 20,  21,  22,  23,  24,  25'
	   xdeltas='0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0'/>


          <para>No glyphs at all for lookahead:</para>

          <aots:context-test
	   id='chaining2_simple_t5' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24'
	   outputs='00, 20,  21,  22,  23,  24'
	   xdeltas='0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0'/>

          <para>Partial match on backtrack:</para>

          <aots:context-test
	   id='chaining2_simple_t6' font='chaining2_simple_f2'
	   inputs ='00, 00,  21,  22,  23,  24,  25,  26,  00'
	   outputs='00, 00,  21,  22,  23,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough for the backtrack:</para>

          <aots:context-test
	   id='chaining2_simple_t7' font='chaining2_simple_f2'
	   inputs =' 21,  22,  23,  24,  25,  26,  00'
	   outputs=' 21,  22,  23,  24,  25,  26,  00'
	   xdeltas='  0,   0,   0,   0,   0,   0,   0'
	   ydeltas='  0,   0,   0,   0,   0,   0,   0'/>

          <para>No glyphs for backtrack at all:</para>

          <aots:context-test
	   id='chaining2_simple_t8' font='chaining2_simple_f2'
	   inputs ='22,  23,  24,  25,  26,  00'
	   outputs='22,  23,  24,  25,  26,  00'
	   xdeltas=' 0,   0,   0,   0,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0'/>

          <para>Partial match on the input:</para>

          <aots:context-test
	   id='chaining2_simple_t9' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22,  00,  24,  25,  26,  00'
	   outputs='00, 20,  21,  22,  00,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough glyphs for the input:</para>

          <aots:context-test
	   id='chaining2_simple_t10' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22,  23'
	   outputs='00, 20,  21,  22,  23'
	   xdeltas='0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0'/>

          <para>Only the first glyph of input matches:</para>

          <aots:context-test
	   id='chaining2_simple_t11' font='chaining2_simple_f2'
	   inputs ='00, 20,  21,  22'
	   outputs='00, 20,  21,  22'
	   xdeltas='0,   0,   0,   0,'
	   ydeltas='0,   0,   0,   0,'/>
        </section>

        <section>
          <title>chaining2_next_glyph</title>

          <para>The next test makes sure that after a match, the next
          glyph being processed follows the input part of the pattern
          match, not the lookahead part. To do this, we extend the
          coverage of the lookup to include glyph 23, and add a
          ChainSubRule that matches glyph 23 alone.</para>

<aots:context-test-font id='chaining2_next_glyph_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='20' in='21 22' ahead='23'>
	  <apply pos='0' lookup='lookup.single'/>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
	<pattern back='' in='23' ahead=''>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_next_glyph_t1' font='chaining2_next_glyph_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   62,   63,   00'
	   xdeltas='0,    0,   20,   20,   20,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>chaining2_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id='chaining2_boundary_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='20' in='21 22' ahead='23'>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_boundary_t1' font='chaining2_boundary_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   21,   22,   23,   00'
	   xdeltas='0,    0,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: InputGlyphCount is 1.</para>

<aots:context-test-font id='chaining2_boundary_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='20' in='21' ahead='22 23'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_boundary_t2' font='chaining2_boundary_f2'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   22,   23,   00'
	   xdeltas='0,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: BacktrackGlyphCount is 0.</para>

<aots:context-test-font id='chaining2_boundary_f3'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='' in='21' ahead='22 23'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_boundary_t3' font='chaining2_boundary_f3'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   22,   23,   00'
	   xdeltas='0,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: AheadGlyphCount is 0.</para>

<aots:context-test-font id='chaining2_boundary_f4'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='20 21' in='22' ahead=''>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_boundary_t4' font='chaining2_boundary_f4'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   21,   62,   23,   00'
	   xdeltas='0,    0,    0,   20,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>
        </section>

        <section>
          <title>chaining2_multiple_subrules</title>

          <para>This next two tests ensure that the ChainSubRules of a
            ChainSubRuleSet are applied in order. In the first test,
            the first context pattern is 20 : 21 22 : 23 24
	    and the second is 20 : 21 22 : 23.</para>

<aots:context-test-font id='chaining2_multiple_subrules_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
	<chainingContextual format='2'>
	  <code-include linkend='chaining2.classes'/>
	  <pattern back='20' in='21 22' ahead='23 24'>
	    <apply pos='0' lookup='lookup.single'/>
	  </pattern>
	  <pattern back='20' in='21 22' ahead='23'>
	    <apply pos='1' lookup='lookup.single'/>
	  </pattern>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_multiple_subrules_t1' font='chaining2_multiple_subrules_f1'
	   inputs ='00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00'
	   outputs='00,  20,  61,  22,  23,  24,  00,  20,  21,  62,  23,  00'
	   xdeltas=' 0,   0,  20,   0,   0,   0,   0,   0,   0,  20,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Next, we invert the order of two ChainSubRules:</para>

<aots:context-test-font id='chaining2_multiple_subrules_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='20' in='21 22' ahead='23'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
	<pattern back='20' in='21 22' ahead='23 24'>
	  <apply pos='0' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_multiple_subrules_t2' font='chaining2_multiple_subrules_f2'
	   inputs ='00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00'
	   outputs='00,  20,  21,  62,  23,  24,  00,  20,  21,  62,  23,  00'
	   xdeltas=' 0,   0,   0,  20,   0,   0,   0,   0,   0,  20,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0'/>
        </section>

        <section>
          <title>chaining2_successive</title>

          <para>In this test, we verify the case described in the
            SubstLookupRecord section. The matched sequence is 18 19 20
            21. Glyphs 19 and 20 are replaced by glyph 23 and glyph 21 is
            replaced by glyph 24. The difficult part is that the lookup that
            replaces 21 by 24 is applied at position 2, which is counted after
            the ligature substitution is applied.</para>

<aots:context-test-font id='chaining2_successive_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
	<chainingContextual format='2'>
	  <code-include linkend='chaining2.classes'/>
	  <pattern back='25' in='20 21 22 23' ahead='24'>
	    <apply pos='1' lookup='lookup.double'/>
	    <apply pos='2' lookup='lookup.single'/>
	  </pattern>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_successive_t1' font='chaining2_successive_f1'
	   inputs ='00,  25,  20,   21,   22,   23,   24,  00'
	   outputs='00,  25,  20,   61,         63,   24,  00'
	   xdeltas='0,    0,   0,   20,   20,    0,    0,   0'
	   ydeltas='0,    0,   0,    0,    0,    0,    0,   0'/>
        </section>

        <section>
          <title>chaining2_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
	  sequence is 18 : 19 20 : 21, and at each position the
	  glyphID is increased by 4. Glyph 26 is covered by
	  lookupFlag.</para>

<aots:context-test-font id='chaining2_lookupflag_f1'>
  <lookup id='lookup.test' type='chainingContextual' ignoreMarks='yes'>
    <chainingContextual format='2'>
	<code-include linkend='chaining2.classes'/>
	<pattern back='20 21' in='22 23 24' ahead='25 26'>
	  <apply pos='1' lookup='lookup.single'/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining2_lookupflag_t1' font='chaining2_lookupflag_f1'
	   inputs ='00, 20, 90, 21, 91, 22, 92, 23, 93, 94, 24, 90, 25, 91, 26, 00'
	   outputs='00, 20, 90, 21, 91, 22, 92, 63, 93, 94, 24, 90, 25, 91, 26, 00'
	   xdeltas=' 0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0'
	   ydeltas=' 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0'/>
        </section>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Chaining Context Substitution Format 3: Coverage-based Chaining
        Context Glyph Substitution</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 3 defines a chaining context rule as a sequence
          of Coverage tables. Each position in the sequence may define
          a different Coverage table for the set of glyphs that
          matches the context pattern. With Format 3, the glyph sets
          defined in the different Coverage tables may intersect,
          unlike Format 2 which specifies fixed class assignments
          (identical for each position in the backtrack, input, or
          lookahead sequence) and exclusive classes (a glyph cannot be
          in more than one class at a time).</para>

        <blockquote>
          <para>Note: The order of the Coverage tables listed in the
            Coverage array must follow the writing direction. For text
            written from right to left, then the right-most glyph will
            be first. Conversely, for text written from left to right,
            the left-most glyph will be first.</para>
        </blockquote>

        <para>The subtable also contains a count of the
          substitutions to be performed on the input Coverage sequence
          (SubstCount) and an array of SubstLookupRecords
          (SubstLookupRecord) in design order: that is, the order in
          which lookups should be applied to the entire glyph
          sequence. (SubstLookupRecords are described next.)</para>

        <otformat>
            <title>ChainContextSubstFormat3 subtable: Coverage-based
            chaining context glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier &#x2013; format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the backtracking
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in
              backtracking sequence, in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in input
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [InputGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in input
              sequence, in glyph sequence order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in lookahead
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [LookaheadGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in
              lookahead sequence, in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2+p+2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords, in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>It is probably worth noting that InputGlyphCount should
          be non-zero, and that BacktrackGlyphCount and
          LookaheadGlyphCount can be zero.</para>

        <para>It is unclear whether the SubstCount can be 0. At first
          it seems that such a subtable is not interesting, since it
          does nothing. On the other hand, this could be useful to
          prevent the activation of following subtables. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The three fields that hold arrays of offsets to
	  coverages have the same name. We assume that their names are
	  Backtrack, Input and Lookahead.</para>

	<para>The pattern matched by this subtable is
          B<subscript>b-1</subscript> L* ... L*
          B<subscript>0</subscript> L* &#x25B6;
	  I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> &#x25C0;
          L* A<subscript>0</subscript> L* ... L*
          A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is Backtrack
	      [k] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is
		Input [k] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is Lookahead
	      [k] &#x2216; LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Chaning contextual substitution format 3 type</code-title>
  chainingContextualTable |=
    attribute format { "3" },
    element backCoverages {
      element coverage { coverageTableOffset }*
    },
    element inCoverages {
      element coverage { coverageTableOffset }*
    },
    element aheadCoverages {
      element coverage { coverageTableOffset }*
    },
    subLookups
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private Block chainingLookupFormat3FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block> blockCache,
					      Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    NodeList backtrack = subtable.getFirstChild ().getChildNodes ();
    int backtrackCount = backtrack.getLength ();
    subtable.removeChild (subtable.getFirstChild ());

    NodeList input = subtable.getFirstChild ().getChildNodes ();
    int inputCount = input.getLength ();
    subtable.removeChild (subtable.getFirstChild ());

    NodeList lookahead = subtable.getFirstChild ().getChildNodes ();
    int lookaheadCount = lookahead.getLength ();
    subtable.removeChild (subtable.getFirstChild ());

    NodeList applies = subtable.getChildNodes ();
    int substCount = applies.getLength ();

    me = new Block (10 + 2*backtrackCount + 2*inputCount + 2*lookaheadCount
                       + 4*substCount,
                    backtrackCount + inputCount + lookaheadCount);
    me.setuint16 (0, 3);

    int offset = 2;
    me.setuint16 (offset, backtrackCount);
    offset += 2;
    for (int i = backtrackCount - 1; i >= 0; i--) {
      Element coverage = (Element) backtrack.item (i);
      me.setOffset (offset, coverageFromXML (coverage, table, blockCache));
      offset += 2; }

    me.setuint16 (offset, inputCount);
    offset += 2;
    for (int i = 0; i &lt; inputCount; i++) {
      Element coverage = (Element) input.item (i);
      me.setOffset (offset, coverageFromXML (coverage, table, blockCache));
      offset += 2; }

    me.setuint16 (offset, lookaheadCount);
    offset += 2;
    for (int i = 0; i &lt; lookaheadCount; i++) {
      Element coverage = (Element) lookahead.item (i);
      me.setOffset (offset, coverageFromXML (coverage, table, blockCache));
      offset += 2; }

    me.setuint16 (offset, substCount);
    offset += 2;
    subLookupsFromXML (substCount, applies, me, offset, lookupIndices);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='chainingLookup.toXMLCount_3'>
  int o = stOffset + 2;

  int backCount = getuint16 (o);
  o += 2;
  for (int c = 0; c &lt; backCount; c++) {
    coverageTableToXMLCount (stOffset + getOffset (o), counts);
    o += 2; }

  int inCount = getuint16 (o);
  o += 2;
  for (int c = 0; c &lt; inCount; c++) {
    coverageTableToXMLCount (stOffset + getOffset (o), counts);
    o += 2; }

  int aheadCount = getuint16 (o);
  o += 2;
  for (int c = 0; c &lt; aheadCount; c++) {
    coverageTableToXMLCount (stOffset + getOffset (o), counts);
    o += 2; }
</code-fragment>

<code-fragment id='chainingLookup.toXML_3'>
    int o = stOffset + 2;

    int backCount = getuint16 (o);
    o += 2;
    for (int c = 0; c &lt; backCount; c++) {
      coverageTableToXML (conf, stOffset + getOffset (o), counts);
      o += 2; }

    int inCount = getuint16 (o);
    o += 2;
    for (int c = 0; c &lt; inCount; c++) {
      coverageTableToXML (conf, stOffset + getOffset (o), counts);
      o += 2; }

    int aheadCount = getuint16 (o);
    o += 2;
    for (int c = 0; c &lt; aheadCount; c++) {
      coverageTableToXML (conf, stOffset + getOffset (o), counts);
      o += 2; }
</code-fragment>

<code-fragment id='chainingLookup.toXMLEmit_3'>
    int o = stOffset + 2;

    conf.ch.startElement ("backCoverages", new AttributesImpl ()); {
      int backCount = getuint16 (o);
      o += 2;
      o += (backCount - 1) * 2;
      for (int c = 0; c &lt; backCount; c++) {
        at = new AttributesImpl ();
        coverageTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  "coverage", at);
        o -= 2; }
      o += (backCount + 1) * 2;
      conf.ch.endElement ("backCoverages"); }

    conf.ch.startElement ("inCoverages", new AttributesImpl ()); {
      int inCount = getuint16 (o);
      o += 2;
      for (int c = 0; c &lt; inCount; c++) {
        at = new AttributesImpl ();
        coverageTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  "coverage", at);
        o += 2; }
      conf.ch.endElement ("inCoverages"); }

    conf.ch.startElement ("aheadCoverages", new AttributesImpl ()); {
      int aheadCount = getuint16 (o);
      o += 2;
      for (int c = 0; c &lt; aheadCount; c++) {
        at = new AttributesImpl ();
        coverageTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  "coverage", at);
        o += 2; }
      conf.ch.endElement ("aheadCoverages"); }

    int posCount = getuint16 (o);
    o += 2;
    subLookupsToXML (conf, posCount, o);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>


<code-fragment id='chainingLookup_format3'>
  <code-title>Execute chaining format 3 subtable and return</code-title>
  { int backtrackGlyphCount = getuint16 (stOffset + 2);
    int inputGlyphCount = getuint16 (stOffset + 4 + 2*backtrackGlyphCount);
    int lookaheadGlyphCount = getuint16 (stOffset + 6 + 2*backtrackGlyphCount
                                         + 2*inputGlyphCount);

    int backPos = curGlyph - 1;

    for (int b = 0 ; b &lt; backtrackGlyphCount; b++) {
      while (lookupFlagCovers (lookupFlag, gr.glyphAt (backPos))) {
        backPos--; }

      if (-1 == getCoverageIndex (gr.glyphAt (backPos),
                                  stOffset + getOffset (stOffset + 4 + 2*b))) {
        return lookupNotApplied; }

      backPos--; }

    int [] matchedPositions = new int [inputGlyphCount];
    int inPos = curGlyph;

    for (int i = 0; i &lt; inputGlyphCount; i++) {
      if (i != 0) {
        while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
          inPos++; }}

      if (-1 == getCoverageIndex (gr.glyphAt (inPos),
                                  stOffset + getOffset (  stOffset + 6
                                                        + 2*backtrackGlyphCount
                                                        + 2*i))) {
        return lookupNotApplied; }

      matchedPositions [i] = inPos;
      inPos++; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos - 1)) {
      return lookupNotApplied; }

    for (int l = 0; l &lt; lookaheadGlyphCount; l++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (-1 == getCoverageIndex (gr.glyphAt (inPos),
                                  stOffset + getOffset (  stOffset + 8
                                                        + 2*backtrackGlyphCount
                                                        + 2*inputGlyphCount
                                                        + 2*l))) {
        return lookupNotApplied; }

      inPos++; }

    int applyCountOffset = stOffset + 8
                                + 2*backtrackGlyphCount
                                + 2*inputGlyphCount
                                + 2*lookaheadGlyphCount;
    int applyCount = getuint16 (applyCountOffset);
    int applyOffset = applyCountOffset + 2;
    if (listener != null) {
      listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                 Tag.tag2string (tag), stOffset); }
    return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Implementation Test</title>

        <section>
          <title>chaining3_simple</title>

          <para>A simple test to start.</para>

<aots:context-test-font id='chaining3_simple_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='20' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='21' format='any'/>
	  <coverage glyphs='22' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='23' format='any'/>
	</aheadCoverages>

	<apply pos='0' lookup='lookup.single'/>
	<apply pos='1' lookup='lookup.single'/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_simple_t1' font='chaining3_simple_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   62,   23,   00'
	   xdeltas='0,    0,   20,   20,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Our next set of tests verifies partial matches. It
            uses slightly more complicated pattern: 20 21 : 22 23 24 :
            25 26, with a standard sublookup applied on 22.</para>

<aots:context-test-font id='chaining3_simple_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
	<chainingContextual format='3'>
	  <backCoverages>
	    <coverage glyphs='20' format='any'/>
	    <coverage glyphs='21' format='any'/>
	  </backCoverages>
	  <inCoverages>
	    <coverage glyphs='22' format='any'/>
	    <coverage glyphs='23' format='any'/>
	    <coverage glyphs='24' format='any'/>
	  </inCoverages>
	  <aheadCoverages>
	    <coverage glyphs='25' format='any'/>
	    <coverage glyphs='26' format='any'/>
	  </aheadCoverages>

	  <apply pos='0' lookup='lookup.single'/>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <para>First, let&#x2019;s verify that the substitution works:</para>

          <aots:context-test
	   id='chaining3_simple_t2' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25,  26,  00'
	   outputs='00, 20,  21,  62,  23,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,  20,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Partial match on the lookahead:</para>

          <aots:context-test
	   id='chaining3_simple_t3' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25,  00,  00'
	   outputs='00, 20,  21,  22,  23,  24,  25,  00,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough for the lookahead:</para>

          <aots:context-test
	   id='chaining3_simple_t4' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24,  25'
	   outputs='00, 20,  21,  22,  23,  24,  25'
	   xdeltas='0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0'/>


          <para>No glyphs at all for lookahead:</para>

          <aots:context-test
	   id='chaining3_simple_t5' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22,  23,  24'
	   outputs='00, 20,  21,  22,  23,  24'
	   xdeltas='0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0'/>

          <para>Partial match on backtrack:</para>

          <aots:context-test
	   id='chaining3_simple_t6' font='chaining3_simple_f2'
	   inputs ='00, 00,  21,  22,  23,  24,  25,  26,  00'
	   outputs='00, 00,  21,  22,  23,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough for the backtrack:</para>

          <aots:context-test
	   id='chaining3_simple_t7' font='chaining3_simple_f2'
	   inputs =' 21,  22,  23,  24,  25,  26,  00'
	   outputs=' 21,  22,  23,  24,  25,  26,  00'
	   xdeltas='  0,   0,   0,   0,   0,   0,   0'
	   ydeltas='  0,   0,   0,   0,   0,   0,   0'/>

          <para>No glyphs for backtrack at all:</para>

          <aots:context-test
	   id='chaining3_simple_t8' font='chaining3_simple_f2'
	   inputs ='22,  23,  24,  25,  26,  00'
	   outputs='22,  23,  24,  25,  26,  00'
	   xdeltas=' 0,   0,   0,   0,   0,   0'
	   ydeltas=' 0,   0,   0,   0,   0,   0'/>

          <para>Partial match on the input:</para>

          <aots:context-test
	   id='chaining3_simple_t9' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22,  00,  24,  25,  26,  00'
	   outputs='00, 20,  21,  22,  00,  24,  25,  26,  00'
	   xdeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0,   0,   0,   0,   0'/>

          <para>Not enough glyphs for the input:</para>

          <aots:context-test
	   id='chaining3_simple_t10' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22,  23'
	   outputs='00, 20,  21,  22,  23'
	   xdeltas='0,   0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0,   0'/>

          <para>Only the first glyph of input matches:</para>

          <aots:context-test
	   id='chaining3_simple_t11' font='chaining3_simple_f2'
	   inputs ='00, 20,  21,  22'
	   outputs='00, 20,  21,  22'
	   xdeltas='0,   0,   0,   0'
	   ydeltas='0,   0,   0,   0'/>
        </section>

        <section>
          <title>chaining3_next_glyph</title>

          <para>The next test makes sure that after a match, the next glyph
	  being processed follows the input part of the pattern match, not
	  the lookahead part.</para>

<aots:context-test-font id='chaining3_next_glyph_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='22' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='21' format='any'/>
	  <coverage glyphs='22' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='21' format='any'/>
	</aheadCoverages>

	<apply pos='0' lookup='lookup.single'/>

    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_next_glyph_t1' font='chaining3_next_glyph_f1'
	   inputs ='00,  22,   21,   22,   21,   22,  21,  00'
	   outputs='00,  22,   61,   22,   61,   22,  21,  00'
	   xdeltas='0,    0,   20,    0,   20,    0,   0,   0'
	   ydeltas='0,    0,    0,    0,    0,    0,   0,   0'/>

        </section>

        <section>
          <title>chaining3_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id='chaining3_boundary_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='20' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='21' format='any'/>
	  <coverage glyphs='22' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='23' format='any'/>
	</aheadCoverages>

    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_boundary_t1' font='chaining3_boundary_f1'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   21,   22,   23,   00'
	   xdeltas='0,    0,    0,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: InputGlyphCount is 1.</para>

<aots:context-test-font id='chaining3_boundary_f2'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='20' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='21' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='22' format='any'/>
	  <coverage glyphs='23' format='any'/>
	</aheadCoverages>

	<apply pos='0' lookup='lookup.single'/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_boundary_t2' font='chaining3_boundary_f2'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   22,   23,   00'
	   xdeltas='0,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>

          <para>Boundary case: BacktrackGlyphCount is 0.</para>

<aots:context-test-font id='chaining3_boundary_f3'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages/>
	<inCoverages>
	  <coverage glyphs='21' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='22' format='any'/>
	  <coverage glyphs='23' format='any'/>
	</aheadCoverages>

	<apply pos='0' lookup='lookup.single'/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_boundary_t3' font='chaining3_boundary_f3'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   61,   22,   23,   00'
	   xdeltas='0,    0,   20,    0,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>


          <para>Boundary case: AheadGlyphCount is 0.</para>

<aots:context-test-font id='chaining3_boundary_f4'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='20' format='any'/>
	  <coverage glyphs='21' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='22' format='any'/>
	</inCoverages>
	<aheadCoverages>
	</aheadCoverages>

	<apply pos='0' lookup='lookup.single'/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_boundary_t4' font='chaining3_boundary_f4'
	   inputs ='00,  20,   21,   22,   23,   00'
	   outputs='00,  20,   21,   62,   23,   00'
	   xdeltas='0,    0,    0,   20,    0,    0'
	   ydeltas='0,    0,    0,    0,    0,    0'/>
        </section>


        <section>
          <title>chaining3_successive</title>

          <para>In this test, we verify the case described in the
          SubstLookupRecord section. The matched sequence is 18 19 20
          21. Glyphs 19 and 20 are replaced by glyph 23 and glyph 21
          is replaced by glyph 24. The difficult part is that the
          lookup that replaces 21 by 24 is applied at position 2,
          which is counted after the ligature substitution is
          applied.</para>

<aots:context-test-font id='chaining3_successive_f1'>
  <lookup id='lookup.test' type='chainingContextual'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='25' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='20' format='any'/>
	  <coverage glyphs='21' format='any'/>
	  <coverage glyphs='22' format='any'/>
	  <coverage glyphs='23' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='24' format='any'/>
	</aheadCoverages>

	<apply pos='1' lookup='lookup.double'/>
	<apply pos='2' lookup='lookup.single'/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_successive_t1' font='chaining3_successive_f1'
	   inputs ='00,  25,  20,   21,   22,   23,   24,  00'
	   outputs='00,  25,  20,   61,         63,   24,  00'
	   xdeltas='0,    0,   0,   20,   20,    0,    0,   0'
	   ydeltas='0,    0,   0,    0,    0,    0,    0,   0'/>
        </section>

        <section>
          <title>chaining3_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
          sequence is 18 : 19 20 : 21, and at each position the
          glyphID is increased by 4. Glyph 26 is covered by
          lookupFlag.</para>

<aots:context-test-font id='chaining3_lookupflag_f1'>
  <lookup id='lookup.test' type='chainingContextual' ignoreMarks='yes'>
    <chainingContextual format='3'>
	<backCoverages>
	  <coverage glyphs='20' format='any'/>
	  <coverage glyphs='21' format='any'/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs='22' format='any'/>
	  <coverage glyphs='23' format='any'/>
	  <coverage glyphs='24' format='any'/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs='25' format='any'/>
	  <coverage glyphs='26' format='any'/>
	</aheadCoverages>

	<apply pos='1' lookup='lookup.single'/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test
	   id='chaining3_lookupflag_t1' font='chaining3_lookupflag_f1'
	   inputs ='00, 20, 90, 21, 91, 22, 92, 23, 93, 94, 24, 90, 25, 91, 26, 00'
	   outputs='00, 20, 90, 21, 91, 22, 92, 63, 93, 94, 24, 90, 25, 91, 26, 00'
	   xdeltas=' 0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0'
	   ydeltas=' 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>LookupType 7: Extension Substitution</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This lookup provides a mechanism whereby any other
          lookup type's subtables are stored at a 32-bit offset
          location in the <ottable>GSUB</ottable> table. This is
          needed if the total size of the subtables exceeds the 16-bit
          limits of the various other offsets in the
          <ottable>GSUB</ottable> table. In this specification, the
          subtable stored at the 32-bit offset location is termed the
          &#x201c;extension&#x201d; subtable.</para>

        <otformat>
          <title>ExtensionSubstFormat1 subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier. Set to 1.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>ExtensionLookupType</otfieldname>
            <otfielddesc>Lookup type of subtable referenced by
              ExtensionOffset (i.e. the extension
              subtable).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ExtensionOffset</otfieldname>
            <otfielddesc>Offset to the extension subtable, of lookup
              type ExtensionLookupType, relative to the start of the
              ExtensionSubstFormat1 subtable.</otfielddesc>
          </otfield>
        </otformat>

        <para>ExtensionLookupType must be set to any lookup type other
          than 7. All subtables in a LookupType 7 lookup must have the
          same ExtensionLookupType. All offsets in the extension
          subtables are set in the usual way, i.e. relative to the
          extension subtables themselves.</para>

        <para>When an OpenType layout engine encounters a LookupType 7
          Lookup table, it shall:</para>

        <itemizedlist>
          <listitem>
            <para>Proceed as though the Lookup table's LookupType
              field were set to the ExtensionLookupType of the
              subtables.</para>
          </listitem>
          <listitem>
            <para>Proceed as though each extension subtable referenced
              by ExtensionOffset replaced the LookupType 7 subtable
              that referenced it.</para>
          </listitem>
        </itemizedlist>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>This subtable does not match a pattern by itself, nor
	  does it have an action by itself.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>Coverage tables</code-title>
  extensionTable |=
    attribute format { "1" },
    element ext {
      attribute type { text },
      attribute name { text }
    }

  standaloneExtensionTable =
    element extensionTable { attribute id { text }, extensionTable }

  extensionTableOffset = attribute name { text } | extensionTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  protected Block extensionFormat1FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block> blockCache,
					   Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    Element ext = (Element) subtable.getFirstChild ();

    int targetType = Integer.parseInt (ext.getAttribute ("type"));
    String t = ext.getAttribute ("name");
    Element targetElem = resolveXMLid (table, t);
    Block target = lookupSubtableFromXML (targetElem, table,
                                          blockCache, targetType, lookupIndices);

    me = new Block (8, 1);
    me.setuint16 (0, 1);
    me.setuint16 (2, targetType);
    me.setBigOffset (4, target);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  public void extensionLookupToXMLCount (int stOffset, int[] counts) {
    int targetType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int) getuint32 (stOffset + 4);

    lookupSubtableToXMLCount (extensionOffset, counts, targetType);

    // This will force the target to be emitted on its own
    counts [extensionOffset] += 2;
  }

  public void extensionLookupToXML (DecompilerConfig conf,
                                   int stOffset, int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    int targetType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int) getuint32 (stOffset + 4);

    lookupSubtableToXML (conf, extensionOffset, counts, targetType);
  }

  public void extensionLookupToXMLEmit (DecompilerConfig conf,
                                        int stOffset, int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    int targetType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int) getuint32 (stOffset + 4);

    AttributesImpl at = new AttributesImpl ();

    at.addAttribute ("", "type", "type", "CDATA", "" + targetType);

    counts [extensionOffset] += 2;
    lookupSubtableOffsetToXML (conf, extensionOffset, counts, targetType);

    conf.ch.element ("ext", at);
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='lookuptable.methods'>
  <code-title>Execute GSUB 7 subtable and return</code-title>
  public LookupResult applyExtensionLookupSubtable
                          (int lookupIndex, int lookupType, int lookupFlag,
                           int stOffset, GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    int extensionLookupType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int)getuint32 (stOffset + 4);

    return applyLookupSubtable (lookupIndex, extensionLookupType,
                                lookupFlag, extensionOffset, gr,
                                curGlyph);
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

        <section>
          <title>gsub7_font1/2: basic tests</title>

	  <para>Our first font has a single subtable.</para>

<aots:test-font id='gsub7_font1'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='7'>
	<extensionSubst format='1'>
	  <ext type='1' name='singlesubst'/>
	</extensionSubst>
      </lookup>
    </lookupList>

    <singleSubstTable id='singlesubst' format='1'>
      <coverage glyphs='18 19' format='any'/>
      <delta v='5'/>
    </singleSubstTable>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub7_test1'
	   font='gsub7_font1'
	   inputs= '17, 18, 19, 20, 21'
	   outputs='17, 23, 24, 20, 21'/>

	  <para>Let&#x2019;s have multiple subtables.</para>

<aots:test-font id='gsub7_font2'>
  <base-font name='base.otf'/>
  <GSUB major='1' minor='0'>
    <code-include linkend='testfonts.gsub.scripts_features'/>
    <lookupList>
      <lookup id="lookup.test" type='7'>
	<extensionSubst format='1'>
	  <ext type='1' name='singlesubst1'/>
	</extensionSubst>
	<extensionSubst format='1'>
	  <ext type='1' name='singlesubst2'/>
	</extensionSubst>
      </lookup>
    </lookupList>

    <singleSubstTable id='singlesubst1' format='1'>
      <coverage glyphs='18' format='any'/>
      <delta v='5'/>
    </singleSubstTable>

    <singleSubstTable id='singlesubst2' format='1'>
      <coverage glyphs='19' format='any'/>
      <delta v='10'/>
    </singleSubstTable>
  </GSUB>
</aots:test-font>

          <aots:gsub-test
	   id='gsub7_test2'
	   font='gsub7_font2'
	   inputs= '17, 18, 19, 20, 21'
	   outputs='17, 23, 29, 20, 21'/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Lookup Type 8: Reverse Chaining Contextual Single
	Substitution</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Reverse Chaining Contextual Single Substitution subtable
	  (ReverseChainSingleSubst) describes single glyph
	  substitutions in context with an ability to look back and/or
	  look ahead in the sequence of glyphs. The major difference
	  between this and other lookup types is that processing of
	  input glyph sequence goes from end to start. Comparing to
	  Chaining Contextual Sustitution this format is restricted to
	  only coverage based subtable format, input sequence could
	  contain only single glyph and only single substitution
	  allowed on this glyph. This substitution rule is integrated
	  into subtable format.</para>

	<para>This lookup type is designed specifically for the Arabic
	  script writing styles, like nastaliq, where the shape of the
	  glyph is determined by the following glyph, beginning at the
	  last glyph of the "joor", or set of connected glyphs. An
	  example of this lookup type is defined in Example 10 at the
	  end of this chapter.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Reverse Chaining Contextual Single Substitution Format 1:
	Coverage Based Reverse Chaining Contextual Single Glyph
	Substitution.</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Format 1 defines a chaining context rule as a sequence
	  of Coverage tables. Each position in the sequence may define
	  a different Coverage table for the set of glyphs that
	  matches the context pattern. With Format 1, the glyph sets
	  defined in the different Coverage tables may
	  intersect.</para>

	<para>Note: Despite reverse order processing, the order of the
	  Coverage tables listed in the Coverage array must be in
	  logical order (follow the writing direction). The backtrack
	  sequence is as illustrated in the LookupType 6: Chaining
	  Contextual Substitution subtable. The input sequence is one
	  glyph located at i in the logical string. The backtrack
	  begins at i - 1 and increases in offset value as one moves
	  toward the logical beginning of the string. The lookahead
	  sequence begins at i + 1 and increases in offset value as
	  one moves toward the logical end of the string. In the
	  reverse chaining process i began at the logical end of the
	  string and moves to the beginning.</para>

	<para>The subtable contains Coverage table for input glyph and
	  Coverage table arrays for lookahead and backtrack sequences,
	  also count of output glyph indices in the Substitute array
	  (GlyphCount), and a list of the output glyph indices
	  (Substitute array). The Substitute array must contain the
	  same number of glyph indices as the Coverage table. To
	  locate the corresponding output glyph index in the
	  Substitute array, this format uses the Coverage Index
	  returned from the Coverage table.</para>

	<otformat>
	  <title>ReverseChainSingleSubstFormat1 subtable:
	    Coverage-based Reverse Chaining Contextual Single Glyph
	    substitution.</title>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>SubstFormat</otfieldname>
	    <otfielddesc>Format identifier &#x2019; format = 1</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>Offset</otfieldtype>
	    <otfieldname>Coverage</otfieldname>
	    <otfielddesc>Offset to Coverage table - from beginning of
	      Substitution table</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>BacktrackGlyphCount</otfieldname>
	    <otfielddesc>Number of glyphs in the backtracking
	      sequence</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>Offset</otfieldtype>
	    <otfieldname>Coverage [BacktrackGlyphCount]</otfieldname>
	    <otfielddesc>Array of offsets to coverage tables in
	      backtracking sequence, in glyph sequence order</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>LookaheadGlyphCount</otfieldname>
	    <otfielddesc>Number of glyphs in lookahead sequence</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>Offset</otfieldtype>
	    <otfieldname>Coverage[LookaheadGlyphCount]</otfieldname>
	    <otfielddesc>Array of offsets to coverage tables in
	      lookahead sequence, in glyph sequence order</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>GlyphCount</otfieldname>
	    <otfielddesc>Number of GlyphIDs in the Substitute array</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>GlyphID</otfieldtype>
	    <otfieldname>Substitute[GlyphCount]</otfieldname>
	    <otfielddesc>Array of substitute GlyphIDs-ordered by
	      Coverage Index</otfielddesc>
	  </otfield>
	</otformat>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Substitution Lookup Record</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All contextual substitution subtables specify the
          substitution data in a Substitution Lookup Record
          (SubstLookupRecord). Each record contains a SequenceIndex,
          which indicates the position where the substitution will
          occur in the glyph sequence. In addition, a LookupListIndex
          identifies the lookup to be applied at the glyph position
          specified by the SequenceIndex.</para>

        <para>The contextual substitution subtables defined in
          Examples 7, 8, and 9 at the end of this chapter show
          SubstLookupRecords.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

        <para>As noted earlier, the description of a SubstLookupRecord
          should be moved back in this section.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>subLookups</code-title>
  subLookups =
    element apply {
      attribute pos { text },
      attribute lookup { text }
    }*
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='lookuptable.methods'>
  private int subLookupsFromXML (int count, NodeList nl, Block b, int offset,
                                 Map&lt;String, Integer> lookupIndices)
      throws InvalidFontException, UnsupportedFontException {
    for (int k = 0; k &lt; count; k++) {
      Element apply = (Element) nl.item (k);
      b.setuint16 (offset,
                   Integer.parseInt (apply.getAttribute ("pos")));

      String lookupName = apply.getAttribute ("lookup");
      int index = 0;
      try {
        index = Integer.parseInt (lookupName); }
      catch (java.lang.NumberFormatException e) {
        Integer ii = lookupIndices.get (lookupName);
        if (ii == null) {
          warning ("cannot resolve '" + lookupName + "'"); }
        index = ii.intValue (); }

      b.setuint16 (offset + 2, index);

      offset += 4; }

    return offset;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='lookuptable.methods'>
  protected void subLookupsToXML (DecompilerConfig conf, int count, int offset)
      throws org.xml.sax.SAXException, InvalidFontException {

    for (int i = 0; i &lt; count; i++) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute ("", "pos", "pos", "CDATA", "" + getuint16 (offset));
      at.addAttribute ("", "lookup", "lookup", "CDATA",
                       "lookup_" + getuint16 (offset + 2));
      conf.ch.element ("apply", at);
      offset += 4; }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment id='lookuptable.methods'>
  <code-title>Apply subLookups</code-title>
  public LookupResult applySubLookups (GlyphRun gr, int[] matchedPositions,
                                       int count, int offset)
      throws InvalidFontException {

    LookupResult result
      = new LookupResult (true,
                          matchedPositions [matchedPositions.length -1] + 1,
                          0);

    for (int su = 0; su &lt; count; su++) {
      int sequenceIndex = getuint16 (offset);
      int lookupListIndex = getuint16 (offset + 2);
      offset += 4;
      LookupResult r = applyLookup (lookupListIndex, gr,
                                    matchedPositions [sequenceIndex]);
      if (r.applied) {
        result.nextToProcess += r.countAdjust;
        result.countAdjust += r.countAdjust; }}

    return result;
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>GSUB Subtable Examples</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The rest of this chapter describes and illustrates
          examples of all the <ottable>GSUB</ottable> subtables,
          including each of the three formats available for contextual
          substitutions. All the examples reflect unique parameters
          described below, but the samples provide a useful reference
          for building subtables specific to other situations.</para>

        <para>All the examples have three columns showing hex data,
          source, and comments.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 1: GSUB Header Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 1 shows a typical <ottable>GSUB</ottable> Header table
          definition.</para>

        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>GSUBHeader</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheGSUBHeader</otexsrc>
            <otexcom>GSUBHeader table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00010000</otexdata>
            <otexsrc>0x00010000</otexsrc>
            <otexcom>version</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>TheScriptList</otexsrc>
            <otexcom>offset to ScriptList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001E</otexdata>
            <otexsrc>TheFeatureList</otexsrc>
            <otexcom>offset to FeatureList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>TheLookupList</otexsrc>
            <otexcom>offset to LookupList table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 2: SingleSubstFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 2 illustrates the SingleSubstFormat1 subtable,
          which uses ranges to replace single input glyphs with their
          corresponding output glyphs. The indices of the output
          glyphs are calculated by adding a constant delta value to
          the indices of the input glyphs. In this example, the
          Coverage table has a format identifier of 1 to indicate the
          range format, which is used because the input glyph indices
          are in consecutive order in the font. The Coverage table
          specifies one range that contains a StartGlyphID for the "0"
          (zero) glyph and an EndGlyphID for the "9" glyph.</para>


        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SingleSubstFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LiningNumeralSubtable</otexsrc>
            <otexcom>SingleSubst subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>LiningNumeralCoverage</otexsrc>
            <otexcom>offset to Coverage table for input
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>00C0</otexdata>
            <otexsrc>192</otexsrc>
            <otexcom>DeltaGlyphID = 192, add to each input glyph
                  index to produce output glyph inde</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LiningNumeralCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat, ranges   1 RangeCount
                  RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004E</otexdata>
            <otexsrc>78</otexsrc>
            <otexcom>Start GlyphID for numeral zero glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0058</otexdata>
            <otexsrc>87</otexsrc>
            <otexcom>End GlyphID for numeral nine glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex first CoverageIndex =
                  0</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3: SingleSubstFormat2 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 3 uses the SingleSubstFormat2 subtable for lists
          to substitute punctuation glyphs in Japanese text that is
          written vertically. Horizontally oriented parentheses and
          square brackets (the input glyphs) are replaced with
          vertically oriented parentheses and square brackets (the
          output glyphs).</para>
        <para>The Coverage table, Format 1, identifies each input
          glyph index. The number of input glyph indices listed in the
          Coverage table matches the number of output glyph indices
          listed in the subtable. For correct substitution, the order
          of the glyph indices in the Coverage table (input glyphs)
          must match the order in the Substitute array (output
          glyphs).</para>


        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SingleSubstFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>VerticalPunctuationSubtable</otexsrc>
            <otexcom>SingleSubst
                  subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubstFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>VerticalPunctuationCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>GlyphCount, equals GlyphCount in Coverage
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0131</otexdata>
            <otexsrc>VerticalOpenBracketGlyph</otexsrc>
            <otexcom>Substitute[0], ordered by Coverage
                  Index</otexcom>
          </otexline>
          <otexline>
            <otexdata>0135</otexdata>
            <otexsrc>VerticalClosedBracketGlyph</otexsrc>
            <otexcom>Substitute[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>013E</otexdata>
            <otexsrc>VerticalOpenParenthesisGlyph</otexsrc>
            <otexcom>Substitute[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0143</otexdata>
            <otexsrc>VerticalClosedParenthesisGlyph</otexsrc>
            <otexcom>Substitute[3</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>VerticalPunctuationCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>003C</otexdata>
            <otexsrc>HorizontalOpenBracketGlyph</otexsrc>
            <otexcom>GlyphArray[0], ordered by GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>HorizontalClosedBracketGlyph</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004B</otexdata>
            <otexsrc>HorizontalOpenParenthesisGlyph</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004F</otexdata>
            <otexsrc>HorizontalClosedParenthesisGlyph</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4: MultipleSubstFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 4 uses a MultipleSubstFormat1 subtable to
          replace a single "ffi" ligature with three individual glyphs
          that form the string &lt;ffi>. The subtable defines a format
          identifier of 1, an offset to a Coverage table that
          specifies the glyph index of the "ffi" ligature (the input
          glyph), an offset to a Sequence table that specifies the
          sequence of glyph indices for the &lt;ffi> string in its
          substitute array (the output glyph sequence), and a count of
          Sequence table offsets.</para>


        <otexample>
          <title>Example 4</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>MultipleSubstFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FfiDecompSubtable</otexsrc>
            <otexcom>MultipleSubst subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>FfiDecompCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceCount, equals GlyphCount in Coverage
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>FfiDecompSequence</otexsrc>
            <otexcom>offset to Sequence[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FfiDecompCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F1</otexdata>
            <otexsrc>ffiGlyphID</otexsrc>
            <otexcom>ligature glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Sequence</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FfiDecompSequence</otexsrc>
            <otexcom>Sequence table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>first glyph in sequence order</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>second glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>001D</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>third glyph</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 5: AlternateSubstFormat 1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 5 uses the AlternateSubstFormat1 subtable to
          replace the default ampersand glyph (input glyph) with one
          of two alternative ampersand glyphs (output glyph).</para>
        <para>In this case, the Coverage table specifies the index of
          a single glyph, the default ampersand, because it is the
          only glyph covered by this lookup. The AlternateSet table
          for this covered glyph identifies the alternative glyphs:
          AltAmpersand1GlyphID and AltAmpersand2GlyphID.</para>
        <para>In Example 5, the index position of the AlternateSet
          table offset in the AlternateSet array is zero (0), which
          correlates with the index position (also zero) of the
          default ampersand glyph in the Coverage table.</para>


        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AlternateSubstFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AltAmpersandSubtable</otexsrc>
            <otexcom>AlternateSubstFormat1
                  subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>AltAmpersandCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AlternateSetCnt, equals GlyphCount in Coverage
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>AltAmpersandSet</otexsrc>
            <otexcom>offset to AlternateSet[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AltAmpersandCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>003A</otexdata>
            <otexsrc>DefaultAmpersandGlyphID</otexsrc>
            <otexcom>GlyphArray[0</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AlternateSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AltAmpersandSet</otexsrc>
            <otexcom>AlternateSet table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>00C9</otexdata>
            <otexsrc>AltAmpersand1GlyphID</otexsrc>
            <otexcom>offset to Alternate[0], in arbitrary
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>00CA</otexdata>
            <otexsrc>AltAmpersand2GlyphID</otexsrc>
            <otexcom>offset to Alternate[1]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 6: LigatureSubstFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 6 shows a LigatureSubstFormat1 subtable that
          defines data to replace a string of glyphs with a single
          ligature glyph. Because a LigatureSubstFormat1 subtable can
          specify glyph substitutions for more than one ligature, this
          subtable defines three ligatures: "etc," "ffi," and "fi."
        </para>
        <para>The sample subtable contains a format identifier (4) and
          an offset to a Coverage table. The Coverage table, which
          lists an index for each first glyph in the ligatures, lists
          indices for the "e" and "f" glyphs. The Coverage table range
          format is used here because the "e" and "f" glyph indices
          are numbered consecutively.</para>
        <para>In the LigatureSubst subtable, LigSetCount specifies two
          LigatureSet tables, one for each covered glyph, and the
          LigatureSet array stores offsets to them. In this array, the
          "e" LigatureSet precedes the "f" LigatureSet, matching the
          order of the corresponding first-glyph components in the
          Coverage table.</para>
        <para>Each LigatureSet table identifies all ligatures that
          begin with a covered glyph. The sample LigatureSet table
          defined for the "e" glyph contains only one ligature, "etc."
          A LigatureSet table defined for the "f" glyph contains two
          ligatures, "ffi" and "fi."</para>
        <para>The sample FLigaturesSet table has offsets to two
          Ligature tables, one for "ffi" and one for "fi." The
          Ligature array lists the "ffi" Ligature table first to
          indicate that the "ffi" ligature is preferred to the "fi"
          ligature.</para>


        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigatureSubstFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigaturesSubtable</otexsrc>
            <otexcom>LigatureSubstFormat1 subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>LigaturesCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LigSetCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>ELigaturesSet</otexsrc>
            <otexcom>offset to LigatureSet[0] table in Coverage
                  Index order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>FLigaturesSet</otexsrc>
            <otexcom>offset to LigatureSet[1] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigaturesCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0019</otexdata>
            <otexsrc>eGlyphID</otexsrc>
            <otexcom>Start, first GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>End, last GlyphID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex, coverage index of start
                  glyphI</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigatureSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ELigaturesSet</otexsrc>
            <otexcom>LigatureSet table definition all
                  ligatures that start with e</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LigatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>etcLigature</otexsrc>
            <otexcom>offset to Ligature[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Ligature</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>etcLigature</otexsrc>
            <otexcom>Ligature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>015B</otexdata>
            <otexsrc>etcGlyphID</otexsrc>
            <otexcom>LigGlyph, output GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>CompCount number of components</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>tGlyphID</otexsrc>
            <otexcom>Component[1], second component in
                  ligature</otexcom>
          </otexline>
          <otexline>
            <otexdata>0017</otexdata>
            <otexsrc>cGlyphID</otexsrc>
            <otexcom>Component[2], third component in
                  ligatur</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>LigatureSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FLigaturesSet</otexsrc>
            <otexcom>LigatureSet table definition all
                  ligatures start with f</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LigatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>ffiLigature</otexsrc>
            <otexcom>offset to Ligature[0] table, listed first
                  because ffi ligature is preferred to fi
                  ligature</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>fiLigature</otexsrc>
            <otexcom>offset to Ligature[1] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Ligature</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ffiLigature</otexsrc>
            <otexcom>Ligature table definitio</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F1</otexdata>
            <otexsrc>ffiGlyphID</otexsrc>
            <otexcom>LigGlyph, output GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>CompCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>Component[1], second component in
                  ligature</otexcom>
          </otexline>
          <otexline>
            <otexdata>001D</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>Component[2], third component in
                  ligatur</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Ligature</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>fiLigature</otexsrc>
            <otexcom>Ligature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F0</otexdata>
            <otexsrc>fiGlyphID</otexsrc>
            <otexcom>LigGlyph, output GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CompCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001D</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>Component[1] second component in
                  ligature</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 7: ContextSubstFormat1 Subtable and
        SubstLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 7 uses a ContextSubstFormat1 subtable for glyph
          sequences to replace a string of three glyphs with another
          string. For the French language system, the subtable defines
          a contextual substitution that replaces the input sequence,
          space-dash-space, with the output sequence, thin
          space-dash-thin space.</para>
        <para>The contextual substitution, called Dash Lookup in this
          example, contains one ContextSubstFormat1 subtable called
          the DashSubtable. The subtable specifies two contexts: a
          SpaceGlyph followed by a DashGlyph, and a DashGlyph followed
          by a SpaceGlyph. In each sequence, a single substitution
          replaces the SpaceGlyph with a ThinSpaceGlyph.</para>
        <para>The Coverage table, labeled DashCoverage, lists two
          GlyphIDs for the first glyphs in the SpaceGlyph and
          DashGlyph sequences. One SubRuleSet table is defined for
          each covered glyph.</para>
        <para>SpaceAndDashSubRuleSet lists all the contexts that begin
          with a SpaceGlyph. It contains an offset to one SubRule
          table (SpaceAndDashSubRule), which specifies two glyphs in
          the context sequence, the second of which is a DashGlyph.
          The SubRule table contains an offset to a SubstLookupRecord
          that lists the position in the sequence where the glyph
          substitution should occur (position 0) and the index of the
          SpaceToThinSpaceLookup applied there to replace the
          SpaceGlyph with a ThinSpaceGlyph. DashAndSpaceSubRuleSet
          lists all the contexts that begin with a DashGlyph. An
          offset to a SubRule table (DashAndSpaceSubRule) specifies
          two glyphs in the context sequence, and the second one is a
          SpaceGlyph. The SubRule table contains an offset to a
          SubstLookupRecord, which lists the position in the sequence
          where the glyph substitution should occur, and an index to
          the same lookup used in the SpaceAndDashSubRule. The lookup
          replaces the SpaceGlyph with a ThinSpaceGlyph.</para>


        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ContextSubstFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DashSubtable</otexsrc>
            <otexcom>ContextSubstFormat1 subtable
                  definition for Lookup[0], DashLookup</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>DashCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubRuleSetCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>SpaceAndDashSubRuleSet</otexsrc>
            <otexcom>offset to SubRuleSet[0], ordered by Coverage
                  Index</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>DashAndSpaceSubRuleSet</otexsrc>
            <otexcom>offset to SubRuleSet[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DashCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>SpaceGlyph</otexsrc>
            <otexcom>GlyphArray[0], in numeric order</otexcom>
          </otexline>
          <otexline>
            <otexdata>005D</otexdata>
            <otexsrc>DashGlyph</otexsrc>
            <otexcom>GlyphArray[1], dash GlyphI</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubRuleSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SpaceAndDashSubRuleSet</otexsrc>
            <otexcom>SubRuleSet[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubRuleCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>SpaceAndDashSubRule</otexsrc>
            <otexcom>offset to SubRule[0], ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SpaceAndDashSubRule</otexsrc>
            <otexcom>SubRule[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount number in input sequence</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>005D</otexdata>
            <otexsrc>DashGlyph</otexsrc>
            <otexcom>Input[1], starting with second glyph SpaceGlyph
                  in Coverage table is first glyph
                  SubstLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>SequenceIndex substitution at first glyph
                  position (0)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex index for
                  SpaceToThinSpaceLookup in LookupLis</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubRuleSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DashAndSpaceSubRuleSet</otexsrc>
            <otexcom>SubRuleSet[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubRuleCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>DashAndSpaceSubRule</otexsrc>
            <otexcom>offset to SubRule[0], ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DashAndSpaceSubRule</otexsrc>
            <otexcom>SubRule[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount number in the input glyph
                  sequence</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>SpaceGlyph</otexsrc>
            <otexcom>Input[1], starting with second glyph
                  SubstLookupRecord definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex substitution at second glyph
                  position(1)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex for
                  SpaceToThinSpaceLookup</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 8: ContextSubstFormat2 Subtable </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 8 uses a ContextSubstFormat2 subtable with glyph
          classes to replace default mark glyphs with their
          alternative forms. Glyph alternatives are selected depending
          upon the height of the base glyph that they combine
          with-that is, the mark glyph used above a high base glyph
          differs from the mark glyph above a very high base
          glyph.</para>
        <para>In the example, SetMarksHighSubtable contains a Class
          table that defines four glyph classes: medium-height glyphs
          (Class 0), all default mark glyphs (Class 1), high glyphs
          (Class 2), and very high glyphs (Class 3). The subtable also
          contains a Coverage table that lists each base glyph that
          functions as a first component in a context, ordered by
          glyph index.</para>
        <para>Two SubClassSets are defined, one for substituting high
          marks and one for very high marks. No SubClassSets are
          specified for Class 0 and Class 1 glyphs because no contexts
          begin with glyphs from these classes. The SubClassSet array
          lists SubClassSets in numerical order, so SubClassSet 2
          precedes SubClassSet 3.</para>
        <para>Within each SubClassSet, a SubClassRule is defined. In
          SetMarksHighSubClassSet2, the SubClassRule table specifies
          two glyphs in the context, the first glyph in Class 2 (a
          high glyph) and the second in Class 1 (a mark glyph). The
          SubstLookupRecord specifies applying
          SubstituteHighMarkLookup at the second position in the
          sequence-that is, a high mark glyph will replace the default
          mark glyph.</para>
        <para>In SetMarksVeryHighSubClassSet3, the SubClassRule
          specifies two glyphs in the context, the first in Class 3 (a
          very high glyph) and the second in Class 1 (a mark glyph).
          The SubstLookupRecord specifies applying
          SubstituteVeryHighMarkLookup at the second position in the
          sequence-that is, a very high mark glyph will replace the
          default mark glyph.</para>


        <otexample>
          <title>Example 8</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ContextSubstFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksHighSubtable</otexsrc>
            <otexcom>ContextSubstFormat2
                  subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>SetMarksHighCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>SetMarksHighClassDef</otexsrc>
            <otexcom>offset to Class Def table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>SubClassSetCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to SubClassSet[0] table, no contexts
                  that begin with Class 0 glyphs are defined</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to SubClassSet[1] table no contexts that
                  begin with Class 1 glyphs are defined</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>SetMarksHighSubClassSet2</otexsrc>
            <otexcom>offset to SubClassSet[2] table for contexts
                  that begin with Class 2 glyphs (high base
                  glyphs)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>SetMarksVeryHighSubClassSet3</otexsrc>
            <otexcom>offset to SubClassSet[3] table for contexts
                  that begin with Class 3 glyphs (very high base
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksHighCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>tahGlyphID</otexsrc>
            <otexcom>GlyphArray[0], high base glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>dhahGlyphID</otexsrc>
            <otexcom>GlyphArray[1], high base glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>cafGlyphID</otexsrc>
            <otexcom>GlyphArray[2], very high base glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>gafGlyphID</otexsrc>
            <otexcom>GlyphArray[3], very high base glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksHighClassDef</otexsrc>
            <otexcom>Class table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class Format, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ClassRangeCount ClassRange[0] ordered by
                  StartGlyphID for Class 2, high base glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>tahGlyphID</otexsrc>
            <otexcom>Start, first Glyph ID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>dhahGlyphID</otexsrc>
            <otexcom>End, last Glyph ID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class ClassRange[1] for Class 3, very high base
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>cafGlyphID</otexsrc>
            <otexcom>Start, first Glyph ID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>gafGlyphID</otexsrc>
            <otexcom>End, last Glyph ID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRange[2] for Class 1, mark
                  gyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D2</otexdata>
            <otexsrc>fathatanDefaultGlyphID</otexsrc>
            <otexcom>Start, first Glyph ID in range default fathatan
                  mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D3</otexdata>
            <otexsrc>dammatanDefaultGlyphID</otexsrc>
            <otexcom>End, last Glyph ID in the range default
                  dammatan mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Clas</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubClassSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksHighSubClassSet2</otexsrc>
            <otexcom>SubClassSet[2] table
                  definition all contexts that begin with Class 2
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubClassRuleCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>SetMarksHighSubClassRule2</otexsrc>
            <otexcom>offset to SubClassRule[0] table ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubClassRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksHighSubClassRule2</otexsrc>
            <otexcom>SubClassRule[0] table
                  definition, Class 2 glyph (high base) glyph followed
                  by a Class 1 glyph (mark)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>offset to Class[1], beginning with the second
                  Class in the context sequence (mark = Class 1) begin
                  SubstLookupRecord array in design order
                  SubstLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex, apply substitution to position
                  2, a mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubClassSet</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksVeryHighSubClassSet3</otexsrc>
            <otexcom>SubClassSet[3]
                  table definition all contexts that begin with Class
                  3 glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubClassRuleCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>SetMarksVeryHighSubClassRule3</otexsrc>
            <otexcom>offset to SubClassRule[0] table ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SubClassRule</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SetMarksVeryHighSubClassRule3</otexsrc>
            <otexcom>SubClassRule[0]
                  table definition Class 3 glyph (very high base
                  glyph) followed by a Class 1 glyph (mark)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>offset to Class[1], beginning with the second
                  Class in the context sequence = marks, Class 1 begin
                  SubstLookupRecord array in design order
                  SubstLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex, apply substitution to position
                  2, second glyph class (mark)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 9: ContextualSubstFormat3 Subtable</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 9 uses the ContextSubstFormat3 subtable with
          Coverage tables to describe a context sequence of three
          lowercase glyphs in the pattern: any ascender or descender
          glyph in position 0 (zero), any x-height glyph in position
          1, and any descender glyph in position 2. The overlapping
          sets of covered glyphs for positions 0 and 2 make Format 3
          better for this context than the class-based Format
          2.</para>
        <para>In positions 0 and 2, swash versions of the glyphs
          replace the default glyphs. The contextual-substitution
          lookup is SwashLookup (LookupList index = 0), and its
          subtable is SwashSubtable. The SwashSubtable defines three
          Coverage tables: AscenderDescenderCoverage, XheightCoverage,
          and DescenderCoverage-one for each glyph position in the
          context sequence, respectively.</para>
        <para>The SwashSubtable also defines two SubstLookupRecords:
          one that applies to position 0, and one for position 2. (No
          substitutions are applied to position 1.) The record for
          position 0 uses a single substitution lookup called
          AscDescSwashLookup to replace the current ascender or
          descender glyph with a swash ascender or descender glyph.
          The record for position 2 uses a single substitution lookup
          called DescSwashLookup to replace the current descender
          glyph with a swash descender glyph.</para>


        <otexample>
          <title>Example 9</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ContextSubstFormat3</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SwashSubtable</otexsrc>
            <otexcom>ContextSubstFormat3 subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount in input glyph sequence</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>AscenderDescenderCoverage</otexsrc>
            <otexcom>offset to Coverage[0] table in context sequence
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>004C</otexdata>
            <otexsrc>XheightCoverage</otexsrc>
            <otexcom>offset to Coverage[1] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>006E</otexdata>
            <otexsrc>DescenderCoverage</otexsrc>
            <otexcom>offset to Coverage[2] table
                  SubstLookupRecord[0] in glyph position order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex, single substitution to output
                  ascender or descender swash
                  SubstLookupRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex single substitution to output
                  descender swas</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>AscenderDescenderCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>12</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>bGlyphID</otexsrc>
            <otexcom>GlyphArray[0] in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0035</otexdata>
            <otexsrc>dGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0037</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>gGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0039</otexdata>
            <otexsrc>hGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>jGlyphID</otexsrc>
            <otexcom>GlyphArray[5]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003C</otexdata>
            <otexsrc>kGlyphID</otexsrc>
            <otexcom>GlyphArray[6]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003D</otexdata>
            <otexsrc>lGlyphID</otexsrc>
            <otexcom>GlyphArray[7]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>pGlyphID</otexsrc>
            <otexcom>GlyphArray[8]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>qGlyphID</otexsrc>
            <otexcom>GlyphArray[9]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0045</otexdata>
            <otexsrc>tGlyphID</otexsrc>
            <otexcom>GlyphArray[10]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>yGlyphID</otexsrc>
            <otexcom>GlyphArray[11</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>XheightCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>aGlyphID</otexsrc>
            <otexcom>GlyphArray[0] in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0034</otexdata>
            <otexsrc>cGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0036</otexdata>
            <otexsrc>eGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003A</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003E</otexdata>
            <otexsrc>mGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003F</otexdata>
            <otexsrc>nGlyphID</otexsrc>
            <otexcom>GlyphArray[5]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>oGlyphID</otexsrc>
            <otexcom>GlyphArray[6]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0043</otexdata>
            <otexsrc>rGlyphID</otexsrc>
            <otexcom>GlyphArray[7]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0044</otexdata>
            <otexsrc>sGlyphID</otexsrc>
            <otexcom>GlyphArray[8]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0045</otexdata>
            <otexsrc>tGlyphID</otexsrc>
            <otexcom>GlyphArray[9]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>uGlyphID</otexsrc>
            <otexcom>GlyphArray[10]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0047</otexdata>
            <otexsrc>vGlyphID</otexsrc>
            <otexcom>GlyphArray[11]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0048</otexdata>
            <otexsrc>wGlyphID</otexsrc>
            <otexcom>GlyphArray[12]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0049</otexdata>
            <otexsrc>xGlyphID</otexsrc>
            <otexcom>GlyphArray[13]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004B</otexdata>
            <otexsrc>zGlyphID</otexsrc>
            <otexcom>GlyphArray[14</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DescenderCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>5</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>gGlyphID</otexsrc>
            <otexcom>GlyphArray[0] in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>jGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>pGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>qGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>yGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 10: ReverseChainSingleSubstFormat1 Subtable
	and SubstLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Example 10 uses a ReverseChainSingleSubstFormat1
	  subtable for glyph sequences to glyph with the correct form
	  that has a thick connection to the left (thick exit). This
	  allow the glyph to correctly connect to the letter form to
	  the left of it.</para>

	<para>The ThickExitCoverage table is the listing of glyphs to
	  be matched for substitution.</para>

	<para>The LookaheadCoverage table, labeled ThickEntryCoverage,
	  lists four GlyphIDs for the glyph following a substitution
	  coverage glyph. This lookahead coverage attempts to match
	  the context that will cause the substitution to take
	  place.</para>

	<para>The Substitute table maps the glyphs to replace those in
	  the ThickConnectCoverage table.</para>

	<otexample>
	  <title>Example 10</title>
	  <otexline>
	    <otexdata></otexdata>
	    <otexsrc>ReverseChainSingleSubstFormat1</otexsrc>
	    <otexcom></otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>ThickConnect</otexdata>
	    <otexsrc>ReverseChainSingleSubstFormat1</otexsrc>
	    <otexcom>subtable definition</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>SubstFormat</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0068</otexdata>
	    <otexsrc>ThickExitCoverage</otexsrc>
	    <otexcom>offset to Coverage table</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0000</otexdata>
	    <otexsrc>0</otexsrc>
	    <otexcom>BacktrackGlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0000</otexdata>
	    <otexsrc>null</otexsrc>
	    <otexcom>not used offset to BacktrackCoverage[0]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>LookaheadGlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0026</otexdata>
	    <otexsrc>ThickEntryCoverage</otexsrc>
	    <otexcom>offset to LookaheadCoverage[0]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>000C</otexdata>
	    <otexsrc>12</otexsrc>
	    <otexcom>GlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A7</otexdata>
	    <otexsrc>BEm2</otexsrc>
	    <otexcom>Substitute[0], ordered by Coverage Index</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00B9</otexdata>
	    <otexsrc>BEi3</otexsrc>
	    <otexcom>Substitute[1]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00C5</otexdata>
	    <otexsrc>JIMm3</otexsrc>
	    <otexcom>Substitute[2]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00D4</otexdata>
	    <otexsrc>JIMi2</otexsrc>
	    <otexcom>Substitute[3]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00EA</otexdata>
	    <otexsrc>SINm2</otexsrc>
	    <otexcom>Substitute[4]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00F2</otexdata>
	    <otexsrc>SINi2</otexsrc>
	    <otexcom>Substitute[5]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00FD</otexdata>
	    <otexsrc>SADm2</otexsrc>
	    <otexcom>Substitute[6]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>010D</otexdata>
	    <otexsrc>SADi2</otexsrc>
	    <otexcom>Substitute[7]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>011B</otexdata>
	    <otexsrc>TOEm3</otexsrc>
	    <otexcom>Substitute[8]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>012B</otexdata>
	    <otexsrc>TOEi3</otexsrc>
	    <otexcom>Substitute[9]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>013B</otexdata>
	    <otexsrc>AINm2</otexsrc>
	    <otexcom>Substitute[10]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0141</otexdata>
	    <otexsrc>AINi2</otexsrc>
	    <otexcom>Substitute[11]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata></otexdata>
	    <otexsrc>CoverageFormat1</otexsrc>
	    <otexcom></otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>ThickEntryCoverage</otexdata>
	    <otexsrc>Coverage</otexsrc>
	    <otexcom>table definition</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>CoverageFormat, lists</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>001F</otexdata>
	    <otexsrc>31</otexsrc>
	    <otexcom>GlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A5</otexdata>
	    <otexsrc>ALEFf1</otexsrc>
	    <otexcom>GlyphArray[0], in GlyphID order</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A9</otexdata>
	    <otexsrc>BEm4</otexsrc>
	    <otexcom>GlyphArray[1]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00AA</otexdata>
	    <otexsrc>BEm5</otexsrc>
	    <otexcom>GlyphArray[2]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00E2</otexdata>
	    <otexsrc>DALf1</otexsrc>
	    <otexcom>GlyphArray[3]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0167</otexdata>
	    <otexsrc>KAFf1</otexsrc>
	    <otexcom>GlyphArray[4]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0168</otexdata>
	    <otexsrc>KAFfs1</otexsrc>
	    <otexcom>GlyphArray[5]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0169</otexdata>
	    <otexsrc>KAFm1</otexsrc>
	    <otexcom>GlyphArray[6]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>016D</otexdata>
	    <otexsrc>KAFm5</otexsrc>
	    <otexcom>GlyphArray[7]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>016E</otexdata>
	    <otexsrc>KAFm6</otexsrc>
	    <otexcom>GlyphArray[8]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0170</otexdata>
	    <otexsrc>KAFm8</otexsrc>
	    <otexcom>GlyphArray[9]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0183</otexdata>
	    <otexsrc>GAFf1</otexsrc>
	    <otexcom>GlyphArray[10]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0184</otexdata>
	    <otexsrc>GAFfs1</otexsrc>
	    <otexcom>GlyphArray[11]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0185</otexdata>
	    <otexsrc>GAFm1</otexsrc>
	    <otexcom>GlyphArray[12]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0189</otexdata>
	    <otexsrc>GAFm5</otexsrc>
	    <otexcom>GlyphArray[13]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>018A</otexdata>
	    <otexsrc>GAFm6</otexsrc>
	    <otexcom>GlyphArray[14]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>018C</otexdata>
	    <otexsrc>GAFm8</otexsrc>
	    <otexcom>GlyphArray[15]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>019F</otexdata>
	    <otexsrc>LAMf1</otexsrc>
	    <otexcom>GlyphArray[16]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A0</otexdata>
	    <otexsrc>LAMm1</otexsrc>
	    <otexcom>GlyphArray[17]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A1</otexdata>
	    <otexsrc>LAMm2</otexsrc>
	    <otexcom>GlyphArray[18]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A2</otexdata>
	    <otexsrc>LAMm3</otexsrc>
	    <otexcom>GlyphArray[19]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A3</otexdata>
	    <otexsrc>LAMm4</otexsrc>
	    <otexcom>GlyphArray[20]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A4</otexdata>
	    <otexsrc>LAMm5</otexsrc>
	    <otexcom>GlyphArray[21]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A5</otexdata>
	    <otexsrc>LAMm6</otexsrc>
	    <otexcom>GlyphArray[22]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A6</otexdata>
	    <otexsrc>LAMm7</otexsrc>
	    <otexcom>GlyphArray[23]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A7</otexdata>
	    <otexsrc>LAMm8</otexsrc>
	    <otexcom>GlyphArray[24]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A8</otexdata>
	    <otexsrc>LAMm9</otexsrc>
	    <otexcom>GlyphArray[25]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A9</otexdata>
	    <otexsrc>LAMm10</otexsrc>
	    <otexcom>GlyphArray[26]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01AA</otexdata>
	    <otexsrc>LAMm11</otexsrc>
	    <otexcom>GlyphArray[27]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01AB</otexdata>
	    <otexsrc>LAMm12</otexsrc>
	    <otexcom>GlyphArray[28]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01AC</otexdata>
	    <otexsrc>LAMm13</otexsrc>
	    <otexcom>GlyphArray[29]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01EC</otexdata>
	    <otexsrc>HAYf2</otexsrc>
	    <otexcom>GlyphArray[30]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata></otexdata>
	    <otexsrc>CoverageFormat1</otexsrc>
	    <otexcom></otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>ThickExitCoverage</otexdata>
	    <otexsrc>Coverage</otexsrc>
	    <otexcom>table definition</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>CoverageFormat, lists</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>000C</otexdata>
	    <otexsrc>12</otexsrc>
	    <otexcom>GlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A6</otexdata>
	    <otexsrc>BEm1</otexsrc>
	    <otexcom>GlyphArray[0], ordered by GlyphID</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00B7</otexdata>
	    <otexsrc>BEi1</otexsrc>
	    <otexcom>GlyphArray[1]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00C3</otexdata>
	    <otexsrc>JIMm1</otexsrc>
	    <otexcom>GlyphArray[2]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00D2</otexdata>
	    <otexsrc>JIMi1</otexsrc>
	    <otexcom>GlyphArray[3]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00E9</otexdata>
	    <otexsrc>SINm1</otexsrc>
	    <otexcom>GlyphArray[4]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00F1</otexdata>
	    <otexsrc>SINi1</otexsrc>
	    <otexcom>GlyphArray[5]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00FC</otexdata>
	    <otexsrc>SADm1</otexsrc>
	    <otexcom>GlyphArray[6]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>010C</otexdata>
	    <otexsrc>SADi1</otexsrc>
	    <otexcom>GlyphArray[7]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0119</otexdata>
	    <otexsrc>TOEm1</otexsrc>
	    <otexcom>GlyphArray[8]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0129</otexdata>
	    <otexsrc>TOEi1</otexsrc>
	    <otexcom>GlyphArray[9]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>013A</otexdata>
	    <otexsrc>AINm1</otexsrc>
	    <otexcom>GlyphArray[10]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0140</otexdata>
	    <otexsrc>AINi1</otexsrc>
	    <otexcom>GlyphArray[11]</otexcom>
	  </otexline>
	</otexample>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.JSTF' web:index='yes'>
    <title>JSTF - The Justification Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Justification table (<ottable>JSTF</ottable>)
        provides font developers with additional control over glyph
        substitution and positioning in justified text.
        Text-processing clients now have more options to expand or
        shrink word and glyph spacing so text fills the specified line
        length.</para>

        <para>When justifying text, the text-processing client
        distributes the characters in each line to completely fill the
        specified line length. Whether removing space to fit more
        characters in the line or adding more space to spread the
        characters, justification can produce large gaps between
        words, cramped or extended glyph spacing, uneven line break
        patterns, and other jarring visual effects. For
        example:</para>

        <figure>
          <title>Figure 6a. Poorly justified text</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig6a.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>To offset these effects, text-processing clients have
        used justification algorithms that redistribute the space with
        a series of glyph spacing adjustments that progress from least
        to most obvious. Typically, the client will begin by expanding
        or compressing the space between words. If these changes
        aren't enough or look distracting, the client might hyphenate
        the word at the end of the line or adjust the space between
        glyphs in one or more lines.</para>

        <para>To disguise spacing inconsistencies so they won't
        disrupt the flow of text for a reader, the font developer can
        use the <ottable>JSTF</ottable> table to enable or disable
        individual glyph substitution and positioning actions that
        apply to specific scripts, language systems, and glyphs in the
        font.</para>

        <para>For instance, a ligature glyph can replace multiple
        glyphs, shortening the line of text with an unobtrusive,
        localized adjustment (see Figure 6b). Font-specific
        positioning changes can be applied to particular glyphs in a
        text line that combines two or more fonts. Other options
        include repositioning the individual glyphs in the line,
        expanding the space between specific pairs of glyphs, and
        decreasing the spacing within particular glyph
        sequences.</para>

        <figure>
          <title>Figure 6b. <ottable>JSTF</ottable> shortens the top
          line of this example by using the "ffi" ligature</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig6b.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The font designer or developer defines
        <ottable>JSTF</ottable> data as prioritized suggestions. Each
        suggestion lists the particular actions that the client can
        use to adjust the line of text. Justification actions may
        apply to both vertical and horizonal text.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Table Organization</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>JSTF</ottable> table organizes data by
        script and language system, as do the <ottable>GSUB</ottable>
        and <ottable>GPOS</ottable> tables.  The
        <ottable>JSTF</ottable> table begins with a header that lists
        scripts in an array of JstfScriptRecords (see Figure 6c). Each
        record contains a ScriptTag and an offset to a JstfScript
        table that contains script and language-specific data:</para>

        <itemizedlist>
          <listitem>
            <para>A default justification language system table
              (DefJstfLangSys) defines script-specific data that
              applies to the entire script in the absence of any
              language-specific information.</para>
          </listitem>
          <listitem>
            <para>A justification language system table (JstfLangSys)
              stores the justification data for each language
              system.</para>
          </listitem>
        </itemizedlist>

        <figure>
          <title>Figure 6c. High-level organization of <ottable>JSTF</ottable>
            table</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='fig6c.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>A JstfLangSys table contains a list of justification
        suggestions. Each suggestion consists of a list of
        <ottable>GSUB</ottable> or <ottable>GPOS</ottable> LookupList
        indices to lookups that may be enabled or disabled to add or
        remove space in the line of text. In addition, each suggestion
        can include a set of dedicated justification lookups with
        maximum adjustment values to extend or shrink the amount of
        space.</para>

        <para>The font developer prioritizes suggestions based on how
        they affect the appearance and function of the text line, and
        the client applies the suggestions in that order.
        Low-numbered (high-priority) suggestions correspond to "least
        bad" options.</para>

        <para>Each script also may supply a list of extender glyphs,
        such as kashidas in Arabic. A client may use the extender
        glyphs in addition to the justification suggestions.</para>

	<para>A client begins justifying a line of text only after
	implementing all selected <ottable>GSUB</ottable> and
	<ottable>GPOS</ottable> features for the string. Starting with
	the lowest-numbered suggestion, the client enables or disables
	the lookups specified in the <ottable>JSTF</ottable> table,
	reassembles the lookups in the LookupList order, and applies
	them to each glyph in the string one after another. If the
	line still is not the correct length, the client processes the
	next suggestion in ascending order of priority. This continues
	until the line length meets the justification
	requirements.</para>

	<para>Note: If any <ottable>JSTF</ottable> suggestion at any
	priority level modifies a <ottable>GSUB</ottable> or
	<ottable>GPOS</ottable> lookup that was previously applied to
	the glyph string, then the text processing client must apply
	the <ottable>JSTF</ottable> suggestion to an unmodified
	version of the glyph string.</para>

        <para>The rest of this chapter describes the tables and
        records used by the <ottable>JSTF</ottable> table for scripts
        and language systems:</para>

        <itemizedlist>
          <listitem>
            <para>Script information includes the JstfScript table
              (plus its associated JstfLangSysRecords) and the
              ExtenderGlyph table.</para>
          </listitem>
          <listitem>
            <para>Language system information includes the JstfLangSys
              table, JstfPriority table (and its associated
              JstfDataRecord), the JstfModList table, and the JstfMax
              table.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>JSTF Header</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>JSTF</ottable> table begins with a header
          that contains a version number for the table (Version), a
          count of the number of scripts used in the font
          (JstfScriptCount), and an array of records
          (JstfScriptRecord). Each record contains a script tag
          (JstfScriptTag) and an offset to a JstfScript table
          (JstfScript).</para>

        <para>Note: The JstfScriptTags must correspond with the
          ScriptTags listed in the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables.</para>

        <para>Example 1 at the end of this chapter shows a
          <ottable>JSTF</ottable> Header table and
          JstfScriptRecord.</para>

        <otformat>
          <title>JSTF header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>fixed32</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the <ottable>JSTF</ottable>
              table-initially set to 0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>JstfScriptCount</otfieldname>
            <otfielddesc>Number of JstfScriptRecords in this
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>JstfScriptRecord [JstfScriptCount]</otfieldname>
            <otfielddesc>Array of JstfScriptRecords-in alphabetical
              order, by JstfScriptTag</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>JstfScriptRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>JstfScriptTag</otfieldname>
            <otfielddesc>4-byte JstfScript
              identification</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>JstfScript</otfieldname>
            <otfielddesc>Offset to JstfScript table-from beginning of
              <ottable>JSTF</ottable> Header</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  JSTF =
    element JSTF {
      attribute major { "1" },
      attribute minor { "0" },

      element script {
        attribute tag { text }
        jstfScriptTableOffset
      }*

      (  standaloneJstfScriptTable
       | standaloneExtenderGlyphTable
       | standaloneJstfLangSysTable
       | standaloneJstfPriorityTable
       | standaloneJstfModList
       | standaloneJstfMaxTable

       | standaloneLookupTable
       | standaloneSinglePosTable
       | standalonePairPosTable
       | standaloneCursiveAttachmentTable
       | standaloneMarkToBaseAttachmentTable
       | standaloneMarkToLigatureAttachmentTable
       | standaloneMarkToMarkAttachmentTable
       | standaloneExtensionTable

       | standaloneCoverageTable
       | standaloneClassDefTable
       | standaloneDeviceTable)*
      )*
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='zzzcompiler'>
        <title>Compiler</title>

<code-fragment id='zzzjstf.methods'>
  public void fromXML (Element jstf)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block> blockCache = new HashMap&lt;Element, Block> ();
    NodeList scripts = jstf.getChildNodes ();
    int scriptCount = scripts.getLength ();

    Block me = new Block (4 + 6*scriptCount, scriptCount);
    me.setFixed (0, 1, 0);

    for (int i = 0; i &lt; l.getLength (); i++) {
      (Element) script = (Element) scripts.item (i);

      me.setTag (4 + 6*i + offset, script.getAttribute ("tag"));
      me.setOffset (4 + 6*i + 4,
                    jstfScriptTableFromXML (script. jstf, blockCache)); }

    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='zzzdecompiler'>
        <title>Decompiler</title>

<code-fragment id='zzzjstf.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] counts = new int [data.length];
    for (int i = 0; i &lt; counts.length; i++) {
      counts [i] = 0; }

    int scriptCount = getuint16 (4);
    for (int i = 0; i &lt; scriptCount; i++) {
      jstfScriptTableToXMLCount (getOffset (4 + 6*i + 4), counts); }

    if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 1; }}
    if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 2; }}

    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);

    conf.ch.startElement ("JSTF", at); {

      for (int i = 0; i &lt; scriptCount; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "tag", "tag", "CDATA",
                         Tag.tag2string (getTag (4 + 6*i)));
        jstfScriptTableOffsetToXML (conf, getOffset (4 + 6*i + 4), counts,
                                    script, at); }

      for (int i = 0; i &lt; scriptCount; i++) {
        jstfScriptTableToXML (conf, getOffset (4 + 6*i + 4), counts); }

      conf.ch.endElement ("JSTF"); }
  }
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Justification Script Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>A Justification Script (JstfScript) table describes the
        justification information for a single script. It consists of
        an offset to a table that defines extender glyphs
        (ExtenderGlyph), an offset to a default justification table
        for the script (DefJstfLangSys), and a count of the language
        systems that define justification data
        (JstfLangSysCount).</para>

        <para>If a script uses the same justification information for
        all language systems, the font developer defines only the
        DefJstfLangSys table and sets the JstfLangSysCount to zero
        (0). However, if any language system has unique justification
        suggestions, JstfLangSysCount will be a positive value, and
        the JstfScript table must include an array of records
        (JstfLangSysRecord), one for each language system. Each
        JstfLangSysRecord contains a language system tag
        (JstfLangSysTag) and an offset to a justification language
        system table (JstfLangSys). In the JstfLangSysRecord array,
        records are ordered alphabetically by JstfLangSysTag.</para>

        <para>Note: No JstfLangSysRecord is defined for the default
        script data; the data is stored in the DefJstfLangSys table
        instead.</para>

        <para>Example 2 at the end of the chapter shows a JstfScript
        table for the Arabic script and a JstfLangSysRecord for the
        Farsi language system.</para>

        <otformat>
          <title>JstfScript table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExtenderGlyph</otfieldname>
            <otfielddesc>Offset to ExtenderGlyph table-from beginning
              of JstfScript table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>DefJstfLangSys</otfieldname>
            <otfielddesc>Offset to Default JstfLangSys table-from
              beginning of JstfScript table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>JstfLangSysCount</otfieldname>
            <otfielddesc>Number of JstfLangSysRecords in this table-
              may be zero (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>JstfLangSysRecord [JstfLangSysCount]</otfieldname>
            <otfielddesc>Array of JstfLangSysRecords-in alphabetical
              order, by JstfLangSysTag</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>JstfLangSysRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>JstfLangSysTag</otfieldname>
            <otfielddesc>4-byte JstfLangSys identifier</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>JstfLangSys</otfieldname>
            <otfielddesc>Offset to JstfLangSys table-from beginning of
              JstfScript table</otfielddesc>
          </otfield>
        </otformat>

      </section>
      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  jstfScriptTable =
    element extenderGlyph { extenderGlyphTableOffset }?,
    element defaultLangSys { jstfLangSysTableOffset }?,
    element langSys {
      attribute tag { text },
      jstfLangSysTableOffset
    }*

  standaloneJstfScriptTable =
    element jstfScriptTable { attribute id { text }, jstfScriptTable }

  jstfScriptTableOffset = attribute name { text } | jstfScriptTable
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Extender Glyph Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>The Extender Glyph table (ExtenderGlyph) lists indices
        of glyphs, such as Arabic kashidas, that a client may insert
        to extend the length of the line for justification. The table
        consists of a count of the extender glyphs for the script
        (GlyphCount) and an array of extender glyph indices
        (ExtenderGlyph), arranged in increasing numerical
        order.</para>

	<para>Example 2 at the end of this chapter shows an
	ExtenderGlyph table for Arabic kashida glyphs.</para>

        <otformat>
          <title>ExtenderGlyph table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of Extender Glyphs in this
              script</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>ExtenderGlyph [GlyphCount]</otfieldname>
            <otfielddesc>GlyphIDs-in increasing numerical
              order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  extenderGlyphTable =
    attribute glyphs { text }

  standaloneExtenderGlyphTable =
    element extenderGlyphTable { attribute id { text }, extenderGlyphTable }

  extenderGlyphTableOffset = attribute name { text } | extenderGlyphTable
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Justification Language System Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Justification Language System (JstfLangSys) table
        contains an array of justification suggestions, ordered by
        priority. A text-processing client doing justification should
        begin with the suggestion that has a zero (0) priority, and
        then-as necessary-apply suggestions of increasing priority
        until the text is justified.</para>

        <para>The font developer defines the number and the meaning of
        the priority levels. Each priority level stands alone; its
        suggestions are not added to the previous levels. The
        JstfLangSys table consists of a count of the number of
        priority levels (JstfPriorityCnt) and an array of offsets to
        Justification Priority tables (JstfPriority), stored in
        priority order. Example 2 at the end of the chapter shows how
        to define a JstfLangSys table.</para>

        <otformat>
          <title>JstfLangSys table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>JstfPriorityCnt</otfieldname>
            <otfielddesc>Number of JstfPriority tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>JstfPriority [JstfPriorityCnt]</otfieldname>
            <otfielddesc>Array of offsets to JstfPriority tables-from
              beginning of JstfLangSys table-in priority
              order</otfielddesc>
          </otfield>
        </otformat>

      </section>
      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  jstfLangSysTable =
    element priority {
      jstfPriorityTableOffset
    }*

  standaloneJstfLangSysTable =
    element jstfLangSysTable { attribute id { text }, jstfLanSysTable }

  jstfLangSysTableOffset = attribute name { text } | jstfLangSysTable
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Justification Priority Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Justification Priority (JstfPriority) table defines
          justification suggestions for a single priority level. Each
          priority level specifies whether to enable or disable
          <ottable>GSUB</ottable> and <ottable>GPOS</ottable> lookups
          or apply text justification lookups to shrink and extend
          lines of text.</para>

        <para>JstfPriority has offsets to four tables with line
          shrinkage data: two are JstfGSUBModList tables for enabling
          and disabling glyph substitution lookups, and two are
          JstfGPOSModList tables for enabling and disabling glyph
          positioning lookups. Offsets to JstfGSUBModList and
          JstfGPOSModList tables also are defined for line
          extension.</para>

        <para>Example 3 at the end of this chapter demonstrates two
          JstfPriority tables for two justification
          suggestions.</para>


        <otformat>
          <title>JstfPriority table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ShrinkageEnableGSUB</otfieldname>
            <otfielddesc>Offset to Shrinkage Enable JstfGSUBModList
              table-from beginning of JstfPriority table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ShrinkageDisableGSUB</otfieldname>
            <otfielddesc>Offset to Shrinkage Disable JstfGSUBModList
              table-from beginning of JstfPriority table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ShrinkageEnableGPOS</otfieldname>
            <otfielddesc>Offset to Shrinkage Enable JstfGPOSModList
              table-from beginning of JstfPriority table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ShrinkageDisableGPOS</otfieldname>
            <otfielddesc>Offset to Shrinkage Disable JstfGPOSModList
              table-from beginning of JstfPriority table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ShrinkageJstfMax</otfieldname>
            <otfielddesc>Offset to Shrinkage JstfMax table-from
              beginning of JstfPriority table -may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExtensionEnableGSUB</otfieldname>
            <otfielddesc>Offset to Extension Enable JstfGSUBModList
              table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExtensionDisableGSUB</otfieldname>
            <otfielddesc>Offset to Extension Disable JstfGSUBModList
              table-from beginning of JstfPriority table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExtensionEnableGPOS</otfieldname>
            <otfielddesc>Offset to Extension Enable JstfGSUBModList
              table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExtensionDisableGPOS</otfieldname>
            <otfielddesc>Offset to Extension Disable JstfGSUBModList
              table-from beginning of JstfPriority table-may be
              NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ExtensionJstfMax</otfieldname>
            <otfielddesc>Offset to Extension JstfMax table-from
              beginning of JstfPriority table -may be
              NULL</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  jstfPriorityTable =
    element shrinkage {
      element enableGSUB   { jstfModListOffset }?,
      element disableGSUB  { jstfModListOffset }?,
      element enableGPOS   { jstfModListOffset }?,
      element disableGPOS  { jstfModListOffset }?,
      element jstfMax      { jstfMaxTableOffset }? },

    element extension {
      element enableGSUB   { jstfModListOffset }?,
      element disableGSUB  { jstfModListOffset }?,
      element enableGPOS   { jstfModListOffset }?,
      element disableGPOS  { jstfModListOffset }?,
      element jstfMax      { jstfMaxTableOffset }? }

  standaloneJstfPriorityTable =
    element jstfPriority { attribute id { text }, jstfPriorityTable }

  jstfPriorityTableOffset = attribute name { text } | jstfPriorityTable
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Justification Modification List Tables</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The Justification Modification List tables
          (JstfGSUBModList and JstfGPOSModList) contain lists of
          indices into the lookup lists of either the GSUB or GPOS
          tables. The client can enable or disable the lookups to
          justify text. For example, to increase line length, the
          client might disable a <ottable>GSUB</ottable> ligature
          substitution.</para>

        <para>Each JstfModList table consists of a count of Lookups
          (LookupCount) and an array of lookup indices
          (LookupIndex).</para>

        <para>To justify a line of text, a text-processing client
          enables or disables the specified lookups in a JstfModList
          table, reassembles the lookups in the LookupList order, and
          applies them to each glyph in the string one after
          another.</para>

        <para>Note: If any <ottable>JSTF</ottable> suggestion at any
          priority level modifies a <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> lookup previously applied to the
          glyph string, then the text-processing client must apply the
          <ottable>JSTF</ottable> suggestion to an unmodified version
          of the glyph string.</para>


        <para>Example 3 at the end of this chapter shows
          JstfGSUBModList and JstfGPOSModList tables with data for
          shrinking and extending text line lengths.</para>

        <otformat>
          <title>JstfGSUBModList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of lookups for this
              modification</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GSUBLookupIndex [LookupCount]</otfieldname>
            <otfielddesc>Array of LookupIndex identifiers in GSUB-in
              increasing numerical order</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>JstfGPOSModList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of lookups for this
              modification</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GPOSLookupIndex [LookupCount]</otfieldname>
            <otfielddesc>Array of LookupIndex identifiers in GPOS-in
              increasing numerical order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  jstfModList =
    attribute lookups { text }

  standaloneJstfModList =
    element jstfModList { attribute id { text }, jstfModList }

  jstfModListOffset = attribute name { text } | jstfModList
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Justification Maximum Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>A Justification Maximum table (JstfMax) consists of an
          array of offsets to justification lookups (Lookup) and a
          count of the defined lookups (Lookup). JstfMax lookups
          typically are located after the JstfMax table in the font
          definition.</para>

        <para>JstfMax tables have the same format as lookup tables and
          subtables in the <ottable>GPOS</ottable> table, but the
          JstfMax lookups reside in the <ottable>JSTF</ottable> table
          and contain justification data only. The lookup data might
          specify a single adjustment value for positioning all glyphs
          in the script, or it might specify more elaborate
          adjustments, such as different values for different glyphs
          or special values for specific pairs of glyphs.</para>

        <para>Note: All <ottable>GPOS</ottable> lookup types except
          contextual positioning lookups may be defined in a JstfMax
          table.</para>

        <para>JstfMax lookup values are defined in
          <ottable>GPOS</ottable> ValueRecords and may be specified
          for any advance or placement position, whether horizontal or
          vertical. These values define the maximum shrinkage or
          extension allowed per glyph. To justify text, a
          text-processing client may choose to adjust a glyph's
          positioning by any amount from zero (0) to the specified
          maximum.</para>

        <para>Example 4 at the end of this chapter shows a JstfMax
          table. It defines a justification lookup to change the size
          of the word space glyph to extend line lengths.</para>


        <otformat>
          <title>JstfMax table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of lookup Indices for this
              modification</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Lookup [LookupCount]</otfieldname>
            <otfielddesc>Array of offsets to
              <ottable>GPOS</ottable>-type lookup tables-from
              beginning of JstfMax table-in design order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='zzzschema'>
  <code-title>JST</code-title>
  jstfMaxTable =
    element lookup {
      GPOSJSTFlookupTableOffset
    }*

  standaloneJstfMaxTable =
    element jstfMaxTable { attribute id { text }, jstfMaxTable }

  jstfMaxTableOffset = attribute name { text } | jstfMaxTable

  standaloneGPOSJSTFlookupTable =
    element lookupTable { attribute id { text }, GPOSJSTlookupTable

  GPOSJSTFlookupTableOffset = attribute name { text } | GPOSJSTFlookupTable
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>JSTF Table Examples</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The rest of this chapter describes examples of all the
          <ottable>JSTF</ottable> table formats. All the examples reflect unique
          parameters described below, but the samples provide a useful
          reference for building tables specific to other
          situations.</para>
        <para>The examples have three columns showing hex data,
          source, and comments.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 1: JSTF Header Table and JstfScriptRecord</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 1 demonstrates how a script is defined in the
          <ottable>JSTF</ottable> Header with a JstfScriptRecord that
          identifies the script and references its JstfScript
          table.</para>


        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JSTFHeader</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>TheJSTFHeader</otexsrc>
            <otexcom>JSTFHeader table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00010000</otexdata>
            <otexsrc>0x00010000</otexsrc>
            <otexcom>version</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>JstfScriptCount JstfScriptRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>74686169</otexdata>
            <otexsrc>"thai"</otexsrc>
            <otexcom>JstfScriptTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>ThaiScript</otexsrc>
            <otexcom>offset to JstfScript table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 2: JstfScript Table, ExtenderGlyph Table,
        JstfLangSysRecord, and JstfLangSys Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 2 shows a JstfScript table for the Arabic script
          and the tables it references. The DefJstfLangSys table
          defines justification data to apply to the script in the
          absence of language-specific information. In the example,
          the table lists two justification suggestions in priority
          order.</para>
        <para>JstfScript also supplies language-specific justification
          data for the Farsi language. The JstfLangSysRecord
          identifies the language and references its JstfLangSys
          table. The FarsiJstfLangSys lists one suggestion for
          justifying Farsi text.</para>
        <para>The ExtenderGlyph table in JstfScript lists the indices
          of all the extender glyphs used in the script.</para>


        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfScript</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ArabicScript</otexsrc>
            <otexcom>JstfScript table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>ArabicExtenders</otexsrc>
            <otexcom>ExtenderGlyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>ArabicDefJstfLangSys</otexsrc>
            <otexcom>offset to DefJstfLangSys table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>JstfLangSysCount JstfLangSysRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>50455220</otexdata>
            <otexsrc>"FAR</otexsrc>
            <otexcom>" JstfLangSysTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>FarsiJstfLangSys</otexsrc>
            <otexcom>JstfLangSy</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ExtenderGlyph</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ArabicExtenders</otexsrc>
            <otexcom>ExtenderGlyph table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>01D3</otexdata>
            <otexsrc>TatweelGlyphID</otexsrc>
            <otexcom>ExtenderGlyph[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>01D4</otexdata>
            <otexsrc>LongTatweelGlyphID</otexsrc>
            <otexcom>ExtenderGlyph[1</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfLangSys</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>ArabicDefJstfLangSys</otexsrc>
            <otexcom>JstfLangSys table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>JstfPriorityCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>ArabicScriptJstfPriority1</otexsrc>
            <otexcom>offset to JstfPriority[0] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001E</otexdata>
            <otexsrc>ArabicScriptJstfPriority2</otexsrc>
            <otexcom>offset to JstfPriority[1] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfLangSys</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>FarsiJstfLangSys</otexsrc>
            <otexcom>JstfLangSys table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>JstfPriorityCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>FarsiLangJstfPriority1</otexsrc>
            <otexcom>offset to JstfPriority[0] table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 3: JstfPriority Table, JstfGSUBModList Table, and
        JstfGPOSModList Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Example 3 shows the JstfPriority and JstfModList table
          definitions for two justification suggestions defined in
          priority order. The first suggestion uses ligature
          substitution to shrink the lengths of text lines, and it
          extends line lengths by replacing ligatures with their
          individual glyph components. Other lookup actions are not
          recommended at this priority level and are set to NULL. The
          associated JstfModList tables enable and disable three
          substitution lookups.</para>
        <para>The second suggestion enables glyph kerning to reduce
          line lenths and disables glyph kerning to extend line
          lengths. Each action uses three lookups. This suggestion
          also includes a JstfMax table to extend line lengths, called
          WordSpaceExpandMax, which is described in Example 4.</para>


        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfPriority</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>USEnglishFirstJstfPriority</otexsrc>
            <otexcom>JstfPriority table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>EnableGSUBLookupsToShrink</otexsrc>
            <otexcom>offset to ShrinkageEnableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ShrinkageDisableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ShrinkageEnableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ShrinkageDisableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to Shrinkage JstfMax table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ExtensionEnableGSUB, JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>DisableGSUBLookupsToExtend</otexsrc>
            <otexcom>offset to ExtensionDisableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ExtensionEnableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ExtensionDisableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to Extension JstfMax tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfPriority</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>USEnglishSecondJstfPriority</otexsrc>
            <otexcom>JstfPriority table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ShrinkageEnableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ShrinkageDisableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ShrinkageEnableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>DisableGPOSLookupsToShrink</otexsrc>
            <otexcom>offset to ShrinkageDisableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to Shrinkage JstfMax table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ExtensionEnableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ExtensionDisableGSUB JstfGSUBModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>EnableGPOSLookupsToExtend</otexsrc>
            <otexcom>offset to ExtensionEnableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to ExtensionDisableGPOS JstfGPOSModList
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to Extension JstfMax tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfGSUBModList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>EnableGSUBLookupsToShrink</otexsrc>
            <otexcom>JstfGSUBModList table
                  definition, enable three ligature substitution
                  lookups</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>002E</otexdata>
            <otexsrc>46</otexsrc>
            <otexcom>LookupIndex[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0035</otexdata>
            <otexsrc>53</otexsrc>
            <otexcom>LookupIndex[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0063</otexdata>
            <otexsrc>99</otexsrc>
            <otexcom>LookupIndex[2</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfGPOSModList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DisableGPOSLookupsToShrink</otexsrc>
            <otexcom>JstfGPOSModList
                  table definition, disable three tight kerning
                  lookups</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>006C</otexdata>
            <otexsrc>108</otexsrc>
            <otexcom>LookupIndex[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>006E</otexdata>
            <otexsrc>110</otexsrc>
            <otexcom>LookupIndex[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0070</otexdata>
            <otexsrc>112</otexsrc>
            <otexcom>LookupIndex[2</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfGSUBModList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>DisableGSUBLookupsToExtend</otexsrc>
            <otexcom>JstfGSUBModList
                  table definition, disable three ligature
                  substitution lookups</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>002E</otexdata>
            <otexsrc>46</otexsrc>
            <otexcom>LookupIndex[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0035</otexdata>
            <otexsrc>53</otexsrc>
            <otexcom>LookupIndex[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0063</otexdata>
            <otexsrc>99</otexsrc>
            <otexcom>LookupIndex[2</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfGPOSModList</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>EnableGPOSLookupsToExtend</otexsrc>
            <otexcom>JstfGPOSModList table
                  definition enable three tight kerning
                  lookups</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>006C</otexdata>
            <otexsrc>108</otexsrc>
            <otexcom>LookupIndex[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>006E</otexdata>
            <otexsrc>110</otexsrc>
            <otexcom>LookupIndex[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0070</otexdata>
            <otexsrc>112</otexsrc>
            <otexcom>LookupIndex[2]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Example 4: JstfMax Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The JstfMax table in Example 4 defines a lookup to
          expand the advance width of the word space glyph and extend
          line lengths. The lookup definition is identical to the
          SinglePos lookup type in the <ottable>GPOS</ottable> table
          although it is enabled only when justifying text. The
          ValueRecord in the WordSpaceExpand lookup subtable specifies
          an XAdvance adjustment of 360 units, which is the maximum
          value the font developer recommends for acceptable text
          rendering. The text-processing client may implement the
          lookup using any value between zero and the maximum.</para>


        <otexample>
          <title>Example 4</title>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>JstfMax</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordSpaceExpandMax</otexsrc>
            <otexcom>JstfMax table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>WordSpaceExpandLookup</otexsrc>
            <otexcom>offset to Jstf Lookup[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>Lookup</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordSpaceExpandLookup</otexsrc>
            <otexcom>Jstf Lookup table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupType, SinglePos Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0x0000</otexsrc>
            <otexcom>LookupFlag</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>WordSpaceExpandSubtable</otexsrc>
            <otexcom>offset to Subtable[0], SinglePos
                  subtabl</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>SinglePosFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordSpaceExpandSubtable</otexsrc>
            <otexcom>SinglePos subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>PosFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>WordSpaceCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>0x0004</otexsrc>
            <otexcom>ValueFormat, XAdvance only</otexcom>
          </otexline>
          <otexline>
            <otexdata>0168</otexdata>
            <otexsrc>360</otexsrc>
            <otexcom>Value XAdvance value in Jstf, this is a max
                  value, expand word space from zero to this
                  amoun</otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom></otexcom>
          </otexline>
          <otexline>
            <otexdata></otexdata>
            <otexsrc>WordSpaceCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0022</otexdata>
            <otexsrc>WordSpaceGlyphID</otexsrc>
            <otexcom>GlyphArray[0]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.EBDT'>
    <title>EBDT - Embedded Bitmap Data Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Three tables are used to embed bitmaps in
          OpenType fonts. They are the <ottable>EBLC</ottable>
          table for embedded bitmap locators, the
          <ottable>EBDT</ottable> table for embedded bitmap data, and
          the <ottable>EBSC</ottable> table for embedded bitmap
          scaling information.</para>

        <para>OpenType embedded bitmaps are also called 'sbits' (for
          "scaler bitmaps"). A set of bitmaps for a face at a given
          size is called a strike.</para>

        <para>The <ottable>EBLC</ottable> table identifies the sizes
          and glyph ranges of the sbits, and keeps offsets to glyph
          bitmap data in indexSubTables. The <ottable>EBDT</ottable>
          table then stores the glyph bitmap data, in a number of
          different possible formats.  Glyph metrics information may
          be stored in either the <ottable>EBLC</ottable> or
          <ottable>EBDT</ottable> table, depending upon the
          indexSubTable and glyph bitmap data formats. The
          <ottable>EBSC</ottable> table identifies sizes that will be
          handled by scaling up or scaling down other sbit
          sizes.</para>

        <para>The <ottable>EBDT</ottable> table is a superset of
          Apple's AAT (Apple Advanced Typography) 'bdat' table.</para>

        <para>The <ottable>EBDT</ottable> table begins with a header
          containing simply the table version number.</para>

        <otformat>
          <title>?</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>FIXED</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Initially defined as 0x00020000</otfielddesc>
          </otfield>
        </otformat>

       <para>The rest of the <ottable>EBDT</ottable> table is a
          collection of bitmap data. The data can be in a number of
          possible formats, indicated by information in the <ottable>EBLC</ottable>
          table. Some of the formats contain metric information plus
          image data, and other formats contain only the image
          data. Long word alignment is not required for these sub
          tables; byte alignment is sufficient.</para>

        <para>There are also two different formats for glyph metrics:
          big glyph metrics and small glyph metrics. Big glyph metrics
          define metrics information for both horizontal and vertical
          layouts. This is important in fonts (such as Kanji) where
          both types of layout may be used. Small glyph metrics define
          metrics information for one layout direction only. Which
          direction applies, horizontal or vertical, is determined by
          the 'flags' field in the bitmapSizeTable field of the <ottable>EBLC</ottable>
          table.</para>

        <table>
          <title>bigGlyphMetrics</title>
          <tgroup cols="2">
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>BYTE</entry>
                <entry>height</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>width</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>horiBearingX</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>horiBearingY</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>horiAdvance</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>vertBearingX</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>vertBearingY</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>vertAdvance</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <table>
          <title>smallGlyphMetrics</title>
          <tgroup cols="2">
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>BYTE</entry>
                <entry>height</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>width</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>BearingX</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>BearingY</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>Advance</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The nine different formats currently defined for glyph
          bitmap data are listed and described below. Different
          formats are better for different purposes. Apple 'bdat'
          tables support only formats 1 through 7.</para>

        <para>In all formats, if the bitDepth is greater than 1, all
          of a pixel's bits are stored consecutively in memory, and
          all of a row's pixels are stored consecutively.</para>

        <para>Note: Each of these formats can contain black/white or
          grayscale bitmaps depending on the setting of the bitDepth
          field in the <ottable>EBLC</ottable> table. For performance reasons, we
          recommend using a byte-aligned format for embedded bitmaps
          with bitDepth of 8.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 1: small metrics, byte-aligned data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>smallGlyphMetrics</otfieldtype>
            <otfieldname>smallMetrics</otfieldname>
            <otfielddesc>Metrics information for the
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>5</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>image data</otfieldname>
            <otfielddesc>Byte-aligned bitmap data</otfielddesc>
          </otfield>
        </otformat>

        <para>Glyph bitmap format 1 consists of small metrics records
          (either horizontal or vertical depending on the
          bitmapSizeTable 'flag' value in the <ottable>EBLC</ottable> table) followed
          by byte aligned bitmap data. The bitmap data begins with the
          most significant bit of the first byte corresponding to the
          top-left pixel of the bounding box, proceeding through
          succeeding bits moving left to right. The data for each row
          is padded to a byte boundary, so the next row begins with
          the most significant bit of a new byte. 1 bits correspond to
          black, and 0 bits to white.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 2: small metrics, bit-aligned data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <title>?</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>smallGlyphMetrics</otfieldtype>
            <otfieldname>smallMetrics</otfieldname>
            <otfielddesc>Metrics information for the
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>5</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>image data</otfieldname>
            <otfielddesc>Bit-aligned bitmap data</otfielddesc>
          </otfield>
        </otformat>

        <para>Glyph bitmap format 2 is the same as format 1 except
          that the bitmap data is bit aligned. This means that the
          data for a new row will begin with the bit immediately
          following the last bit of the previous row. The start of
          each glyph must be byte aligned, so the last row of a glyph
          may require padding. This format takes a little more time to
          parse, but saves file space compared to format 1. </para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 3: (obsolete)</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Format 3 is obsolete.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 4: (not supported) metrics in EBLC, compressed
        data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Glyph bitmap format 4 is a compressed format used by
          Apple in some of their Far East fonts. MS has not
          implemented it in our rasterizer.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 5: metrics in EBLC, bit-aligned image data
        only</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <title>?</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>image data</otfieldname>
            <otfielddesc>Bit-aligned bitmap data</otfielddesc>
          </otfield>
        </otformat>

        <para>Glyph bitmap format 5 is similar to format 2 except that
          no metrics information is included, just the bit aligned
          data. This format is for use with <ottable>EBLC</ottable> indexSubTable
          format 2 or format 5, which will contain the metrics
          information for all glyphs. It works well for Kanji
          fonts.</para>

        <para>The rasterizer recalculates sbit metrics for Format 5
          bitmap data, allowing Windows to report correct ABC widths,
          even if the bitmaps have white space on either side of the
          bitmap image. This allows fonts to store monospaced bitmap
          glyphs in the efficient Format 5 without breaking Windows
          GetABCWidths call.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 6: big metrics, byte-aligned data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <title>?</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>bigGlyphMetrics</otfieldtype>
            <otfieldname>bigMetrics</otfieldname>
            <otfielddesc>Metrics information for the
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>image data</otfieldname>
            <otfielddesc>Byte-aligned bitmap data</otfielddesc>
          </otfield>
        </otformat>

        <para>Glyph bitmap format 6 is the same as format 1 except
          that is uses big glyph metrics instead of small.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 7: big metrics, bit-aligned data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>bigGlyphMetrics</otfieldtype>
            <otfieldname>bigMetrics</otfieldname>
            <otfielddesc>Metrics information for the
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>VARIABLE</otfieldtype>
            <otfieldname>image data</otfieldname>
            <otfielddesc>Bit-aligned bitmap data</otfielddesc>
          </otfield>
        </otformat>

        <para>Glyph bitmap format 7 is the same as format 2 except
          that is uses big glyph metrics instead of small.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>ebdtComponent; array used by Formats 8 and 9</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphCode</otfieldname>
            <otfielddesc>Component glyph code</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>xOffset</otfieldname>
            <otfielddesc>Position of component left</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>3</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>yOffset</otfieldname>
            <otfielddesc>Position of component top</otfielddesc>
          </otfield>
        </otformat>

        <para>The component array, used by Formats 8 and 9, contains
          the glyph code of the component, which can be looked up in
          the <ottable>EBLC</ottable> table, as well as xOffset and yOffset values
          which tell where to position the top-left corner of the
          component in the composite. Nested composites (a composite
          of composites) are allowed, and the number of nesting levels
          is determined by implementation stack space.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 8: small metrics, component data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>smallGlyphMetrics</otfieldtype>
            <otfieldname>smallMetrics</otfieldname>
            <otfielddesc>Metrics information for the
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>5</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>pad</otfieldname>
            <otfielddesc>Pad to short boundary</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numComponents</otfieldname>
            <otfielddesc>Number of components</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ebdtComponent</otfieldtype>
            <otfieldname>componentArray [n]</otfieldname>
            <otfielddesc>Glyph code, offset array</otfielddesc>
          </otfield>
        </otformat>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 9: big metrics, component data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>bigGlyphMetrics</otfieldtype>
            <otfieldname>bigMetrics</otfieldname>
            <otfielddesc>Metrics information for the
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numComponents</otfieldname>
            <otfielddesc>Number of components</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>ebdtComponent</otfieldtype>
            <otfieldname>componentArray [n]</otfieldname>
            <otfielddesc>Glyph code, offset array</otfielddesc>
          </otfield>
        </otformat>

        <para>Glyph bitmap formats 8 and 9 are used for composite
          bitmaps. For accented characters and other composite glyphs
          it may be more efficient to store a copy of each component
          separately, and then use a composite description to
          construct the finished glyph. The composite formats allow
          for any number of components, and allow the components to be
          positioned anywhere in the finished glyph. Format 8 uses
          small metrics, and format 9 uses big metrics.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.EBLC'>
    <title>EBLC - Embedded Bitmap Location Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Three tables are used to embed bitmaps in OpenType
          fonts. They are the <ottable>EBLC</ottable> table for embedded bitmap
          locators, the 'EBDT' table for embedded bitmap data, and the
          <ottable>EBSC</ottable> table for embedded bitmap scaling information.
          OpenType embedded bitmaps are called 'sbits' (for "scaler
          bitmaps"). A set of bitmaps for a face at a given size is
          called a strike.</para>

        <para>The <ottable>EBLC</ottable> table identifies the sizes and glyph ranges
          of the sbits, and keeps offsets to glyph bitmap data in
          indexSubTables. The 'EBDT' table then stores the glyph
          bitmap data, also in a number of different possible formats.
          Glyph metrics information may be stored in either the <ottable>EBLC</ottable>
          or 'EBDT' table, depending upon the indexSubTable and glyph
          bitmap formats. The <ottable>EBSC</ottable> table identifies sizes that will
          be handled by scaling up or scaling down other sbit
          sizes.</para>

        <para>The <ottable>EBLC</ottable> table uses the same format as Apple's AAT
          (Apple Advanced Typography) 'bloc' table.</para>

        <para>The <ottable>EBLC</ottable> table begins with a header containing the
          table version and number of strikes. An OpenType font may
          have one or more strikes embedded in the 'EBDT'
          table.</para>

        <otformat>
          <title>eblcHeader</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>FIXED</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>initially defined as 0x00020000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numSizes</otfieldname>
            <otfielddesc>Number of bitmapSizeTables</otfielddesc>
          </otfield>
        </otformat>

        <para>The eblcHeader is followed immediately by the
          bitmapSizeTable array(s). The numSizes in the eblcHeader
          indicates the number of bitmapSizeTables in the array. Each
          strike is defined by one bitmapSizeTable.</para>

        <otformat>
          <title>bitmapSizeTable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>indexSubTableArrayOffset</otfieldname>
            <otfielddesc>offset to index subtable from beginning of
              EBLC.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>indexTablesSize</otfieldname>
            <otfielddesc>number of bytes in corresponding index
              subtables and array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numberOfIndexSubTables</otfieldname>
            <otfielddesc>an index subtable for each range or format
              change</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>colorRef</otfieldname>
            <otfielddesc>not used; set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>sbitLineMetrics</otfieldtype>
            <otfieldname>hori</otfieldname>
            <otfielddesc>line metrics for text rendered
              horizontally</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>sbitLineMetrics</otfieldtype>
            <otfieldname>vert</otfieldname>
            <otfielddesc>line metrics for text rendered
              vertically</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>40</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>startGlyphIndex</otfieldname>
            <otfielddesc>lowest glyph index for this
              size</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>42</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>endGlyphIndex</otfieldname>
            <otfielddesc>highest glyph index for this
              size</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>44</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>ppemX</otfieldname>
            <otfielddesc>horizontal pixels per Em</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>45</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>ppemY</otfieldname>
            <otfielddesc>vertical pixels per Em</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>46</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>bitDepth</otfieldname>
            <otfielddesc>the Microsoft rasterizer v.1.7 or greater
              supports the following bitDepth values, as described
              below: 1, 2, 4, and 8.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>47</otfieldoffs>
            <otfieldtype>CHAR</otfieldtype>
            <otfieldname>flags</otfieldname>
            <otfielddesc>vertical or horizontal (see
              bitmapFlags)</otfielddesc>
          </otfield>
        </otformat>

        <para>The indexSubTableArrayOffset is the offset from the
          beginning of the <ottable>EBLC</ottable> table to the indexSubTableArray.
          Each strike has one of these arrays to support various
          formats and discontiguous ranges of bitmaps. The
          indexTablesSize is the total number of bytes in the
          indexSubTableArray and the associated indexSubTables. The
          numberOfIndexSubTables is a count of the indexSubTables for
          this strike.</para>
        <para>The horizontal and vertical line metrics contain the
          ascender, descender, linegap, and advance information for
          the strike. The line metrics format is described in the
          following table:</para>

        <table>
          <title>sbitLineMetrics</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>CHAR</entry>
                <entry>ascender</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>descender</entry>
              </row>
              <row>
                <entry>BYTE</entry>
                <entry>widthMax</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>caretSlopeNumerator</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>caretSlopeDenominator</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>caretOffset</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>minOriginSB</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>minAdvanceSB</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>maxBeforeBL</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>minAfterBL</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>pad1</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>pad2</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The caret slope determines the angle at which the caret
          is drawn, and the offset is the number of pixels (+ or -) to
          move the caret. This is a signed char since we are dealing
          with integer metrics. The minOriginSB, minAdvanceSB ,
          maxBeforeBL, and minAfterBL are described in the diagrams
          below. The main need for these numbers is for scalers that
          may need to pre-allocate memory and/or need more metric
          information to position glyphs. All of the line metrics are
          one byte in length. The line metrics are not used directly
          by the rasterizer, but are available to clients who want to
          parse the <ottable>EBLC</ottable> table.</para>

        <para>The startGlyphIndex and endGlyphIndex describe the
          minimum and maximum glyph codes in the strike, but a strike
          does not necessarily contain bitmaps for all glyph codes in
          this range. The indexSubTables determine which glyphs are
          actually present in the 'EBDT' table.</para>
        <para>The ppemX and ppemY fields describe the size of the
          strike in pixels per Em. The ppem measurement is equivalent
          to point size on a 72 dots per inch device. Typically, ppemX
          will be equal to ppemY for devices with 'square pixels'. To
          accommodate devices with rectangular pixels, and to allow
          for bitmaps with other aspect ratios, ppemX and ppemY may
          differ.</para>
        <para>The bitDepth field is used to specify the number of
          levels of gray used in the embedded bitmaps. The Microsoft
          rasterizer v.1.7 or greater support the following
          values.</para>


        <table>
          <title>bitDepth</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>black/white</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>4 levels of gray</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>16 levels of gray</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>256 levels of gray</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The 'flags' byte contains two bits to indicate the
          direction of small glyph metrics: horizontal or vertical.
          The remaining bits are reserved.</para>

        <table>
          <title>Bitmap Flags</title>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>CHAR</entry>
                <entry>0x01</entry>
                <entry>Horizontal</entry>
              </row>
              <row>
                <entry>CHAR</entry>
                <entry>0x02</entry>
                <entry>Vertical</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The colorRef and bitDepth fields are reserved for future
          enhancements. For monochrome bitmaps they should have the
          values colorRef=0 and bitDepth=1.</para>

        <figure>
          <title>Horizontal text</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00283.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Vertical text</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00284.gif'/>
            </imageobject>
          </mediaobject>
        </figure>


        <para>Associated with the image data for every glyph in a
          strike is a set of glyph metrics. These glyph metrics
          describe bounding box height and width, as well as side
          bearing and advance width information. The glyph metrics can
          be found in one of two places. For ranges of glyphs (not
          necessarily the whole strike) whose metrics may be different
          for each glyph, the glyph metrics are stored along with the
          glyph image data in the 'EBDT' table. Details of how this is
          done is described in the 'EBDT' section of this document.
          For ranges of glyphs whose metrics are identical for every
          glyph, we save significant space by storing a single copy of
          the glyph metrics in the indexSubTable in the <ottable>EBLC</ottable>.</para>
        <para>There are also two different formats for glyph metrics:
          big glyph metrics and small glyph metrics. Big glyph metrics
          define metrics information for both horizontal and vertical
          layouts. This is important in fonts (such as Kanji) where
          both types of layout may be used. Small glyph metrics define
          metrics information for one layout direction only. Which
          direction applies, horizontal or vertical, is determined by
          the 'flags' field in the bitmapSizeTable.</para>

        <table>
          <title>bigGlyphMetrics</title>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Offset</entry>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>BYTE</entry>
                <entry>height</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>BYTE</entry>
                <entry>width</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>CHAR</entry>
                <entry>horiBearingX</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>CHAR</entry>
                <entry>horiBearingY</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>BYTE</entry>
                <entry>horiAdvance</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>CHAR</entry>
                <entry>vertBearingX</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>CHAR</entry>
                <entry>vertBearingY</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>BYTE</entry>
                <entry>vertAdvance</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>smallGlyphMetrics</title>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Offset</entry>
                <entry>Type</entry>
                <entry>Name</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>BYTE</entry>
                <entry>height</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>BYTE</entry>
                <entry>width</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>CHAR</entry>
                <entry>BearingX</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>CHAR</entry>
                <entry>BearingY</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>BYTE</entry>
                <entry>Advance</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The following diagram illustrates the meaning of the
          glyph metrics.</para>

        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00285.gif'/>
            </imageobject>
          </mediaobject>
        </informalfigure>

        <para>The bitmapSizeTable for each strike contains the offset
          to an array of indexSubTableArray elements. Each element
          describes a glyph code range and an offset to the
          indexSubTable for that range. This allows a strike to
          contain multiple glyph code ranges and to be represented in
          multiple index formats if desirable.</para>

        <otformat>
          <title>indexSubTableArray</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>firstGlyphIndex</otfieldname>
            <otfielddesc>first glyph code of this range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>lastGlyphIndex</otfieldname>
            <otfielddesc>last glyph code of this range
              (inclusive)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>additionalOffsetToIndexSubtable</otfieldname>
            <otfielddesc>add to indexSubTableArrayOffset to get offset
              from beginning of <ottable>EBLC</ottable></otfielddesc>
          </otfield>
        </otformat>

        <para>After determining the strike, the rasterizer searches
          this array for the range containing the given glyph code.
          When the range is found, the additionalOffsetToIndexSubtable
          is added to the indexSubTableArrayOffset to get the offset
          of the indexSubTable in the <ottable>EBLC</ottable>.</para>
        <para>The first indexSubTableArray is located after the last
          bitmapSizeSubTable entry. Then the indexSubTables for the
          strike follow. Another indexSubTableArray (if more than one
          strike) and its indexSubTables are next. The <ottable>EBLC</ottable>
          continues with an array and indexSubTables for each
          strike.</para>
        <para>We now have the offset to the indexSubTable. All
          indexSubTable formats begin with an indexSubHeader which
          identifies the indexSubTable format, the format of the
          'EBDT' image data, and the offset from the beginning of the
          'EBDT' table to the beginning of the image data for this
          range.</para>

        <otformat>
          <title>indexSubHeader</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>indexFormat</otfieldname>
            <otfielddesc>format of this indexSubTable</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>imageFormat</otfieldname>
            <otfielddesc>format of 'EBDT' image data</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>imageDataOffset</otfieldname>
            <otfielddesc>offset to image data in 'EBDT'
              table</otfielddesc>
          </otfield>
        </otformat>

        <para>There are currently five different formats used for the
          indexSubTable, depending upon the size and type of bitmap
          data in the glyph code range. Apple 'bloc' tables support
          only formats 1 through 3.</para>
        <para>The choice of which indexSubTable format to use is up to
          the font manufacturer, but should be made with the aim of
          minimizing the size of the font file. Ranges of glyphs with
          variable metrics - that is, where glyphs may differ from
          each other in bounding box height, width, side bearings or
          advance - must use format 1, 3 or 4. Ranges of glyphs with
          constant metrics can save space by using format 2 or 5,
          which keep a single copy of the metrics information in the
          indexSubTable rather than a copy per glyph in the 'EBDT'
          table. In some monospaced fonts it makes sense to store
          extra white space around some of the glyphs to keep all
          metrics identical, thus permitting the use of format 2 or
          5.</para>
        <para>Structures for each indexSubTable format are listed
          below.</para>


        <otformat>
          <title>indexSubTable1: variable metrics glyphs with 4 byte
            offsets</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>indexSubHeader</otfieldtype>
            <otfieldname>header</otfieldname>
            <otfielddesc>header info</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>offsetArray []</otfieldname>
            <otfielddesc>offsetArray[glyphIndex] + imageDataOffset =
              glyphData sizeOfArray = (lastGlyph-firstGlyph+1)+1+1 pad
              if needed </otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>indexSubTable2: all glyphs have identical
            metrics</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>indexSubHeader</otfieldtype>
            <otfieldname>header</otfieldname>
            <otfielddesc>header info</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>imageSize</otfieldname>
            <otfielddesc>all the glyphs are of the same
              size</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>bigGlyphMetrics</otfieldtype>
            <otfieldname>bigMetrics</otfieldname>
            <otfielddesc>all glyphs have the same metrics; glyph data
              may be compressed, byte-aligned, or
              bit-aligned</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>indexSubTable3: variable metrics glyphs with 2 byte
            offsets</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>indexSubHeader</otfieldtype>
            <otfieldname>header</otfieldname>
            <otfielddesc>header info</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>offsetArray []</otfieldname>
            <otfielddesc>offsetArray[glyphIndex] + imageDataOffset =
              glyphData sizeOfArray = (lastGlyph-firstGlyph+1)+1+1 pad
              if needed  </otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>indexSubTable4: variable metrics glyphs with sparse
            glyph codes</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>indexSubHeader</otfieldtype>
            <otfieldname>header</otfieldname>
            <otfielddesc>header info</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numGlyphs</otfieldname>
            <otfielddesc>array length</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>codeOffsetPair</otfieldtype>
            <otfieldname>glyphArray []</otfieldname>
            <otfielddesc>one per glyph;
              sizeOfArray=numGlyphs+1</otfielddesc>
          </otfield>
        </otformat>

        <para>codeOffsetPair: used by indexSubTable4</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphCode</otfieldname>
            <otfielddesc>code of glyph present</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>offset</otfieldname>
            <otfielddesc>location in EBDT</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>indexSubTable5: constant metrics glyphs with sparse
            glyph codes</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>indexSubHeader</otfieldtype>
            <otfieldname>header</otfieldname>
            <otfielddesc>header info</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>imageSize</otfieldname>
            <otfielddesc>all glyphs have the same data
              size</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>bigGlyphMetrics</otfieldtype>
            <otfieldname>bigMetrics</otfieldname>
            <otfielddesc>all glyphs have the same
              metrics</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numGlyphs</otfieldname>
            <otfielddesc>array length</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphCodeArray []</otfieldname>
            <otfielddesc>one per glyph, sorted by glyph code;
              sizeOfArray=numGlyphs</otfielddesc>
          </otfield>
        </otformat>

        <para>The size of the 'EBDT' image data can be calculated from
          the indexSubTable information. For the constant metrics
          formats (2 and 5) the image data size is constant, and is
          given in the imageSize field. For the variable metrics
          formats (1, 3, and 4) image data must be stored contiguously
          and in glyph code order, so the image data size may be
          calculated by subtracting the offset for the current glyph
          from the offset of the next glyph. Because of this, it is
          necessary to store one extra element in the offsetArray
          pointing just past the end of the range's image data. This
          will allow the correct calculation of the image data size
          for the last glyph in the range.</para>
        <para>Contiguous, or nearly contiguous, ranges of glyph codes
          are handled best by formats 1, 2, and 3 which store an
          offset for every glyph code in the range. Very sparse ranges
          of glyph codes should use format 4 or 5 which explicitly
          call out the glyph codes represented in the range. A small
          number of missing glyphs can be efficiently represented in
          formats 1 or 3 by having the offset for the missing glyph be
          followed by the same offset for the next glyph, thus
          indicating a data size of zero.</para>
        <para>The only difference between formats 1 and 3 is the size
          of the offsetArray elements: format 1 uses ULONG's while
          format 3 uses USHORT's. Therefore format 1 can cover a
          greater range (> 64k bytes) while format 3 saves more space
          in the <ottable>EBLC</ottable> table. Since the offsetArray elements are
          added to the imageDataOffset base address in the
          indexSubHeader, a very large set of glyph bitmap data could
          be addressed by splitting it into multiple ranges, each less
          than 64k bytes in size, allowing the use of the more
          efficient format 3.</para>
        <para>The <ottable>EBLC</ottable> table specification requires double word
          (ULONG) alignment for all subtables. This occurs naturally
          for indexSubTable formats 1, 2, and 4, but may not for
          formats 3 and 5, since they include arrays of type USHORT.
          When there is an odd number of elements in these arrays it
          is necessary to add an extra padding element to maintain
          proper alignment.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.EBSC'>
    <title>EBSC - Embedded Bitmap Scaling Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>EBSC</ottable> table provides a mechanism for describing
          embedded bitmaps which are created by scaling other embedded
          bitmaps. While this is the sort of thing that outline font
          technologies were invented to avoid, there are cases (small
          sizes of Kanji, for example) where scaling a bitmap produces
          a more legible font than scan-converting an outline. For
          this reason the <ottable>EBSC</ottable> table allows a font to define a
          bitmap strike as a scaled version of another strike.</para>
        <para>The <ottable>EBSC</ottable> table begins with a header containing the
          table version and number of strikes.</para>

        <otformat>
          <title>ebscHeader</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>FIXED</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>initially defined as 0x00020000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>numSizes</otfieldname>
            <otfielddesc></otfielddesc>
          </otfield>
        </otformat>

        <para>The ebscHeader is followed immediately by the
          bitmapScaleTable array. The numSizes in the ebscHeader
          indicates the number of bitmapScaleTables in the array. Each
          strike is defined by one bitmapScaleTable.</para>

        <otformat>
          <title>bitmapScaleTable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>sbitLineMetrics</otfieldtype>
            <otfieldname>hori</otfieldname>
            <otfielddesc>line metrics</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>sbitLineMetrics</otfieldtype>
            <otfieldname>vert</otfieldname>
            <otfielddesc>line metrics</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>ppemX</otfieldname>
            <otfielddesc>target horizontal pixels per Em</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>ppemY</otfieldname>
            <otfielddesc>target vertical pixels per Em</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>substitutePpemX</otfieldname>
            <otfielddesc>use bitmaps of this size</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>substitutePpemY</otfieldname>
            <otfielddesc>use bitmaps of this size</otfielddesc>
          </otfield>
        </otformat>

        <para>The line metrics have the same meaning as those in the
          bitmapSizeTable, and refer to font wide metrics after
          scaling. The ppemX and ppemY values describe the size of the
          font after scaling. The substitutePpemX and substitutePpemY
          values describe the size of a strike that exists as an sbit
          in the <ottable>EBLC</ottable> and 'EBDT', and that will be scaled up or down
          to generate the new strike.</para>
        <para>Notice that scaling in the x direction is independent of
          scaling in the y direction, and their scaling values may
          differ. A square aspect-ratio strike could be scaled to a
          non-square aspect ratio. Glyph metrics are scaled by the
          same factor as the pixels per Em (in the appropriate
          direction), and are rounded to the nearest integer
          pixel.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.DSIG'>
    <title>DSIG - Digital Signature Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The DSIG table contains the digital signature of the
          OpenType font. Signature formats are widely documented and
          rely on a key pair architecture. Software developers, or
          publishers posting material on the Internet, create
          signatures using a private key. Operating systems or
          applications authenticate the signature using a public
          key.</para>
        <para>The W3C and major software and operating system
          developers have specified security standards that describe
          signature formats, specify secure collections of web
          objects, and recommend authentication architecture. OpenType
          fonts with signatures will support these standards.</para>
        <para>OpenType fonts offer many security features:</para>
        <itemizedlist>
          <listitem>
            <para>Operating systems and browsing applications can
              identify the source and integrity of font files before
              using them,</para>
          </listitem>
          <listitem>
            <para>Font developers can specify embedding restrictions
              in OpenType fonts, and these restrictions cannot be
              altered in a font signed by the developer. </para>
          </listitem>
        </itemizedlist>

        <para>The enforcement of signatures is an administrative
          policy, enabled by the operating system. Windows will soon
          require installed software components, including fonts, to
          be signed. Internet browsers will also give users and
          administrators the ability to screen out unsigned objects
          obtained on-line, including web pages, fonts, graphics, and
          software components.</para>
        <para>Anyone can obtain identity certificates and encryption
          keys from a certifying agency, such as Verisign or GTE's
          Cybertrust, free or at a very low cost.</para>
        <para>The DSIG table is organized as follows. The first
          portion of the table is the header:</para>

        <otformat>
	  <title>DSIG Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulVersion</otfieldname>
            <otfielddesc>Version number of the DSIG
              table (0x00000001)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usNumSigs</otfieldname>
            <otfielddesc>Number of signatures in the
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usFlag</otfieldname>
            <otfielddesc>
	      <para>permission flags</para>
	      <para>Bit 0: cannot be resigned</para>
	      <para>Bit 1-7: Reserved (Set to 0)</para>
	    </otfielddesc>
          </otfield>
        </otformat>

	<para>The version of the DSIG table is expressed as a ULONG,
	  beginning at 0. The version of the DSIG table currently used
	  is version 1 (0x00000001).</para>

	<para>Permission bit 0 allows a party signing the font to
	  prevent any other parties from also signing the font
	  (counter-signatures). If this bit is set to zero (0) the
	  font may have a signature applied over the existing digital
	  signature(s). A party who wants to ensure that their
	  signature is the last signature can set this bit.</para>

        <para>The DSIG header information is followed by entries for each
          of the signatures in the table specifying format and offset
          information:</para>

        <otformat>
	  <title>Format/Offset Table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulFormat</otfieldname>
            <otfielddesc>format of the signature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulLength</otfieldname>
            <otfielddesc>Length of signature in bytes</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ulOffset</otfieldname>
            <otfielddesc>Offset to the signature block from the
              beginning of the table</otfielddesc>
          </otfield>
        </otformat>

        <para>This information is then followed by one or more
          signature blocks:</para>

        <otformat>
	  <title>Signature Block</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usReserved1</otfieldname>
            <otfielddesc>Reserved for later use; 0 for
              now</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>usReserved2</otfieldname>
            <otfielddesc>Reserved for later use; 0 for
              now</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>cbSignature</otfieldname>
            <otfielddesc>Length (in bytes) of the PKCS#7 packet in
              pbSignature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>BYTE[]</otfieldtype>
            <otfieldname>bSignature</otfieldname>
            <otfielddesc>PKCS#7 packet</otfielddesc>
          </otfield>
        </otformat>

        <para>The format identifier specifies both the format of the
          signature object, as well as the hashing algorithm used to
          create and authenticate the signature. Currently only one
          format is defined, but at least one other format will soon
          be defined to handle subsetting scenarios. Format 1 supports
          PKCS#7 signatures with X.509 certificates and
          counter-signatures, as these signatures have been
          standardized for use by the W3C with the participation of
          numerous software developers.</para>

        <para>For more information about PKCS#7 signatures, see <ulink
            url='ftp://ftp.rsa.com/pub/pkcs/ascii/pkcs-7.asc'>ftp://ftp.rsa.com/pub/pkcs/ascii/pkcs-7.asc</ulink>.</para>

        <para>For more information about counter-signatures, see
          <ulink
            url='ftp://ftp.rsa.com/pub/pkcs/ascii/pkcs-9.asc'>ftp://ftp.rsa.com/pub/pkcs/ascii/pkcs-9.asc</ulink>.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='annotation'>
        <title>Annotation</title>

	<para>It is unclear what is measured by the field ulLength in
	a Format/Offset table: it is the length of the Signature Block
	table, or the length of the bSignature array in that table? In
	either case, this seems to be a redundant value, and its
	correlation to the cbSignature field should be noted. Looking
	at Adobe fonts, it seems that we interpreted it as the length
	of the signature block.</para>

	<para>The Format/Offset Table is a misnommer. This is actually
	a <emphasis>record</emphasis>, not a
	<emphasis>table</emphasis>, since it is not
	pointed. Similarly, the DSIG header should be augmented by an
	array of those records.</para>

        <para>The reference point of the ulOffset field in the
        Format/Offset is unclear. It is from the beginning of the DSIG
        table, or from the beginning of the Format/Offset record (thus
        being inconsistent with the layout tables)? Looking at Adobe
        fonts, it seems that we interpreted it as the relative to the
        beginning of the DSIG table.</para>

	<para>The Signature Block is a misnommer. This is actually a
	<emphasis>table</emphasis>, not a <emphasis>block</emphasis>.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role='zzzxml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title></code-title>
  DSIG =
    element DSIG {
      attribute version { "1" },
      attribute flags { text },
      element signature {
        attribute format { text },
        text
      }*
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='dsig.methods'>
  public void fromXML (Element table)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block> blockCache = new HashMap&lt;Element, Block> ();

    NodeList children = table.getChildNodes ();

    Block me = new Block (8 + children.getLength () * 12, children.getLength ());
    me.setuint32 (0, 1);
    me.setuint16 (4, children.getLength ());
    me.setuint16 (6, Integer.parseInt (table.getAttribute ("flags")));

    int offset = 8;
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element s = (Element) children.item (i);
      byte [] data = decodeBinaryFromXML (s.getFirstChild ().getNodeValue ());
      Block signatureBlock = new Block (data.length, 0);
      for (int j = 0; j &lt; data.length; j++) {
        signatureBlock.setuint8 (j, data [j]); }

      me.setuint32 (offset, Integer.parseInt (s.getAttribute ("format")));
      me.setuint32 (offset + 4, signatureBlock.content.length);
      me.setBigOffset (offset + 8, signatureBlock); }

    data = me.serialize ();
  }

  byte[] decodeBinaryFromXML (String s) {
    ByteBuffer bb = new ByteBuffer (256);

    char[] ch = s.toCharArray ();

    int i = 0;
    while (i &lt; ch.length) {
      if ('%' == ch [i]) {
        i++;
        int b = Integer.parseInt (new String (ch, i, 2), 16);
        i += 2;
        bb.addCard8 (b); }

      else {
        i++; }}

    return bb.toArray ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='dsig.methods'>
  <code-title>Decompile a DSIG table</code-title>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at = new AttributesImpl ();
    at.addAttribute ("", "version", "version", "CDATA", "" + getuint32 (0));
    at.addAttribute ("", "flags", "flags", "CDATA", "" + getuint16 (6));

    conf.ch.startElement ("DSIG", at); {
      for (int i = 0; i &lt; getuint16 (4); i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "format", "format", "CDATA",
                         "" + getuint32 (8 + 12*i));
        conf.ch.startElement ("signature", at); {
          int offset = (int)getuint32 (8 + 12*i + 8);
          conf.ch.characters (toXML (offset,
                              (int)getuint32 (8 + 12*i + 4)));
          conf.ch.endElement ("signature"); }}
      conf.ch.endElement ("DSIG"); }
  }

  public String toXML (int offset, int length) {
    StringBuilder s = new StringBuilder ();
    char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7',
                     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

    for (int i = offset; i &lt; offset + length; i++) {
      s.append ('%');
      s.append (digits [(data[i] >>4) &amp; 0xf]);
      s.append (digits [data[i]       &amp; 0xf]);
      s.append (' '); }

    return s.toString ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Dsig'>
  <code-title>DSIG Class</code-title>
package com.adobe.aots.opentype;

import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Dsig extends Table {

  public Dsig () {
    super (Tag.DSIG, null);
  }

  public Dsig (Font font) {
    super (Tag.DSIG, font);
  }

  <code-include linkend='dsig.methods'/>

  public int[] getTableVersion () {
    return getFixed (0);
  }
}
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 1: For whole fonts, with either TrueType outlines
        and/or CFF data</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>PKCS#7 or PKCS#9. The signed content digest is created
          as follows:</para>

        <itemizedlist>
          <listitem>
            <para>If there is an existing DSIG table in the
              font,</para>
            <itemizedlist>
              <listitem>
                <para>Remove DSIG table from font.</para>
                <para>Remove DSIG table entry from sfnt Table
                  Directory.</para>
                <para>Adjust table offsets as necessary.</para>
                <para>Zero out the file checksum in the head
                  table.</para>
                <para>Add the usFlag (reserved, set at 1 for now) to
                  the stream of bytes</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Hash the full stream of bytes using a secure one-way
              hash (such as MD5) to create the content digest.</para>
          </listitem>
          <listitem>
            <para>Create the PKCS#7 signature block using the content
              digest.</para>
          </listitem>
          <listitem>
            <para>Create a new DSIG table containing the signature
              block.</para>
          </listitem>
          <listitem>
            <para>Add the DSIG table to the font, adjusting table
              offsets as necessary.</para>
          </listitem>
          <listitem>
            <para>Add a DSIG table entry to the sfnt Table
              Directory.</para>
          </listitem>
          <listitem>
            <para>Recalculate the checksum in the head table.</para>
          </listitem>
        </itemizedlist>

        <para>Prior to signing a font file, ensure that all the
          following attributes are true.</para>

        <itemizedlist>
          <listitem>
            <para>The magic number in the head table is
              correct.</para>
          </listitem>
          <listitem>
            <para>Given the number of tables value in the offset
              table, the other values in the offset table are
              consistent.</para>
          </listitem>
          <listitem>
            <para>The tags of the tables are ordered alphabetically
              and there are no duplicate tags.</para>
          </listitem>
          <listitem>
            <para>The offset of each table is a multiple of 4. (That
              is, tables are long word aligned.)</para>
          </listitem>
          <listitem>
            <para>The first actual table in the file comes immediately
              after the directory of tables.</para>
          </listitem>
          <listitem>
            <para>If the tables are sorted by offset, then for all
              tables i (where index 0 means the the table with the
              smallest offset), Offset[i] + Length[i] &lt;= Offset[i+1]
              and Offset[i] + Length[i] >= Offset[i+1] - 3. In other
              words, the tables do not overlap, and there are at most
              3 bytes of padding between tables.</para>
          </listitem>
          <listitem>
            <para>The pad bytes between tables are all zeros.</para>
          </listitem>
          <listitem>
            <para>The offset of the last table in the file plus its
              length is not greater than the size of the file.</para>
          </listitem>
          <listitem>
            <para>The checksums of all tables are correct.</para>
          </listitem>
          <listitem>
            <para>The head table's checkSumAdjustment field is
              correct.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Signatures for TrueType Collections</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The <ottable>DSIG</ottable> table for a TrueType
	  Collection (TTC) must be the last table in the TTC file. The
	  offset and checksum to the table is put in the TTCHeader
	  (version 2). Signatures of TTC files are expected to be
	  Format 1 signatures.</para>

	<para>The signature of a TTC file applies to the entire file,
	  not to the individual fonts contained within the
	  TTC. Signing the TTC file ensures that other contents are
	  not added to the TTC.</para>

	<para>Individual fonts included in a TrueType collection
	  should not be individually signed as the process of making
	  the TTC could invalidate the signature on the font.</para>
      </section>
    </section>

  </section>

  <!--************************************************************************-->
  <section id='chapter.gasp'>
    <title>gasp - Grid-fitting And Scan-conversion Procedure</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table contains information which describes the
          preferred rasterization techniques for the typeface when it
          is rendered on grayscale-capable devices. This table also
          has some use for monochrome devices, which may use the table
          to turn off hinting at very large or small sizes, to improve
          performance.</para>
        <para>At very small sizes, the best appearance on grayscale
          devices can usually be achieved by rendering the glyphs in
          grayscale without using hints. At intermediate sizes,
          hinting and monochrome rendering will usually produce the
          best appearance. At large sizes, the combination of hinting
          and grayscale rendering will typically produce the best
          appearance.</para>
        <para>If the <ottable>gasp</ottable> table is not present in a typeface, the
          rasterizer may apply default rules to decide how to render
          the glyphs on grayscale devices.</para>
        <para>The <ottable>gasp</ottable> table consists of a header followed by
          groupings of <ottable>gasp</ottable> records:</para>


        <otformat>
          <title>gasp Table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Version number (set to 0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numRanges</otfieldname>
            <otfielddesc>Number of records to follow</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GASPRANGE</otfieldtype>
            <otfieldname>gaspRange [numRanges]</otfieldname>
            <otfielddesc>Sorted by ppem</otfielddesc>
          </otfield>
        </otformat>

        <para>Each GASPRANGE record looks like this:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rangeMaxPPEM</otfieldname>
            <otfielddesc>Upper limit of range, in PPEM</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rangeGaspBehavior</otfieldname>
            <otfielddesc>Flags describing desired rasterizer
              behavior.</otfielddesc>
          </otfield>
        </otformat>

        <para>There are two flags for the rangeGaspBehavior
          flags:</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Flag</entry>
                <entry>Meaning</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GASP_GRIDFIT</entry>
                <entry>Use gridfitting</entry>
              </row>
              <row>
                <entry>GASP_DOGRAY</entry>
                <entry>Use grayscale rendering</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The set of bit flags may be extended in the future.The
          four currently defined values of rangeGaspBehavior would
          have the following uses:</para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Flag</entry>
                <entry>Value</entry>
                <entry>Meaning</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>GASP_DOGRAY</entry>
                <entry>0x0002</entry>
                <entry>small sizes, typically ppem&lt;9</entry>
              </row>
              <row>
                <entry>GASP_GRIDFIT</entry>
                <entry>0x0001</entry>
                <entry>medium sizes, typically 9&lt;=ppem&lt;=16</entry>
              </row>
              <row>
                <entry>GASP_DOGRAY|GASP_GRIDFIT</entry>
                <entry>0x0003</entry>
                <entry>large sizes, typically ppem>16</entry>
              </row>
              <row>
                <entry>(neither)</entry>
                <entry>0x0000</entry>
                <entry>optional for very large sizes, typically
                  ppem>2048</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The records in the gaspRange[] array must be sorted in
          order of increasing rangeMaxPPEM value. The last record
          should use 0xFFFF as a sentinel value for rangeMaxPPEM and
          should describe the behavior desired at all sizes larger
          than the previous record's upper limit. If the only entry in
          <ottable>gasp</ottable> is the 0xFFFF sentinel value, the
          behavior described will be used for all sizes.</para>

        <bridgehead>Sample <ottable>gasp</ottable> table</bridgehead>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Flag</entry>
                <entry>Value</entry>
                <entry>Meaning</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>version</entry>
                <entry>0x0000</entry>
                <entry></entry>
              </row>
              <row>
                <entry>numRanges</entry>
                <entry>0x0003</entry>
                <entry></entry>
              </row>
              <row>
                <entry>Range[0], Flag</entry>
                <entry>0x0008 0x0002</entry>
                <entry>ppem &lt;= 8, grayscale only</entry>
              </row>
              <row>
                <entry>Range[1], Flag</entry>
                <entry>0x0010 0x0001</entry>
                <entry>9&lt;=ppem &lt;= 16, gridfit only</entry>
              </row>
              <row>
                <entry>Range[2], Flag</entry>
                <entry>0xFFFF 0x0003</entry>
                <entry>16 &lt; ppem, gridfit and grayscale</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.hdmx'>
    <title>hdmx - Horizontal Device Metrics</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The hdmx table relates to OpenType fonts with TrueType
          outlines. The Horizontal Device Metrics table stores integer
          advance widths scaled to particular pixel sizes. This allows
          the font manager to build integer width tables without
          calling the scaler for each glyph. Typically this table
          contains only selected screen sizes. This table is sorted by
          pixel size. The checksum for this table applies to both
          subtables listed.</para>

        <para>Note that for non-square pixel grids, the character
          width (in pixels) will be used to determine which device
          record to use. For example, a 12 point character on a device
          with a resolution of 72x96 would be 12 pixels high, and 16 pixels
          wide. The hdmx device record for 16 pixel characters
          would be used.</para>

	<para>When the hdmx table is used, bit 2 of the flag field in
	  the <ottable>head</ottable> table must be set to 1 to
	  indicate that instructions may depend on point size.</para>

        <para>If bit 4 of the flag field in the
          <ottable>head</ottable> table is not set, then it is assumed
          that the font scales linearly; in this case an
          <ottable>hdmx</ottable> table is not necessary and should
          not be built. If bit 4 of the flag field is set, then one or
          more glyphs in the font are assumed to scale nonlinearly. In
          this case, performance can be improved by including the
          <ottable>hdmx</ottable> table with one or more important
          DeviceRecord's for important sizes. Please see the chapter
          "Recommendations for Windows Fonts" for more detail.</para>

        <para>The table begins as follows:</para>

        <otformat>
	  <title>hdmx header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Table version number (0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>numRecords</otfieldname>
            <otfielddesc>Number of device records.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>LONG</otfieldtype>
            <otfieldname>sizeDeviceRecord</otfieldname>
            <otfielddesc>Size of a device record, long
              aligned.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>DeviceRecord</otfieldtype>
            <otfieldname>records[numRecords]</otfieldname>
            <otfielddesc>Array of device records.</otfielddesc>
          </otfield>
        </otformat>

        <para>Each DeviceRecord for format 0 looks like this.</para>

	<otformat>
	  <title>Device Record</title>
	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>pixelSize</otfieldname>
	    <otfielddesc>Pixel size for following widths (as
                  ppem).</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>maxWidth</otfieldname>
	    <otfielddesc>Maximum width.</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>widths [numGlyphs]</otfieldname>
	    <otfielddesc>Array of widths (numGlyphs is from the
	      <ottable>maxp</ottable>)</otfielddesc>
	  </otfield>
	</otformat>

        <para>Each DeviceRecord is padded with 0's to make it long
          word aligned.</para>

        <para>Each Width value is the width of the particular glyph,
          in pixels, at the pixels per em (ppem) size listed at the
          start of the DeviceRecord.</para>
        <para>The ppem sizes are measured along the y axis.</para>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
hdmx =
  element hdmx {
    attribute version { text },
    element deviceRecord {
      attribute pixelSize { text },
      attribute maxWidth { text },
      element width {
        attribute gid { text },
        attribute v   { text }}* }* }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='hdmx.methods'>
  public void fromXML (Element hdmx)
    throws InvalidFontException, UnsupportedFontException {

    NodeList deviceRecords = hdmx.getChildNodes ();

    int numRecords = deviceRecords.getLength ();

    int sizeDeviceRecord = 0;

    for (int i = 0; i &lt; numRecords; i++) {
      Element deviceRecord = (Element) deviceRecords.item (i);
      int deviceRecordSize = 2 + deviceRecord.getChildNodes ().getLength ();
      sizeDeviceRecord = Math.max (deviceRecordSize, sizeDeviceRecord); }

    while (sizeDeviceRecord % 4 != 0) {
      sizeDeviceRecord++; }

    Block me = new Block (2 + 2 + 4 + numRecords * sizeDeviceRecord, 0);

    int offset = 0;

    me.setuint16 (offset,
                  Integer.decode (hdmx.getAttribute ("version")).intValue ());
    me.setint16 (offset + 2, numRecords);
    me.setint32 (offset + 4, sizeDeviceRecord);

    offset += 8;

    for (int i = 0; i &lt; numRecords; i++) {
      Element deviceRecord = (Element) deviceRecords.item (i);
      me.setuint8 (offset, Integer.decode (deviceRecord.getAttribute ("pixelSize")).intValue ());
      offset++;
      me.setuint8 (offset, Integer.decode (deviceRecord.getAttribute ("maxWidth")).intValue ());
      offset++;

      NodeList widths = deviceRecord.getChildNodes ();
      for (int j = 0; j &lt; widths.getLength (); j++) {
        Element width = (Element) widths.item (j);
        me.setuint8 (offset, Integer.decode (width.getAttribute ("v")).intValue ());
        offset ++; }

      while (offset % 4 != 0) {
       offset++; }}

    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='hdmx.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at = new AttributesImpl ();
    at.addAttribute ("", "version", "version", "CDATA", "" + getuint16 (0));

    conf.ch.startElement ("hdmx", at); {
      int offset;
      int numGlyphs = font.maxp.getNumGlyphs ();

      int numRecords = getint16 (2);
      int sizeDeviceRecord = getint32 (4);

      offset = 8;

      for (int i = 0; i &lt; numRecords; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "pixelSize", "pixelSize", "CDATA", "" + getuint8 (offset));
        at.addAttribute ("", "maxWidth", "maxWidth", "CDATA", "" + getuint8 (offset + 1));

        conf.ch.startElement ("deviceRecord", at); {
          for (int gid = 0; gid &lt; numGlyphs; gid++) {
            at = new AttributesImpl ();
            at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
            at.addAttribute ("", "v", "v", "CDATA", "" + getuint8 (offset + 2 + gid));
            conf.ch.element ("width", at); }
          conf.ch.endElement ("deviceRecord"); }

        offset += sizeDeviceRecord; }

      conf.ch.endElement ("hdmx"); }
  }
</code-fragment>
      </section>


      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Hdmx'>
  <code-title>Hdmx class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Hdmx extends Table {

  public Hdmx () {
    super (Tag.hdmx, null);
  }

  public Hdmx (Font font) {
    super (Tag.hdmx, font);
  }

  <code-include linkend='hdmx.methods'/>
}
</code-fragment>

      </section>
    </section>
  </section>


  <!--************************************************************************-->
  <section id='chapter.kern'>
    <title>kern - Kerning</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Note: Apple has extended the definition of the
	<ottable>kern</ottable> table to provide additional
	functionality. The Apple extensions are not supported on
	Windows. Fonts intended for cross-platform use or for the
	Windows platform in general should conform to the
	<ottable>kern</ottable> table format specified here.</para>

        <para>The kerning table contains the values that control the
        intercharacter spacing for the glyphs in a font. There is
        currently no system level support for kerning (other than
        returning the kern pairs and kern values). OpenType fonts
        containing CFF outlines are not supported by the
        <ottable>kern</ottable> table and must use the
        <ottable>GPOS</ottable> OpenType Layout table.</para>

        <para>Each subtable varies in format, and can contain
        information for vertical or horizontal text, and can contain
        kerning values or minimum values. Kerning values are used to
        adjust inter-character spacing, and minimum values are used to
        limit the amount of adjustment that the scaler applies by the
        combination of kerning and tracking. Because the adjustments
        are additive, the order of the subtables containing kerning
        values is not important. However, tables containing minimum
        values should usually be placed last, so that they can be used
        to limit the total effect of other subtables.</para>

        <para>The kerning table in the OpenType font file has a
        header, which contains the format number and the number of
        subtables present, and the subtables themselves.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Table version number (starts at
              0)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>nTables</otfieldname>
            <otfielddesc>Number of subtables in the kerning
              table.</otfielddesc>
          </otfield>
        </otformat>

        <para>Kerning subtables will share the same header format.
        This header is used to identify the format of the subtable and
        the kind of information it contains:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Kern subtable version number</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>length</otfieldname>
            <otfielddesc>Length of the subtable, in bytes (including
              this header). </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>coverage</otfieldname>
            <otfielddesc>What type of information is contained in this
              table.</otfielddesc>
          </otfield>
        </otformat>

        <para>The coverage field is divided into the following
        sub-fields, with sizes given in bits:</para>

        <otformat>
          <otfield>
            <otfieldoffs>horizontal</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>1</otfieldname>
            <otfielddesc>1 if table has horizontal data, 0 if
              vertical.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>minimum</otfieldoffs>
            <otfieldtype>1</otfieldtype>
            <otfieldname>1</otfieldname>
            <otfielddesc>If this bit is set to 1, the table has
              minimum values. If set to 0, the table has kerning
              values.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>cross-stream</otfieldoffs>
            <otfieldtype>2</otfieldtype>
            <otfieldname>1</otfieldname>
            <otfielddesc>
	      <para>If set to 1, kerning is perpendicular to the flow
		of the text.</para>

	      <para>If the text is normally written horizontally,
		kerning will be done in the up and down directions. If
		kerning values are positive, the text will be kerned
		upwards; if they are negative, the text will be kerned
		downwards.</para>

	      <para>If the text is normally written vertically,
		kerning will be done in the left and right
		directions. If kerning values are positive, the text
		will be kerned to the right; if they are negative, the
		text will be kerned to the left.</para> <para>The
		value 0x8000 in the kerning data resets the
		cross-stream kerning back to 0.</para>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>override</otfieldoffs>
            <otfieldtype>3</otfieldtype>
            <otfieldname>1</otfieldname>
            <otfielddesc>If this bit is set to 1 the value in this
              table should replace the value currently being
              accumulated.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>reserved1</otfieldoffs>
            <otfieldtype>4-7</otfieldtype>
            <otfieldname>4</otfieldname>
            <otfielddesc>Reserved. This should be set to
              zero.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>format</otfieldoffs>
            <otfieldtype>8-15</otfieldtype>
            <otfieldname>8</otfieldname>
            <otfielddesc>Format of the subtable. Only formats 0 and 2
              have been defined. Formats 1 and 3 through 255 are
              reserved for future use.</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
<!--
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>kern table</code-title>
  kern =
    element kern {
      attribute version { "0" },

      kernsubtable*
    }

  kernsubtable |=
    element kernsubtable {
      attribute version { "0" },
      attribute horizontalData { yesOrNo },
      attribute minimumValues {yesOrNo },
      attribute crossStream { yesOrNo },
      attribute override { yesOrNo },
      attribute format { "0" },

      element pair {
        attribute left { text },
        attribute right { text },
        attribute v { text }
      }*
    }

  kernsubtable !=
    element kernsubtable {
      attribute version { "0" },
      attribute horizontalData { yesOrNo },
      attribute minimumValues {yesOrNo },
      attribute crossStream { yesOrNo },
      attribute override { yesOrNo },
      attribute format { "2" },

      element pair {
        attribute left { text },
        attribute right { text },
        attribute v { text }
      }*
    }
</code-fragment>
-->
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 0</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This is the only format that will be properly
          interpreted by Windows and OS/2.</para>
        <para>This subtable is a sorted list of kerning pairs and
          values. The list is preceded by information which makes it
          possible to make an efficient binary search of the
          list:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>nPairs</otfieldname>
            <otfielddesc>This gives the number of kerning pairs in the
              table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>searchRange</otfieldname>
            <otfielddesc>The largest power of two less than or equal
              to the value of nPairs, multiplied by the size in bytes
              of an entry in the table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>entrySelector</otfieldname>
            <otfielddesc>This is calculated as log2 of the largest
              power of two less than or equal to the value of nPairs.
              This value indicates how many iterations of the search
              loop will have to be made. (For example, in a list of
              eight items, there would have to be three iterations of
              the loop).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rangeShift</otfieldname>
            <otfielddesc>The value of nPairs minus the largest power
              of two less than or equal to nPairs, and then multiplied
              by the size in bytes of an entry in the
              table.</otfielddesc>
          </otfield>
        </otformat>

        <para>This is followed by the list of kerning pairs and
          values. Each has the following format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>left</otfieldname>
            <otfielddesc>The glyph index for the left-hand glyph in
              the kerning pair.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>right</otfieldname>
            <otfielddesc>The glyph index for the right-hand glyph in
              the kerning pair. </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>FWORD</otfieldtype>
            <otfieldname>value</otfieldname>
            <otfielddesc>The kerning value for the above pair, in
              FUnits. If this value is greater than zero, the
              characters will be moved apart. If this value is less
              than zero, the character will be moved closer
              together.</otfielddesc>
          </otfield>
        </otformat>

	<para>The left and right halves of the kerning pair make an
	unsigned 32-bit number, which is then used to order the
	kerning pairs numerically.</para>

	<para>A binary search is most efficiently coded if the search
	range is a power of two. The search range can be reduced by
	half by shifting instead of dividing. In general, the number
	of kerning pairs, nPairs, will not be a power of two. The
	value of the search range, searchRange, should be the largest
	power of two less than or equal to nPairs. The number of pairs
	not covered by searchRange (that is, nPairs - searchRange) is
	the value rangeShift.</para>

        <para>Windows v3.1 does not make use of the
        <ottable>kern</ottable> data other than to expose it to
        applications through the GetFontData() API.Format 2 </para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Format 2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This subtable is a two-dimensional array of kerning
          values. The glyphs are mapped to classes, using a different
          mapping for left- and right-hand glyphs. This allows glyphs
          that have similar right- or left-side shapes to be handled
          together. Each similar right- or left-hand shape is said to
          be single class.</para>
        <para>Each row in the kerning array represents one left-hand
          glyph class, each column represents one right-hand glyph
          class, and each cell contains a kerning value. Row and
          column 0 always represent glyphs that do not kern and
          contain all zeros.</para>
        <para>The values in the right class table are stored
          pre-multiplied by the number of bytes in a single kerning
          value, and the values in the left class table are stored
          pre-multiplied by the number of bytes in one row. This
          eliminates needing to multiply the row and column values
          together to determine the location of the kerning value. The
          array can be indexed by doing the right- and left-hand class
          mappings, adding the class values to the address of the
          array, and fetching the kerning value to which the new
          address points.</para>
        <para>The header for the simple array has the following
          format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rowWidth</otfieldname>
            <otfielddesc>The width, in bytes, of a row in the
              table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>leftClassTable</otfieldname>
            <otfielddesc>Offset from beginning of this subtable to
              left-hand class table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>rightClassTable</otfieldname>
            <otfielddesc>Offset from beginning of this subtable to
              right-hand class table. </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>array</otfieldname>
            <otfielddesc>Offset from beginning of this subtable to the
              start of the kerning array. </otfielddesc>
          </otfield>
        </otformat>

        <para>Each class table has the following header:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>firstGlyph</otfieldname>
            <otfielddesc>First glyph in class range.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>nGlyphs</otfieldname>
            <otfielddesc>Number of glyph in class range.</otfielddesc>
          </otfield>
        </otformat>

        <para>This header is followed by nGlyphs number of class
          values, which are in USHORT format. Entries for glyphs that
          don't participate in kerning should point to the row or
          column at position zero.</para>

        <para>The array itself is a left by right array of kerning
          values, which are FWords, where left is the number of
          left-hand classes and R is the number of right-hand classes.
          The array is stored by row.</para>
        <para>Note that this format is the quickest to process since
          each lookup requires only a few index operations. The table
          can be quite large since it will contain the number of cells
          equal to the product of the number of right-hand classes and
          the number of left-hand classes, even though many of these
          classes do not kern with each other.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.LTSH'>
    <title>LTSH - Linear Threshold</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>LTSH</ottable> table relates to OpenType
        fonts containing TrueType outlines. There are noticeable
        improvements to fonts on the screen when instructions are
        carefully applied to the sidebearings. The gain in readability
        is offset by the necessity for the OS to grid fit the glyphs
        in order to find the actual advance width for the glyphs
        (since instructions may be moving the sidebearing points). The
        TrueType outline format already has two mechanisms to side
        step the speed issues: the <ottable>hdmx</ottable> table,
        where precomputed advance widths may be saved for selected
        ppem sizes, and the 'vdmx' table, where precomputed vertical
        advance widths may be saved for selected ppem sizes. The
        <ottable>LTSH</ottable> table (Linear ThreSHold) is a second,
        complementary method.</para>

        <para>The LTSH table defines the point at which it is
        reasonable to assume linearly scaled advance widths on a
        glyph-by-glyph basis. This table should not be included unless
        bit 4 of the "flags" field in the <ottable>head</ottable>
        table is set. The criteria for linear scaling is:</para>

        <itemizedlist>
          <listitem>
            <para>(ppem size is &gt;= 50) AND (difference between the
              rounded linear width and the rounded instructed width
              &lt;= 2% of the rounded linear width)</para>
          </listitem>
          <listitem>
            <para>Linear width == Instructed width</para>
          </listitem>
        </itemizedlist>

        <para>The LTSH table records the ppem for each glyph at which
          the scaling becomes linear again, despite instructions
          effecting the advance width. It is a requirement that, at
          and above the recorded threshold size, the glyph remain
          linear in its scaling (i.e., not legal to set threshold at
          55 ppem if glyph becomes nonlinear again at 90 ppem). The
          format for the table is:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Version number (starts at 0).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numGlyphs</otfieldname>
            <otfielddesc>Number of glyphs (from "numGlyphs" in <ottable>maxp</ottable>
              table).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>yPels [numGlyphs]</otfieldname>
            <otfielddesc>The vertical pel height at which the glyph
              can be assumed to scale linearly. On a per glyph
              basis.</otfielddesc>
          </otfield>
        </otformat>

        <para>Note that glyphs which do not have instructions on their
          sidebearings should have yPels = 1; i.e., always scales
          linearly.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.PCLT'>
    <title>PCLT - PCL 5 Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>PCLT</ottable> table is strongly
          discouraged for OpenType fonts with TrueType outlines. Extra
          information on many of these fields can be found in the HP
          PCL 5 Printer Language Technical Reference Manual available
          from Hewlett-Packard Boise Printer Division.</para>
          <para>The format for the table is:</para>

        <informaltable>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Offset</entry>
                <entry>Type</entry>
                <entry>Name of Entry</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>FIXED</entry>
                <entry>Version</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>ULONG</entry>
                <entry>FontNumber</entry>
              </row>
              <row>
                <entry>6</entry>
               <entry>USHORT</entry>
                <entry>Pitch</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>USHORT</entry>
                <entry>xHeight</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>USHORT</entry>
                <entry>Style</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>USHORT</entry>
                <entry>TypeFamily</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>USHORT</entry>
                <entry>CapHeight</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>USHORT</entry>
                <entry>SymbolSet</entry>
              </row>
              <row>
                <entry>18</entry>
                <entry>CHAR</entry>
                <entry>Typeface[16]</entry>
              </row>
              <row>
                <entry>34</entry>
                <entry>CHAR</entry>
                <entry>CharacterComplement[8]</entry>
              </row>
              <row>
                <entry>42</entry>
                <entry>CHAR</entry>
                <entry>FileName[6]</entry>
              </row>
              <row>
                <entry>48</entry>
                <entry>CHAR</entry>
                <entry>StrokeWeight</entry>
              </row>
              <row>
                <entry>49</entry>
                <entry>CHAR</entry>
                <entry>WidthType</entry>
              </row>
              <row>
                <entry>50</entry>
                <entry>BYTE</entry>
                <entry>SerifStyle</entry>
              </row>
              <row>
                <entry>51</entry>
                <entry>BYTE</entry>
                <entry>Reserved (pad)</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <bridgehead>Version</bridgehead>

        <para>Table version number 1.0 is represented as
          0x00010000.</para>

        <bridgehead>FontNumber</bridgehead>

        <para>This 32-bit number is segmented in two parts. The most
          significant bit indicates native versus converted format.
          Only font vendors should create fonts with this bit zeroed.
          The 7 next most significant bits are assigned by
          Hewlett-Packard Boise Printer Division to major font
          vendors. The least significant 24 bits are assigned by the
          vendor. Font vendors should attempt to insure that each of
          their fonts are marked with unique values.</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Code</entry>
                <entry>Vendor</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>A</entry>
                <entry>Adobe Systems</entry>
              </row>
              <row>
                <entry>B</entry>
                <entry>Bitstream Inc.</entry>
              </row>
              <row>
                <entry>C</entry>
                <entry>Agfa Corporation</entry>
              </row>
              <row>
                <entry>H</entry>
                <entry>Bigelow &amp; Holmes</entry>
              </row>
              <row>
                <entry>L</entry>
                <entry>Linotype Company</entry>
              </row>
              <row>
                <entry>M</entry>
                <entry>Monotype Typography Ltd.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <bridgehead>Pitch</bridgehead>

        <para>The width of the space in FUnits (FUnits are described
          by the unitsPerEm field of the <ottable>head</ottable> table). Monospace
          fonts derive the width of all characters from this
          field.</para>


        <bridgehead>xHeight</bridgehead>

        <para>The height of the optical line describing the height of
          the lowercase x in FUnits. This might not be the same as the
          measured height of the lowercase x.</para>


        <bridgehead>Style</bridgehead>

        <para>The most significant 6 bits are reserved. The 5 next
          most significant bits encode structure. The next 3 most
          significant bits encode appearance width. The 2 least
          significant bits encode posture.</para>

        <table>
          <title>Structure (bits 5-9)</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Solid (normal, black)</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Outline (hollow)</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Inline (incised, engraved)</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Contour, edged (antique, distressed)</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Solid with shadow</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Outline with shadow</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Inline with shadow</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Contour, or edged, with shadow</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Pattern filled</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Pattern filled #1 (when more than one
                  pattern)</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Pattern filled #2 (when more than two
                  patterns)</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>Pattern filled #3 (when more than three
                  patterns)</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>Pattern filled with shadow</entry>
              </row>
              <row>
                <entry>13</entry>
                <entry>Pattern filled with shadow #1 (when more than
                  one pattern or shadow)</entry>
              </row>
              <row>
                <entry>14</entry>
                <entry>Pattern filled with shadow #2 (when more than
                  two patterns or shadows)</entry>
              </row>
              <row>
                <entry>15</entry>
                <entry>Pattern filled with shadow #3 (when more than
                  three patterns or shadows)</entry>
              </row>
              <row>
                <entry>16</entry>
                <entry>Inverse</entry>
              </row>
              <row>
                <entry>17</entry>
                <entry>Inverse with border</entry>
              </row>
              <row>
                <entry>18-31</entry>
                <entry>reserved</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Width (bits 2-4)</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>normal</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>condensed</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>compressed, extra condensed</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>extra compressed</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>ultra compressed</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>reserved</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>expanded, extended</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>extra expanded, extra extended</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Posture (bits 0-1)</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>upright</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>oblique, italic</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>alternate italic (backslanted, cursive,
                  swash)</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>reserved</entry>
              </row>
            </tbody>
          </tgroup>
        </table>




        <bridgehead>TypeFamily</bridgehead>

        <para>The 4 most significant bits are font vendor codes. The
          12 least significant bits are typeface family codes. Both
          are assigned by HP Boise Division. </para>

        <table>
          <title>Vendor Codes (bits 12-15)</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>reserved</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Agfa Corporation</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Bitstream Inc.</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Linotype Company</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Monotype Typography Ltd.</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Adobe Systems</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>font repackagers</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>vendors of unique typefaces</entry>
              </row>
              <row>
                <entry>8-15</entry>
                <entry>reserved</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <bridgehead>CapHeight</bridgehead>

        <para>The height of the optical line describing the top of the
          uppercase H in FUnits. This might not be the same as the
          measured height of the uppercase H. </para>


        <bridgehead>SymbolSet</bridgehead>

        <para>The most significant 11 bits are the value of the symbol
          set "number" field. The value of the least significant 5
          bits, when added to 64, is the ASCII value of the symbol set
          "ID" field. Symbol set values are assigned by HP Boise
          Division. Unbound fonts, or "typefaces" should have a symbol
          set value of 0. See the PCL 5 Printer Language Technical
          Reference Manual or the PCL 5 Comparison Guide for the most
          recent published list of codes. </para>


        <table>
          <title>Examples</title>
          <tgroup cols='3'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry></entry>
                <entry>PCL</entry>
                <entry>decimal</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Windows 3.1 "ANSI"</entry>
                <entry>19U</entry>
                <entry>629</entry>
              </row>
              <row>
                <entry>Windows 3.0 "ANSI"</entry>
                <entry>9U</entry>
                <entry>309</entry>
              </row>
              <row>
                <entry>Adobe "Symbol"</entry>
                <entry>19M</entry>
                <entry>621</entry>
              </row>
              <row>
                <entry>Macintosh</entry>
                <entry>12J</entry>
                <entry>394</entry>
              </row>
              <row>
                <entry>PostScript ISO Latin 1</entry>
                <entry>11J</entry>
                <entry>362</entry>
              </row>
              <row>
                <entry>PostScript Std. Encoding</entry>
                <entry>10J</entry>
                <entry>330</entry>
              </row>
              <row>
                <entry>Code Page 1004</entry>
                <entry>9J</entry>
                <entry>298</entry>
              </row>
              <row>
                <entry>DeskTop</entry>
                <entry>7J</entry>
                <entry>234</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <bridgehead>TypeFace</bridgehead>

        <para>This 16-byte ASCII string appears in the "font print" of
          PCL printers. Care should be taken to insure that the base
          string for all typefaces of a family are consistent, and
          that the designators for bold, italic, etc. are
          standardized. </para>

        <table>
          <title>Example</title>
          <tgroup cols='1'>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>Times New</entry>
              </row>
              <row>
                <entry>Times New  Bd</entry>
              </row>
              <row>
                <entry>Times New  It</entry>
              </row>
              <row>
                <entry>Times New  BdIt</entry>
              </row>
              <row>
                <entry>Courier New</entry>
              </row>
              <row>
                <entry>Courier New  Bd</entry>
              </row>
              <row>
                <entry>Courier New  It</entry>
              </row>
              <row>
                <entry>Courier New  BdIt</entry>
              </row>
            </tbody>
          </tgroup>
        </table>



        <bridgehead>CharacterComplement</bridgehead>

        <para>This 8-byte field identifies the symbol collections
          provided by the font, each bit identifies a symbol
          collection and is independently interpreted. Symbol set
          bound fonts should have this field set to all F's (except
          bit 0). </para>


        <table>
          <title>Example</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>DOS/PCL Complement</entry>
                <entry>0xFFFFFFFF003FFFFE</entry>
              </row>
              <row>
                <entry>Windows 3.1 "ANSI"</entry>
                <entry>0xFFFFFFFF37FFFFFE</entry>
              </row>
              <row>
                <entry>Macintosh</entry>
                <entry>0xFFFFFFFF36FFFFFE</entry>
              </row>
              <row>
                <entry>ISO 8859-1 Latin 1</entry>
                <entry>0xFFFFFFFF3BFFFFFE</entry>
              </row>
              <row>
                <entry>ISO 8859-1,2,9 Latin 1,2,5</entry>
                <entry>0xFFFFFFFF0BFFFFFE</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The character collections identified by each bit are as
          follows:</para>


        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>31</entry>
                <entry>ASCII (supports several standard
                  interpretations)</entry>
              </row>
              <row>
                <entry>30</entry>
                <entry>Latin 1 extensions</entry>
              </row>
              <row>
                <entry>29</entry>
                <entry>Latin 2 extensions</entry>
              </row>
              <row>
                <entry>28</entry>
                <entry>Latin 5 extensions</entry>
              </row>
              <row>
                <entry>27</entry>
                <entry>Desktop Publishing Extensions</entry>
              </row>
              <row>
                <entry>26</entry>
                <entry>Accent Extensions (East and West
                  Europe)</entry>
              </row>
              <row>
                <entry>25</entry>
                <entry>PCL Extensions</entry>
              </row>
              <row>
                <entry>24</entry>
                <entry>Macintosh Extensions</entry>
              </row>
              <row>
                <entry>23</entry>
                <entry>PostScript Extensions</entry>
              </row>
              <row>
                <entry>22</entry>
                <entry>Code Page Extensions</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The character complement field also indicates the index
          mechanism used with an unbound font. Bit 0 must always be
          cleared when the font elements are provided in Unicode
          order.</para>


        <bridgehead>FileName</bridgehead>

        <para>This 6-byte field is composed of 3 parts. The first 3
          bytes are an industry standard typeface family string. The
          fourth byte is a treatment character, such as R, B, I. The
          last two characters are either zeroes for an unbound font or
          a two character mnemonic for a symbol set if symbol set
          found. </para>

        <table>
          <title>Examples</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>TNRR00</entry>
                <entry>Times New (text weight, upright)</entry>
              </row>
              <row>
                <entry>TNRI00</entry>
                <entry>Times New Italic</entry>
              </row>
              <row>
                <entry>TNRB00</entry>
                <entry>Times New Bold</entry>
              </row>
              <row>
                <entry>TNRJ00</entry>
                <entry>Times New Bold Italic</entry>
              </row>
              <row>
                <entry>COUR00</entry>
                <entry>Courier</entry>
              </row>
              <row>
                <entry>COUI00</entry>
                <entry>Courier Italic</entry>
              </row>
              <row>
                <entry>COUB00</entry>
                <entry>Courier Bold</entry>
              </row>
              <row>
                <entry>COUJ00</entry>
                <entry>Courier Bold Italic</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Treatment Flags</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>R</entry>
                <entry>Text, normal, book, etc.</entry>
              </row>
              <row>
                <entry>I</entry>
                <entry>Italic, oblique, slanted, etc.</entry>
              </row>
              <row>
                <entry>B</entry>
                <entry>Bold</entry>
              </row>
              <row>
                <entry>J</entry>
                <entry>Bold Italic, Bold Oblique</entry>
              </row>
              <row>
                <entry>D</entry>
                <entry>Demibold</entry>
              </row>
              <row>
                <entry>E</entry>
                <entry>Demibold Italic, Demibold Oblique</entry>
              </row>
              <row>
                <entry>K</entry>
                <entry>Black</entry>
              </row>
              <row>
                <entry>G</entry>
                <entry>Black Italic, Black Oblique</entry>
              </row>
              <row>
                <entry>L</entry>
                <entry>Light</entry>
              </row>
              <row>
                <entry>P</entry>
                <entry>Light Italic, Light Oblique</entry>
              </row>
              <row>
                <entry>C</entry>
                <entry>Condensed</entry>
              </row>
              <row>
                <entry>A</entry>
                <entry>Condensed Italic, Condensed Oblique</entry>
              </row>
              <row>
                <entry>F</entry>
                <entry>Bold Condensed</entry>
              </row>
              <row>
                <entry>H</entry>
                <entry>Bold Condensed Italic, Bold Condensed
                  Oblique</entry>
              </row>
              <row>
                <entry>S</entry>
                <entry>Semibold (lighter than demibold)</entry>
              </row>
              <row>
                <entry>T</entry>
                <entry>Semibold Italic, Semibold Oblique</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>other treatment flags are assigned over time.</para>


        <bridgehead>StrokeWeight</bridgehead>

        <para>This signed 1-byte field contains the PCL stroke weight
          value. Only values in the range -7 to 7 are valid:</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>-7</entry>
                <entry>Ultra Thin</entry>
              </row>
              <row>
                <entry>-6</entry>
                <entry>Extra Thin</entry>
              </row>
              <row>
                <entry>-5</entry>
                <entry> Thin</entry>
              </row>
              <row>
                <entry>-4</entry>
                <entry>Extra Light</entry>
              </row>
              <row>
                <entry>-3</entry>
                <entry>Light</entry>
              </row>
              <row>
                <entry>-2</entry>
                <entry>Demilight</entry>
              </row>
              <row>
                <entry>-1</entry>
                <entry>Semilight</entry>
              </row>
              <row>
                <entry>0</entry>
                <entry>Book, text, regular, etc.</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Semibold (Medium, when darker than
                  Book)</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Demibold</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Bold</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Extra Bold</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Black</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Extra Black</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Ultra Black, or Ultra</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Type designers often use interesting names for weights
          or combinations of weights and styles, such as Heavy,
          Compact, Inserat, Bold No. 2, etc. PCL stroke weights are
          assigned on the basis of the entire family and use of the
          faces. Typically, display faces don't have a "text" weight
          assignment.</para>


        <bridgehead>WidthType</bridgehead>

        <para>This signed 1-byte field contains the PCL appearance
          width value. The values are not directly related to those in
          the appearance with field of the style word above. Only
          values in the range -5 to 5 are valid. </para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>-5</entry>
                <entry>Ultra Compressed</entry>
              </row>
              <row>
                <entry>-4</entry>
                <entry>Extra Compressed</entry>
              </row>
              <row>
                <entry>-3</entry>
                <entry>Compressed, or Extra Condensed</entry>
              </row>
              <row>
                <entry>-2</entry>
                <entry>Condensed</entry>
              </row>
              <row>
                <entry>0</entry>
                <entry>Normal</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Expanded</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Extra Expanded</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <bridgehead>SerifStyle</bridgehead>

        <para>This signed 1-byte field contains the PCL serif style
          value. The most significant 2 bits of this byte specify the
          serif/sans or contrast/monoline characterisitics of the
          typeface.</para>

        <table>
          <title>Bottom 6 bit values:</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>Sans Serif Square</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Sans Serif Round</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Serif Line</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>Serif Triangle</entry>
              </row>
              <row>
                <entry>4</entry>
                <entry>Serif Swath</entry>
              </row>
              <row>
                <entry>5</entry>
                <entry>Serif Block</entry>
              </row>
              <row>
                <entry>6</entry>
                <entry>Serif Bracket</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Rounded Bracket</entry>
              </row>
              <row>
                <entry>8</entry>
                <entry>Flair Serif, Modified Sans</entry>
              </row>
              <row>
                <entry>9</entry>
                <entry>Script Nonconnecting</entry>
              </row>
              <row>
                <entry>10</entry>
                <entry>Script Joining</entry>
              </row>
              <row>
                <entry>11</entry>
                <entry>Script Calligraphic</entry>
              </row>
              <row>
                <entry>12</entry>
                <entry>Script Broken Letter</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
          <title>Top 2 bit values:</title>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>reserved</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Sans Serif/Monoline</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>Serif/Contrasting</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>reserved</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <bridgehead>Reserved</bridgehead>

        <para>Should be set to zero.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.VDMX'>
    <title>Vertical Device Metrics</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The VDMX table relates to OpenType fonts with TrueType
        outlines. Under Windows, the usWinAscent and usWinDescent
        values from the <ottable>OS/2</ottable> table will be used to
        determine the maximum black height for a font at any given
        size. Windows calls this distance the Font Height. Because
        TrueType instructions can lead to Font Heights that differ
        from the actual scaled and rounded values, basing the Font
        Height strictly on the yMax and yMin can result in "lost
        pixels."  Windows will clip any pixels that extend above the
        yMax or below the yMin. In order to avoid grid fitting the
        entire font to determine the correct height, the VDMX table
        has been defined.</para>

        <para>The VDMX table consists of a header followed by
          groupings of VDMX records:</para>

        <otformat>
	  <title>VDMX Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Version number (0 or 1).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numRecs</otfieldname>
            <otfielddesc>Number of VDMX groups present</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numRatios</otfieldname>
            <otfielddesc>Number of aspect ratio
              groupings</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Ratio</otfieldtype>
            <otfieldname>ratRange [numRatios]</otfieldname>
            <otfielddesc>Ratio ranges (see below for more
              info)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>offset [numRatios]</otfieldname>
            <otfielddesc>Offset from start of this table to the VDMX
              group for this ratio range.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>?</otfieldoffs>
            <otfieldtype>Vdmx</otfieldtype>
            <otfieldname>groups</otfieldname>
            <otfielddesc>The actual VDMX groupings (documented below)
                </otfielddesc>
          </otfield>
        </otformat>

	<otformat>
	  <title>Ratio Record</title>
	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>bCharSet</otfieldname>
	    <otfielddesc>Character set (see below)</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>1</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>xRatio</otfieldname>
	    <otfielddesc>Value to use for x-Ratio</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>2</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>yStartRatio</otfieldname>
	    <otfielddesc>Starting y-Ratio value</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>3</otfieldoffs>
	    <otfieldtype>BYTE</otfieldtype>
	    <otfieldname>yEndRatio</otfieldname>
	    <otfielddesc>Ending y-ratio value</otfielddesc>
	  </otfield>
	</otformat>

	<para>Ratios are set up as follows:</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <tbody>
              <row>
                <entry>For a 1:1 aspect ratio</entry>
                <entry>Ratios.xRatio = 1; Ratios.yStartRatio = 1;
                  Ratios.yEndRatio = 1;</entry>
              </row>
              <row>
                <entry>For 1:1 through 2:1 ratio</entry>
                <entry>Ratios.xRatio = 2; Ratios.yStartRatio = 1;
                  Ratios.yEndRatio = 2;</entry>
              </row>
              <row>
                <entry>For 1.33:1 ratio</entry>
                <entry>Ratios.xRatio = 4; Ratios.yStartRatio = 3;
                  Ratios.yEndRatio = 3;</entry>
              </row>
              <row>
                <entry>For all aspect ratios</entry>
                <entry>Ratio.xRatio = 0; Ratio.yStartRatio = 0;
                  Ratio.yEndRatio = 0;</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>All values set to zero signal the default grouping to
          use; if present, this must be the last Ratio group in the
          table. Ratios of 2:2 are the same as 1:1.</para>

        <para>Aspect ratios are matched against the target device by
          normalizing the entire ratio range record based on the
          current X resolution and performing a range check of Y
          resolutions for each record after normalization. Once a
          match is found, the search stops. If the 0,0,0 group is
          encountered during the search, it is used (therefore if this
          group is not at the end of the ratio groupings, no group
          that follows it will be used). If there is not a match and
          there is no 0,0,0 record, then there is no VDMX data for
          that aspect ratio.</para>

        <para>Note that range checks are conceptually performed as
        follows:</para>

        <para>(deviceXRatio == Ratio.xRatio) &amp;&amp; (deviceYRatio
          >= Ratio.yStartRatio) &amp;&amp; (deviceYRatio &lt;=
          Ratio.yEndRatio)</para>

        <para>Each ratio grouping refers to a specific VDMX record
          group; there must be at least 1 VDMX group in the
          table.</para>

        <para>The bCharSet value is used to denote cases where the
          VDMX group was computed based on a subset of the glyphs
          present in the font file. The semantics of bCharSet is
	  different based on the version of the VDMX table. It is
	  recommended that VDMX version 1 be used. The currently
	  defined values for character set are:</para>

        <table>
	  <title>Character Set Values &#x2019; Version 0</title>
          <tgroup cols="2">
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>No subset; the VDMX group applies to all glyphs
                  in the font. This is used for symbol or dingbat
                  fonts.</entry>
              </row>
              <row>
                <entry>1</entry>
                <entry>Windows ANSI subset; the VDMX group was
                  computed using only the glyphs required to complete
                  the Windows ANSI character set. Windows will ignore
                  any VDMX entries that are not for the ANSI subset
                  (i.e. ANSI_CHARSET)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table>
	  <title>Character Set Values &#x2019; Version 1</title>
          <tgroup cols="2">
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0</entry>
                <entry>No subset; the VDMX group applies to all glyphs
                  in the font. If adding new character sets to
		  existing font, add this flag and the groups necessary
		  to support it. This should only be used in conjunction
		  with ANSI_CHARSET.</entry>
	      </row>
              <row>
                <entry>1</entry>
                <entry>No subset; the VDMX group applies to all glyphs
                in the font. Used when creating a new font for
                Windows. No need to support SYMBOL_CHARSET.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <para>VDMX groups immediately follow the table header. Each
          set of records (there need only be one set) has the
          following layout:</para>

        <otformat>
	  <title>VDMX Group</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>recs</otfieldname>
            <otfielddesc>Number of height records in this
              group</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>startsz</otfieldname>
            <otfielddesc>Starting yPelHeight</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>3</otfieldoffs>
            <otfieldtype>BYTE</otfieldtype>
            <otfieldname>endsz</otfieldname>
            <otfielddesc>Ending yPelHeight</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>vTable</otfieldtype>
            <otfieldname>entry [recs]</otfieldname>
            <otfielddesc>The VDMX records</otfielddesc>
          </otfield>
        </otformat>

	<otformat>
	  <title>vTable Record</title>
	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>USHORT</otfieldtype>
	    <otfieldname>yPelHeight</otfieldname>
	    <otfielddesc>yPelHeight to which values apply</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>2</otfieldoffs>
	    <otfieldtype>SHORT</otfieldtype>
	    <otfieldname>yMax</otfieldname>
	    <otfielddesc>Maximum value (in pels) for this yPelHeight</otfielddesc>
	  </otfield>
	  <otfield>
	    <otfieldoffs>4</otfieldoffs>
	    <otfieldtype>SHORT</otfieldtype>
	    <otfieldname>yMin</otfieldname>
	    <otfielddesc>Minimum value (in pels) for this yPelHeight</otfielddesc>
	  </otfield>
	</otformat>

        <para>This table must appear in sorted order (sorted by
          yPelHeight), but need not be continous. It should have an
          entry for every pel height where the yMax and yMin do not
          scale linearly, where linearly scaled heights are defined
          as:</para>
        <para>Hinted yMax and yMin are identical to scaled/rounded
          yMax and yMin</para>
        <para>It is assumed that once yPelHeight reaches 255, all
          heights will be linear, or at least close enough to linear
          that it no longer matters. Please note that while the Ratios
          structure can only support ppem sizes up to 255, the vTable
          structure can support much larger pel heights (up to 65535).
          The choice of SHORT and USHORT for vTable is dictated by the
          requirement that yMax and yMin be signed values (and 127 to
          -128 is too small a range) and the desire to word-align the
          vTable elements.</para>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
VDMX =
  element VDMX {
    attribute version { text },
    element ratio {
      attribute bCharSet { text },
      attribute xRatio  { text },
      attribute yStartRatio { text },
      attribute yEndRatio { text },
      attribute groupIndex { text }}*,

    element group {
      attribute groupIndex { text },
      attribute startsz { text },
      attribute endsz { text },
      element rec {
        attribute yPelHeight { text },
        attribute yMax { text },
        attribute yMin { text }}* }*
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='vdmx.methods'>
  public void fromXML (Element vdmx)
    throws InvalidFontException, UnsupportedFontException {

    throw new UnsupportedFontException ("compilation of VDMX tables not supported");  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='vdmx.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at = new AttributesImpl ();
    at.addAttribute ("", "version", "version", "CDATA", "" + getuint16 (0));

    conf.ch.startElement ("VDMX", at); {
      int offset;

      int numRecs = getuint16 (2);
      int numRatios = getuint16 (4);

      for (int i = 0; i &lt; numRatios; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "bCharSet", "bCharSet", "CDATA", "" + getuint8 (6 + i*4));
        at.addAttribute ("", "xRatio", "xRatio", "CDATA", "" + getuint8 (6 + i*4 + 1));
        at.addAttribute ("", "yStartRatio", "yStartRatio", "CDATA", "" + getuint8 (6 + i*4 + 2));
        at.addAttribute ("", "yEndRatio", "yEndRatio", "CDATA", "" + getuint8 (6 + i*4 + 3));
        at.addAttribute ("", "groupIndex", "groupIndex", "CDATA", "" + getuint16 (6 + numRatios*4 + 2*i));
        conf.ch.element ("ratio", at); }

      offset = 6 + numRatios * (4 + 2);

      for (int i = 0; i &lt; numRecs; i++) {
        int nbRecs = getuint16 (offset);
        at = new AttributesImpl ();
        at.addAttribute ("", "groupIndex", "groupIndex", "CDATA", "" + offset);
        at.addAttribute ("", "startsz", "startsz", "CDATA", "" + getuint8 (offset + 2));
        at.addAttribute ("", "endsz", "endsz", "CDATA", "" + getuint8 (offset + 3));

        conf.ch.startElement ("group", at); {
          offset += 4;
          for (int j = 0; j &lt; nbRecs; j++) {
            at = new AttributesImpl ();
            at.addAttribute ("", "yPelHeight", "yPelHeight", "CDATA", "" + getuint16 (offset));
            at.addAttribute ("", "yMax", "yMax", "CDATA", "" + getint16 (offset + 2));
            at.addAttribute ("", "yMin", "yMin", "CDATA", "" + getint16 (offset + 4));
            conf.ch.element ("rec", at);
            offset += 6; }
          conf.ch.endElement ("group"); }}

      conf.ch.endElement ("VDMX"); }
  }
</code-fragment>
      </section>


      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Vdmx'>
  <code-title>Vdmx class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Vdmx extends Table {

  public Vdmx () {
    super (Tag.VDMX, null);
  }

  public Vdmx (Font font) {
    super (Tag.VDMX, font);
  }

  <code-include linkend='vdmx.methods'/>
}
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.vhea'>
    <title>vhea - Vertical Header Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The vertical header table (tag name:
        <ottable>vhea</ottable>) contains information needed for
        vertical fonts. The glyphs of vertical fonts are written
        either top to bottom or bottom to top. This table contains
        information that is general to the font as a
        whole. Information that pertains to specific glyphs is given
        in the vertical metrics table (tag name:
        <ottable>vmtx</ottable>) described separately. The formats of
        these tables are similar to those for horizontal metrics (hhea
        and hmtx).</para>

        <para>Data in the vertical header table must be consistent
          with data that appears in the vertical metrics table. The
          advance height and top sidebearing values in the vertical
          metrics table must correspond with the maximum advance
          height and minimum bottom sidebearing values in the vertical
          header table.</para>

        <para>See the section "OpenType CJK Font Guidelines" for more
          information about constructing CJK (Chinese, Japanese, and
          Korean) fonts.</para>

	<para>The difference between version 1.0 and version 1.1 is
	  the name and definition of: <itemizedlist>
	    <listitem>
	      <para>ascender becomes vertTypoAscender</para>
	    </listitem>
	    <listitem>
	      <para>descender becomes vertTypoDescender</para>
	    </listitem>
	    <listitem>
	      <para>lineGap becomes vertTypoLineGap</para>
	    </listitem>
	  </itemizedlist></para>

        <para>The vertical header table format follows: Vertical
          Header Table</para>

        <otformat>
	  <title>Version 1.0</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Version number of the vertical header table;
              0x0001000 for version 1.0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>ascent</otfieldname>
            <otfielddesc>Distance in FUnits from the centerline to the
	      previous line&#x2019; descent.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>descent</otfieldname>
            <otfielddesc>Distance in FUnits from the centerline to
	      the next line&#x2019;s ascent.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>lineGap</otfieldname>
            <otfielddesc>Reserved; set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>advanceHeightMax</otfieldname>
            <otfielddesc>The maximum advance height measurement
	      &#x2014; in FUnits &#x2014; found in the font. This value
	      must be consistent with the entries in the vertical metrics
              table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>minTop</otfieldname>
            <otfielddesc>The minimum top sidebearing measurement found
              in the font, in FUnits. This value must be consistent
              with the entries in the vertical metrics
              table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>minBottom</otfieldname>
            <otfielddesc>The minimum bottom sidebearing measurement
              found in the font, in FUnits. This value must be
              consistent with the entries in the vertical metrics
              table. </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMaxExtent</otfieldname>
            <otfielddesc>Defined as yMaxExtent=minTopSideBearing +
              (yMax - yMin)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretSlopeRise</otfieldname>
            <otfielddesc>The value of the caretSlopeRise field divided
              by the value of the caretSlopeRun Field determines the
              slope of the caret. A value of 0 for the rise and a
              value of 1 for the run specifies a horizontal caret. A
              value of 1 for the rise and a value of 0 for the run
              specifies a vertical caret. Intermediate values are
              desirable for fonts whose glyphs are oblique or italic.
              For a vertical font, a horizontal caret is
              best.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretSlopeRun</otfieldname>
            <otfielddesc>See the caretSlopeRise field. Value=1 for
              nonslanted vertical fonts.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretOffset</otfieldname>
            <otfielddesc>The amount by which the highlight on a
              slanted glyph needs to be shifted away from the glyph in
              order to produce the best appearance. Set value equal to
              0 for nonslanted fonts.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>metricDataFormat</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>34</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numOfLongVerMetrics</otfieldname>
            <otfielddesc>Number of advance heights in the vertical
              metrics table.</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
	  <title>Version 1.1</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Version number of the vertical header table;
              0x00011000 for version 1.1. Note the representation of a
              non-zero fractional part, in Fixed
              numbers.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>vertTypoAscender</otfieldname>
            <otfielddesc>The vertical typographic ascender for this
              font. It is the distance in FUnits from the ideographic
              em-box center baseline for the vertical axis to the
              right of the ideographic em-box and is usually set to
              (head.unitsPerEm)/2. For example, a font with an em of
              1000 fUnits will set this field to 500. See the baseline
              section of the OpenType Tag Registry for a description
              of the ideographic em-box. </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>vertTypoDescender</otfieldname>
            <otfielddesc>The vertical typographic descender for this
              font. It is the distance in FUnits from the ideographic
              em-box center baseline for the horizontal axis to the
              left of the ideographic em-box and is usually set to
              (head.unitsPerEm)/2. For example, a font with an em of
              1000 fUnits will set this field to 500.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>vertTypoLineGap</otfieldname>
            <otfielddesc>The vertical typographic gap for this font.
              An application can determine the recommended line
              spacing for single spaced vertical text for an OpenType
              font by the following expression: ideo embox width +
              vhea.vertTypoLineGap </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>advanceHeightMax</otfieldname>
            <otfielddesc>The maximum advance height measurement -in
              FUnits found in the font. This value must be consistent
              with the entries in the vertical metrics
              table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>minTopSideBearing</otfieldname>
            <otfielddesc>The minimum top sidebearing measurement found
              in the font, in FUnits. This value must be consistent
              with the entries in the vertical metrics
              table.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>minBottomSideBearing</otfieldname>
            <otfielddesc>The minimum bottom sidebearing measurement
              found in the font, in FUnits. This value must be
              consistent with the entries in the vertical metrics
              table. </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMaxExtent</otfieldname>
            <otfielddesc>Defined as yMaxExtent=minTopSideBearing +
              (yMax - yMin)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretSlopeRise</otfieldname>
            <otfielddesc>The value of the caretSlopeRise field divided
              by the value of the caretSlopeRun Field determines the
              slope of the caret. A value of 0 for the rise and a
              value of 1 for the run specifies a horizontal caret. A
              value of 1 for the rise and a value of 0 for the run
              specifies a vertical caret. Intermediate values are
              desirable for fonts whose glyphs are oblique or italic.
              For a vertical font, a horizontal caret is
              best.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretSlopeRun</otfieldname>
            <otfielddesc>See the caretSlopeRise field. Value=1 for
              nonslanted vertical fonts.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>caretOffset</otfieldname>
            <otfielddesc>The amount by which the highlight on a
              slanted glyph needs to be shifted away from the glyph in
              order to produce the best appearance. Set value equal to
              0 for nonslanted fonts.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>metricDataFormat</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>34</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numOfLongVerMetrics</otfieldname>
            <otfielddesc>Number of advance heights in the vertical
              metrics table.</otfielddesc>
          </otfield>
        </otformat>

        <para>Vertical Header Table Example</para>

        <otformat>
          <otfield>
            <otfieldoffs>0/4</otfieldoffs>
            <otfieldtype>0x00011000</otfieldtype>
            <otfieldname>version</otfieldname>
            <otfielddesc>Version number of the vertical header table,
              in fixed-point format, is 1.1 </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4/2</otfieldoffs>
            <otfieldtype>1024</otfieldtype>
            <otfieldname>vertTypoAscender</otfieldname>
            <otfielddesc>Half the em-square height.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6/2</otfieldoffs>
            <otfieldtype>-1024</otfieldtype>
            <otfieldname>vertTypoDescender</otfieldname>
            <otfielddesc>Minus half the em-square
              height.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>vertTypoLineGap</otfieldname>
            <otfielddesc>Typographic line gap is 0
              FUnits.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10/2</otfieldoffs>
            <otfieldtype>2079</otfieldtype>
            <otfieldname>advanceHeightMax</otfieldname>
            <otfielddesc>The maximum advance height measurement found
              in the font is 2079 FUnits.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12/2</otfieldoffs>
            <otfieldtype>-342</otfieldtype>
            <otfieldname>minTopSideBearing</otfieldname>
            <otfielddesc>The minimum top sidebearing measurement found
              in the font is -342 FUnits.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>14/2</otfieldoffs>
            <otfieldtype>-333</otfieldtype>
            <otfieldname>minBottomSideBearing</otfieldname>
            <otfielddesc>The minimum bottom sidebearing measurement
              found in the font is -333 FUnits.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16/2</otfieldoffs>
            <otfieldtype>2036</otfieldtype>
            <otfieldname>yMaxExtent</otfieldname>
            <otfielddesc>minTopSideBearing +
              (yMax-yMin)=2036.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>18/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>caretSlopeRise</otfieldname>
            <otfielddesc>The caret slope rise of 0 and a caret slope
              run of 1 indicate a horizontal caret for a vertical
              font.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20/2</otfieldoffs>
            <otfieldtype>1</otfieldtype>
            <otfieldname>caretSlopeRun</otfieldname>
            <otfielddesc>The caret slope rise of 0 and a caret slope
              run of 1 indicate a horizontal caret for a vertical
              font.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>caretOffset</otfieldname>
            <otfielddesc>Value set to 0 for nonslanted
              fonts.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24/4</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>26/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>28/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>30/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>reserved</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32/2</otfieldoffs>
            <otfieldtype>0</otfieldtype>
            <otfieldname>metricDataFormat</otfieldname>
            <otfielddesc>Set to 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>34/2</otfieldoffs>
            <otfieldtype>258</otfieldtype>
            <otfieldname>numOfLongVerMetrics</otfieldname>
            <otfielddesc>Number of advance heights in the vertical
              metrics table is 258.</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
vhea =
  element vhea {
    attribute major { text },
    attribute minor { text },
    element typo {
      attribute ascender  { text },
      attribute descender { text },
      attribute lineGap   { text }
    },
    element advanceHeightMax {
      attribute v { text }
    },
    element minTopSideBearing {
      attribute v { text }
    },
    element minBottomSideBearing {
      attribute v { text }
    },
    element yMaxExtent {
      attribute v { text }
    },
    element caret {
      attribute slopeRise { text },
      attribute slopeRun { text },
      attribute offset { text }
    },
    element numberOfVMetrics {
      attribute v { text }
    }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='vhea.methods'>
  public void fromXML (Element vhea)
      throws InvalidFontException, UnsupportedFontException {

    Block me = new Block (36, 0);

    me.setFixed (0,
                 Integer.decode (vhea.getAttribute ("major")).intValue (),
                 Integer.decode (vhea.getAttribute ("minor")).intValue ());

    NodeList children = vhea.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if ("typo".equals (e.getTagName ())) {
        me.setFWord (4, Integer.decode (e.getAttribute ("ascender")).intValue());
        me.setFWord (6, Integer.decode (e.getAttribute ("descender")).intValue());
        me.setFWord (8, Integer.decode (e.getAttribute ("lineGap")).intValue()); }

      if ("advanceHeightMax".equals (e.getTagName ())) {
        me.setuFWord (10, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("minTopSideBearing".equals (e.getTagName ())) {
        me.setFWord (12, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("minBottomSideBearing".equals (e.getTagName ())) {
        me.setFWord (14, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("yMaxExtent".equals (e.getTagName ())) {
        me.setFWord (16, Integer.decode (e.getAttribute ("v")).intValue()); }

      if ("caret".equals (e.getTagName ())) {
        me.setint16 (18, Integer.decode (e.getAttribute ("slopeRise")).intValue());
        me.setint16 (20, Integer.decode (e.getAttribute ("slopeRun")).intValue());
        me.setint16 (22, Integer.decode (e.getAttribute ("offset")).intValue()); }

      if ("numberOfVMetrics".equals (e.getTagName ())) {
        me.setint16 (34, Integer.decode (e.getAttribute ("v")).intValue()); }}

    me.setint16 (24, 0);
    me.setint16 (26, 0);
    me.setint16 (28, 0);
    me.setint16 (30, 0);
    me.setint16 (32, 0);

    data = me.serialize ();
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='vhea.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    int [] version = getFixed (0);
    at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + version [0]);
    at.addAttribute ("", "minor", "minor", "CDATA", "" + version [1]);
    conf.ch.startElement ("vhea", at); {

      at = new AttributesImpl ();
      at.addAttribute ("", "ascender", "ascent", "CDATA", "" + getFWord (4));
      at.addAttribute ("", "descender", "descent", "CDATA", "" + getFWord (6));
      at.addAttribute ("", "lineGap", "lineGap", "CDATA", "" +  getFWord (8));
      conf.ch.element ("typo", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getuFWord (10) );
      conf.ch.element ("advanceHeightMax", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getFWord (12) );
      conf.ch.element ("minTopSideBearing", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getFWord (14) );
      conf.ch.element ("minBottomSideBearing", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" +  getFWord (16) );
      conf.ch.element ("yMaxExtent", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "slopeRise", "slopeRise", "CDATA", "" +  getint16 (18) );
      at.addAttribute ("", "slopeRun", "slopeRun", "CDATA", "" +  getint16 (20) );
      at.addAttribute ("", "offset", "offset", "CDATA", "" +  getint16 (22) );
      conf.ch.element ("caret", at);

      at = new AttributesImpl ();
      at.addAttribute ("", "v", "v", "CDATA", "" + getNumberOfVMetrics ());
      conf.ch.element ("numberOfVMetrics", at);

      conf.ch.endElement ("vhea"); }
  }
</code-fragment>
      </section>

      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

        <para>Here is the class definition for <ottable>vhea</ottable>
          tables:</para>

<code-fragment package='com.adobe.aots.opentype' class='Vhea'>
  <code-title>Vhea class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Vhea extends Table {

  public Vhea () {
    super (Tag.vhea, null);
  }

  public Vhea (Font font) {
    super (Tag.vhea, font);
  }

  <code-include linkend='vhea.methods'/>
}
</code-fragment>


        <para>We have simple accessor functions:</para>

<code-fragment id='vhea.methods'>
  <code-title>Vhea class</code-title>
  public int getNumberOfVMetrics () {
    return getuint16 (34);
  }

  public void setNumberOfVMetrics (int n) {
    setuint16 (34, n);
  }
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.vmtx'>
    <title>vmtx - Vertical Metrics Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The vertical metrics table allows you to specify the
          vertical spacing for each glyph in a vertical font. This
          table consists of either one or two arrays that contain
          metric information (the advance heights and top
          sidebearings) for the vertical layout of each of the glyphs
          in the font. The vertical metrics coordinate system is shown
          below.</para>

        <figure>
          <title>Figure 2a. Glyphs in the Latin, Kanji, and Arabic
            scripts</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00287.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>OpenType vertical fonts require both a vertical
          header table (<ottable>vhea</ottable>) and the vertical metrics table
          discussed below. The vertical header table contains
          information that is general to the font as a whole. The
          vertical metrics table contains information that pertains to
          specific glyphs. The formats of these tables are similar to
          those for horizontal metrics (hhea and hmtx).</para>
        <para>See the section "OpenType CJK Font Guidelines" for more
          information about constructing CJK (Chinese, Japanese, and
          Korean) fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Vertical Origin and Advance Height</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


        <para>The y coordinate of a glyph's vertical origin is
          specified as the sum of the glyph's top side bearing
          (recorded in the <ottable>vmtx</ottable> table) and the top (i.e. maximum y)
          of the glyph&#x2019;s bounding box.</para>

        <para>TrueType OpenType fonts contain glyph bounding box
          information in the Glyph Data (<ottable>glyf</ottable>)
          table. CFF OpenType fonts do not contain glyph bounding box
          information, and so for these fonts the top of the glyph's
          bounding box must be calculated from the charstring data in
          the Compact Font Format (<ottable>CFF</ottable>) table.</para>

        <para>OpenType 1.3 introduced the optional Vertical Origin
          (<ottable>VORG</ottable>) table for CFF OpenType fonts,
          which records the y coordinate of glyphs' vertical origins
          directly, thus obviating the need to calculate bounding
          boxes as an intermediate step. This improves accuracy and
          efficiency for CFF OpenType clients.</para>

        <para>The x coordinate of a glyph's vertical origin is not
          specified in the <ottable>vmtx</ottable> table. Vertical writing
          implementions may make use of the baseline values in the
          Baseline (<ottable>BASE</ottable>) table, if present, in
          order to align the glyphs in the x direction as appropriate
          to the desired vertical baseline.</para>

        <para>The advance height of a glyph starts from the y
          coordinate of the glyph&#x2019;s vertical origin and advances
          downwards. Its endpoint is at the y coordinate of the
          vertical origin of the next glyph in the run, by default.
          Metric-adjustment OpenType layout features such as Vertical
          Kerning ('vkrn') could modify the vertical advances in a
          manner similar to kerning in horizontal mode.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Vertical Metrics Table Format</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The overall structure of the vertical metrics table
          consists of two arrays shown below: the vMetrics array
          followed by an array of top side bearings. The top side
          bearing is measured relative to the top of the origin of
          glyphs, for vertical composition of ideographic
          glyphs.</para>
        <para>This table does not have a header, but does require that
          the number of glyphs included in the two arrays equals the
          total number of glyphs in the font.</para>
        <para>The number of entries in the vMetrics array is
          determined by the value of the numOfLongVerMetrics field of
          the vertical header table.</para>
        <para>The vMetrics array contains two values for each entry.
          These are the advance height and the top sidebearing for
          each glyph included in the array.</para>
        <para>In monospaced fonts, such as Courier or Kanji, all
          glyphs have the same advance height. If the font is
          monospaced, only one entry need be in the first array, but
          that one entry is required.</para>
        <para>The format of an entry in the vertical metrics array is
          given below.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>advanceHeight</otfieldname>
            <otfielddesc>The advance height of the glyph. Unsigned
              integer in FUnits </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>topSideBearing</otfieldname>
            <otfielddesc>The top sidebearing of the glyph. Signed
              integer in FUnits.</otfielddesc>
          </otfield>
        </otformat>

        <para>The second array is optional and generally is used for a
          run of monospaced glyphs in the font. Only one such run is
          allowed per font, and it must be located at the end of the
          font. This array contains the top sidebearings of glyphs not
          represented in the first array, and all the glyphs in this
          array must have the same advance height as the last entry in
          the vMetrics array. All entries in this array are therefore
          monospaced.</para>
        <para>The number of entries in this array is calculated by
          subtracting the value of numOfLongVerMetrics from the number
          of glyphs in the font. The sum of glyphs represented in the
          first array plus the glyphs represented in the second array
          therefore equals the number of glyphs in the font. The
          format of the top sidebearing array is given below.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>topSideBearing []</otfieldname>
            <otfielddesc>The top sidebearing of the glyph. Signed
              integer in FUnits. </otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
vmtx =
  element vmtx {
    element vMetric {
      attribute tsb { text },
      attribute adv { text }
    }*,
    element tsb {
      attribute tsb { text }
    }*
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='vmtx.methods'>
  public void fromXML (Element vmtx)
    throws InvalidFontException, UnsupportedFontException {

    NodeList metrics = vmtx.getChildNodes ();

    int vmetrics = 0;
    int tsbs = 0;
    for (int i = 0; i &lt; metrics.getLength (); i++) {
      Element x = (Element) metrics.item (i);
      if ("vMetric".equals (x.getTagName ())) {
        vmetrics++; }
      if ("tsb".equals (x.getTagName ())) {
        tsbs++; }}

    Block me = new Block (vmetrics*4 + tsbs*2, 0);

    int offset = 0;
    for (int i = 0; i &lt; metrics.getLength (); i++) {
      Element metric = (Element) metrics.item (i);
      if ("vMetric".equals (metric.getTagName ())) {
        me.setuint16 (offset,
                      Integer.decode (metric.getAttribute ("adv")).intValue ());
        me.setint16 (offset + 2,
                     Integer.decode (metric.getAttribute ("tsb")).intValue ());
        offset += 4; }
      if ("tsb".equals (metric.getTagName ())) {
        me.setFWord (offset,
                     Integer.decode (metric.getAttribute ("tsb")).intValue ());
        offset += 2; }}

    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='vmtx.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    conf.ch.startElement ("vmtx"); {
      int offset = 0;
      int gid = 0;
      int numberOfVMetrics = font.vhea.getNumberOfVMetrics ();
      int numTsb = font.maxp.getNumGlyphs () - numberOfVMetrics;

      for (int i = 0; i &lt; numberOfVMetrics; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        gid++;
        at.addAttribute ("", "adv", "adv", "CDATA", "" + getint16 (offset));
        offset += 2;
        at.addAttribute ("", "tsb", "tsb", "CDATA", "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("vMetric", at); }

      for (int i = 0; i &lt; numTsb; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        gid++;
        at.addAttribute ("", "tsb", "tsb", "CDATA", "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("tsb", at); }

      conf.ch.endElement ("vmtx"); }
  }
</code-fragment>
      </section>


      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Vmtx'>
  <code-title>Vmtx class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Vmtx extends Table {

  public Vmtx () {
    super (Tag.vmtx, null);
  }

  public Vmtx (Font font) {
    super (Tag.vmtx, font);
  }

  public int getTopSideBearing (int glyphID) {
    int numberOfVMetrics = font.vhea.getNumberOfVMetrics ();
    if (glyphID &lt; numberOfVMetrics) {
      return getFWord (4*glyphID + 2); }
    else {
      return getFWord (4*numberOfVMetrics + 2*(glyphID - numberOfVMetrics)); }
  }

  public int getVerticalAdvance (int glyphID) {
    int numberOfVMetrics = font.vhea.getNumberOfVMetrics ();
    if (glyphID &lt; numberOfVMetrics) {
      return getuFWord (4*glyphID); }
    else {
      return getuFWord (4*(numberOfVMetrics - 1)); }
  }

  <code-include linkend='vmtx.methods'/>
}
</code-fragment>

      </section>

    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.VORG'>
    <title>VORG - Vertical Origin Table</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table specifies the y coordinate of the vertical
          origin of every glyph in the font.</para>

        <para>This table may be optionally present only in CFF
          OpenType fonts. If present in TrueType OpenType fonts it
          must be ignored by font clients, just as any other
          unrecognized table would be. This is because this table is
          not needed for TrueType OpenType fonts: the Vertical Metrics
          (<ottable>vmtx</ottable>) and Glyph Data
          (<ottable>glyf</ottable>) tables in TrueType OpenType fonts
          provide all the information necessary to accurately
          calculate the y coordinate of a glyph's vertical origin. See
          the "Vertical Origin and Advance Height" section in the
          <ottable>vmtx</ottable> table specification for more
          details.</para>

        <para>This table was added to version 1.3 of the OpenType
          specification. Note that the <ottable>vmtx</ottable> and
          Vertical Header (<ottable>vhea</ottable>) tables continue to
          be required for all OpenType fonts that support vertical
          writing. Advance heights must continue to be obtained from
          the <ottable>vmtx</ottable> table; that is the only place
          they are stored.</para>

        <para>If a <ottable>VORG</ottable> table is present in a CFF
          OpenType font, a font client may choose to obtain the y
          coordinate of a glyph&#x2019;s vertical origin either:</para>

        <itemizedlist>
          <listitem>
            <para>directly from the <ottable>VORG</ottable>, or:</para>
          </listitem>
          <listitem>
            <para> by first calculating the top of the glyph's
              bounding box from the CFF charstring data and then
              adding to it the glyph's top side bearing from the
              <ottable>vmtx</ottable> table.</para>
          </listitem>
        </itemizedlist>

        <para>The former method offers the advantage of increased
          accuracy and efficiency, since bounding box results
          calculated from the CFF charstring as in the latter method
          can differ depending on the rounding decisions and data
          types of the bounding box algorithm. The latter method
          provides compatibility for font clients who are either
          unaware of or choose not to support the <ottable>VORG</ottable>.</para>
        <para>Thus, the <ottable>VORG</ottable> doesn't add any new font metric values
          per se; it simply improves accuracy and efficiency for CFF
          OpenType font clients, since the intermediate step of
          calculating bounding boxes from the CFF charstring is
          rendered unnecessary.</para>
        <para>See the section "OpenType CJK Font Guidelines" for more
          information about constructing CJK (Chinese, Japanese, and
          Korean) fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Vertical Origin Table Format</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>majorVersion</otfieldname>
            <otfielddesc>Major version (starting at 1). Set to
              1.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>minorVersion</otfieldname>
            <otfielddesc>Minor version (starting at 0). Set to
              0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>defaultVertOriginY</otfieldname>
            <otfielddesc>The y coordinate of a glyph's vertical
              origin, in the font's design coordinate system, to be
              used if no entry is present for the glyph in the
              vertOriginYMetrics array.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>numVertOriginYMetrics</otfieldname>
            <otfielddesc>Number of elements in the vertOriginYMetrics
              array.</otfielddesc>
          </otfield>
        </otformat>

        <para>This is immediately followed by the vertOriginYMetrics
          array (if numVertOriginYMetrics is non-zero), which has
          numVertOriginYMetrics elements of the following
          format:</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>glyphIndex</otfieldname>
            <otfielddesc> Glyph index.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>vertOriginY</otfieldname>
            <otfielddesc>Y coordinate, in the font's design coordinate
              system, of the vertical origin of glyph with index
              glyphIndex.</otfielddesc>
          </otfield>
        </otformat>

        <para>This array must be sorted by increasing glyphIndex, and
          must not have more than one element with the same
          glyphIndex. In a size-optimized implementation, glyphs whose
          vertical origin's y coordinate equals defaultVertOriginY
          will not have an entry in this array.</para>
        <para>If all glyphs in a font share the same
          defaultVertOriginY value, the length of the <ottable>VORG</ottable> table
          will be 8 bytes in a size-optimized implementation, since
          the vertOriginYMetrics array will be absent.</para>
        <para>Typically only the full-width Latin glyphs in an East
          Asian font will have entries in the vertOriginYMetrics
          array. Glyphs rotated for vertical writing, as used in the
          Vertical Alternates and Rotation ('vrt2') feature, for
          example, can take advantage of the default value if they are
          designed appropriately.</para>
        <para>In the following example of a complete <ottable>VORG</ottable> table for
          a 1000-unit-em font, every glyph in the font is specified as
          having a vertOriginY of 880 except for glyphs with glyph
          indexes 10, 12, and 13:</para>

<literallayout>
<![CDATA[
majorVersion         =1
minorVersion         =0
defaultVertOriginY   =880
numVertOriginYMetrics=3
--- vertOriginYMetrics[index]=(glyphIndex,vertOriginY)
[0]=(10,889)
[1]=(12,861)
[2]=(13,849)
]]>
</literallayout>
      </section>

      <!--________________________________________________________________-->
      <section role='xml-representation'>
        <title>XML Representation</title>

<code-fragment id='schema'>
  <code-title>??</code-title>
VORG =
  element VORG {
    attribute major { "1" },
    attribute minor { "0" },
    attribute defaultVertOriginY { text },

    element vMetric {
      attribute gid { text },
      attribute vertOriginY { text }
    }*
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role='compiler'>
        <title>Compiler</title>

<code-fragment id='VORG.methods'>
  public void fromXML (Element vorg)
    throws InvalidFontException, UnsupportedFontException {

    NodeList metrics = vorg.getChildNodes ();

    Block me = new Block (2 + 2 + 2 + 2 + metrics.getLength () * 4, 0);

    int offset = 0;

    me.setuint16 (offset,
                  Integer.decode (vorg.getAttribute ("major")).intValue ());
    offset += 2;

    me.setuint16 (offset,
                  Integer.decode (vorg.getAttribute ("minor")).intValue ());
    offset += 2;

    me.setint16 (offset,
                 Integer.decode (vorg.getAttribute ("defaultVertOriginY")).intValue ());
    offset += 2;

    me.setuint16 (offset, metrics.getLength ());
    offset += 2;

    for (int i = 0; i &lt; metrics.getLength (); i++) {
      Element metric = (Element) metrics.item (i);
      me.setuint16 (offset,
                    Integer.decode (metric.getAttribute ("gid")).intValue ());
      offset += 2;
      me.setint16 (offset,
                   Integer.decode (metric.getAttribute ("verOriginY")).intValue ());
      offset += 2; }

    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role='decompiler'>
        <title>Decompiler</title>

<code-fragment id='VORG.methods'>
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    int offset = 0;
    AttributesImpl at = new AttributesImpl ();
    at.addAttribute ("", "major", "major", "CDATA", "" + getuint16 (offset));
    offset += 2;
    at.addAttribute ("", "minor", "minor", "CDATA", "" + getuint16 (offset));
    offset += 2;
    at.addAttribute ("", "defaultVertOriginY", "defaultVertOriginY", "CDATA",
                     "" + getint16 (offset));
    offset += 2;

    int numVertOriginYMetrics = getuint16 (offset);
    offset += 2;

    conf.ch.startElement ("VORG", at); {

      for (int i = 0; i &lt; numVertOriginYMetrics; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + getuint16 (offset));
        offset += 2;
        at.addAttribute ("", "vertOriginY", "vertOriginY", "CDATA",
                         "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("vMetric", at); }

      conf.ch.endElement ("VORG"); }
  }
</code-fragment>
      </section>


      <!--________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>

<code-fragment package='com.adobe.aots.opentype' class='Vorg'>
  <code-title>Vorg class</code-title>
package com.adobe.aots.opentype;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Vorg extends Table {

  public Vorg () {
    super (Tag.VORG, null);
  }

  public Vorg (Font font) {
    super (Tag.VORG, font);
  }

  public int getVerticalOrigin (int glyphID) {
    int numVertOriginYMetrics = getuint16 (6);

    for (int i = 0; i &lt; numVertOriginYMetrics; i++) {
      if (glyphID == getuint16 (8 + 4*i)) {
        return getint16 (8 + 4*i + 2); }}

    return getint16 (4);
  }

  <code-include linkend='VORG.methods'/>
}
</code-fragment>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.recommendations'>
    <title>Recommendations for OpenType Fonts</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This chapter outlines recommendations for creating
          OpenType fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Byte Ordering</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All OpenType fonts use Motorola-style byte ordering (Big
          Endian).</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>'sfnt' Version</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>OpenType fonts that contain TrueType outlines should use
          the value of 1.0 for the sfnt version. OpenType fonts
          containing CFF data should use the tag 'OTTO' as the sfnt
          version number.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Mixing Outline Formats</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Both Microsoft and Adobe recommend against mixing
          outline formats within a single font. Choose the format that
          meets your feature requirements.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Filenames</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>OpenType fonts may have the extension .OTF, .TTF, or .TTC,
          depending on the type of outlines in the font and the
	  presence of OpenType layout tables.</para>

        <itemizedlist>
          <listitem>
            <para>Fonts with CFF data always have an .OTF
              extension.</para>
          </listitem>
          <listitem>
            <para>Fonts containing TrueType outlines that have
            OpenType layout tables should use the .OTF extension when
            backward compatibility is not an issue. Fonts without
            OpenType layout tables, or fonts that have backward
            compatibility issues should use the .TTF
            extension. TrueType Collection fonts should have a .TTC
            extension whether or not the fonts have OpenType layout
            tables present.</para>
	  </listitem>
        </itemizedlist>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Table Alignment and Length</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All tables should be aligned to begin at offsets which
          are multiples of four bytes. While this is not required by
          the TrueType rasterizer, it does prevent ambiguous checksum
          calculations and greatly speeds table access on some
          processors.</para>

        <para>All tables should be recorded in the table directory
          with their actual length. To ensure that checksums are
          calculated correctly, it is suggested that tables begin on
          LONG word boundries. Any extra space after a table (and
          before the next LONG word boundry) should be padded with
          zeros.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>First Four Glyphs in Fonts</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>TrueType outline fonts should have the following four
	  glyphs at the glyph ID indicated. These were listed in
	  Apple's original TrueType specification. These glyphs are
	  recommended to allow for the same version of the font to
	  work on both Windows and Macintosh. Fonts used on the Mac
	  should be put in a suitcase for the best user
	  experience.</para>

	<informaltable>
	  <tgroup cols='3'>
	    <thead>
	      <row>
		<entry>Glyph ID</entry>
		<entry>Glyph name</entry>
		<entry>Unicode value</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>0</entry>
		<entry>.notdef</entry>
		<entry>undefined</entry>
	      </row>
	      <row>
		<entry>1</entry>
		<entry>.null</entry>
		<entry>U+0000</entry>
	      </row>
	      <row>
		<entry>2</entry>
		<entry>CR</entry>
		<entry>U+000D</entry>
	      </row>
	      <row>
		<entry>3</entry>
		<entry>space</entry>
		<entry>U+0020</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Shape of .notdef glyph</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The .notdef glyph is very important for providing the
	  user feedback that a glyph is not found in the font. This
	  glyph should not be left without an outline as the user will
	  only see what looks like a space if a glyph is missing and
	  not be aware of the active font's limitation.</para>

	<para>It is recommended that the shape of the .notdef glyph be
	  either an empty rectangle, a rectangle with a question mark
	  inside of it, or a rectangle with an "X". Creative shapes,
	  like swirls or other symbols, may not be recognized by users
	  as indicating that a glyph is missing from the font and is
	  not being displayed at that location.</para>

        <figure>
          <title>Suggested shapes of .notdef glyph</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='notdef.gif'/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>BASE</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>BASE</ottable> table allows for different
          scripts in the font to specify different values for the same
          baseline tag.  This situation could arise when a developer
          makes a Unicode font, for example, by combining glyphs from
          fonts that use different baseline systems.</para>

        <para>However, glyphs from different scripts in this font may
          not appear correctly aligned relative to each other when
          used with applications that either don't support the
          <ottable>BASE</ottable> table or that support it but
          assume that a particular baseline will not vary across
          scripts. Furthermore, it is not always possible to determine
          the script of every glyph in the font, some
          "weakly-scripted" characters such as punctuation may be used
          in several scripts, and some glyphs such as ornaments may
          not have a script at all.</para>

        <para>Thus, it is strongly recommended that developers
          construct their fonts so that all scripts in the
          <ottable>BASE</ottable> table record the same value for a
          particular baseline if they want their fonts to work as
          expected in the above situations.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>cmap</ottable> Table </title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>When building a Unicode font for Windows, the platform
          ID should be 3 and the encoding ID should be 1 (this
          subtable must use cmap format 4). When building a symbol
          font for Windows, the platform ID should be 3 and the
          encoding ID should be 0.</para>

        <para>When building a font to support surrogate characters
          i.e. the UCS-4 (4 byte) form of ISO 10646 (ISO 10646 UCS-4
          contains 2^31 code positions and the Unicode transformation
          formats UTF-8 and UTF-16 access a subset of these code
          positions using surrogate characters), use platform ID 3,
          encoding ID 10 and format 12. Depending on support installed
          and the content of text being displayed, Windows 2000 may
          use either the format 4 or format 12 cmap. Therefore the
          first 64k codepoint to glyph mappings must be identical for
          any font containing both cmap format 4 and format 12. Please
          note, that the content of format 12 subtable, needs to be a
          super set of the content in the format 4 subtable. The
          format 4 subtable needs to be included, for backward
          compatibility needs.</para>

        <para>The number of glyphs that may be included in one font is
          limited to 64k.</para>

        <para>Remember that, despite references to 'first' and
          'second' subtables, the subtables must be stored in sorted
          order by platform and encoding ID.</para>


        <para>Macintosh <ottable>cmap</ottable> Table</para>

        <para>When building a font containing Roman characters that
          will be used on the Macintosh, an additional subtable is
          required, specifying platform ID of 1 and encoding ID of 0
          (this subtable may use cmap formats 0, 2, 4, or 6).</para>

        <para>In order for the Macintosh <ottable>cmap</ottable> table to be useful,
          the glyphs required for the Macintosh must have glyph
          indices less than 256 (since the <ottable>cmap</ottable> subtable format 0
          uses BYTE indices and therefore cannot index any glyph above
          255).</para>

        <para>The Apple <ottable>cmap</ottable> subtable should be constructed
          according to Apple guidelines.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>cvt</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Should be defined only if required by font
          instructions.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>fpgm</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Should be defined only if required by TrueType font
          instructions.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>glyf</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>glyf</ottable> table contains TrueType
          outline data, and can be optimized by Agfa MicroType
          Compression. Microsoft recommends that developers perform
          this optimization, using a tool provided by Microsoft, prior
          to finalizing and adding a digital signature to the font.
          This is necessary for the creator's signature to remain
          valid in embedded OpenType fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>hdmx</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table improves the performance of OpenType fonts
          with TrueType outlines. This table is not necessary at all
          unless instructions are used to control the "phantom
          points," and should be omitted if bit 2 of the flags field
          in the <ottable>head</ottable> table is zero. (See the <ottable>head</ottable> table
          documentation in Chapter 2.) Microsoft recommends that this
          table be included for fonts with one or more non-linearly
          scaled glyphs (i.e., bit 2 and 4 of the <ottable>head</ottable> table flags
          field are set).</para>

        <para>Device records should be defined for all sizes from 8
          through 14 point, and even point sizes from 16 through 24
          point. However, the table requires pixel-per-em sizes, which
          depend on the horizontal resolution of the output device.
          The records in <ottable>hdmx</ottable> should cover both 96 dpi devices (CGA,
          EGA, VGA) and 300 dpi devices (laser and ink jet
          printers).</para>

        <para>Thus, <ottable>hdmx</ottable> should contain entries for the following
          pixel sizes (PPEM): 11, 12, 13, 15, 16, 17, 19, 21, 24, 27, 29, 32,
          33, 37, 42, 46, 50, 54, 58, 67, 75, 83, 92, 100. These
          values have been rounded to the nearest pixel. For instance,
          12 points at 300 dpi would measure 37.5 pixels, but this is
          rounded down to 37 for this list. </para>

        <para>This will add approximately 9,600 bytes to the font
          file. However, there will be a significant improvement in
          speed when a client requests advance widths covered by these
          device records.</para>

        <para>If the font includes an <ottable>LTSH</ottable> table, the hdmx values
          are not needed above the linearity threshold.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>head</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Although historical usage of the fontRevision value is
          varied, the recommended use of the field is to set it as a
          Fixed 16.16 value, and to report it rounded and zero-padded
          to three fractional decimal places. Examples: Decimal 1.5 is
          set as 0x00018000 and is reported as "1.500"; decimal 1.001
          is set as 0x00010041 and is reported as "1.001". All data
          required. If the font has been compressed with Agfa
          MicroType Compression, this must be indicated in the flags
          field of the <ottable>head</ottable> table.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>hhead</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All data required. It is suggested that monospaced fonts
          set numberOfHMetrics to three (see hmtx).</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>hmtx</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All data required. It is suggested that monospaced fonts
          have three entries in the numberOfHMetrics field. OpenType
          fonts that include CFF data must set numberOfHMetrics equal
          to the number of glyphs in the font and therefore cannot use
          the "repeat last width" optimization normally available
          within the <ottable>hmtx</ottable> table.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>kern</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Should contain a single kerning pair subtable (format
          0). Windows will not support format 2 (two-dimensional array
          of kern values by class); nor multiple tables (only the
          first format 0 table found will be used) nor coverage bits 0
          through 4 (i.e. assumes horizontal data, kerning values, no
          cross stream, and override). OpenType fonts containing CFF
          data do not support the <ottable>kern</ottable> table and should therefore
          specify kerning data using the <ottable>GPOS</ottable> table
          (LookupType=2).</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>loca</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All data required for fonts with TrueType outlines. We
          recommend that local offsets should be word-aligned, in both
          the short and long formats of this table.</para>

        <para>The actual ordering of the glyphs in the font can be
          optimized based on expected utilization, with the most
          frequently used glyphs appearing at the beginning of the
          font file. Additionally, glyphs that are often used together
          should be grouped together in the file. The will help to
          minimize the amount of swapping required when the font is
          loaded into memory.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>LTSH</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table improves the performance of OpenType fonts
          with TrueType outlines. The table should be used if bit 2 or
          4 of flags in <ottable>head</ottable> is set.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>maxp</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All data required for a font with TrueType outlines.
          Fonts with CFF data must only fill the numGlyphs
          field.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>'name' Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Platform and encoding ID's in the name table should be
          consistent with those in the cmap table. If they are not,
          the font will not load in Windows. When building a Unicode
          font for Windows, the platform ID should be 3 and the
          encoding ID should be 1. When building a symbol font for
          Windows, the platform ID should be 3 and the encoding ID
          should be 0.</para>

        <para>When building a font containing Roman characters that
          will be used on the Macintosh, an additional name record is
          required, specifying platform ID of 1 and encoding ID of
          0.</para>

        <para>Each set of name records should appear for US English
          (language ID = 0x0409 for Microsoft records, language ID = 0
          for Macintosh records); additional language strings for the
          Microsoft set of records (platform ID 3) may be added at the
          discretion of the font vendor.</para>

        <para>Remember that, despite references to "first" and
          "second," the name record must be stored in sorted order (by
          platform ID, encoding ID, language ID, name ID). The 'name'
          table platform/encoding IDs must match the <ottable>cmap</ottable> table
          platform/encoding IDs, which is how Windows knows which name
          set to use.</para>

        <para>Name strings</para>

        <para>We recommend using name ID's 8-12, to identify
          manufacturer, designer, description, URL of the vendor, and
          URL of the designer. URL's must contain the protocol of the
          site: for example, http:// or mailto: or ftp://. The
          OpenType font properties extension can enumerate this
          information to the users.</para>

        <para>The Subfamily string in the 'name' table should be used
          for variants of weight (ultra light to extra black) and
          style (oblique/italic or not). So, for example, the full
          font name of "Helvetica Narrow Italic" should be defined as
          Family name "Helvetica Narrow" and Subfamily "Italic". This
          is so that Windows can group the standard four weights of a
          font in a reasonable fashion for non-typographically aware
          applications which only support combinations of "bold" and
          "italic."</para>

        <para>The Full font name string usually contains a
          concatenation of strings 1 and 2. However, if the font is
          'Regular' as indicated in string 2, then use only the family
          name contained in string 1. This is the font name that
          Windows will expose to users.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>OS/2</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All data required. We recommend applying PANOSE values
          to fonts to improve the user's experience when using the
          Windows fonts folder or other font management utilities. If
          the font is a symbol font, the first byte of the PANOSE
          value must be set to 'decorative.' The PANOSE evaluation
          document is on-line at
          www.fonts.com/hp/panose/greybook/frame.htm.</para>


        <para>sTypoAscender, sTypoDescender and sTypoLineGap</para>

        <para>sTypoAscender is used to determine the optimum offset
          from the top of a text frame to the first baseline.
          sTypoDescender is used to determine the optimum offset from
          the last baseline to the bottom of the text frame. The value
          of (sTypoAscender - sTypoDescender) is recommended to equal
          one em.</para>

	<para>While the OpenType specification allows
          for CJK (Chinese, Japanese, and Korean) fonts'
          sTypoDescender and sTypoAscender fields to specify metrics
          different from the HorizAxis.ideo and HorizAxis.idtp
          baselines in the <ottable>BASE</ottable> table, CJK font
          developers should be aware that existing applications may
          not read the <ottable>BASE</ottable> table at all but
          simply use the sTypoDescender and sTypoAscender fields to
          describe the bottom and top edges of the ideographic
          em-box. If developers want their fonts to work correctly
          with such applications, they should ensure that any
          ideographic em-box values in the <ottable>BASE</ottable>
          table describe the same bottom and top edges as the
          sTypoDescender and sTypoAscender fields. See the sections
          "OpenType CJK Font Guidelines" and "Ideographic Em-Box" for
          more details.</para>

	<para>For Western fonts, the Ascender
          and Descender fields in Type 1 fonts' AFM files are a good
          source of sTypoAscender and sTypoDescender,
          respectively. The Minion Pro font family (designed on a
          1000-unit em), for example, sets sTypoAscender = 727 and
          sTypoDescender = -273.</para>

	<para>sTypoAscender,
          sTypoDescender and sTypoLineGap specify the recommended line
          spacing for single-spaced horizontal text. The
          baseline-to-baseline value is expressed by:</para>

	<para>OS/2.sTypoAscender - OS/2.sTypoDescender +
          OS/2.sTypoLineGap</para>

	<para>sTypoLineGap will usually be
          set by the font developer such that the value of the above
          expression is approximately 120% of the em. The application
          can use this value as the default horizontal line
          spacing. The Minion Pro font family (designed on a 1000-unit
          em), for example, sets sTypoLineGap = 200.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>post</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>All information required, although the VM Usage fields
          may be set to zero. OpenType fonts containing CFF outlines
          use only format 3.0 of the <ottable>post</ottable> table. Glyph names must be
          assigned as described in the Adobe document "Unicode and
          Glyph Names," which specifies glyph naming conventions for
          all Unicode characters as well as those that don't have
          standard Unicode values such as certain ligatures or glyphic
          variants. Note that names for all glyphs must be supplied as
          it cannot be assumed that all Microsoft platforms will
          support the default names supplied on the Macintosh.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>prep</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Should be defined only if required by the TrueType font
          instructions.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title><ottable>VDMX</ottable> Table</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This table improves the performance of OpenType fonts
          with TrueType outlines. It Should be present if hints cause
          the font to scale non-linearly. If not present, the font is
          assumed to scale linearly. Clipping may occur if values in
          this table are absent and font exceeds linear height.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Optimized Table Ordering</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>OpenType fonts with TrueType outlines are more efficient
          in the Windows operating system when the tables are ordered
          as follows (from first to last):</para>

        <para>head, hhea, maxp, OS/2, hmtx, LTSH, VDMX, hdmx, cmap,
          fpgm, prep, cvt, loca, <ottable>glyf</ottable>, kern, name,
          post, gasp, PCLT, DSIG</para>

        <para>The initial loading of an OpenType font containing CFF
          data will be more efficiently handled if the following sfnt
          table ordering is used within the body of the sfnt (listed
          from first to last):</para>

        <para>head, hhea, maxp, OS/2, name, cmap, post, CFF, (other
          tables, as convenient)</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Non-Standard (Symbol) Fonts</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Non-standard fonts such as Symbol or Wingdings(tm) have
          special requirements for Microsoft platforms. These
          requirements affect the 'cmap,' 'name,' and <ottable>OS/2</ottable> tables;
          the requirements and recommendations for all other tables
          remain the same.</para>

        <para>For the Macintosh, non-standard fonts can continue to
          use platform ID 1 (Macintosh) and encoding ID 0 (Roman
          character set). The <ottable>cmap</ottable> subtable should use format 0 and
          follow the standard PostScript character encodings.</para>

        <para>For non-standard fonts on Microsoft platforms, however,
          the <ottable>cmap</ottable> and 'name' tables must use platform ID 3
          (Microsoft) and encoding ID 0 (Unicode, non-standard
          character set). Remember that 'name' table encodings should
          agree with the <ottable>cmap</ottable> table. Additionally, the first byte of
          the PANOSE value in the <ottable>OS/2</ottable> table must be set to
          'decorative.'</para>

        <para>The Microsoft <ottable>cmap</ottable> subtable (platform 3, encoding 0)
          must use format 4. The character codes should start at
          0xF000, which is in the Private Use Area of Unicode.
          Microsoft suggests deriving the format 4 (Microsoft)
          encodings by simply adding 0xF000 to the format 0
          (Macintosh) encodings.</para>

        <para>Under Windows, only the first 224 characters of
          non-standard fonts will be accessible: a space and up to 223
          printing characters. It does not matter where in user space
          these start, but 0xF020 is suggested. The usFirstCharIndex
          and usLastCharIndex values in the <ottable>OS/2</ottable> table would be set
          based on the actual minimum and maximum character indices
          used.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Device Resolutions</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Windows makes use of a logical device resolution. The
          physical resolution of a device is also available, but fonts
          will be rendered based on the logical resolution. The table
          below lists some important logical resolutions in dots per
          inch (Horizontal x Vertical). The most important ratios (in
          order) are 1:1, 1.67:1 and 1.33:1.</para>

        <informaltable>
          <tgroup cols="3">
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Device</entry>
                <entry>Resolution</entry>
                <entry>Aspect Ratio</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>CGA</entry>
                <entry>96 x 48</entry>
                <entry>2:1</entry>
              </row>
              <row>
                <entry>EGA</entry>
                <entry>96 x 72</entry>
                <entry>1.33:1</entry>
              </row>
              <row>
                <entry>VGA</entry>
                <entry>96 x 96</entry>
                <entry>1:1</entry>
              </row>
              <row>
                <entry>8514</entry>
                <entry>120 x 120</entry>
                <entry>1:1</entry>
              </row>
              <row>
                <entry>Dot Matrix</entry>
                <entry>120 x 72</entry>
                <entry>1.67:1</entry>
              </row>
              <row>
                <entry>Laser Printer</entry>
                <entry>300 x 300</entry>
                <entry>1:1</entry>
              </row>
              <row>
                <entry>Laser Printer</entry>
                <entry>600 x 600</entry>
                <entry>1:1</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Baseline to Baseline Distances</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>The <ottable>OS/2</ottable> table fields sTypoAscender, sTypoDescender,
          and sTypoLineGap free applications from Macintosh- or
          Windows-specific metrics which are constrained by backward
          compatibility requirements. The following discussion only
          pertains to the platform-specific metrics.</para>

        <para>The suggested Baseline to Baseline Distance (BTBD) is
          computed differently for Windows and the Macintosh, and it
          is based on different OpenType metrics. However, if the
          recommendations below are followed, the BTBD will be the
          same for both Windows and the Mac.</para>

        <para>Windows</para>

        <para>The Windows metrics in the table below are returned as
          part of the logical font data structure by the GDI
          CreateLogFont( ) API.</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Windows Metric</entry>
                <entry>OpenType Metric</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>ascent</entry>
                <entry>usWinAscent</entry>
              </row>
              <row>
                <entry>descent</entry>
                <entry>usWinDescent</entry>
              </row>
              <row>
                <entry>internal leading</entry>
                <entry>usWinAscent + usWinDescent - unitsPerEm</entry>
              </row>
              <row>
                <entry>external leading</entry>
                <entry>MAX(0, LineGap - ((usWinAscent + usWinDescent)
                  - (Ascender - Descender)))</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The suggested BTBD = ascent + descent + external
          leading</para>

        <para>It should be clear that the "external leading" can never
          be less than zero. Pixels above the ascent or below the
          descent will be clipped from the character; this is true for
          all output devices.</para>

        <para>The usWinAscent and usWinDescent are values from the
          <ottable>OS/2</ottable> table. The unitsPerEm value is from
          the <ottable>head</ottable> table. The LineGap, Ascender and
          Descender values are from the <ottable>hhea</ottable>
          table.</para>


        <para>Macintosh</para>

        <para>Ascender and Descender are metrics defined by Apple and
          are not to be confused with the Windows ascent or descent,
          nor should they be confused with the true typographic
          ascender and descender that are found in AFM files. The
          Macintosh metrics below are returned by the Apple Advanced
          Typography (AAT) GetFontInfo () API.</para>

        <informaltable>
          <tgroup cols='2'>
            <colspec colwidth="3cm"/>
            <colspec colwidth="3cm"/>
            <thead>
              <row>
                <entry>Macintosh Metric</entry>
                <entry>OpenType Metric</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>ascender</entry>
                <entry>Ascender</entry>
              </row>
              <row>
                <entry>descender</entry>
                <entry>Descender</entry>
              </row>
              <row>
                <entry>leading</entry>
                <entry>LineGap</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>The suggested BTBD = ascent + descent + leading</para>

        <para>If pixels extend above the ascent or below the descent,
          the character will be squashed in the vertical direction so
          that all pixels fit within these limitations; this is true
          for screen display only.</para>


        <para>Making Them Match</para>

        <para>If you perform some simple algebra, you will see that
          the suggested BTBD across both Macintosh and Windows will be
          identical if and only if:</para>


        <para>LineGap >= (yMax - yMin) - (Ascender - Descender)</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Style Bits</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>For backwards compatibility with previous versions of
          Windows, the macStyle bits in the <ottable>head</ottable> table will be used
          to determine whetr or not a font is regular, bold or
          italic (in the absence of an <ottable>OS/2</ottable> table). This is
          completely independent of the usWeightClass and PANOSE
          information in the <ottable>OS/2</ottable> table, the ItalicAngle in the
          <ottable>post</ottable> table, and all other related metrics. If the <ottable>OS/2</ottable>
          table is present, then the fsSelection bits are used to
          determine this information.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Drop-out Control</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Drop-out control is needed if there is a difference in
          bitmaps with dropout control on and off. Two cases where
          drop-out control is needed are when the font is rotated or
          when the size of the font is at or below 8 ppem. Do not use
          SCANCTRL unless needed. SCANCTRL or the drop-out control
          rasterizer should be avoided for Roman fonts above 8 points
          per em (ppem) when the font is not under rotation. SCANCTRL
          should not be used for "stretched" fonts (e.g. fonts
          displayed at non-square aspect ratios, like that found on an
          EGA).</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Embedded Bitmaps</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>Three tables are used to embed bitmaps in OpenType
          fonts. They are the <ottable>EBLC</ottable> table for
          embedded bitmap locators, the <ottable>EBDT</ottable> table
          for embedded bitmap data, and the <ottable>EBSC</ottable>
          table for embedded bitmap scaling information.  OpenType
          embedded bitmaps are also called 'sbits'.</para>

	<para>The behavior of sbits within an OpenType font is essentially
          transparent to the client. A client need not be aware
          whether the bitmap returned by the rasterizer comes from an
          sbit or from a scan-converted outline.</para>

        <para>The metrics in 'sbit' tables overrule the outline
          metrics at all sizes where sbits are defined. Fonts with
          <ottable>hdmx</ottable> tables should correct those tables
          with 'sbit' values.</para>

        <para>'Sbit only' fonts, that is fonts with embedded bitmaps
          but without outline data, are permitted. Care must be taken
          to ensure that all required OpenType tables except
          <ottable>glyf</ottable> and <ottable>loca</ottable> are
          present in such a font. Obviously, such fonts will only be
          able to return glyphs and sizes for which sbits are
          defined.</para>

        <itemizedlist>
          <listitem>
            <para>These metrics are returned as part of the logical
              font data structure by the GDI CreateLogFont()
              API.</para>
          </listitem>
          <listitem>
            <para>These metrics are returned by the Apple Advanced
              Typography (AAT) GetFontInfo() API.</para>
          </listitem>
	</itemizedlist>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>OpenType CJK Font Guidelines</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

        <para>This section provides a checklist of links to various
          CJK-related sections of the OpenType specification. Some
          items are requirements; others, recommendations:</para>

        <itemizedlist>
          <listitem>
            <para>The ideographic em-box of an OpenType font will be
              determined as described in the section "Ideographic
              Em-Box" in the Baseline Tags section of the OpenType
              Layout Tag Registry. Also see the description for
              OS/2.sTypoAscender and OS/2.sTypoDescender, and the
              <ottable>BASE</ottable> table recommendation section
              above.</para>
          </listitem>
          <listitem>
            <para>CJK font vendors can choose to provide the
              ideographic character face (ICF) metrics, which
              applications can use for accurate text alignment. This
              is described in the section "Ideographic Character Face"
              in the Baseline Tags section of the OpenType Layout Tag
              Registry.</para>
          </listitem>
          <listitem>
            <para>All OpenType fonts that are used for vertical
              writing must include a Vertical Header
              (<ottable>vhea</ottable>) table and a Vertical Metrics
              (<ottable>vmtx</ottable>) table. CFF OpenType fonts that
              are used for vertical writing may also include,
              optionally, a Vertical Origin (<ottable>VORG</ottable>)
              table for precise vertical origin information.</para>
          </listitem>
          <listitem>
            <para>If an OpenType font with CFF outlines is to be used
              for vertical writing, Adobe Type Manager/NT 4.1 and the
              Windows 2000 OTF driver require that a Vertical Rotation
              ('vrt2') feature be present in the Glyph Substitution
              (<ottable>GSUB</ottable>) table. See the Feature Tags
              section of the OpenType Layout Tag Registry for a
              description of and further requirements for this
              feature.</para>
          </listitem>
          <listitem>
            <para>See the Feature Tags section of the OpenType Layout
              Tag Registry for descriptions of currently registered
              OpenType layout features, such as Alternate Half Widths
              ('halt') and Traditional Forms ('trad'), that can be
              specified in the font.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.tags_registry' web:index='yes'>
    <title>OpenType Layout tag registry</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The tag registry defines the OpenType Layout tags that
	  Microsoft supports. OpenType Layout tags are 4-byte
	  character strings that identify the scripts, language
	  systems, features and baselines in a OpenType Layout
	  font. The registry establishes conventions for naming and
	  using these tags. Registered tags have a specific meaning
	  and convey precise information to developers and
	  text-processing clients of OpenType Layout. Microsoft
	  encourages font developers to use registered tags to assure
	  compatibility and ease of use across fonts, applications,
	  and operating systems. Microsoft will supply a list of
	  additional tags upon request.</para>

	<para>The following sections contain sample sets of commonly
	  used tags for scripts, language systems, and
	  baselines. Microsoft will supply a list of additional tags
	  upon request. In addition, the 'Feature tags' section
	  defines all the feature tags Microsoft has developed and
	  registered to date, including descriptions of the functions
	  of each feature.</para>

	<para>Microsoft expects the list of registered tags and
	  features to expand over time. The most recent version of the
	  registry will be available on Microsoft's ftp and World Wide
	  Web sites.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment' id='ttoreg_basetags'>
      <title>Script tags</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Script tags identify the scripts represented in a
	  OpenType Layout font. Script tags are defined by Microsoft
	  Typography and correspond to the contiguous character code
	  ranges in Unicode.</para>

	<para>All tags are 4-byte character strings composed of a
	  limited set of ASCII characters in the 0x20-0x7E range. A
	  script tag can consist of four or fewer lowercase
	  letters. If a script tag consists less than four lowercase
	  letters, the letters are followed by the requisite number of
	  spaces (0x20), each consisting of a single byte.</para>

	<para>Some of most commonly used script tags are shown
	  below. A full list of script tags is available from
	  Microsoft.</para>

	<table>
	  <title>Registered script tags</title>

	  <tgroup cols='2'>
	    <thead>
	      <row>
		<entry>Script</entry>
		<entry>Script Tag</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Arabic</entry>
		<entry>arab</entry>
	      </row>
	      <row>
		<entry>Armenian</entry>
		<entry>armn</entry>
	      </row>
	      <row>
		<entry>Bengali</entry>
		<entry>beng</entry>
	      </row>
	      <row>
		<entry>Bopomofo</entry>
		<entry>bopo</entry>
	      </row>
	      <row>
		<entry>Braille</entry>
		<entry>brai</entry>
	      </row>
	      <row>
		<entry>Canadian Syllabics</entry>
		<entry>cans</entry>
	      </row>
	      <row>
		<entry>Cherokee</entry>
		<entry>cher</entry>
	      </row>
	      <row>
		<entry>Ideographic</entry>
		<entry>hani</entry>
	      </row>
	      <row>
		<entry>Default</entry>
		<entry>DFLT</entry>
	      </row>
	      <row>
		<entry>Devanagari</entry>
		<entry>deva</entry>
	      </row>
	      <row>
		<entry>Ethiopic</entry>
		<entry>ethi</entry>
	      </row>
	      <row>
		<entry>Georgian</entry>
		<entry>geor</entry>
	      </row>
	      <row>
		<entry>Greek</entry>
		<entry>grek</entry>
	      </row>
	      <row>
		<entry>Gujarati</entry>
		<entry>gujr</entry>
	      </row>
	      <row>
		<entry>Gurmukhi</entry>
		<entry>guru</entry>
	      </row>
	      <row>
		<entry>Hangul Jamo</entry>
		<entry>jamo</entry>
	      </row>
	      <row>
		<entry>Hangul</entry>
		<entry>hang</entry>
	      </row>
	      <row>
		<entry>Hebrew</entry>
		<entry>hebr</entry>
	      </row>
	      <row>
		<entry>Hiragana</entry>
		<entry>kana</entry>
	      </row>
	      <row>
		<entry>Kannada</entry>
		<entry>knda</entry>
	      </row>
	      <row>
		<entry>Katakana</entry>
		<entry>kana</entry>
	      </row>
	      <row>
		<entry>Khmer</entry>
		<entry>khmr</entry>
	      </row>
	      <row>
		<entry>Lao</entry>
		<entry>lao</entry>
	      </row>
	      <row>
		<entry>Latin</entry>
		<entry>latn</entry>
	      </row>
	      <row>
		<entry>Malayalam</entry>
		<entry>mlym</entry>
	      </row>
	      <row>
		<entry>Mongolian</entry>
		<entry>mong</entry>
	      </row>
	      <row>
		<entry>Myanmar</entry>
		<entry>mymr</entry>
	      </row>
	      <row>
		<entry>Ogham</entry>
		<entry>ogam</entry>
	      </row>
	      <row>
		<entry>Oriya</entry>
		<entry>orya</entry>
	      </row>
	      <row>
		<entry>Runic</entry>
		<entry>runr</entry>
	      </row>
	      <row>
		<entry>Sinhala</entry>
		<entry>sinh</entry>
	      </row>
	      <row>
		<entry>Syriac</entry>
		<entry>syrc</entry>
	      </row>
	      <row>
		<entry>Tamil</entry>
		<entry>taml</entry>
	      </row>
	      <row>
		<entry>Telugu</entry>
		<entry>telu</entry>
	      </row>
	      <row>
		<entry>Thaana</entry>
		<entry>thaa</entry>
	      </row>
	      <row>
		<entry>Thai</entry>
		<entry>thai</entry>
	      </row>
	      <row>
		<entry>Tibetan</entry>
		<entry>tibt</entry>
	      </row>
	      <row>
		<entry>Yi</entry>
		<entry>yi</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>


	<para>When the ScriptList table is searched for a script, and
	  no entry is found, and there is an entry for the 'dflt'
	  script, then this entry must be used. Furthermore, the
	  Script table for the 'dflt' script must have a non-NULL
	  DefaultLangSys and a LangSysCount equal to 0; in other
	  words, there is only a default language for the default
	  script.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Language tags</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Language system tags identify the language systems
	  supported in a OpenType Layout font. Microsoft uses the
	  standard language system tag names defined in the Windows
	  Natural Language Support API document (called NLSAPI.doc),
	  in Appendix A: Locales and Language ID's. This document is
	  available on the Microsoft Developers Network CD released by
	  Microsoft quarterly, or it can be acquired directly from
	  Microsoft Typography.</para>

	<para>All tags are 4-byte character strings composed of a
	  limited set of ASCII characters in the 0x20-0x7E range. If a
	  language system tag consists of three or less lowercase
	  letters, the letters are followed by the requisite number of
	  spaces (0x20), each consisting of a single byte.</para>

	<table>
	  <title>Registered language tags</title>

	  <tgroup cols='2'>
	    <thead>
	      <row>
		<entry>Language System Tag</entry>
		<entry>Language System</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Abaza</entry>
		<entry>ABA</entry>
	      </row>
	      <row>
		<entry>Abkhazian</entry>
		<entry>ABK</entry>
	      </row>
	      <row>
		<entry>Adyghe</entry>
		<entry>ADY</entry>
	      </row>
	      <row>
		<entry>Afrikaans</entry>
		<entry>AFK</entry>
	      </row>
	      <row>
		<entry>Afar</entry>
		<entry>AFR</entry>
	      </row>
	      <row>
		<entry>Agaw</entry>
		<entry>AGW</entry>
	      </row>
	      <row>
		<entry>Altai</entry>
		<entry>ALT</entry>
	      </row>
	      <row>
		<entry>Amharic</entry>
		<entry>AMH</entry>
	      </row>
	      <row>
		<entry>Arabic</entry>
		<entry>ARA</entry>
	      </row>
	      <row>
		<entry>Aari</entry>
		<entry>ARI</entry>
	      </row>
	      <row>
		<entry>Arakanese</entry>
		<entry>ARK</entry>
	      </row>
	      <row>
		<entry>Assamese</entry>
		<entry>ASM</entry>
	      </row>
	      <row>
		<entry>Athapaskan</entry>
		<entry>ATH</entry>
	      </row>
	      <row>
		<entry>Avar</entry>
		<entry>AVR</entry>
	      </row>
	      <row>
		<entry>Awadhi</entry>
		<entry>AWA</entry>
	      </row>
	      <row>
		<entry>Aymara</entry>
		<entry>AYM</entry>
	      </row>
	      <row>
		<entry>Azeri</entry>
		<entry>AZE</entry>
	      </row>
	      <row>
		<entry>Badaga</entry>
		<entry>BAD</entry>
	      </row>
	      <row>
		<entry>Baghelkhandi</entry>
		<entry>BAG</entry>
	      </row>
	      <row>
		<entry>Balkar</entry>
		<entry>BAL</entry>
	      </row>
	      <row>
		<entry>Baule</entry>
		<entry>BAU</entry>
	      </row>
	      <row>
		<entry>Berber</entry>
		<entry>BBR</entry>
	      </row>
	      <row>
		<entry>Bench</entry>
		<entry>BCH</entry>
	      </row>
	      <row>
		<entry>Bible Cree</entry>
		<entry>BCR</entry>
	      </row>
	      <row>
		<entry>Belarussian</entry>
		<entry>BEL</entry>
	      </row>
	      <row>
		<entry>Bemba</entry>
		<entry>BEM</entry>
	      </row>
	      <row>
		<entry>Bengali</entry>
		<entry>BEN</entry>
	      </row>
	      <row>
		<entry>Bulgarian</entry>
		<entry>BGR</entry>
	      </row>
	      <row>
		<entry>Bhili</entry>
		<entry>BHI</entry>
	      </row>
	      <row>
		<entry>Bhojpuri</entry>
		<entry>BHO</entry>
	      </row>
	      <row>
		<entry>Bikol</entry>
		<entry>BIK</entry>
	      </row>
	      <row>
		<entry>Bilen</entry>
		<entry>BIL</entry>
	      </row>
	      <row>
		<entry>Blackfoot</entry>
		<entry>BKF</entry>
	      </row>
	      <row>
		<entry>Balochi</entry>
		<entry>BLI</entry>
	      </row>
	      <row>
		<entry>Balante</entry>
		<entry>BLN</entry>
	      </row>
	      <row>
		<entry>Balti</entry>
		<entry>BLT</entry>
	      </row>
	      <row>
		<entry>Bambara</entry>
		<entry>BMB</entry>
	      </row>
	      <row>
		<entry>Bamileke</entry>
		<entry>BML</entry>
	      </row>
	      <row>
		<entry>Breton</entry>
		<entry>BRE</entry>
	      </row>
	      <row>
		<entry>Brahui</entry>
		<entry>BRH</entry>
	      </row>
	      <row>
		<entry>Braj Bhasha</entry>
		<entry>BRI</entry>
	      </row>
	      <row>
		<entry>Burmese</entry>
		<entry>BRM</entry>
	      </row>
	      <row>
		<entry>Bashkir</entry>
		<entry>BSH</entry>
	      </row>
	      <row>
		<entry>Beti</entry>
		<entry>BTI</entry>
	      </row>
	      <row>
		<entry>Catalan</entry>
		<entry>CAT</entry>
	      </row>
	      <row>
		<entry>Cebuano</entry>
		<entry>CEB</entry>
	      </row>
	      <row>
		<entry>Chechen</entry>
		<entry>CHE</entry>
	      </row>
	      <row>
		<entry>Chaha Gurage</entry>
		<entry>CHG</entry>
	      </row>
	      <row>
		<entry>Chattisgarhi</entry>
		<entry>CHH</entry>
	      </row>
	      <row>
		<entry>Chichewa</entry>
		<entry>CHI</entry>
	      </row>
	      <row>
		<entry>Chukchi</entry>
		<entry>CHK</entry>
	      </row>
	      <row>
		<entry>Chipewyan</entry>
		<entry>CHP</entry>
	      </row>
	      <row>
		<entry>Cherokee</entry>
		<entry>CHR</entry>
	      </row>
	      <row>
		<entry>Chuvash</entry>
		<entry>CHU</entry>
	      </row>
	      <row>
		<entry>Comorian</entry>
		<entry>CMR</entry>
	      </row>
	      <row>
		<entry>Coptic</entry>
		<entry>COP</entry>
	      </row>
	      <row>
		<entry>Cree</entry>
		<entry>CRE</entry>
	      </row>
	      <row>
		<entry>Carrier</entry>
		<entry>CRR</entry>
	      </row>
	      <row>
		<entry>Crimean Tatar</entry>
		<entry>CRT</entry>
	      </row>
	      <row>
		<entry>Church Slavonic</entry>
		<entry>CSL</entry>
	      </row>
	      <row>
		<entry>Czech</entry>
		<entry>CSY</entry>
	      </row>
	      <row>
		<entry>Danish</entry>
		<entry>DAN</entry>
	      </row>
	      <row>
		<entry>Dargwa</entry>
		<entry>DAR</entry>
	      </row>
	      <row>
		<entry>Woods Cree</entry>
		<entry>DCR</entry>
	      </row>
	      <row>
		<entry>German (Standard)</entry>
		<entry>DEU</entry>
	      </row>
	      <row>
		<entry>Dogri</entry>
		<entry>DGR</entry>
	      </row>
	      <row>
		<entry>Dhivehi</entry>
		<entry>DHV</entry>
	      </row>
	      <row>
		<entry>Djerma</entry>
		<entry>DJR</entry>
	      </row>
	      <row>
		<entry>Dangme</entry>
		<entry>DNG</entry>
	      </row>
	      <row>
		<entry>Dinka</entry>
		<entry>DNK</entry>
	      </row>
	      <row>
		<entry>Dungan</entry>
		<entry>DUN</entry>
	      </row>
	      <row>
		<entry>Dzongkha</entry>
		<entry>DZN</entry>
	      </row>
	      <row>
		<entry>Ebira</entry>
		<entry>EBI</entry>
	      </row>
	      <row>
		<entry>Eastern Cree</entry>
		<entry>ECR</entry>
	      </row>
	      <row>
		<entry>Edo</entry>
		<entry>EDO</entry>
	      </row>
	      <row>
		<entry>Efik</entry>
		<entry>EFI</entry>
	      </row>
	      <row>
		<entry>Greek</entry>
		<entry>ELL</entry>
	      </row>
	      <row>
		<entry>English</entry>
		<entry>ENG</entry>
	      </row>
	      <row>
		<entry>Erzya</entry>
		<entry>ERZ</entry>
	      </row>
	      <row>
		<entry>Spanish</entry>
		<entry>ESP</entry>
	      </row>
	      <row>
		<entry>Estonian</entry>
		<entry>ETI</entry>
	      </row>
	      <row>
		<entry>Basque</entry>
		<entry>EUQ</entry>
	      </row>
	      <row>
		<entry>Evenki</entry>
		<entry>EVK</entry>
	      </row>
	      <row>
		<entry>Even</entry>
		<entry>EVN</entry>
	      </row>
	      <row>
		<entry>Ewe</entry>
		<entry>EWE</entry>
	      </row>
	      <row>
		<entry>French Antillean</entry>
		<entry>FAN</entry>
	      </row>
	      <row>
		<entry>Farsi</entry>
		<entry>FAR</entry>
	      </row>
	      <row>
		<entry>Finnish</entry>
		<entry>FIN</entry>
	      </row>
	      <row>
		<entry>Fijian</entry>
		<entry>FJI</entry>
	      </row>
	      <row>
		<entry>Flemish</entry>
		<entry>FLE</entry>
	      </row>
	      <row>
		<entry>Forest Nenets</entry>
		<entry>FNE</entry>
	      </row>
	      <row>
		<entry>Fon</entry>
		<entry>FON</entry>
	      </row>
	      <row>
		<entry>Faroese</entry>
		<entry>FOS</entry>
	      </row>
	      <row>
		<entry>French (Standard)</entry>
		<entry>FRA</entry>
	      </row>
	      <row>
		<entry>Frisian</entry>
		<entry>FRI</entry>
	      </row>
	      <row>
		<entry>Friulian</entry>
		<entry>FRL</entry>
	      </row>
	      <row>
		<entry>Futa</entry>
		<entry>FTA</entry>
	      </row>
	      <row>
		<entry>Fulani</entry>
		<entry>FUL</entry>
	      </row>
	      <row>
		<entry>Ga</entry>
		<entry>GAD</entry>
	      </row>
	      <row>
		<entry>Gaelic</entry>
		<entry>GAE</entry>
	      </row>
	      <row>
		<entry>Gagauz</entry>
		<entry>GAG</entry>
	      </row>
	      <row>
		<entry>Galician</entry>
		<entry>GAL</entry>
	      </row>
	      <row>
		<entry>Garshuni</entry>
		<entry>GAR</entry>
	      </row>
	      <row>
		<entry>Garhwali</entry>
		<entry>GAW</entry>
	      </row>
	      <row>
		<entry>Ge'ez</entry>
		<entry>GEZ</entry>
	      </row>
	      <row>
		<entry>Gilyak</entry>
		<entry>GIL</entry>
	      </row>
	      <row>
		<entry>Gumuz</entry>
		<entry>GMZ</entry>
	      </row>
	      <row>
		<entry>Gondi</entry>
		<entry>GON</entry>
	      </row>
	      <row>
		<entry>Greenlandic</entry>
		<entry>GRN</entry>
	      </row>
	      <row>
		<entry>Garo</entry>
		<entry>GRO</entry>
	      </row>
	      <row>
		<entry>Guarani</entry>
		<entry>GUA</entry>
	      </row>
	      <row>
		<entry>Gujarati</entry>
		<entry>GUJ</entry>
	      </row>
	      <row>
		<entry>Haitian</entry>
		<entry>HAI</entry>
	      </row>
	      <row>
		<entry>Halam</entry>
		<entry>HAL</entry>
	      </row>
	      <row>
		<entry>Harauti</entry>
		<entry>HAR</entry>
	      </row>
	      <row>
		<entry>Hausa</entry>
		<entry>HAU</entry>
	      </row>
	      <row>
		<entry>Hawaiin</entry>
		<entry>HAW</entry>
	      </row>
	      <row>
		<entry>Hammer-Banna</entry>
		<entry>HBN</entry>
	      </row>
	      <row>
		<entry>Hiligaynon</entry>
		<entry>HIL</entry>
	      </row>
	      <row>
		<entry>Hindi</entry>
		<entry>HIN</entry>
	      </row>
	      <row>
		<entry>High Mari</entry>
		<entry>HMA</entry>
	      </row>
	      <row>
		<entry>Hindko</entry>
		<entry>HND</entry>
	      </row>
	      <row>
		<entry>Ho</entry>
		<entry>HO </entry>
	      </row>
	      <row>
		<entry>Harari</entry>
		<entry>HRI</entry>
	      </row>
	      <row>
		<entry>Croatian</entry>
		<entry>HRV</entry>
	      </row>
	      <row>
		<entry>Hungarian</entry>
		<entry>HUN</entry>
	      </row>
	      <row>
		<entry>Armenian</entry>
		<entry>HYE</entry>
	      </row>
	      <row>
		<entry>Igbo</entry>
		<entry>IBO</entry>
	      </row>
	      <row>
		<entry>Ijo</entry>
		<entry>IJO</entry>
	      </row>
	      <row>
		<entry>Ilokano</entry>
		<entry>ILO</entry>
	      </row>
	      <row>
		<entry>Indonesian</entry>
		<entry>IND</entry>
	      </row>
	      <row>
		<entry>Ingush</entry>
		<entry>ING</entry>
	      </row>
	      <row>
		<entry>Inuktitut</entry>
		<entry>INU</entry>
	      </row>
	      <row>
		<entry>Irish</entry>
		<entry>IRI</entry>
	      </row>
	      <row>
		<entry>Irish Traditional</entry>
		<entry>IRT</entry>
	      </row>
	      <row>
		<entry>Icelandic</entry>
		<entry>ISL</entry>
	      </row>
	      <row>
		<entry>Inari Sami</entry>
		<entry>ISM</entry>
	      </row>
	      <row>
		<entry>Italian</entry>
		<entry>ITA</entry>
	      </row>
	      <row>
		<entry>Hebrew</entry>
		<entry>IWR</entry>
	      </row>
	      <row>
		<entry>Javanese</entry>
		<entry>JAV</entry>
	      </row>
	      <row>
		<entry>Yiddish</entry>
		<entry>JII</entry>
	      </row>
	      <row>
		<entry>Japanese</entry>
		<entry>JAN</entry>
	      </row>
	      <row>
		<entry>Judezmo</entry>
		<entry>JUD</entry>
	      </row>
	      <row>
		<entry>Jula</entry>
		<entry>JUL</entry>
	      </row>
	      <row>
		<entry>Kabardian</entry>
		<entry>KAB</entry>
	      </row>
	      <row>
		<entry>Kachchi</entry>
		<entry>KAC</entry>
	      </row>
	      <row>
		<entry>Kalenjin</entry>
		<entry>KAL</entry>
	      </row>
	      <row>
		<entry>Kannada</entry>
		<entry>KAN</entry>
	      </row>
	      <row>
		<entry>Karachay</entry>
		<entry>KAR</entry>
	      </row>
	      <row>
		<entry>Georgian</entry>
		<entry>KAT</entry>
	      </row>
	      <row>
		<entry>Kazakh</entry>
		<entry>KAZ</entry>
	      </row>
	      <row>
		<entry>Kebena</entry>
		<entry>KEB</entry>
	      </row>
	      <row>
		<entry>Khutsuri Georgian</entry>
		<entry>KGE</entry>
	      </row>
	      <row>
		<entry>Khakass</entry>
		<entry>KHA</entry>
	      </row>
	      <row>
		<entry>Khanty-Kazim</entry>
		<entry>KHK</entry>
	      </row>
	      <row>
		<entry>Khmer</entry>
		<entry>KHM</entry>
	      </row>
	      <row>
		<entry>Khanty-Shurishkar</entry>
		<entry>KHS</entry>
	      </row>
	      <row>
		<entry>Khanty-Vakhi</entry>
		<entry>KHV</entry>
	      </row>
	      <row>
		<entry>Khowar</entry>
		<entry>KHW</entry>
	      </row>
	      <row>
		<entry>Kikuyu</entry>
		<entry>KIK</entry>
	      </row>
	      <row>
		<entry>Kirghiz</entry>
		<entry>KIR</entry>
	      </row>
	      <row>
		<entry>Kisii</entry>
		<entry>KIS</entry>
	      </row>
	      <row>
		<entry>Kokni</entry>
		<entry>KKN</entry>
	      </row>
	      <row>
		<entry>Kalmyk</entry>
		<entry>KLM</entry>
	      </row>
	      <row>
		<entry>Kamba</entry>
		<entry>KMB</entry>
	      </row>
	      <row>
		<entry>Kumaoni</entry>
		<entry>KMN</entry>
	      </row>
	      <row>
		<entry>Komo</entry>
		<entry>KMO</entry>
	      </row>
	      <row>
		<entry>Komso</entry>
		<entry>KMS</entry>
	      </row>
	      <row>
		<entry>Kanuri</entry>
		<entry>KNR</entry>
	      </row>
	      <row>
		<entry>Kodagu</entry>
		<entry>KOD</entry>
	      </row>
	      <row>
		<entry>Konkani</entry>
		<entry>KOK</entry>
	      </row>
	      <row>
		<entry>Kikongo</entry>
		<entry>KON</entry>
	      </row>
	      <row>
		<entry>Komi-Permyak</entry>
		<entry>KOP</entry>
	      </row>
	      <row>
		<entry>Korean</entry>
		<entry>KOR</entry>
	      </row>
	      <row>
		<entry>Komi-Zyrian</entry>
		<entry>KOZ</entry>
	      </row>
	      <row>
		<entry>Kpelle</entry>
		<entry>KPL</entry>
	      </row>
	      <row>
		<entry>Krio</entry>
		<entry>KRI</entry>
	      </row>
	      <row>
		<entry>Karakalpak</entry>
		<entry>KRK</entry>
	      </row>
	      <row>
		<entry>Karelian</entry>
		<entry>KRL</entry>
	      </row>
	      <row>
		<entry>Karaim</entry>
		<entry>KRM</entry>
	      </row>
	      <row>
		<entry>Karen</entry>
		<entry>KRN</entry>
	      </row>
	      <row>
		<entry>Koorete</entry>
		<entry>KRT</entry>
	      </row>
	      <row>
		<entry>Kashmiri</entry>
		<entry>KSH</entry>
	      </row>
	      <row>
		<entry>Khasi</entry>
		<entry>KSI</entry>
	      </row>
	      <row>
		<entry>Kildin Sami</entry>
		<entry>KSM</entry>
	      </row>
	      <row>
		<entry>Kui</entry>
		<entry>KUI</entry>
	      </row>
	      <row>
		<entry>Kulvi</entry>
		<entry>KUL</entry>
	      </row>
	      <row>
		<entry>Kumyk</entry>
		<entry>KUM</entry>
	      </row>
	      <row>
		<entry>Kurdish</entry>
		<entry>KUR</entry>
	      </row>
	      <row>
		<entry>Kurukh</entry>
		<entry>KUU</entry>
	      </row>
	      <row>
		<entry>Kuy</entry>
		<entry>KUY</entry>
	      </row>
	      <row>
		<entry>Koryak</entry>
		<entry>KYK</entry>
	      </row>
	      <row>
		<entry>Ladin</entry>
		<entry>LAD</entry>
	      </row>
	      <row>
		<entry>Lahuli</entry>
		<entry>LAH</entry>
	      </row>
	      <row>
		<entry>Lak</entry>
		<entry>LAK</entry>
	      </row>
	      <row>
		<entry>Lambani</entry>
		<entry>LAM</entry>
	      </row>
	      <row>
		<entry>Lao</entry>
		<entry>LAO</entry>
	      </row>
	      <row>
		<entry>Latin</entry>
		<entry>LAT</entry>
	      </row>
	      <row>
		<entry>Laz</entry>
		<entry>LAZ</entry>
	      </row>
	      <row>
		<entry>L-Cree</entry>
		<entry>LCR</entry>
	      </row>
	      <row>
		<entry>Ladakhi</entry>
		<entry>LDK</entry>
	      </row>
	      <row>
		<entry>Lezgi</entry>
		<entry>LEZ</entry>
	      </row>
	      <row>
		<entry>Lingala</entry>
		<entry>LIN</entry>
	      </row>
	      <row>
		<entry>Low Mari</entry>
		<entry>LMA</entry>
	      </row>
	      <row>
		<entry>Limbu</entry>
		<entry>LMB</entry>
	      </row>
	      <row>
		<entry>Lomwe</entry>
		<entry>LMW</entry>
	      </row>
	      <row>
		<entry>Lower Sorbian</entry>
		<entry>LSB</entry>
	      </row>
	      <row>
		<entry>Lule Sami</entry>
		<entry>LSM</entry>
	      </row>
	      <row>
		<entry>Lithuanian</entry>
		<entry>LTH</entry>
	      </row>
	      <row>
		<entry>Luba</entry>
		<entry>LUB</entry>
	      </row>
	      <row>
		<entry>Luganda</entry>
		<entry>LUG</entry>
	      </row>
	      <row>
		<entry>Luhya</entry>
		<entry>LUH</entry>
	      </row>
	      <row>
		<entry>Luo</entry>
		<entry>LUO</entry>
	      </row>
	      <row>
		<entry>Latvian</entry>
		<entry>LVI</entry>
	      </row>
	      <row>
		<entry>Majang</entry>
		<entry>MAJ</entry>
	      </row>
	      <row>
		<entry>Makua</entry>
		<entry>MAK</entry>
	      </row>
	      <row>
		<entry>Malayalam Traditional</entry>
		<entry>MAL</entry>
	      </row>
	      <row>
		<entry>Mansi</entry>
		<entry>MAN</entry>
	      </row>
	      <row>
		<entry>Marathi</entry>
		<entry>MAR</entry>
	      </row>
	      <row>
		<entry>Marwari</entry>
		<entry>MAW</entry>
	      </row>
	      <row>
		<entry>Mbundu</entry>
		<entry>MBN</entry>
	      </row>
	      <row>
		<entry>Manchu</entry>
		<entry>MCH</entry>
	      </row>
	      <row>
		<entry>Moose Cree</entry>
		<entry>MCR</entry>
	      </row>
	      <row>
		<entry>Mende</entry>
		<entry>MDE</entry>
	      </row>
	      <row>
		<entry>Me'en</entry>
		<entry>MEN</entry>
	      </row>
	      <row>
		<entry>Mizo</entry>
		<entry>MIZ</entry>
	      </row>
	      <row>
		<entry>Macedonian</entry>
		<entry>MKD</entry>
	      </row>
	      <row>
		<entry>Male</entry>
		<entry>MLE</entry>
	      </row>
	      <row>
		<entry>Malagasy</entry>
		<entry>MLG</entry>
	      </row>
	      <row>
		<entry>Malinke</entry>
		<entry>MLN</entry>
	      </row>
	      <row>
		<entry>Malayalam Reformed</entry>
		<entry>MLR</entry>
	      </row>
	      <row>
		<entry>Malay</entry>
		<entry>MLY</entry>
	      </row>
	      <row>
		<entry>Mandinka</entry>
		<entry>MND</entry>
	      </row>
	      <row>
		<entry>Mongolian</entry>
		<entry>MNG</entry>
	      </row>
	      <row>
		<entry>Manipuri</entry>
		<entry>MNI</entry>
	      </row>
	      <row>
		<entry>Maninka</entry>
		<entry>MNK</entry>
	      </row>
	      <row>
		<entry>Manx Gaelic</entry>
		<entry>MNX</entry>
	      </row>
	      <row>
		<entry>Moksha</entry>
		<entry>MOK</entry>
	      </row>
	      <row>
		<entry>Moldavian</entry>
		<entry>MOL</entry>
	      </row>
	      <row>
		<entry>Mon</entry>
		<entry>MON</entry>
	      </row>
	      <row>
		<entry>Moroccan</entry>
		<entry>MOR</entry>
	      </row>
	      <row>
		<entry>Maori</entry>
		<entry>MRI</entry>
	      </row>
	      <row>
		<entry>Maithili</entry>
		<entry>MTH</entry>
	      </row>
	      <row>
		<entry>Maltese</entry>
		<entry>MTS</entry>
	      </row>
	      <row>
		<entry>Mundari</entry>
		<entry>MUN</entry>
	      </row>
	      <row>
		<entry>Naga-Assamese</entry>
		<entry>NAG</entry>
	      </row>
	      <row>
		<entry>Nanai</entry>
		<entry>NAN</entry>
	      </row>
	      <row>
		<entry>Naskapi</entry>
		<entry>NAS</entry>
	      </row>
	      <row>
		<entry>N-Cree</entry>
		<entry>NCR</entry>
	      </row>
	      <row>
		<entry>Ndebele</entry>
		<entry>NDB</entry>
	      </row>
	      <row>
		<entry>Ndonga</entry>
		<entry>NDG</entry>
	      </row>
	      <row>
		<entry>Nepali</entry>
		<entry>NEP</entry>
	      </row>
	      <row>
		<entry>Newari</entry>
		<entry>NEW</entry>
	      </row>
	      <row>
		<entry>Norway House Cree</entry>
		<entry>NHC</entry>
	      </row>
	      <row>
		<entry>Nisi</entry>
		<entry>NIS</entry>
	      </row>
	      <row>
		<entry>Niuean</entry>
		<entry>NIU</entry>
	      </row>
	      <row>
		<entry>Nkole</entry>
		<entry>NKL</entry>
	      </row>
	      <row>
		<entry>Dutch</entry>
		<entry>NLD</entry>
	      </row>
	      <row>
		<entry>Nogai</entry>
		<entry>NOG</entry>
	      </row>
	      <row>
		<entry>Norwegian</entry>
		<entry>NOR</entry>
	      </row>
	      <row>
		<entry>Northern Sami</entry>
		<entry>NSM</entry>
	      </row>
	      <row>
		<entry>Northern Tai</entry>
		<entry>NTA</entry>
	      </row>
	      <row>
		<entry>Esperanto</entry>
		<entry>NTO</entry>
	      </row>
	      <row>
		<entry>Nynorsk</entry>
		<entry>NYN</entry>
	      </row>
	      <row>
		<entry>Oji-Cree</entry>
		<entry>OCR</entry>
	      </row>
	      <row>
		<entry>Ojibway</entry>
		<entry>OJB</entry>
	      </row>
	      <row>
		<entry>Oriya</entry>
		<entry>ORI</entry>
	      </row>
	      <row>
		<entry>Oromo</entry>
		<entry>ORO</entry>
	      </row>
	      <row>
		<entry>Ossetian</entry>
		<entry>OSS</entry>
	      </row>
	      <row>
		<entry>Palestinian Aramaic</entry>
		<entry>PAA</entry>
	      </row>
	      <row>
		<entry>Pali</entry>
		<entry>PAL</entry>
	      </row>
	      <row>
		<entry>Punjabi</entry>
		<entry>PAN</entry>
	      </row>
	      <row>
		<entry>Palpa</entry>
		<entry>PAP</entry>
	      </row>
	      <row>
		<entry>Pashto</entry>
		<entry>PAS</entry>
	      </row>
	      <row>
		<entry>Polytonic Greek</entry>
		<entry>PGR</entry>
	      </row>
	      <row>
		<entry>Pilipino</entry>
		<entry>PIL</entry>
	      </row>
	      <row>
		<entry>Palaung</entry>
		<entry>PLG</entry>
	      </row>
	      <row>
		<entry>Polish</entry>
		<entry>PLK</entry>
	      </row>
	      <row>
		<entry>Provencal</entry>
		<entry>PRO</entry>
	      </row>
	      <row>
		<entry>Portuguese</entry>
		<entry>PTG</entry>
	      </row>
	      <row>
		<entry>Chin</entry>
		<entry>QIN</entry>
	      </row>
	      <row>
		<entry>Rajasthani</entry>
		<entry>RAJ</entry>
	      </row>
	      <row>
		<entry>R-Cree</entry>
		<entry>RCR</entry>
	      </row>
	      <row>
		<entry>Russian Buriat</entry>
		<entry>RBU</entry>
	      </row>
	      <row>
		<entry>Riang</entry>
		<entry>RIA</entry>
	      </row>
	      <row>
		<entry>Rhaeto-Romanic</entry>
		<entry>RMS</entry>
	      </row>
	      <row>
		<entry>Romanian</entry>
		<entry>ROM</entry>
	      </row>
	      <row>
		<entry>Romany</entry>
		<entry>ROY</entry>
	      </row>
	      <row>
		<entry>Rusyn</entry>
		<entry>RSY</entry>
	      </row>
	      <row>
		<entry>Ruanda</entry>
		<entry>RUA</entry>
	      </row>
	      <row>
		<entry>Russian</entry>
		<entry>RUS</entry>
	      </row>
	      <row>
		<entry>Sadri</entry>
		<entry>SAD</entry>
	      </row>
	      <row>
		<entry>Sanskrit</entry>
		<entry>SAN</entry>
	      </row>
	      <row>
		<entry>Santali</entry>
		<entry>SAT</entry>
	      </row>
	      <row>
		<entry>Sayisi</entry>
		<entry>SAY</entry>
	      </row>
	      <row>
		<entry>Sekota</entry>
		<entry>SEK</entry>
	      </row>
	      <row>
		<entry>Selkup</entry>
		<entry>SEL</entry>
	      </row>
	      <row>
		<entry>Sango</entry>
		<entry>SGO</entry>
	      </row>
	      <row>
		<entry>Shan</entry>
		<entry>SHN</entry>
	      </row>
	      <row>
		<entry>Sibe</entry>
		<entry>SIB</entry>
	      </row>
	      <row>
		<entry>Sidamo</entry>
		<entry>SID</entry>
	      </row>
	      <row>
		<entry>Silte Gurage</entry>
		<entry>SIG</entry>
	      </row>
	      <row>
		<entry>Skolt Sami</entry>
		<entry>SKS</entry>
	      </row>
	      <row>
		<entry>Slovak</entry>
		<entry>SKY</entry>
	      </row>
	      <row>
		<entry>Slavey</entry>
		<entry>SLA</entry>
	      </row>
	      <row>
		<entry>Slovenian</entry>
		<entry>SLV</entry>
	      </row>
	      <row>
		<entry>Somali</entry>
		<entry>SML</entry>
	      </row>
	      <row>
		<entry>Samoan</entry>
		<entry>SMO</entry>
	      </row>
	      <row>
		<entry>Sena</entry>
		<entry>SNA</entry>
	      </row>
	      <row>
		<entry>Sindhi</entry>
		<entry>SND</entry>
	      </row>
	      <row>
		<entry>Sinhalese</entry>
		<entry>SNH</entry>
	      </row>
	      <row>
		<entry>Soninke</entry>
		<entry>SNK</entry>
	      </row>
	      <row>
		<entry>Sodo Gurage</entry>
		<entry>SOG</entry>
	      </row>
	      <row>
		<entry>Sotho</entry>
		<entry>SOT</entry>
	      </row>
	      <row>
		<entry>Albanian</entry>
		<entry>SQI</entry>
	      </row>
	      <row>
		<entry>Serbian</entry>
		<entry>SRB</entry>
	      </row>
	      <row>
		<entry>Saraiki</entry>
		<entry>SRK</entry>
	      </row>
	      <row>
		<entry>Serer</entry>
		<entry>SRR</entry>
	      </row>
	      <row>
		<entry>South Slavey</entry>
		<entry>SSL</entry>
	      </row>
	      <row>
		<entry>Southern Sami</entry>
		<entry>SSM</entry>
	      </row>
	      <row>
		<entry>Suri</entry>
		<entry>SUR</entry>
	      </row>
	      <row>
		<entry>Svan</entry>
		<entry>SVA</entry>
	      </row>
	      <row>
		<entry>Swedish</entry>
		<entry>SVE</entry>
	      </row>
	      <row>
		<entry>Swadaya Aramaic</entry>
		<entry>SWA</entry>
	      </row>
	      <row>
		<entry>Swahili</entry>
		<entry>SWK</entry>
	      </row>
	      <row>
		<entry>Swazi</entry>
		<entry>SWZ</entry>
	      </row>
	      <row>
		<entry>Sutu</entry>
		<entry>SXT</entry>
	      </row>
	      <row>
		<entry>Syriac</entry>
		<entry>SYR</entry>
	      </row>
	      <row>
		<entry>Tabasaran</entry>
		<entry>TAB</entry>
	      </row>
	      <row>
		<entry>Tajiki</entry>
		<entry>TAJ</entry>
	      </row>
	      <row>
		<entry>Tamil</entry>
		<entry>TAM</entry>
	      </row>
	      <row>
		<entry>Tatar</entry>
		<entry>TAT</entry>
	      </row>
	      <row>
		<entry>TH-Cree</entry>
		<entry>TCR</entry>
	      </row>
	      <row>
		<entry>Telugu</entry>
		<entry>TEL</entry>
	      </row>
	      <row>
		<entry>Tongan</entry>
		<entry>TGN</entry>
	      </row>
	      <row>
		<entry>Tigre</entry>
		<entry>TGR</entry>
	      </row>
	      <row>
		<entry>Tigrinya</entry>
		<entry>TGY</entry>
	      </row>
	      <row>
		<entry>Thai</entry>
		<entry>THA</entry>
	      </row>
	      <row>
		<entry>Tahitian</entry>
		<entry>THT</entry>
	      </row>
	      <row>
		<entry>Tibetan</entry>
		<entry>TIB</entry>
	      </row>
	      <row>
		<entry>Turkmen</entry>
		<entry>TKM</entry>
	      </row>
	      <row>
		<entry>Temne</entry>
		<entry>TMN</entry>
	      </row>
	      <row>
		<entry>Tswana</entry>
		<entry>TNA</entry>
	      </row>
	      <row>
		<entry>Tundra Nenets</entry>
		<entry>TNE</entry>
	      </row>
	      <row>
		<entry>Tonga</entry>
		<entry>TNG</entry>
	      </row>
	      <row>
		<entry>Todo</entry>
		<entry>TOD</entry>
	      </row>
	      <row>
		<entry>Turkish</entry>
		<entry>TRK</entry>
	      </row>
	      <row>
		<entry>Tsonga</entry>
		<entry>TSG</entry>
	      </row>
	      <row>
		<entry>Turoyo Aramaic</entry>
		<entry>TUA</entry>
	      </row>
	      <row>
		<entry>Tulu</entry>
		<entry>TUL</entry>
	      </row>
	      <row>
		<entry>Tuvin</entry>
		<entry>TUV</entry>
	      </row>
	      <row>
		<entry>Twi</entry>
		<entry>TWI</entry>
	      </row>
	      <row>
		<entry>Udmurt</entry>
		<entry>UDM</entry>
	      </row>
	      <row>
		<entry>Ukrainian</entry>
		<entry>UKR</entry>
	      </row>
	      <row>
		<entry>Urdu</entry>
		<entry>URD</entry>
	      </row>
	      <row>
		<entry>Upper Sorbian</entry>
		<entry>USB</entry>
	      </row>
	      <row>
		<entry>Uyghur</entry>
		<entry>UYG</entry>
	      </row>
	      <row>
		<entry>Uzbek</entry>
		<entry>UZB</entry>
	      </row>
	      <row>
		<entry>Venda</entry>
		<entry>VEN</entry>
	      </row>
	      <row>
		<entry>Vietnamese</entry>
		<entry>VIT</entry>
	      </row>
	      <row>
		<entry>Wa</entry>
		<entry>WA </entry>
	      </row>
	      <row>
		<entry>Wagdi</entry>
		<entry>WAG</entry>
	      </row>
	      <row>
		<entry>West-Cree</entry>
		<entry>WCR</entry>
	      </row>
	      <row>
		<entry>Welsh</entry>
		<entry>WEL</entry>
	      </row>
	      <row>
		<entry>Wolof</entry>
		<entry>WLF</entry>
	      </row>
	      <row>
		<entry>Xhosa</entry>
		<entry>XHS</entry>
	      </row>
	      <row>
		<entry>Yakut</entry>
		<entry>YAK</entry>
	      </row>
	      <row>
		<entry>Yoruba</entry>
		<entry>YBA</entry>
	      </row>
	      <row>
		<entry>Y-Cree</entry>
		<entry>YCR</entry>
	      </row>
	      <row>
		<entry>Yi Classic</entry>
		<entry>YIC</entry>
	      </row>
	      <row>
		<entry>Yi Modern</entry>
		<entry>YIM</entry>
	      </row>
	      <row>
		<entry>Chinese Phonetic</entry>
		<entry>ZHP</entry>
	      </row>
	      <row>
		<entry>Chinese Simplified</entry>
		<entry>ZHS</entry>
	      </row>
	      <row>
		<entry>Chinese Traditional</entry>
		<entry>ZHT</entry>
	      </row>
	      <row>
		<entry>Zande</entry>
		<entry>ZND</entry>
	      </row>
	      <row>
		<entry>Zulu</entry>
		<entry>ZUL</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </section>
    </section>

    <!--======================================================================-->
      <section role='fragment'>
      <title>Baseline tags</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This section defines the standard OpenType Layout
	  baseline tags that Microsoft supports. A registered baseline
	  tag has a specific meaning when used in the horizontal
	  writing direction (used in the <ottable>BASE</ottable> table's HorizAxis
	  table), vertical writing direction (used in the <ottable>BASE</ottable>
	  table's VertAxis table), or both, and conveys information to
	  font users about a baseline's use. For example, the "romn"
	  baseline tag is commonly used to identify the baseline to
	  layout Latin text in the horizontal, vertical, or both
	  directions for Latin text layout. For compatibility and ease
	  of use, Microsoft encourages font developers to use
	  registered baseline tags.</para>


	<para>This version of the Tag Registry identifies the
	  baselines that Microsoft has implemented to date. All
	  baseline tags are 4-byte character strings composed of a
	  limited set of ASCII characters in the 0x20-0x7E
	  range. Baseline tags consist of four lowercase
	  letters. </para>

	<table>
	  <title>Registered baseline tags</title>

	  <tgroup cols='3'>
	    <thead>
	      <row>
		<entry>Baseline Tag</entry>
		<entry>Baseline for HorizAxis</entry>
		<entry>Baseline for VertAxis</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>hang</entry>
		<entry>The hanging baseline. This is the horizontal
		  line from which syllables seem to hang in Tibetan
		script.</entry>
		<entry>The hanging baseline, (which now appears
		vertical) for Tibetan characters rotated 90 degrees
		clockwise, for vertical writing mode.</entry>
	      </row>
	      <row>
		<entry>icfb</entry>
		<entry>deographic character face bottom edge
		baseline. (See section Ideographic Character Face
		below for usage.)</entry> <entry>Ideographic character
		face left edge baseline.  (See section Ideographic
		Character Face below for usage.)</entry>
	      </row>
	      <row>
		<entry>icft</entry> <entry>Ideographic character face
		top edge baseline.  (See section Ideographic Character
		Face below for usage.)</entry> <entry>Ideographic
		character face right edge baseline.  (See section
		Ideographic Character Face below for usage.)</entry>
	      </row>
	      <row>
		<entry>ideo</entry> <entry>Ideographic em-box bottom
		edge baseline.  (See section Ideographic Em-Box below
		for usage.)</entry> <entry>Ideographic em-box left
		edge baseline. If this tag is present in the VertAxis,
		the value must be set to 0.  (See section Ideographic
		Em-Box below for usage.)</entry>
	      </row>
	      <row>
		<entry>idtp</entry> <entry>Ideographic em-box top edge
		baseline. (See section Ideographic Em-Box below for
		usage.)</entry> <entry>Ideographic em-box right edge
		baseline. If this tag is present in the VertAxis, the
		value is strongly recommended to be set to
		head.unitsPerEm. (See section Ideographic Em-Box below
		for usage.)</entry>
	      </row>
	      <row>
		<entry>math</entry> <entry>The baseline about which
		mathematical characters are centered.</entry>
		<entry>The baseline about which mathematical
		characters, when rotated 90 degrees clockwise for
		vertical writing mode, are centered.</entry>
	      </row>
	      <row>
		<entry>romn</entry> <entry>The baseline used by simple
		alphabetic scripts such as Latin, Cyrillic and
		Greek.</entry> <entry>The alphabetic baseline for
		characters rotated 90 degrees clockwise for vertical
		writing mode. (This would not apply to alphabetic
		characters that remain upright in vertical writing
		mode, since these characters are not rotated.)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<bridgehead>Ideographic Em-Box</bridgehead>

	<para>The notation &lt;Axis>.&lt;Baseline Tag> is used in the
	  following description to mean the baseline tag as defined in
	  the specified axis. For example, HorizAxis.ideo means the
	  ideo baseline tag as defined in the HorizAxis of the BASE
	  table. See above for a list of registered baseline
	  tags.</para>

	<para>A font&#x2019;s ideographic em-box is the rectangle that
	  defines a standard escapement around the full-width
	  ideographic glyphs of the font, for both the horizontal and
	  vertical writing directions. It is usually a square, but may
	  be non-square as in the case of fonts used in Japanese
	  newspaper layout that have a vertically condensed
	  design.</para>

	<para>The left, right, top and bottom edges of the ideographic
	  em-box are to be determined as follows:</para>

<literallayout>
ideoEmboxLeft = 0

If HorizAxis.ideo defined:

    ideoEmboxBottom = HorizAxis.ideo

    If HorizAxis.idtp defined:
        ideoEmboxTop = HorizAxis.idtp
    Else:
        ideoEmboxTop = HorizAxis.ideo + head.unitsPerEm

    If VertAxis.idtp defined:
        ideoEmboxRight = VertAxis.idtp
    Else:
        ideoEmboxRight = head.unitsPerEm

    If VertAxis.ideo defined and non-zero:
        Warning: Bad VertAxis.ideo value

Else If this is a CJK font:

    ideoEmboxBottom = OS/2.sTypoDescender
    ideoEmboxTop = OS/2.sTypoAscender
    ideoEmboxRight = head.unitsPerEm

Else:
    ideoEmbox cannot be determined for this font
</literallayout>


	<para>Determining whether a font is CJK (Chinese, Japanese, or
	  Korean) or not, as in the second-last "Else" clause above,
	  can be done by checking the CJK-related bits of the
	  OS/2.ulUnicodeRange fields.</para>

	<para>Note that font designers can specify a HorizAxis.ideo
	  baseline in their non-CJK fonts; this can be used by
	  applications when aligning the font with an ideographic font
	  used on the same line of text, when the user has specified
	  ideographic em-box alignment.</para>

	<para>The ideographic em-box center baseline is defined as
	  halfway between the ideographic em-box top and bottom
	  baselines in the horizontal axis, and halfway between the
	  ideographic em-box left and right baselines in the vertical
	  axis. These center baselines are defined in whole character
	  units. The division used in the calculation must round to
	  the character unit nearest 0 if needed. Thus, for maximal
	  precision of center baseline placement, vendors should
	  ensure that opposite edges of the ideographic em-box box are
	  an even number of character units apart.</para>

	<para>Example:</para>

	<para>The values of the ideographic baseline tags for the
	  Kozuka Mincho font family (designed on a 1000-unit em) are:
	  HorizAxis.ideo = -120; HorizAxis.idtp = 880. Since this
	  describes a square ideographic em-box, it is sufficient to
	  record only the following: HorizAxis.ideo = -120. If
	  HorizAxis.ideo is not present, then the following will be
	  used for the ideographic em-box bottom and top, since this
	  is a CJK font: OS/2.sTypoDescender = -120;
	  OS/2.sTypoAscender = 880.</para>

	<para>Compatibility notes:

	  <orderedlist>
	    <listitem>
	      <para>Most applications expect the width of full-width
	      ideographs in a CJK font to be exactly one em, thus it
	      is strongly recommended that VertAxis.idtp, if present,
	      be set to head.unitsPerEm. (The idtp baseline tag was
	      introduced in OpenType 1.3.)</para>
	    </listitem>

	    <listitem>
	      <para>While the OpenType specification allows for CJK
		fonts' OS/2.sTypoDescender and OS/2.sTypoAscender
		fields to specify metrics different from the
		HorizAxis.ideo and HorizAxis.idtp in the <ottable>BASE</ottable> table,
		CJK font developers should be aware that existing
		applications may not read the <ottable>BASE</ottable> table at all but
		simply use the OS/2.sTypoDescender and
		OS/2.sTypoAscender fields to describe the bottom and
		top edges of the ideographic em-box. If developers
		want their fonts to work correctly with such
		applications, they should ensure that any ideographic
		em-box values in the <ottable>BASE</ottable> table of their CJK fonts
		describe the same bottom and top edges as the
		OS/2.sTypoDescender and OS/2.sTypoAscender fields.</para>
	    </listitem>

	    <listitem>
	      <para>Applications on platforms other than Windows that
	      don't parse the <ottable>OS/2</ottable> table won't have
	      access to the OS/2.sTypoDescender and OS/2.sTypoAscender
	      fields, since these metrics are exposed only through
	      Windows APIs currently. Thus, CJK fonts will typically
	      have the same descender value recorded in
	      hhea.Descender, OS/2.sTypoDescender, and HorizAxis.ideo
	      (if present), and the same Ascender value recorded in
	      hhea.Ascender, OS/2.sTypoAscender, and HorizAxis.idtp
	      (if present).</para>
	    </listitem>
	  </orderedlist></para>

	  <para>See the section "OpenType CJK Font Guidelines"
	    for more information about constructing CJK
	    fonts.</para>


	<bridgehead>Ideographic Character Face</bridgehead>

	<para>he notation &lt;Axis>.&lt;Baseline Tag> is used in the
	  following description to mean the baseline tag as defined in
	  the specified axis. For example, HorizAxis.icfb means the
	  icfb baseline tag as defined in the HorizAxis of the BASE
	  table. See above for a list of registered baseline
	  tags.</para>

	<para>The ideographic character face (ICF), also known as the
	average character face (ACF), specifies the approximate
	bounding box of the full-width ideographic and kana glyphs in
	a CJK font. (This is different from the FontBBox, as described
	in the PostScript programming language, which is the bounding
	box of all glyphs in the font.) In Japanese, the term for ICF
	is heikin jizura.</para>

	<para>It is typically expressed as a percentage that
	represents the ratio of the length of an ICF box edge to the
	length of an ideographic em-box edge, and is conceptualized as
	a square centered within the ideographic em-box. However, in
	OpenType, the ICF box's left, bottom, right, and top edges are
	specified as the VertAxis.icfb, HorizAxis.icfb, VertAxis.icft,
	and HorizAxis.icft baselines, respectively, thus giving font
	designers the flexibility to specify a non-square and/or
	non-centered ICF box.</para>

	<para>Font designers should set the value of the ICF box edges
	based on how tight or loose they want the font to appear when
	text is set with no tracking or kerning (beta gumi in
	Japanese). Therefore, the left-over boundary of the
	ideographic em-box around the ICF box is the default
	escapement of the font.</para>

	<para>Applications can use the ICF box as an alignment tool,
	to ensure that glyphs touch the edges of the text frame and
	page objects are visually aligned to text edges. It is also
	useful for aligning glyphs of different sizes on the same
	line. In Japanese traditional paper-based workflow, the ICF
	box was often used for these purposes. It provides optically
	aligned results that are superior to using the ideographic
	em-box.</para>

	<para>HorizAxis.icfb is the mininum piece of information
	required to define the ICF, in a CJK font. First, the
	ideographic em-box dimensions must be calculated as in the
	section "Ideographic Em-Box" above. The ICF edges are then
	calculated in the following order:</para>

<literallayout>

If HorizAxis.icfb defined:

    icfBottom = HorizAxis.icfb
    margin = HorizAxis.icfb - ideoEmboxBottom

    If HorizAxis.icft defined:
      icfTop = HorizAxis.icft
    Else:
      icfTop = ideoEmboxTop - margin

    If VertAxis.icfb defined:
      icfLeft = VertAxis.icfb
    Else:
      icfLeft = margin

    If VertAxis.icft defined:
      icfRight = VertAxis.icft
    Else:
      icfRight = ideoEmBoxRight - icfLeft

Else:
   ICF cannot be determined for this font
</literallayout>

	<para>For the last case above, i.e. fonts that don't have ICF
	  information in their <ottable>BASE</ottable> table, an
	  application may choose to apply a heuristic such as
	  calculating the bounding box of some or all of the
	  ideographic and kana glyphs, and then averaging its margin
	  with the ideographic em-box.</para>

	<para>The ICF center baseline is defined as halfway between
	the ICF top and bottom baselines in the horizontal axis, and
	halfway between the ICF left and right baselines in the
	vertical axis. These center baselines are defined in whole
	character units. The division used in the calculation must
	round to the character unit nearest 0 if needed. Thus, for
	maximal precision of center baseline placement, vendors should
	ensure that opposite edges of the ICF box are an even number
	of character units apart.</para>

	<para>Example:</para>

	<para>The values of the ICF baselines for the Extra Light and
	Heavy weights of the Kozuka Mincho font family (designed on a
	1000-unit em, with ideographic em-box as given in the example
	in the previous section) are:</para>

<literallayout>
    Kozuka Mincho Extra Light:
    VertAxis.icfb = 41; HorizAxis.icfb = -79;
    VertAxis.icft = 959; HorizAxis.icft = 839.
</literallayout>

	<para>Since this describes a square ICF centered in a square
	ideographic em-box, it is sufficient to record only the
	following:</para>

<literallayout>
    HorizAxis.icfb = -79.
</literallayout>


<literallayout>
    Kozuka Mincho Heavy:
    VertAxis.icfb = 26; HorizAxis.icfb = -94;
    VertAxis.icft = 974; HorizAxis.icft = 854.
</literallayout>

	<para>It is sufficient to record only:</para>

<literallayout>
HorizAxis.icfb = -94.
</literallayout>

	<para>It is strongly recommended that each of the edges of the
	ICF box be equidistant from the corresponding edge of the
	ideographic em-box. Following this will result in more
	predictable results in applications that use these
	values. That is, for fonts based on a square ideographic
	em-box, the ICF box should be a centered square.</para>

	<para>See the section "OpenType CJK Font Guidelines" for more
	  information about constructing CJK fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Feature tags</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Features provide information about how to use the glyphs
	in a font to render a script or language. For example, an
	Arabic font might have a feature for substituting initial
	glyph forms, and a Kanji font might have a feature for
	positioning glyphs vertically. All OpenType Layout features
	define data for glyph substitution, glyph positioning, or
	both.</para>

	<para>Each OpenType Layout feature has a feature tag that
	identifies its typographic function and effects. By examining
	a feature's tag, a text-processing client can determine what a
	feature does and decide whether to implement it. All tags are
	4-byte character strings composed of a limited set of ASCII
	characters in the 0x20-0x7E range. Microsoft-registered
	feature tags use four lowercase letters. For instance, the
	"mark" feature manages the placement of diacritical marks, and
	the "swsh" feature renders swash glyphs.</para>

	<para>A feature definition may not provide all the information
	required to properly implement glyph substitution or
	positioning actions. In many cases, a text-processing client
	may need to supply additional data. For example, the function
	of the "init" feature is to provide initial glyph
	forms. Nothing in the feature's lookup tables indicates when
	or where to apply this feature during text processing. To
	correctly use the "init" feature in Arabic text where initial
	glyph forms appear at the beginning of words, text-processing
	clients must be able to identify the first glyph position in
	each word before making the glyph substitution. In all cases,
	the text-processing client is responsible for applying,
	combining, and arbitrating among features and rendering the
	result.</para>

	<para>The tag space defined by tags consisting of four
	uppercase letters (A-Z) with no punctuation, spaces, or
	numbers, is reserved as a vendor space. Font vendors may use
	such tags to identify private features. For example, the
	feature tag "PKRN" might designate a private feature that may
	be used to kern punctuation marks. Microsoft does not
	guarantee the compatibility or usability of private features,
	and it cannot ensure that two font vendors will not choose the
	same tag for a private feature.</para>

	<para>This version of the Tag Registry describes all the
	OpenType Layout features Microsoft has developed to date. It
	also includes details that identify the lookups that Microsoft
	uses to implement each feature. Lookup information is provided
	for reference purposes only; the set of lookups used to
	implement a feature will vary across system platforms,
	applications, fonts, and font developers.</para>

	<bridgehead>To register features</bridgehead>

	<para>Microsoft encourages font developers to use 'registered'
	feature tags when implementing registered features. However,
	font developers also may define and register their own
	features.</para>

	<para>Microsoft welcomes nominations for new features and
	feature tags to register. To qualify for registration, a
	feature must have a single function that is clearly identified
	by its tag. The function of the feature should be defined at
	the lowest useful level and must be distinctly different from
	the functions of currently registered features. When font
	developers register feature tags and functions with Microsoft,
	they do not have to supply implementation details.</para>

	<para>Microsoft reserves the right to officially assign
	feature tags in the Microsoft Tag Registry. Although Microsoft
	has reserved the feature and feature tag definitions listed in
	this registry, Microsoft fonts do not necessarily contain all
	of the features.</para>

	<bridgehead>Registered features</bridgehead>

	<para>The features listed below are sorted in alphabetical
	order by tag name. Click on the feature tag to view feature
	description and implementation, or go to the feature
	descriptions page.</para>

	<table>
	  <title>List of registered features</title>
	  <tgroup cols='2'>
	    <thead>
	      <row>
		<entry>Feature Tag</entry>
		<entry>Friendly Name</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>aalt</entry>
		<entry>Access All Alternates</entry>
	      </row>
	      <row>
		<entry>abvf</entry>
		<entry>Above-base Forms</entry>
	      </row>
	      <row>
		<entry>abvm</entry>
		<entry>Above-base Mark Positioning</entry>
	      </row>
	      <row>
		<entry>abvs</entry>
		<entry>Above-base Substitutions</entry>
	      </row>
	      <row>
		<entry>afrc</entry>
		<entry>Alternative Fractions</entry>
	      </row>
	      <row>
		<entry>akhn</entry>
		<entry>Akhands</entry>
	      </row>
	      <row>
		<entry>blwf</entry>
		<entry>Below-base Forms</entry>
	      </row>
	      <row>
		<entry>blwm</entry>
		<entry>Below-base Mark Positioning</entry>
	      </row>
	      <row>
		<entry>blws</entry>
		<entry>Below-base Substitutions</entry>
	      </row>
	      <row>
		<entry>calt</entry>
		<entry>Contextual Alternates</entry>
	      </row>
	      <row>
		<entry>case</entry>
		<entry>Case-Sensitive Forms</entry>
	      </row>
	      <row>
		<entry>ccmp</entry>
		<entry>Glyph Composition / Decomposition</entry>
	      </row>
	      <row>
		<entry>clig</entry>
		<entry>Contextual Ligatures</entry>
	      </row>
	      <row>
		<entry>cpsp</entry>
		<entry>Capital Spacing</entry>
	      </row>
	      <row>
		<entry>cswh</entry>
		<entry>Contextual Swash</entry>
	      </row>
	      <row>
		<entry>curs</entry>
		<entry>Cursive Positioning</entry>
	      </row>
	      <row>
		<entry>c2sc</entry>
		<entry>Small Capitals From Capitals</entry>
	      </row>
	      <row>
		<entry>c2pc</entry>
		<entry>Petite Capitals From Capitals</entry>
	      </row>
	      <row>
		<entry>dist</entry>
		<entry>Distances</entry>
	      </row>
	      <row>
		<entry>dlig</entry>
		<entry>Discretionary Ligatures</entry>
	      </row>
	      <row>
		<entry>dnom</entry>
		<entry>Denominators</entry>
	      </row>
	      <row>
		<entry>expt</entry>
		<entry>Expert Forms</entry>
	      </row>
	      <row>
		<entry>falt</entry>
		<entry>Final Glyph on Line Alternates</entry>
	      </row>
	      <row>
		<entry>fin2</entry>
		<entry>Terminal Forms #2</entry>
	      </row>
	      <row>
		<entry>fin3</entry>
		<entry>Terminal Forms #3</entry>
	      </row>
	      <row>
		<entry>fina</entry>
		<entry>Terminal Forms</entry>
	      </row>
	      <row>
		<entry>frac</entry>
		<entry>Fractions</entry>
	      </row>
	      <row>
		<entry>fwid</entry>
		<entry>Full Widths</entry>
	      </row>
	      <row>
		<entry>half</entry>
		<entry>Half Forms</entry>
	      </row>
	      <row>
		<entry>haln</entry>
		<entry>Halant Forms</entry>
	      </row>
	      <row>
		<entry>halt</entry>
		<entry>Alternate Half Widths</entry>
	      </row>
	      <row>
		<entry>hist</entry>
		<entry>Historical Forms</entry>
	      </row>
	      <row>
		<entry>hkna</entry>
		<entry>Horizontal Kana Alternates</entry>
	      </row>
	      <row>
		<entry>hlig</entry>
		<entry>Historical Ligatures</entry>
	      </row>
	      <row>
		<entry>hngl</entry>
		<entry>Hangul</entry>
	      </row>
	      <row>
		<entry>hwid</entry>
		<entry>Half Widths</entry>
	      </row>
	      <row>
		<entry>init</entry>
		<entry>Initial Forms</entry>
	      </row>
	      <row>
		<entry>isol</entry>
		<entry>Isolated Forms</entry>
	      </row>
	      <row>
		<entry>ital</entry>
		<entry>Italics</entry>
	      </row>
	      <row>
		<entry>jalt</entry>
		<entry>Justification Alternates</entry>
	      </row>
	      <row>
		<entry>jp78</entry>
		<entry>JIS78 Forms</entry>
	      </row>
	      <row>
		<entry>jp83</entry>
		<entry>JIS83 Forms</entry>
	      </row>
	      <row>
		<entry>jp90</entry>
		<entry>JIS90 Forms</entry>
	      </row>
	      <row>
		<entry>kern</entry>
		<entry>Kerning</entry>
	      </row>
	      <row>
		<entry>lfbd</entry>
		<entry>Left Bounds</entry>
	      </row>
	      <row>
		<entry>liga</entry>
		<entry>Standard Ligatures</entry>
	      </row>
	      <row>
		<entry>ljmo</entry>
		<entry>Leading Jamo Forms</entry>
	      </row>
	      <row>
		<entry>lnum</entry>
		<entry>Lining Figures</entry>
	      </row>
	      <row>
		<entry>locl</entry>
		<entry>Localized Forms</entry>
	      </row>
	      <row>
		<entry>mark</entry>
		<entry>Mark Positioning</entry>
	      </row>
	      <row>
		<entry>med2</entry>
		<entry>Medial Forms #2</entry>
	      </row>
	      <row>
		<entry>medi</entry>
		<entry>Medial Forms</entry>
	      </row>
	      <row>
		<entry>mgrk</entry>
		<entry>Mathematical Greek</entry>
	      </row>
	      <row>
		<entry>mkmk</entry>
		<entry>Mark to Mark Positioning</entry>
	      </row>
	      <row>
		<entry>mset</entry>
		<entry>Mark Positioning via Substitution</entry>
	      </row>
	      <row>
		<entry>nalt</entry>
		<entry>Alternate Annotation Forms</entry>
	      </row>
	      <row>
		<entry>nlck</entry>
		<entry>NLC Kanji Forms</entry>
	      </row>
	      <row>
		<entry>nukt</entry>
		<entry>Nukta Forms</entry>
	      </row>
	      <row>
		<entry>numr</entry>
		<entry>Numerators</entry>
	      </row>
	      <row>
		<entry>onum</entry>
		<entry>Oldstyle Figures</entry>
	      </row>
	      <row>
		<entry>opbd</entry>
		<entry>Optical Bounds</entry>
	      </row>
	      <row>
		<entry>ordn</entry>
		<entry>Ordinals</entry>
	      </row>
	      <row>
		<entry>ornm</entry>
		<entry>Ornaments</entry>
	      </row>
	      <row>
		<entry>palt</entry>
		<entry>Proportional Alternate Widths</entry>
	      </row>
	      <row>
		<entry>pcap</entry>
		<entry>Petite Capitals</entry>
	      </row>
	      <row>
		<entry>pnum</entry>
		<entry>Proportional Figures</entry>
	      </row>
	      <row>
		<entry>pref</entry>
		<entry>Pre-Base Forms</entry>
	      </row>
	      <row>
		<entry>pres</entry>
		<entry>Pre-base Substitutions</entry>
	      </row>
	      <row>
		<entry>pstf</entry>
		<entry>Post-base Forms</entry>
	      </row>
	      <row>
		<entry>psts</entry>
		<entry>Post-base Substitutions</entry>
	      </row>
	      <row>
		<entry>pwid</entry>
		<entry>Proportional Widths</entry>
	      </row>
	      <row>
		<entry>qwid</entry>
		<entry>Quarter Widths</entry>
	      </row>
	      <row>
		<entry>rand</entry>
		<entry>Randomize</entry>
	      </row>
	      <row>
		<entry>rlig</entry>
		<entry>Required Ligatures</entry>
	      </row>
	      <row>
		<entry>rphf</entry>
		<entry>Reph Forms</entry>
	      </row>
	      <row>
		<entry>rtbd</entry>
		<entry>Right Bounds</entry>
	      </row>
	      <row>
		<entry>rtla</entry>
		<entry>Right-to-left alternates</entry>
	      </row>
	      <row>
		<entry>ruby</entry>
		<entry>Ruby Notation Forms</entry>
	      </row>
	      <row>
		<entry>salt</entry>
		<entry>Stylistic Alternates</entry>
	      </row>
	      <row>
		<entry>sinf</entry>
		<entry>Scientific Inferiors</entry>
	      </row>
	      <row>
		<entry>size</entry>
		<entry>Optical size</entry>
	      </row>
	      <row>
		<entry>smcp</entry>
		<entry>Small Capitals</entry>
	      </row>
	      <row>
		<entry>smpl</entry>
		<entry>Simplified Forms</entry>
	      </row>
	      <row>
		<entry>ss01</entry>
		<entry>Stylistic Set 1</entry>
	      </row>
	      <row>
		<entry>ss02</entry>
		<entry>Stylistic Set 2</entry>
	      </row>
	      <row>
		<entry>ss03</entry>
		<entry>Stylistic Set 3</entry>
	      </row>
	      <row>
		<entry>ss04</entry>
		<entry>Stylistic Set 4</entry>
	      </row>
	      <row>
		<entry>ss05</entry>
		<entry>Stylistic Set 5</entry>
	      </row>
	      <row>
		<entry>ss06</entry>
		<entry>Stylistic Set 6</entry>
	      </row>
	      <row>
		<entry>ss07</entry>
		<entry>Stylistic Set 7</entry>
	      </row>
	      <row>
		<entry>ss08</entry>
		<entry>Stylistic Set 8</entry>
	      </row>
	      <row>
		<entry>ss09</entry>
		<entry>Stylistic Set 9</entry>
	      </row>
	      <row>
		<entry>ss10</entry>
		<entry>Stylistic Set 10</entry>
	      </row>
	      <row>
		<entry>ss11</entry>
		<entry>Stylistic Set 11</entry>
	      </row>
	      <row>
		<entry>ss12</entry>
		<entry>Stylistic Set 12</entry>
	      </row>
	      <row>
		<entry>ss13</entry>
		<entry>Stylistic Set 13</entry>
	      </row>
	      <row>
		<entry>ss14</entry>
		<entry>Stylistic Set 14</entry>
	      </row>
	      <row>
		<entry>ss15</entry>
		<entry>Stylistic Set 15</entry>
	      </row>
	      <row>
		<entry>ss16</entry>
		<entry>Stylistic Set 16</entry>
	      </row>
	      <row>
		<entry>ss17</entry>
		<entry>Stylistic Set 17</entry>
	      </row>
	      <row>
		<entry>ss18</entry>
		<entry>Stylistic Set 18</entry>
	      </row>
	      <row>
		<entry>ss19</entry>
		<entry>Stylistic Set 19</entry>
	      </row>
	      <row>
		<entry>ss20</entry>
		<entry>Stylistic Set 20</entry>
	      </row>
	      <row>
		<entry>subs</entry>
		<entry>Subscript</entry>
	      </row>
	      <row>
		<entry>sups</entry>
		<entry>Superscript</entry>
	      </row>
	      <row>
		<entry>swsh</entry>
		<entry>Swash</entry>
	      </row>
	      <row>
		<entry>titl</entry>
		<entry>Titling</entry>
	      </row>
	      <row>
		<entry>tjmo</entry>
		<entry>Trailing Jamo Forms</entry>
	      </row>
	      <row>
		<entry>tnam</entry>
		<entry>Traditional Name Forms</entry>
	      </row>
	      <row>
		<entry>tnum</entry>
		<entry>Tabular Figures</entry>
	      </row>
	      <row>
		<entry>trad</entry>
		<entry>Traditional Forms</entry>
	      </row>
	      <row>
		<entry>twid</entry>
		<entry>Third Widths</entry>
	      </row>
	      <row>
		<entry>unic</entry>
		<entry>Unicase</entry>
	      </row>
	      <row>
		<entry>valt</entry>
		<entry>Alternate Vertical Metrics</entry>
	      </row>
	      <row>
		<entry>vatu</entry>
		<entry>Vattu Variants</entry>
	      </row>
	      <row>
		<entry>vert</entry>
		<entry>Vertical Writing</entry>
	      </row>
	      <row>
		<entry>vhal</entry>
		<entry>Alternate Vertical Half Metrics</entry>
	      </row>
	      <row>
		<entry>vjmo</entry>
		<entry>Vowel Jamo Forms</entry>
	      </row>
	      <row>
		<entry>vkna</entry>
		<entry>Vertical Kana Alternates</entry>
	      </row>
	      <row>
		<entry>vkrn</entry>
		<entry>Vertical Kerning</entry>
	      </row>
	      <row>
		<entry>vpal</entry>
		<entry>Proportional Alternate Vertical Metrics</entry>
	      </row>
	      <row>
		<entry>vrt2</entry>
		<entry>Vertical Alternates and Rotation</entry>
	      </row>
	      <row>
		<entry>zero</entry>
		<entry>Slashed Zero</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Tag: 'aalt'</para>

	<para>Friendly name: Access All Alternates</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature makes all variations of a
	selected character accessible. This serves several purposes:
	An application may not support the feature by which the
	desired glyph would normally be accessed; the user may need a
	glyph outside the context supported by the normal
	substitution, or the user may not know what feature produces
	the desired glyph. Since many-to-one substitutions are not
	covered, ligatures would not appear in this table unless they
	were variant forms of another ligature.</para>

	<para>Example: A user inputs the P in Poetica, and is
	presented with a choice of the four standard capital forms,
	the eight swash capital forms, the initial capital form and
	the small capital form.</para>

	<para>Recommended implementation: The aalt table groups glyphs
	into semantic units. These units include the glyph which
	represents the default form for the underlying Unicode value
	stored by the application. While many of these substitutions
	are one-to-one (GSUB lookup type 1), others require a
	selection from a set (GSUB lookup type 3). The manufacturer
	may choose to build two tables (one for each lookup type) or
	only one which uses lookup type 3 for all substitutions. As in
	any one-from-many substitution, alternates present in more
	than one face should be ordered consistently across a family,
	so that those alternates can work correctly when switching
	between family members. This feature should be ordered first
	in the font, to take precedence over other features.</para>

	<para>Application interface: The application determines the
	GID for the default form of a given character (Unicode value
	with no features applied). It then checks to see whether the
	GID is found in the aalt coverage table. If so, the
	application passes this value to the feature table and gets
	back the GIDs in the associated group.</para>

	<para>UI suggestion: While most one-from-many substitution
	features can be applied globally with reasonable results, aalt
	i not designed to support this use. The application should
	indicate to the user which glyphs in the user's document have
	alternative forms (i.e which are in the coverage table for
	aalt). When the user selects one of those glyphs and applies
	the aalt feature, an application could display the forms
	sequentially in context, or present a palette showing all the
	forms at once, or give the user a choice between these
	approaches. The application may assume that the first glyph in
	a set is the preferred form, so the font developer should
	order them accordingly. When only one alternate exists, this
	feature could toggle directly between the alternate and
	default forms.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may be used in
	combination with other features.</para>

	<para>Tag: 'abvf'</para>

	<para>Friendly name: Above-base Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the above-base form of a vowel.</para>

	<para>Example: In complex scripts like Khmer, the vowel OE
	must be split into a pre-base form and an above-base form. The
	above-base form of OE would be substituted to form the correct
	piece of the letter that is displayed above the base
	consonant.</para>

	<para>Recommended implementation: This feature substitutes the
	GID for OE with the above part of the glyph (GSUB lookup type
	1).</para>

	<para>Application interface: In a sequence where a split vowel
	with an above form is used, the application must insert the
	pre-base glyph into the correct location and then apply the
	above-base form feature. The application gets back the GID for
	the correct form for the piece that is placed above the base
	glyph. The application may also choose to position this glyph
	if required, after this feature is called.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Khmer script.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'abvm'</para>

	<para>Friendly name: Above-base Mark Positioning</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Positions marks above base glyphs.</para>

	<para>Example: In complex scripts like Devanagari (Indic), the
	Anuswar needs to be positioned above the base glyph. This base
	glyph can be a base consonant or conjunct. The base glyph and
	the presence/absence of other marks above the base glyph
	decides the location of the Anuswar, so that they do not
	overlap each other.</para>

	<para>Recommended implementation: The abvm table provides
	positioning information (x,y) to enable mark positioning (GPOS
	lookup type 4, 5).</para>

	<para>Application interface: The application must define the
	GIDs of the base glyphs above which marks need to be
	positioned, and the marks themselves. If these are located in
	the coverage table, the application passes the sequence to the
	abvm table and gets the positioning values (x,y) or
	positioning adjustments for the mark in return.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: Can be used to position default
	marks; or those that have been selected from a number of
	alternates based on contextual requirement using a feature
	like abvs.</para>


	<para>Tag: 'abvs'</para>

	<para>Friendly name: Above-base Substitutions</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes a ligature for a base glyph and
	mark that's above it.</para>

	<para>Example: In complex scripts like Kannada (Indic), the
	vowel sign for the vowel I which a mark, is positioned above
	base consonants. This mark combines with the consonant Ga to
	form a ligature.</para>

	<para>Recommended implementation: Lookups for this feature map
	each sequence of consonant and vowel sign to the corresponding
	ligature in the font (GSUB lookup type 4).</para>

	<para>Application interface: The application must define the
	GIDs of the base glyphs and the mark that combines with it to
	form a ligature. The application passes the sequence to the
	abvs table. If these are located in the coverage table, it
	gets the GID for the ligature in return.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: None.</para>


	<para>Tag: 'afrc'</para>

	<para>Friendly name: Alternative Fractions</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces figures separated by a slash with an
	alternative form.</para>

	<para>Example: The user enters 3/4 in a recipe and get the
	threequarters nut fraction.</para>

	<para>Recommended implementation: The afrc table maps sets of
	figures separated by slash (U+002F) or fraction (U+2044)
	characters to corresponding fraction glyphs in the font (GSUB
	lookup type 4).</para>

	<para>Application interface: The application must define the
	full sequence of GIDs to be replaced. When the full sequence
	is found in the frac coverage table, the application passes
	the sequence to the afrc table and gets a new GID in return.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'akhn'</para>

	<para>Friendly name: Akhand</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Preferentially substitutes a sequence of
	characters with a ligature. This substitution is done
	irrespective of any characters that may precede or follow the
	sequence.</para>

	<para>Example: In complex scripts like Devanagari (Indic), the
	sequence Ka, Halant, Ssa should always produce the ligature
	Kssa, irrespective of characters that precede/follow the above
	given sequence. The Kssa is identified in Devanagari as an
	Akhand character (meaning unbreakable).</para>

	<para>Recommended implementation: This feature maps the
	sequences for generating Akhands defined in the given script,
	to the ligature they form (GSUB lookup type 4).</para>

	<para>Application interface: The application passes the full
	sequence of GIDs. If these are located in the coverage table
	of the Akhand table, the application gets back the GID for the
	akhand ligature in return.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in most Indic
	scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'blwf'</para>

	<para>Friendly name: Below-base Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the below-base form of a consonant
	in conjuncts.</para>

	<para>Example: In complex scripts like Oriya (Indic), the
	consonant Va has a below-base form that is used to generate
	conjuncts. Given a sequence Gha, Virama (Halant), Va; the
	below-base form of Va would be substituted to form the
	conjunct GhVa.</para>

	<para>Recommended implementation: This feature substitutes the
	GID sequence of consonant followed by (virama) halant; by the
	GID of the below base form of the consonant (GSUB lookup type
	4).</para>

	<para>Application interface: In a conjunct formation sequence,
	if a consonant is identified as having a below base form, the
	application gets back the GID for this. The application may
	also choose to position this glyph if required, after this
	feature is called.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in a number of
	Indic scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'blwm'</para>

	<para>Friendly name: Below-base Mark Positioning</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Positions marks below base glyphs.</para>

	<para>Example: In complex scripts like Gujarati (Indic), the
	vowel sign U needs to be positioned below base
	consonant/conjuncts that form the base glyph. This position
	can vary depending on the base glyph, as well as the
	presence/absence of other marks below the base glyph.</para>

	<para>Recommended implementation: The blwm table provides
	positioning information (x,y) to enable mark positioning (GPOS
	lookup type 4, 5).</para>

	<para>Application interface: The application must define the
	GIDs of the base glyphs below which marks need to be
	positioned, and the marks themselves. If these are located in
	the coverage table, the application passes the sequence to the
	blwm table and gets the positioning values (x,y) or
	positioning adjustments for the mark in return.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: Can be used to position default
	marks; or those that have been selected from a number of
	alternates based on contextual requirement using a feature
	like blws.</para>


	<para>Tag: "blws"</para>

	<para>Friendly name: Below-base Substitutions</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Produces ligatures that comprise of base glyph
	and below-base forms.</para>

	<para>Example: In the Malayalam script (Indic), the conjunct
	Kla, requires a ligature which is formed using the base glyph
	Ka and the below-base form of consonant La. This feature can
	also be used to substitute ligatures formed using base glyphs
	and below base matras in Indic scripts.</para>

	<para>Recommended implementation: The blws table maps the
	identified conjunct forming sequences; or consonant vowel sign
	sequences; to their ligatures (GSUB lookup type 4).</para>

	<para>Application interface: For GIDs found in the blws
	coverage table, the application passes the sequence of GIDs to
	the table, and gets back the GID for the ligature.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'calt'</para>

	<para>Friendly name: Contextual Alternates</para>

	<para>Registered by: Adobe</para>

	<para>Function: In specified situations, replaces default
	glyphs with alternate forms which provide better joining
	behavior. Used in script typefaces which are designed to have
	some or all of their glyphs join.</para>

	<para>Example: In Caflisch Script, o is replaced by o.alt2
	when followed by an ascending letterform.</para>

	<para>Recommended implementation: The calt table specifies the
	context in which each substitution occurs, and maps one or
	more default glyphs to replacement glyphs (GSUB lookup type
	6).</para>

	<para>Application interface: The application passes sequences
	of GIDs to the feature table, and gets back new GIDs. Note
	that full sequences must be passed.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: Not applicable to
	ideographic scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'case'</para>

	<para>Friendly name: Case-Sensitive Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Shifts various punctuation marks up to a
	position that works better with all-capital sequences or sets
	of lining figures; also changes oldstyle figures to lining
	figures. By default, glyphs in a text face are designed to
	work with lowercase characters. Some characters should be
	shifted vertically to fit the higher visual center of
	all-capital or lining text. Also, lining figures are the same
	height (or close to it) as capitals, and fit much better with
	all-capital text.</para>

	<para>Example: The user selects a block of text and applies
	this feature. The dashes, bracketing characters, guillemet
	quotes and the like shift up to match the capitals, and
	oldstyle figures change to lining figures.</para>

	<para>Recommended implementation: The font may implement this
	change by substituting different glyphs (GSUB lookup type 1)
	or by repositioning the original glyphs (GPOS lookup type 1).</para>

	<para>Application interface: The application queries whether
	specific GIDs are found in the coverage table for the case
	feature. If so, it passes these IDs to the table and gets back
	either new GIDs or positional adjustments (XPlacement and
	YPlacement).</para>

	<para>UI suggestion: It would be good to apply this feature
	(or turn it off) by default when the user changes case on a
	sequence of more than one character. Applications could also
	detect words consisting only of capitals, and apply this
	feature based on user preference settings.</para>

	<para>Script/language sensitivity: Applies only to European
	scripts; particularly prominent in Spanish-language setting.</para>

	<para>Feature interaction: This feature overrides the results
	of other features affecting the figures (e.g. onum and tnum).</para>


	<para>Tag: "ccmp"</para>

	<para>Friendly name: Glyph Composition/Decomposition</para>

	<para>Registered by: Microsoft</para>

	<para>Function: To minimize the number of glyph alternates, it
	is sometimes desired to decompose a character into two
	glyphs. Additionally, it may be preferable to compose two
	characters into a single glyph for better glyph
	processing. This feature permits such
	composition/decompostion. The feature should be processed as
	the first feature processed, and should be processed only when
	it is called.</para>

	<para>Example: In Syriac, the character 0x0732 is a combining
	mark that has a dot above AND a dot below the base
	character. To avoid multiple glyph variants to fit all base
	glyphs, the character is decomposed into two glyphs...a dot
	above and a dot below. These two glyphs can then be correctly
	placed using GPOS. In Arabic it might be preferred to combine
	the shadda with fatha (0x0651, 0x064E) into a ligature before
	processing shapes. This allows the font vendor to do special
	handling of the mark combination when doing further processing
	without requiring larger contextual rules.</para>

	<para>Recommended implementation: The ccmp table maps the
	character sequence to its corresponding ligature (GSUB lookup
	type 4) or string of glyphs (GSUB lookup type 2). When using
	GSUB lookup type 4, sequences that are made up of larger
	number of glyphs must be placed before those that require
	fewer glyphs.</para>

	<para>Application interface: For GIDs found in the ccmp
	coverage table, the application passes the sequence of GIDs to
	the table, and gets back the GID for the ligature, or GIDs for
	the multiple substitution.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature needs to be
	implemented prior to any other feature.</para>


	<para>Tag: 'clig'</para>

	<para>Friendly name: Contextual Ligatures</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces a sequence of glyphs with a single
	glyph which is preferred for typographic purposes. Unlike
	other ligature features, clig specifies the context in which
	the ligature is recommended. This capability is important in
	some script designs and for swash ligatures.</para>

	<para>Example: The glyph for ft replaces the sequence f t in
	Bickham Script, except when preceded by an ascending letter.</para>

	<para>Recommended implementation: The clig table maps
	sequences of glyphs to corresponding ligatures in a chained
	context (GSUB lookup type 8). Ligatures with more components
	must be stored ahead of those with fewer components in order
	to be found. The set of contextual ligatures will vary by
	design and script.</para>

	<para>Application interface: For sets of GIDs found in the
	clig coverage table, the application passes the sequence of
	GIDs to the table and gets back a single new GID. Note that
	full sequences must be passed. Note: This may include a change
	of character code. Besides the original character code, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: Applies to virtually all
	scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also dlig.</para>


	<para>Tag: 'cpsp'</para>

	<para>Friendly name: Capital Spacing</para>

	<para>Registered by: Adobe</para>

	<para>Function: Globally adjusts inter-glyph spacing for
	all-capital text. Most typefaces contain capitals and
	lowercase characters, and the capitals are positioned to work
	with the lowercase. When capitals are used for words, they
	need more space between them for legibility and
	esthetics. This feature would not apply to monospaced
	designs. Of course the user may want to override this behavior
	in order to do more pronounced letterspacing for esthetic
	reasons.</para>

	<para>Example: The user sets a title in all caps, and the
	Capital Spacing feature opens the spacing.</para>

	<para>Recommended implementation: The cpsp table stores
	alternate advance widths for the capital letters covered,
	generally increasing them by a uniform percentage (GPOS lookup
	type 1).</para>

	<para>Application interface: For GIDs found in the cpsp
	coverage table, the application passes a sequence of GIDs to
	the cpsp table and gets back a set of XPlacement and XAdvance
	adjustments. The application may rely on the user to apply
	this feature (e.g., by selecting text for a change to
	all-caps) or apply its own heuristics for recognizing words
	consisting of capitals.</para>

	<para>UI suggestion: This feature should be on by
	default. Applications may want to allow the user to respecify
	the percentage to fit individual tastes and functions.</para>

	<para>Script/language sensitivity: Should not be used in
	connecting scripts (e.g. most Arabic).</para>

	<para>Feature interaction: May be used in addition to any
	other feature (note specifically that this feature is additive
	with other GPOS features like kern).</para>


	<para>Tag: 'cswh'</para>

	<para>Friendly name: Contextual Swash</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature replaces default character glyphs
	with corresponding swash glyphs in a specified context. Note
	that there may be more than one swash alternate for a given
	character.</para>

	<para>Example: The user sets the word "HOLIDAY" in Poetica
	with this feature active, and is presented with a choice of
	three alternate forms appropriate for an initial H and one
	alternate appropriate for a medial L.</para>

	<para>Recommended implementation: The cswh table maps GIDs for
	default forms to those for one or more corresponding swash
	forms in a chained context, which may require a selection from
	a set (GSUB lookup type 8). If several styles of swash are
	present across the font, the set of forms for each character
	should be ordered consistently.</para>

	<para>Application interface: For GIDs found in the cswh
	coverage table, the application passes the GIDs to the swsh
	table and gets back one or more new GIDs. If more than one GID
	is returned, the application must provide a means for the user
	to select the one desired.</para>

	<para>UI suggestion: This feature should be inactive by
	default. When more than one GID is returned, an application
	could display the forms sequentially in context, or present a
	palette showing all the forms at once, or give the user a
	choice between these approaches. The application may assume
	that the first glyph in a set is the preferred form, so the
	font developer should order them accordingly.</para>

	<para>Script/language sensitivity: Does not apply to
	ideographic scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also swsh and init.</para>


	<para>Tag: "curs"</para>

	<para>Friendly name: Cursive Positioning</para>

	<para>Registered by: Microsoft</para>

	<para>Function: In cursive scripts like Arabic, this feature
	cursively positions adjacent glyphs.</para>

	<para>Example: In Arabic, the Meem followed by a Reh are
	cursively positioned by overlapping the exit point of the Meem
	on the entry point of the Reh.</para>

	<para>Recommended implementation: The curs table provides
	entry and exit points (x,y) for glyphs to be cursively
	positioned (GPOS lookup type 3).</para>

	<para>Application interface: For GIDs located in the coverage
	table, the application gets back positioning point locations
	for the preceding and following glyphs.</para>

	<para>UI suggestion: This feature could be made active or
	inactive by default, at the user's preference.</para>

	<para>Script/language sensitivity: Can be used in any cursive
	script.</para>

	<para>Feature interaction: None.</para>


	<para>Tag:'c2pc'</para>

	<para>Friendly name: Petite Capitals From Capitals</para>

	<para>Registered by: Tiro Typeworks / Emigre</para>

	<para>Function: This feature turns capital characters into
	petite capitals. It is generally used for words which would
	otherwise be set in all caps, such as acronyms, but which are
	desired in petite-cap form to avoid disrupting the flow of
	text. See the pcap feature description for notes on the
	relationship of caps, smallcaps and petite caps.</para>

	<para>Example: The user types UNICEF or NASA, applies c2pc and
	gets petite cap text.</para>

	<para>Recommended implementation: The c2pc table maps capital
	glyphs to the corresponding petite cap forms (GSUB lookup type
	1).</para>

	<para>Application interface: For GIDs found in the c2pc
	coverage table, the application passes GIDs to the c2pc table,
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to scripts
	with both upper- and lowercase forms (e.g. Latin, Cyrillic,
	Greek).</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. Also see pcap.</para>


	<para>Tag: 'c2sc'</para>

	<para>Friendly name: Small Capitals From Capitals</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature turns capital characters into
	small capitals. It is generally used for words which would
	otherwise be set in all caps, such as acronyms, but which are
	desired in small-cap form to avoid disrupting the flow of
	text.</para>

	<para>Example: The user types UNICEF or SCUBA, applies c2sc
	and gets small cap text.</para>

	<para>Recommended implementation: The c2sc table maps capital
	glyphs to the corresponding small-cap forms (GSUB lookup type
	1).</para>

	<para>Application interface: For GIDs found in the c2sc
	coverage table, the application passes GIDs to the c2sc table,
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to European
	scripts (Cyrillic, Greek and Latin), which have capital forms.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. Also see smcp.</para>


	<para>Tag: "dist"</para>

	<para>Friendly name: Distances</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Provides a means to control distance between
	glyphs.</para>

	<para>Example: In the Devanagari (Indic) script, the distance
	between the vowel sign U and a consonant can be adjusted using
	this.</para>

	<para>Recommended implementation: The dist table provides
	distances by which a glyph needs to move towards or away from
	another glyph (GPOS lookup type 2).</para>

	<para>Application interface: For GIDs found in the dist
	coverage table, the application passes their GID to the table
	and gets back the distance that needs to be maintained between
	them.</para>

	<para>UI suggestion: This feature could be made active or
	inactive by default, at the user's preference.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: None.</para>


	<para>Tag: 'dlig'</para>

	<para>Friendly name: Discretionary Ligatures</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces a sequence of glyphs with a single
	glyph which is preferred for typographic purposes. This
	feature covers those ligatures which may be used for special
	effect, at the user's preference.</para>

	<para>Example: The glyph for ct replaces the sequence of
	glyphs c t, or U+322E (Kanji ligature for "Friday") replaces
	the sequence U+91D1 U+66DC U+65E5.</para>

	<para>Recommended implementation: The dlig table maps
	sequences of glyphs to corresponding ligatures (GSUB lookup
	type 4). Ligatures with more components must be stored ahead
	of those with fewer components in order to be found. The set
	of discretionary ligatures will vary by design and script.</para>

	<para>Application interface: For sets of GIDs found in the
	dlig coverage table, the application passes the sequence of
	GIDs to the table and gets back a single new GID. Note that
	full sequences must be passed. This may include a change of
	character code. Besides the original character code, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies to virtually all
	scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also clig.</para>


	<para>Tag: 'dnom'</para>

	<para>Friendly name: Denominators</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces selected figures which follow a slash
	with denominator figures.</para>

	<para>Example: In the string 11/17 selected by the user, the
	application turns the 17 into denominators when the user
	applies the fraction feature (frac).</para>

	<para>Recommended implementation: The dnom table maps sets of
	figures and related characters to corresponding numerator
	glyphs in the font (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the dnom
	coverage table, the application passes a GID to the table and
	gets back a new GID.</para>

	<para>UI suggestion: This feature should normally be called by
	an application when the user applies the frac feature.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature supports frac. It may
	be used in combination with other substitution (GSUB)
	features, whose results it may override.</para>


	<para>Tag: 'expt'</para>

	<para>Friendly name: Expert Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Like the JIS78 Forms described above, this
	feature replaces standard forms in Japanese fonts with
	corresponding forms preferred by typographers. Although most
	of the JIS78 substitutions are included, the expert
	substitution goes on to handle many more characters.</para>

	<para>Example: The user would invoke this feature to replace
	kanji character U+5516 with U+555E.</para>

	<para>Recommended implementation: The expt table maps many
	default (JIS90) GIDs to corresponding alternates (GSUB lookup
	type 1).</para>

	<para>Application interface: For GIDs found in the expt
	coverage table, the application passes the GIDs to the table
	and gets back one new GID for each. Note: This is a change of
	character code. Besides the original character code, the
	application should store the code for the new character.</para>

	<para>UI suggestion: Applications may choose to have this
	feature active or inactive by default, depending on their
	target markets.</para>

	<para>Script/language sensitivity: Applies only to Japanese.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when it's
	applied, except the palt, vpal, vert and vrt2 features, which
	may be used in addition.</para>


	<para>Tag:  "falt"</para>

	<para>Friendly name: Final Glyph on Line Alternates</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces line final glyphs with alternate
	forms specifically designed for this purpose (they would have
	less or more advance width as need may be), to help
	justification of text.</para>

	<para>Example: In the Arabic script, providing alternate forms
	for line final glyphs would result in better
	justification. eg. replacing a long tailed Yeh-with-tail with
	one that has a slightly longer/shorter tail.</para>

	<para>Recommended implementation: The falt table maps line
	final glyphs (in isolated or final forms) to their
	corresponding alternate forms (GSUB lookup type 3).</para>

	<para>Application interface: For GIDs found in the falt
	coverage table, the application passes a GID to the table and
	gets back a new GID.</para>

	<para>UI suggestion: This feature could be made active or
	inactive by default, at the user's preference.</para>

	<para>Script/language sensitivity: Can be used in any cursive
	script.</para>

	<para>Feature interaction: Would need to be applied last, only
	after all other features have been applied to the run.</para>


	<para>Tag: "fin2"</para>

	<para>Friendly name: Terminal Form #2</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces the Alaph glyph at the end of Syriac
	words with its appropriate form, when the preceding base
	character cannot be joined to, and that preceding base
	character is not a Dalath, Rish, or dotless Dalath-Rish.</para>

	<para>Example: When an Alaph is preceded by a He, the Alaph
	  would be replaced by an appropriate form. This feature is
	  used only for the Syriac script alaph character.</para>

	<para>Recommended implementation: The fin2 table maps default
	alphabetic forms to corresponding final forms (GSUB lookup
	type 5).</para>

	<para>Application interface: The application is responsible
	for noting word boundaries. For GIDs in the middle of words
	and found in the fin2 coverage table, the application passes a
	GID to the feature and gets back a new GID.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Used only with the Syriac
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also init and fina.</para>


	<para>Tag: "fin3"</para>

	<para>Friendly name: Terminal Form #3</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces Alaph glyphs at the end of Syriac
	words when the preceding base character is a Dalath, Rish, or
	dotless Dalath-Rish.</para>

	<para>Example: When an Alaph is preceded by a Dalath, the
	  Alaph would be replaced by an appropriate form.
	  This feature is used only for the Syriac script alaph character.</para>

	<para>Recommended implementation: The fin3 table maps default
	alphabetic forms to corresponding final forms (GSUB lookup
	type 5).</para>

	<para>Application interface: The application is responsible
	for noting word boundaries. For GIDs in the middle of words
	and found in the fin3 coverage table, the application passes a
	GID to the feature and gets back a new GID.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Used only with the Syriac
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also init and fina.</para>


	<para>Tag: 'fina'</para>

	<para>Friendly name: Terminal Forms</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces glyphs at the ends of words with
	alternate forms designed for this use. This is common in Latin
	connecting scripts, and required in various non-Latins like
	Arabic.</para>

	<para>Example: In the typeface Poetica, the default e in the
	word 'type' is replaced with the e.end form.</para>

	<para>Recommended implementation: The fina table maps default
	alphabetic forms to corresponding ending forms (GSUB lookup
	type 1).</para>

	<para>Application interface: The application is responsible
	for noting word boundaries. For GIDs at the ends of words and
	found in the fina coverage table, the application passes a GID
	to the feature and gets back a new GID.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: Can be used in any
	alphabetic script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also init and medi.</para>


	<para>Tag: 'frac'</para>

	<para>Friendly name: Fractions</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces figures separated by a slash with
	'common' (diagonal) fractions.</para>

	<para>Example: The user enters 3/4 in a recipe and gets the
	threequarters fraction.</para>

	<para>Recommended implementation: The frac table maps sets of
	figures separated by slash or fraction characters to
	corresponding fraction glyphs in the font. These may be
	precomposed fractions (GSUB lookup type 4) or arbitrary
	fractions (GSUB lookup type 1).</para>

	<para>Application interface: The application must define the
	full sequence of GIDs to be replaced, based on user input
	(i.e. user selection determines the string's
	delimitation). When the full sequence is found in the frac
	coverage table, the application passes the sequence to the
	frac table and gets a new GID in return. When the frac table
	does not contain an exact match, the application performs two
	steps. First, it uses the numr feature (see below) to replace
	figures (as used in the numr coverage table) preceding the
	slash with numerators, and to replace the typographic slash
	character (U+002F) with the fraction slash character
	(U+2044). Second, it uses the dnom feature (see below) to
	replace all remaining figures (as listed in the dnom coverage
	table) with denominators.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may require the
	application to call the numr and dnom features. It may be used
	in combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'fwid'</para>

	<para>Friendly name: Full Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces glyphs set on other widths with
	glyphs set on full (usually em) widths. In a CJKV font, this
	may include "lower ASCII" Latin characters and various
	symbols. In a European font, this feature replaces
	proportionally-spaced glyphs with monospaced glyphs, which are
	generally set on widths of 0.6 em.</para>

	<para>Example: The user may invoke this feature in a Japanese
	font to get full monospaced Latin glyphs instead of the
	corresponding proportionally-spaced versions.</para>

	<para>Recommended implementation: The font may contain
	alternate glyphs designed to be set on full widths (GSUB
	lookup type 1), or it may specify alternate (full-width)
	metrics for the proportional glyphs (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the fwid
	coverage table, the application passes the GIDs to the table
	and gets back either new GIDs or positional adjustments
	(XPlacement and XAdvance).</para>

	<para>UI suggestion: This feature would normally be off by
	default.</para>

	<para>Script/language sensitivity: Applies to any script which
	can use monospaced forms.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. tnum, halt, hwid,
	palt, pwid, qwid and twid), which should be turned off when
	it's applied. It deactivates the kern feature.</para>


	<para>Tag: "half"</para>

	<para>Friendly name: Half Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Produces the half forms of consonants in Indic
	scripts.</para>

	<para>Example: In Hindi (Devanagari script), the conjunct KKa,
	obtained by doubling the Ka, is denoted with a half form of Ka
	followed by the full form.</para>

	<para>Recommended implementation: The half table maps the
	sequence of a consonant followed by a virama (halant) to its
	half form (GSUB lookup type 4).</para>

	<para>Application interface: For substitution sequences
	defined in the half table [consonant followed by the virama
	(halant)], the application passes the sequence of GIDs to the
	table, and gets back the GID for the half form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts
	that show similarity to Devanagari.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features, except akhn .</para>


	<para>Tag: "haln"</para>

	<para>Friendly name: Halant Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Produces the halant forms of consonants in
	Indic scripts.</para>

	<para>Example: In Sanskrit (Devanagari script), syllable final
	consonants are frequently required in their halant form.</para>

	<para>Recommended implementation: The haln table maps the
	sequence of a consonant followed by a virama (halant) to its
	halant form (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	halant table, the application passes the sequence of GIDs to
	the feature (essentially the consonant and virama), and gets
	back the GID for the halant form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'halt'</para>

	<para>Friendly name: Alternate Half Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Respaces glyphs designed to be set on full-em
	widths, fitting them onto half-em widths. This differs from
	hwid in that it does not substitute new glyphs.</para>

	<para>Example: The user may invoke this feature in a CJKV font
	to get better fit for punctuation or symbol glyphs without
	disrupting the monospaced alignment.</para>

	<para>Recommended implementation: The font specifies alternate
	metrics for the full-width glyphs (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the halt
	coverage table, the application passes the GIDs to the table
	and gets back positional adjustments (XPlacement, XAdvance,
	YPlacement and YAdvance).</para>

	<para>UI suggestion: This feature would be off by default.</para>

	<para>Script/language sensitivity: Used only in CJKV fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. tnum, fwid, hwid,
	palt, twid), which should be turned off when it's applied. It
	deactivates the kern feature. See also vhal.</para>


	<para>Tag: 'hist'</para>

	<para>Friendly name: Historical Forms</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Some letterforms were in common use in the
	past, but appear anachronistic today. The best-known example
	is the long form of s; others would include the old Fraktur
	k. Some fonts include the historical forms as alternates, so
	they can be used for a 'period' effect. This feature replaces
	the default (current) forms with the historical
	alternates. While some ligatures are also used for historical
	effect, this feature deals only with single characters.</para>

	<para>Example: The user applies this feature in Adobe Jenson
	to get the archaic forms of M, Q and Z.</para>

	<para>Recommended implementation: The hist table maps default
	forms to corresponding historical forms (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the hist
	coverage table, the application passes the GIDs to the hist
	table and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'hkna'</para>

	<para>Friendly name: Horizontal Kana Alternates</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces standard kana with forms that have
	been specially designed for only horizontal writing. This is a
	typographic optimization for improved fit and more even
	color. Also see vkna.</para>

	<para>Example: Standard full-width kana (hiragana and
	katakana) are replaced by forms that are designed for
	horizontal use.</para>

	<para>Recommended implementation: The font includes a set of
	specially-designed glyphs, listed in the hkna coverage
	table. The hkna feature maps the standard full-width forms to
	the corresponding special horizontal forms (GSUB lookup type
	1).</para>

	<para>Application interface: For GIDs found in the hkna
	coverage table, the application passes GIDs to the feature,
	and gets back new GIDs.</para>

	<para>UI suggestion:This feature would be off by default.</para>

	<para>Script/language sensitivity: Applies only to fonts that
	support kana (hiragana and katakana).</para>

	<para>Feature interaction: This feature may be used with the
	kern feature. Since it is for horizontal use, features
	applying to vertical behaviors (e.g. vkna, vert, vrt2 or vkrn)
	do not apply.</para>


	<para>Tag: 'hlig'</para>

	<para>Friendly name: Historical Ligatures</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Some ligatures were in common use in the past,
	but appear anachronistic today. Some fonts include the
	historical forms as alternates, so they can be used for a
	'period' effect. This feature replaces the default (current)
	forms with the historical alternates.</para>

	<para>Example: The user applies this feature using Palatino
	Linotype, and historic ligatures are formed for all long s
	forms, including: long s+t, long s+b, long s+h, long s+k, and
	several others.</para>

	<para>Recommended implementation: The hlig table maps default
	ligatures and character combinations to corresponding
	historical ligatures (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the hlig
	coverage table, the application passes the GIDs to the hlig
	table and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'hngl'</para>

	<para>Friendly name: Hangul</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces hanja (Chinese-style) Korean
	characters with the corresponding hangul (syllabic)
	characters. This effectively reverses the standard input
	method, in which hangul are entered and replaced by
	hanja. Many of these substitutions are one-to-one (GSUB lookup
	type 1), but hanja substitution often requires the user to
	choose from several possible hangul characters (GSUB lookup
	type 3).</para>

	<para>Example: The user may call this feature to get U+AC00
	from U+4F3D.</para>

	<para>Recommended implementation: This table associates each
	hanja character in the font with one or more hangul
	characters. The manufacturer may choose to build two tables
	(one for each lookup type) or only one which uses lookup type
	3 for all substitutions. As in any one-from-many substitution,
	alternates should be ordered consistently across a family, so
	that those alternates can work correctly when switching
	between family members.</para>

	<para>Application interface: For GIDs found in the hngl
	coverage table, the application passes the GIDs to the table
	and gets back one or more new GIDs. If more than one GID is
	returned, the application must provide a means for the user to
	select the one desired. Note: This is a change of semantic
	value. Besides the original character codes (when entered as
	hanja), the application should store the code for the new
	character.</para>

	<para>UI suggestion: This feature should be inactive by
	default. The application may note the user's choice when
	selecting from multiple hangul, and offer it as a default the
	next time the source hanja character is encountered. In the
	absence of such prior information, the application may assume
	that the first hangul in a set is the preferred form, so the
	font developer should order them accordingly.</para>

	<para>Script/language sensitivity: Korean only.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when it's
	applied, except the palt, vert and vrt2 may be used in
	addition.</para>


	<para>Tag: 'hwid'</para>

	<para>Friendly name: Half Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces glyphs on proportional widths, or
	fixed widths other than half an em, with glyphs on half-em
	(en) widths. Many CJKV fonts have glyphs which are set on
	multiple widths; this feature selects the half-em
	version. There are various contexts in which this is the
	preferred behavior, including compatibility with older desktop
	documents.</para>

	<para>Example: The user may replace a proportional Latin glyph
	with the same character set on a half-em width.</para>

	<para>Recommended implementation: The font may contain
	alternate glyphs designed to be set on half-em widths (GSUB
	lookup type 1), or it may specify alternate metrics for the
	original glyphs (GPOS lookup type 1) which adjust their
	spacing to fit in half-em widths.</para>

	<para>Application interface: For GIDs found in the hwid
	coverage table, the application passes the GIDs to the table
	and gets back either new GIDs or positional adjustments
	(XPlacement and XAdvance).</para>

	<para>UI suggestion: This feature would normally be off by
	default.</para>

	<para>Script/language sensitivity: Generally used only in CJKV
	fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. tnum, fwid, halt,
	qwid and twid), which should be turned off when it's
	applied. It deactivates the kern feature.</para>


	<para>Tag: 'init'</para>

	<para>Friendly name: Initial Forms</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces glyphs at the beginnings of words
	with alternate forms designed for this use. This is common in
	Latin connecting scripts, and required in various non-Latins
	like Arabic.</para>

	<para>Example: In the typeface Ex Ponto, the default t in the
	word 'type' is replaced with the t.begin form.</para>

	<para>Recommended implementation: The init table maps default
	alphabetic forms to corresponding beginning forms (GSUB lookup
	type 1).</para>

	<para>Application interface: The application is responsible
	for noting word boundaries. For GIDs at the beginnings of
	words and found in the init coverage table, the application
	passes a GID to the feature and gets back a new GID.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: Can be used in any
	alphabetic script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also medi and fina.</para>


	<para>Tag: "isol"</para>

	<para>Friendly name: Isolated Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces the nominal form of glyphs with their
	isolated forms.</para>

	<para>Example: In Arabic, if the Alef is followed by Lam, the
	default glyph for Alef is replaced with its isolated form.</para>

	<para>Recommended implementation: The isol table maps default
	alphabetic forms to corresponding isolated forms (GSUB lookup
	type 1).</para>

	<para>Application interface: For GIDs found in the isol
	coverage table, the application passes a GID to the feature
	and gets back a new GID for the isolated form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Can be used in any cursive
	script.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features. See also init, medi, fina.</para>


	<para>Tag: 'ital'</para>

	<para>Friendly name: Italics</para>

	<para>Registered by: Adobe</para>

	<para>Function: Some fonts (such as Adobe's Pro Japanese
	fonts) will have both Roman and Italic forms of some
	characters in a single font. This feature replaces the Roman
	glyphs with the corresponding Italic glyphs.</para>

	<para>Example: The user would apply this feature to replace B
	with B.</para>

	<para>Recommended implementation: The ital table maps the
	Roman forms in a font to the corresponding Italic forms (GSUB
	lookup type 1).</para>

	<para>Application interface: For GIDs found in the ital
	coverage table, the application passes the GIDs to the table
	and gets back one new GID for each.</para>

	<para>UI suggestion: When a user selects text and applies an
	Italic style, an application should check for this feature and
	use it if present.</para>

	<para>Script/language sensitivity: Applies mostly to Latin;
	note that many non-Latin fonts contain Latin as well.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. In CJKV fonts it should activate the
	kern feature (which would be on anyway in other scripts).</para>


	<para>Tag: "jalt"</para>

	<para>Friendly name: Justification Alternates</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Improves justification of text by replacing
	glyphs with alternate forms specifically designed for this
	purpose (they would have less or more advance width as need
	may be).</para>

	<para>Example: In the Arabic script, providing alternate forms
	for line final glyphs would result in better justification and
	reduce the use of tatweels (Kashidas). eg. replacing a Swash
	Kaf with an alternate form.</para>

	<para>Recommended implementation: The jalt table maps the
	initial, medial, final or isolated forms to their
	corresponding alternate forms (GSUB lookup type 3).</para>

	<para>Application interface: The application is responsible
	for noting line ends/boundaries. For GIDs found in the jalt
	coverage table, the application passes a GID to the feature
	and gets back a new GID.</para>

	<para>UI suggestion: This feature could be made active or
	inactive by default, at the user's preference.</para>

	<para>Script/language sensitivity: Can be used in any cursive
	script.</para>

	<para>Feature interaction: If the font contains init, medi,
	fina, isol features, these need to be called prior to calling
	this feature.</para>


	<para>Tag: 'jp78'</para>

	<para>Friendly name: JIS78 Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature replaces default (JIS90) Japanese
	glyphs with the corresponding forms from the JIS C 6226-1978
	(JIS78) specification.</para>

	<para>Example: The user would invoke this feature to replace
	kanji character U+5516 with U+555E.</para>

	<para>Recommended implementation: When JIS90 glyphs correspond
	to JIS78 forms, the jp78 table maps each of those glyphs to
	their alternates. While many of these substitutions are
	one-to-one (GSUB lookup type 1), others require a selection
	from a set (GSUB lookup type 3). The manufacturer may choose
	to build two tables (one for each lookup type) or only one
	which uses lookup type 3 for all substitutions.</para>

	<para>Application interface: For GIDs found in the jp78
	coverage table, the application passes the GIDs to the table
	and gets back one or more new GIDs. If more than one GID is
	returned, the application must provide a means for the user to
	select the one desired. The application may assume that the
	first glyph in a set is the preferred form, so the font
	developer should order them accordingly. Note: This is a
	change of character code. Besides the original character code,
	the application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to Japanese.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when it's
	applied, except the palt, vpal, vert and vrt2 features, which
	may be used in addition.</para>


	<para>Tag: 'jp83'</para>

	<para>Friendly name: JIS83 Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature replaces default (JIS90) Japanese
	glyphs with the corresponding forms from the JIS X 0208-1983
	(JIS83) specification.</para>

	<para>Example: Because of the Han unification in Unicode,
	there are no JIS83 glyphs which have distinct Unicode values,
	so the substitution cannot be described specifically.</para>

	<para>Recommended implementation: When JIS90 glyphs correspond
	to JIS83 forms, the jp83 table maps each of those glyphs to
	their alternates (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the jp83
	coverage table, the application passes the GIDs to the table
	and gets back one or more new GIDs. If more than one GID is
	returned, the application must provide a means for the user to
	select the one desired.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to Japanese.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when it's
	applied, except the palt, vpal, vert and vrt2 features, which
	may be used in addition.</para>


	<para>Tag: 'jp90'</para>

	<para>Friendly name: JIS90 Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature replaces Japanese glyphs from the
	JIS78 or JIS83 specifications with the corresponding forms
	from the JIS X 0208-1990 (JIS90) specification.</para>

	<para>Example: The user would invoke this feature to replace
	kanji character U+555E with U+5516.</para>

	<para>Recommended implementation: The jp90 table maps each
	JIS78 and JIS83 form in a font to JIS90 forms (GSUB lookup
	type 1). The application stores a record of any simplified
	forms which resulted from substitutions (the jp78 or jp83
	features); for such forms, applying the jp90 feature undoes
	the previous substitution. When there is no record of a
	substitution, the application uses the jp90 table to get back
	to the default form.</para>

	<para>Application interface: For GIDs found in the jp90
	coverage table, the application passes the GIDs to the table
	and gets back one new GID for each. Note: This is a change of
	character code. Besides the original character code, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to Japanese.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when it's
	applied, except the palt, vpal, vert and vrt2 features, which
	may be used in addition.</para>

	<para>Tag: 'kern'</para>

	<para>Friendly name: Kerning</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Adjusts amount of space between glyphs,
	generally to provide optically consistent spacing between
	glyphs. Although a well-designed typeface has consistent
	inter-glyph spacing overall, some glyph combinations require
	adjustment for improved legibility. Besides standard
	adjustment in the horizontal direction, this feature can
	supply size-dependent kerning data via device tables,
	"cross-stream" kerning in the Y text direction, and adjustment
	of glyph placement independent of the advance adjustment. Note
	that this feature may apply to runs of more than two glyphs,
	and would not be used in monospaced fonts. Also note that this
	feature does not apply to text set vertically.</para>

	<para>Example: The o is shifted closer to the T in the
	combination "To."</para>

	<para>Recommended implementation: The font stores a set of
	adjustments for pairs of glyphs (GPOS lookup type 2 or
	8). These may be stored as one or more tables matching left
	and right classes, and/or as individual pairs. Additional
	adjustments may be provided for larger sets of glyphs
	(e.g. triplets, quadruplets, etc.) to overwrite the results of
	pair kerns in particular combinations.</para>

	<para>Application interface: The application passes a sequence
	of GIDs to the kern table, and gets back adjusted positions
	(XPlacement, XAdvance, YPlacement and YAdvance) for those
	GIDs. When using the type 2 lookup on a run of glyphs, it's
	critical to remember to not consume the last glyph, but to
	keep it available as the first glyph in a subsequent run (this
	is a departure from normal lookup behavior).</para>

	<para>UI suggestion: This feature should be active by default
	for horizontal text setting. Applications may wish to allow
	users to add further manually-specified adjustments to suit
	specific needs and tastes.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: If 'kern' is activated, 'palt' must
	also be activated if it exists. (If 'palt' is activated, there
	is no requirement that 'kern' must also be activated.) May be
	used in addition to any other feature except those which
	result in fixed (uniform) advance widths (e.g. fwid, halt,
	hwid, qwid and twid).</para>


	<para>Tag: 'lfbd'</para>

	<para>Friendly name: Left Bounds</para>

	<para>Registered by: Adobe</para>

	<para>Function: Aligns glyphs by their apparent left extents
	at the left ends of horizontal lines of text, replacing the
	default behavior of aligning glyphs by their origins. This
	feature is called by the Optical Bounds ( opbd) feature
	above.</para>

	<para>Example: Succeeding lines beginning with T, D and W
	would shift to the left by varying amounts when the text is
	left-justified and this feature is applied.</para>

	<para>Recommended implementation: Values for affected glyphs
	describe the amount by which the placement and advance width
	should be altered (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the lfbd
	coverage table, the application passes a GID to the table and
	gets back a new XPlacement and XAdvance value.</para>

	<para>UI suggestion: This feature is called by an application
	when the user invokes the opbd feature.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: Should not be applied to glyphs
	which use fixed-width features (e.g. fwid, halt, hwid, qwid
	and twid) or vertical features (e.g. vert, vrt2, vpal, valt
	and vhal). Is called by the opbd feature.</para>


	<para>Tag: 'liga'</para>

	<para>Friendly name: Standard Ligatures</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces a sequence of glyphs with a single
	glyph which is preferred for typographic purposes. This
	feature covers the ligatures which the designer/manufacturer
	judges should be used in normal conditions.</para>

	<para>Example: The glyph for ffl replaces the sequence of
	glyphs f f l.</para>

	<para>Recommended implementation: The liga table maps
	sequences of glyphs to corresponding ligatures (GSUB lookup
	type 4). Ligatures with more components must be stored ahead
	of those with fewer components in order to be found. The set
	of standard ligatures will vary by design and script.</para>

	<para>Application interface: For sets of GIDs found in the
	liga coverage table, the application passes the sequence of
	GIDs to the table and gets back a single new GID. Note that
	full sequences must be passed.</para>

	<para>UI suggestion: This feature serves a critical function
	in some contexts, and should be active by default.</para>

	<para>Script/language sensitivity: Applies to virtually all
	scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: "ljmo"</para>

	<para>Friendly name: Leading Jamo Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the leading jamo form of a
	cluster.</para>

	<para>Example: In Hangul script, the jamo cluster is composed
	of three parts (leading consonant, vowel, and trailing
	consonant). When a sequence of leading class jamos are found,
	their combined leading jamo form is substituted.</para>

	<para>Recommended implementation: The ljmo table maps the
	sequence required to convert a series of jamos into its
	leading jamo form (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	ljmo table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the leading jamo form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required for Hangul script
	when Ancient Hangul writing system is supported.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'lnum'</para>

	<para>Friendly name: Lining Figures</para>

	<para>Registered by: Adobe (Modified by Adobe, this is the
	newer description)</para>

	<para>Function: This feature changes selected figures from
	oldstyle to the default lining form.</para>

	<para>Example: The user invokes this feature in order to get
	lining figures, which fit better with all-capital
	text. Various characters designed to be used with figures may
	also be covered by this feature. In cases where lining figures
	are the default form, this feature would undo previous
	substitutions.</para>

	<para>Recommended implementation: The lnum table maps each
	oldstyle figure, and any associated characters to the
	corresponding lining form (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the lnum
	coverage table, the application passes a GID to the onum table
	and gets back a new GID. Even if the current figures resulted
	from an earlier substitution, it may not be correct to simply
	revert to the original GIDs, because of interaction with the
	figure width features, so it's best to use this table.</para>

	<para>UI suggestion: This feature should be inactive by
	default. Users can switch between the lining and oldstyle sets
	by turning this feature on or off. Note that this feature is
	distinct from the figure width features (pnum and tnum). When
	the user invokes this feature, the application may wish to
	inquire whether a change in width is also desired.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature overrides the results
	of the Oldstyle Figures feature ( onum).</para>


	<para>Tag: 'locl'</para>

	<para>Friendly name: Localized Forms</para>

	<para>Registered by: Tiro Typeworks/Adobe</para>

	<para>Function: Many scripts used to write multiple languages
	over wide geographical areas have developed localized variant
	forms of specific letters, which are used by individual
	literary communities. For example, a number of letters in the
	Bulgarian and Serbian alphabets have forms distinct from their
	Russian counterparts and from each other. In some cases the
	localized form differs only subtly from the script 'norm', in
	others the forms are radically distinct. This feature enables
	localized forms of glyphs to be substituted for default
	forms.</para>

	<para>Example: The user applies this feature to text to enable
	localized Bulgarian forms of Cyrillic letters; alternatively,
	the feature might enable localized Russian forms in a
	Bulgarian manufactured font in which the Bulgarian forms are
	the efault characters.</para>

	<para>Recommended implementation: For a given Unicode value,
	the font contains glyphs for two or more locales. The locl
	table maps GIDs for default forms to GIDs for corresponding
	localized alternatives. These are one-to-one substitutions
	(GSUB lookup type 1).</para>

	<para>Application interface: Localized forms are associated
	with specific languages and are activated by language
	tags. Which glyph is used as the localized form should be
	determined by the language the user has specified. The user
	can switch localized forms by selecting a new language, or may
	enable default forms by switching off the locl feature.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: Applies to all scripts and
	languages; but of course behavior differs by script and
	language.</para>

	<para>Feature interaction: This feature can be used in
	combination with any other feature. It replaces and extends
	the earlier locale-specific tags zhcn, zhtw, jajp, kokr and
	vivn which had been defined for CJKV scripts.</para>


	<para>Tag: 'mark'</para>

	<para>Friendly name: Mark Positioning</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Positions mark glyphs with respect to base
	  glyphs.</para>

	<para>Example: In the Arabic script, positioning the Hamza
	above the Yeh.</para>

	<para>Recommended implementation: This feature may be
	implemented as a MarkToBase Attachment lookup (GPOS LookupType
	= 4) or a MarkToLigature Attachment lookup (GPOS LookupType =
	5).</para>

	<para>Application interface: For GIDs found in the mark
	coverage table, the application gets back the positioning or
	position adjustment values for the mark glyph.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: None.</para>


	<para>Tag: "med2"</para>

	<para>Friendly name: Medial Form #3</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces Alaph glyphs in the middle of Syriac
	words when the preceding base character cannot be joined to.</para>

	<para>Example: When an Alaph is preceded by a Waw, the Alaph
	  would be replaced by an appropriate form.</para>

	<para>This feature is used only for the Syriac script alaph
	character.</para>

	<para>Recommended implementation: The med2 table maps default
	alphabetic forms to corresponding medial forms (GSUB lookup
	type 5).</para>

	<para>Application interface: The application is responsible
	for noting word boundaries. For GIDs in the middle of words
	and found in the med2 coverage table, the application passes a
	GID to the feature and gets back a new GID.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Used only with the Syriac
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also init and fina.</para>


	<para>Tag: 'medi'</para>

	<para>Friendly name: Medial Forms</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces glyphs in the middles of words
	(i.e. following a beginning and preceding an end) with
	alternate forms designed for this use. Note: This is different
	from the default form, which is designed for stand-alone
	use. This is common in Latin connecting scripts, and required
	in various non-Latins like Arabic.</para>

	<para>Example: In the typeface Caflisch Script, the y and p in
	the word 'type' are replaced by the y.med and p.med forms.</para>

	<para>Recommended implementation: The medi table maps default
	alphabetic forms to corresponding medial forms (GSUB lookup
	type 1).</para>

	<para>Application interface: The application is responsible
	for noting word boundaries. For GIDs in the middles of words
	and found in the medi coverage table, the application passes a
	GID to the feature and gets back a new GID.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: Can be used in any
	alphabetic script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also init and fina.</para>


	<para>Tag: 'mgrk'</para>

	<para>Friendly name: Mathematical Greek</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces standard typographic forms of Greek
	glyphs with corresponding forms commonly used in mathematical
	notation (which are a subset of the Greek alphabet).</para>

	<para>Example: The user applies this feature to U+03A3
	(Sigma), and gets U+2211 (summation).</para>

	<para>Recommended implementation: The mgrk table maps Greek
	glyphs to the corresponding forms used for mathematics (GSUB
	lookup type 1).</para>

	<para>Application interface: For GIDs found in the mgrk
	coverage table, the application passes a GID to the feature
	table and gets back a new GID. Note: This is a change of
	semantic value. Besides the original character codes, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default in
	most applications. Math-oriented applications may want to
	activate this feature by default.</para>

	<para>Script/language sensitivity: Could apply to any font
	which includes coverage for the Greek script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: "mkmk"</para>

	<para>Friendly name: Mark to Mark Positioning</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Positions marks with respect to other
	marks. Required in various non-Latin scripts like Arabic.</para>

	<para>Example: In Arabic, the ligaturised mark Ha with Hamza
	above it; can also be obtained by positioning these marks
	relative to one another.</para>

	<para>Recommended implementation: This feature may be
	implemented as a MarkToMark Attachment lookup (GPOS lookup
	type 6).</para>

	<para>Application interface: The application gets back
	positioning values or positional adjustments for marks.</para>

	<para>UI suggestion: This feature should be active by
	default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: None.</para>


	<para>Tag: 'mset'</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Positions Arabic combining marks in fonts for
	  Windows 95 using glyph substitution</para>

	<para>Example: In Arabic, the Hamza is positioned differently
	when placed above a Yeh Barree as compared to the Alef.</para>

	<para>Windows 95 implementation: In contrast to the "mark"
	feature, "mset" uses glyph substitution to combine marks and
	base glyphs. It replaces a default mark glyph with a correctly
	positioned mark glyph. The font designer specifies the
	position of the mark when describing the mark's contour in the
	font file. Microsoft's Arabic fonts, created for Windows 95,
	use a contextual substitution lookup (GSUB LookupType = 5) to
	implement the "mset" feature.</para>


	<para>Tag: 'nalt'</para>

	<para>Friendly name: Alternate Annotation Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces default glyphs with various
	notational forms (e.g. glyphs placed in open or solid circles,
	squares, parentheses, diamonds or rounded boxes). In some
	cases an annotation form may already be present, but the user
	may want a different one.</para>

	<para>Example: The user invokes this feature to get U+3200
	(the circled form of 'ga') from U+3131 (hangul 'ga').</para>

	<para>Recommended implementation: The nalt table maps GIDs for
	various standard forms to one or more corresponding annotation
	forms. While many of these substitutions are one-to-one (GSUB
	lookup type 1), others require a selection from a set (GSUB
	lookup type 3). The manufacturer may choose to build two
	tables (one for each lookup type) or only one which uses
	lookup type 3 for all substitutions. If more than one form is
	present, the set of forms for each character should be ordered
	consistently - both within the font and across the family.</para>

	<para>Application interface: For GIDs found in the nalt
	coverage table, the application passes a GID and gets back a
	set of new GIDs, then stores the one selected by the user.</para>

	<para>UI suggestion: This feature should be inactive by
	default. The application must provide a means for the user to
	select the desired form from the set returned by the table. It
	can note the position of the selected form in a set of
	alternates, and offer the glyph at that position as the
	default selection the next time this feature is invoked. In
	the absence of such prior information, the application may
	assume that the first glyph in a set is the preferred form, so
	the font developer should order them accordingly.</para>

	<para>Script/language sensitivity: Used mostly in CJKV fonts,
	but can apply to European scripts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when it's
	applied, except the vert and vrt2 features, which may be used
	in addition.</para>


	<para>Tag: "nlck"</para>

	<para>Friendly name: NLC Kanji Forms</para>

	<para>Registered by: Adobe Systems Inc.</para>

	<para>Function: The National Language Council (NLC) of Japan
	has defined new glyph shapes for a number of JIS
	characters. The 'nlck' feature is used to access those
	glyphs.</para>

	<para>Example: The glyph
          <mediaobject>
            <imageobject>
              <imagedata fileref='nlc1.gif'/>
            </imageobject>
          </mediaobject>
	  is replaced by the glyph
          <mediaobject>
            <imageobject>
              <imagedata fileref='nlc2.gif'/>
            </imageobject>
          </mediaobject>.</para>

	<para>Recommended implementation: One-for-one substitution of
	non-NLC glyphs by the corresponding NLC glyph.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Used only with Kanji
	script.</para>

	<para>Feature interaction: This feature is exclusive with the
	'jp78', 'jp83', 'jp90' and similar features. It can be
	combined with the 'palt', 'vpal', 'vert' and 'vrt2' features.</para>


	<para>Tag: "nukt"</para>

	<para>Friendly name: Nukta Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Produces Nukta forms in Indic scripts.</para>

	<para>Example: In Hindi (Devanagari script), a consonant when
	combined with a nukta gives its nukta form.</para>

	<para>Recommended implementation: The nukt table maps the
	sequence of a consonant followed by a nukta to the consonant's
	nukta form (GSUB lookup type 4).</para>

	<para>Application interface: The application passes the
	sequence of GIDs (consonant and nukta), to the table, and gets
	back the GID for the nukta form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'numr'</para>

	<para>Friendly name: Numerators</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces selected figures which precede a
	slash with numerator figures, and replaces the typographic
	slash with the fraction slash.</para>

	<para>Example: In the string 11/17 selected by the user, the
	application turns the 11 into numerators, and the slash into a
	fraction slash when the user applies the fraction feature
	(frac).</para>

	<para>Recommended implementation: The numr table maps sets of
	figures and related characters to corresponding numerator
	glyphs in the font. It also maps the typographic slash
	(U+002F) to the fraction slash (U+2044). All mappings are
	one-to-one (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the numr
	coverage table, the application passes a GID to the table and
	gets back a new GID.</para>

	<para>UI suggestion: This feature should normally be called by
	an application when the user applies the frac feature.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature supports frac. It may
	be used in combination with other substitution (GSUB)
	features, whose results it may override.</para>


	<para>Tag: 'onum'</para>

	<para>Friendly name: Oldstyle Figures</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: This feature changes selected figures from the
	default lining style to oldstyle form.</para>

	<para>Example: The user invokes this feature to get oldstyle
	figures, which fit better into the flow of normal upper- and
	lowercase text. Various characters designed to be used with
	figures may also have oldstyle versions.</para>

	<para>Recommended implementation: The onum table maps each
	lining figure, and any associated characters, to the
	corresponding oldstyle form (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the onum
	coverage table, the application passes a GID to the onum table
	and gets back a new GID.</para>

	<para>UI suggestion: Users can switch between the lining and
	oldstyle sets by turning this feature on or off. Note: This
	feature is separate from the figure-width features pnum and
	tnum. When the user changes figure style, the application may
	want to query whether a change in width is also desired.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature overrides the results
	of the Lining Figures feature (lnum).</para>


	<para>Tag: 'opbd'</para>

	<para>Friendly name: Optical Bounds</para>

	<para>Registered by: Adobe (Modified by Adobe, this is the
	newer description)</para>

	<para>Function: Aligns glyphs by their apparent left or right
	extents in horizontal setting, or apparent top or bottom
	extents in vertical setting, replacing the default behavior of
	aligning glyphs by their origins. Another name for this
	behavior would be visual justification. The optical edge of a
	given glyph is only indirectly related to its advance width or
	bounding box; this feature provides a means for getting true
	visual alignment.</para>

	<para>Example: Succeeding lines beginning with T, D and W
	would shift to the left by varying amounts when the text is
	left-justified and this feature is applied. Succeeding lines
	ending with r, h and y would likewise shift to the right by
	differing degrees when the text is right-justified and this
	feature is applied.</para>

	<para>Recommended implementation: Values for affected glyphs
	are defined with a separate record for left, right, top, and
	bottom. Each record describes the amount by which the
	placement and advance width should be altered (GPOS lookup
	type 1).</para>

	<para>Application interface: For GIDs found in the opbd
	coverage table, the application calls one of two related
	tables, depending on the position of the glyph. For glyphs at
	the left end of a horizontal line, it calls the lfbd table,
	for glyphs at the right end of a horizontal line, it calls the
	rtbd table.</para>

	<para>UI suggestion: This feature should be active by
	default. It effectively changes the line length, so
	justification algorithms should account for this adjustment.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: Should not be applied to glyphs
	which use fixed-width features (e.g. fwid, halt, hwid, qwid
	and twid) or vertical features (e.g. vert, vrt2, vpal, valt
	and vhal). Uses lfbd and rtbd features.</para>


	<para>Tag: 'ordn'</para>

	<para>Friendly name: Ordinals</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces default alphabetic glyphs with the
	corresponding ordinal forms for use after figures. One
	exception to the follows-a-figure rule is the numero character
	(U+2116), which is actually a ligature substitution, but is
	best accessed through this feature.</para>

	<para>Example: The user applies this feature to turn 2.o into
	2.o (abbreviation for secundo).</para>

	<para>Recommended implementation: The ordn table maps various
	lowercase letters to corresponding ordinal forms in a chained
	context (GSUB lookup type 6), and the sequence No to the
	numero character (GSUB lookup type 4).</para>

	<para>Application interface: For sets of GIDs found in the
	clig coverage table, the application passes the sequence of
	GIDs to the table and gets back new GIDs. Note that full
	sequences must be passed. Note: This may be a change of
	semantic value. Besides the original character codes, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies mostly to Latin
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'ornm'</para>

	<para>Friendly name: Ornaments</para>

	<para>Registered by: Adobe</para>

	<para>Function: This is a dual-function feature, which uses
	two input methods to give the user access to ornament glyphs
	(e.g. fleurons, dingbats and border elements) in the font. One
	method replaces the bullet character with a selection from the
	full set of available ornaments; the other replaces specific
	"lower ASCII" characters with ornaments assigned to them. The
	first approach supports the general or browsing user; the
	second supports the power user.</para>

	<para>Example: The user inputs qwwwwwwwwwe to form the top of
	a flourished box in Adobe Caslon, or inputs the bullet
	character, then chooses the thistle dingbat.</para>

	<para>Recommended implementation: The ornm table maps all
	ornaments in a font to the bullet character (GSUB lookup type
	3) and each ornament in a font to a corresponding alphanumeric
	character (GSUB lookup type 1). The manufacturer may choose to
	build two tables (one for each lookup type) or only one which
	uses lookup type 3 for all substitutions. As in any
	one-from-many substitution, alternates present in more than
	one face should be ordered consistently across a family, so
	that those alternates can work correctly when switching
	between family members.</para>

	<para>Application interface: When this feature is invoked, the
	application must note whether the selected text is the bullet
	character (U+2022) or alphanumeric characters. In the first
	case, it passes the GID for bullet to the ornm table and gets
	back a set of GIDs, and gives the user a means to select from
	among them. In the second case, for GIDs found in the ornm
	coverage table, it passes GIDs to the ornm table and gets back
	new GIDs.</para>

	<para>UI suggestion: This feature should be inactive by
	default. When more than one GID is returned (the bullet case),
	an application could display the forms sequentially in
	context, or present a palette showing all the forms at once,
	or give the user a choice between these approaches. Once the
	user has selected a specific ornament, that one should be the
	default selection the next time the bullet is typed. In the
	absence of such prior information, the application may assume
	that the first ornament in a set is the preferred form, so the
	font developer should order them accordingly.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other substitution (GSUB) features, which should be
	turned off when it's applied.</para>


	<para>Tag: 'palt'</para>

	<para>Friendly name: Proportional Alternate Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Respaces glyphs designed to be set on full-em
	widths, fitting them onto individual (more or less
	proportional) horizontal widths. This differs from pwid in
	that it does not substitute new glyphs (GPOS, not GSUB
	feature). The user may prefer the monospaced form, or may
	simply want to ensure that the glyph is well-fit and not
	rotated in vertical setting (Latin forms designed for
	proportional spacing would be rotated).</para>

	<para>Example: The user may invoke this feature in a Japanese
	font to get Latin, Kanji, Kana or Symbol glyphs with the
	full-width design but individual metrics.</para>

	<para>Recommended implementation: The font specifies alternate
	metrics for the full-width glyphs (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the palt
	coverage table, the application passes the GIDs to the table
	and gets back positional adjustments (XPlacement, XAdvance,
	YPlacement and YAdvance).</para>

	<para>UI suggestion: This feature would be off by default.</para>

	<para>Script/language sensitivity: Used mostly in CJKV fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. fwid, halt, hwid,
	qwid and twid), which should be turned off when it's
	applied. Applying this feature should activate the kern
	feature. See also vpal.</para>


	<para>Tag:'pcap'</para>

	<para>Friendly name: Petite Capitals</para>

	<para>Registered by: Tiro Typeworks / Emigre</para>

	<para>Function: Some fonts contain an additional size of
	capital letters, shorter than the regular smallcaps and
	whimsically referred to as petite caps. Such forms are most
	likely to be found in designs with a small lowercase x-height,
	where they better harmonise with lowercase text than the
	taller smallcaps (for examples of petite caps, see the Emigre
	type families Mrs Eaves and Filosofia). This feature turns
	lowercase characters into petite capitals. Forms related to
	petite capitals, such as specially designed figures, may be
	included.</para>

	<figure>
	  <title>pcap illustration</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='pcapprop.gif'/>
            </imageobject>
          </mediaobject>
	</figure>

	<para></para>

	<para>Example: The user enters text as lowercase or mixed
	case, and gets petite cap text or text with regular uppercase
	and petite caps. Note that some designers, might extend the
	petite cap lookups to include uppercase-to-smallcap
	substitutions, creating a shifting hierarchy of uppercase
	forms.</para>

	<para>Recommended implementation: The pcap table maps
	lowercase glyphs to the corresponding petite cap forms (GSUB
	lookup type 1).</para>

	<para>Application interface: For GIDs found in the pcap
	coverage table, the application passes GIDs to the pcap table,
	and gets back new GIDs. Petite cap substitutions should follow
	language rules for smallcap (smcp) substitutions.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to scripts
	with both upper- and lowercase forms (e.g. Latin, Cyrillic,
	Greek).</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'pnum'</para>

	<para>Friendly name: Proportional Figures</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces figure glyphs set on uniform
	(tabular) widths with corresponding glyphs set on
	glyph-specific (proportional) widths. Tabular widths will
	generally be the default, but this cannot be safely
	assumed. Of course this feature would not be present in
	monospaced designs.</para>

	<para>Example: The user may apply this feature to get even
	spacing for lining figures used as dates in an all-cap
	headline.</para>

	<para>Recommended implementation: In order to simplify
	associated kerning and get the best glyph design for a given
	width, this feature should use new glyphs for the figures,
	rather than only adjusting the fit of the tabular glyphs
	(although some may be simple copies); i.e. not a GPOS
	feature. The pnum table maps tabular versions of lining and/or
	oldstyle figures to corresponding proportional glyphs (GSUB
	lookup type 1).</para>

	<para>Application interface: For GIDs found in the pnum
	coverage table, the application passes GIDs to the pnum table
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by
	default. The application may want to query the user about this
	feature when the user changes figure style (onum or lnum).</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature overrides the results
	of the Tabular Figures feature (tnum).</para>


	<para>Tag: 'pref'</para>

	<para>Friendly name: Pre-base Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the pre-base form of a consonant.</para>

	<para>Example: In the Khmer script, the consonant Ra has a
	pre-base subscript form subscript called Coeng Ra. When the
	sequence of Coeng followed by Ra, its pre-base form is
	substituted.</para>

	<para>Recommended implementation: The pref table maps the
	sequence required to convert a consonant into its pre-base
	form (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	pref table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the pre base form of the
	consonant.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Khmer and
	Myanmar (Burmese) scripts that have pre-base forms for
	consonants.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'pres'</para>

	<para>Friendly name: Pre-base Substitutions</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Produces the pre-base forms of conjuncts in
	Indic scripts. It can also be used to substitute the
	appropriate glyph variant for pre-base vowel signs.</para>

	<para>Example: In the Gujarati (Indic) script, the doubling of
	consonant Ka requires the first Ka to be substituted by its
	pre-base form. This in turn ligates with the second
	Ka. Applying this feature would result in the ligaturised
	version of the doubled Ka.</para>

	<para>Recommended implementation: The pres table maps a
	sequence of consonants separated by the virama (halant), to
	the ligated conjunct form (GSUB lookup type 4). In the case of
	pre-base matra substitution, the appropriate matra can be
	substituted using contextual substitution (GSUB lookup type
	5).</para>

	<para>Application interface: For substitutions defined in the
	pres table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the ligature (or matra as
	the case may be).</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'pstf'</para>

	<para>Friendly name: Post-base Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the post-base form of a
	consonant.</para>

	<para>Example: In the Gurmukhi (Indic) script, the consonant
	Ya has a post base form. When the Ya is used as the second
	consonant in conjunct formation, its post-base form is
	substituted.</para>

	<para>Recommended implementation: The pstf table maps the
	sequence required to convert a consonant into its post-base
	form (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	pstf table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the post base form of the
	consonant.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic scripts
	that have post-base forms for consonants eg: Gurmukhi,
	Malayalam.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'psts'</para>

	<para>Friendly name: Post-base Substitutions</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes a sequence of a base glyph and
	post-base glyph, with its ligaturised form.</para>

	<para>Example: In the Malayalam (Indic) script, the consonant
	Va has a post base form. When the Va is doubled to form a
	conjunct- VVa; the first Va [base] and the post base form that
	follows it, is substituted with a ligature.</para>

	<para>Recommended implementation: The psts table maps
	identified conjunct formation sequences to corresponding
	ligatures (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	psts table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the ligature.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Can be used in any
	alphabetic script. Required in Indic scripts.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'pwid'</para>

	<para>Friendly name: Proportional Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces glyphs set on uniform widths
	(typically full or half-em) with proportionally spaced
	glyphs. The proportional variants are often used for the Latin
	characters in CJKV fonts, but may also be used for Kana in
	Japanese fonts.</para>

	<para>Example: The user may invoke this feature in a Japanese
	font to get a proportionally-spaced glyph instead of a
	corresponding half-width Roman glyph or a full-width Kana
	glyph.</para>

	<para>Recommended implementation: The font contains alternate
	glyphs designed to be set on proportional widths (GSUB lookup
	type 1).</para>

	<para>Application interface: For GIDs found in the pwid
	coverage table, the application passes the GIDs to the table
	and gets back new GIDs.</para>

	<para>UI suggestion: Applications may want to have this
	feature active or inactive by default depending on their
	markets.</para>

	<para>Script/language sensitivity: Although used mostly in
	CJKV fonts, this feature could be applied in European
	scripts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. fwid, halt, hwid,
	palt, qwid, twid, valt and vhal), which should be turned off
	when it's applied. Applying this feature should activate the
	kern feature.</para>


	<para>Tag: 'qwid'</para>

	<para>Friendly name: Quarter Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces glyphs on other widths with glyphs
	set on widths of one quarter of an em (half an en). The
	characters involved are normally figures and some forms of
	punctuation.</para>

	<para>Example: The user may apply qwid to place a four-digit
	figure in a single slot in a column of vertical text.</para>

	<para>Recommended implementation: The font may contain
	alternate glyphs designed to be set on quarter-em widths (GSUB
	lookup type 1), or it may specify alternate metrics for the
	original glyphs (GPOS lookup type 1) which adjust their
	spacing to fit in quarter-em widths.</para>

	<para>Application interface: For GIDs found in the qwid
	coverage table, the application passes the GIDs to the table
	and gets back either new GIDs or positional adjustments
	(XPlacement and XAdvance).</para>

	<para>UI suggestion: This feature would normally be off by
	default.</para>

	<para>Script/language sensitivity: Generally used only in CJKV
	fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. fwid, halt, hwid and
	twid), which should be turned off when it's applied. It
	deactivates the kern feature.</para>


	<para>Tag: 'rand'</para>

	<para>Friendly name: Randomize</para>

	<para>Registered by: Adobe</para>

	<para>Function: In order to emulate the irregularity and
	variety of handwritten text, this feature allows multile
	alternate forms to be used.</para>

	<para>Example: The user applies this feature in FF Kosmic to
	get three forms of f in one word.</para>

	<para>Recommended implementation: The rand table maps GIDs for
	default glyphs to one or more GIDs for corresponding
	alternates (GSUB lookup type 3).</para>

	<para>Application interface: For GIDs found in the rand
	coverage table, the application passes a GID to the rand table
	and gets back one or more new GIDs. The application selects
	one of these either by a pseudo-random algorithm, or by noting
	the sequence of IDs returned, storing that sequence, and
	stepping through that set as the corresponding character code
	is invoked.</para>

	<para>UI suggestion: This feature should be enabled/disabled
	via a preference setting; "enabled" is the recommended
	default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'rlig'</para>

	<para>Friendly name: Required Ligatures</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Replaces a sequence of glyphs with a single
	glyph which is preferred for typographic purposes. This
	feature covers those ligatures, which the script determines as
	required to be used in normal conditions. This feature is
	important for some scripts to insure correct glyph formation.</para>

	<para>Example: The Arabic character lam followed by alef will
	always form a ligated lamalef form. This ligated form is a
	requirement of the script's shaping. The same happens with the
	Syriac script.</para>

	<para>Recommended implementation: The rlig table maps GIDs for
	default glyphs to one or more GIDs for corresponding
	alternates (GSUB lookup type 3).</para>

	<para>Application interface: The rlig table maps sequences of
	glyphs to corresponding ligatures (GSUB lookup type
	4). Ligatures with more components must be stored ahead of
	those with fewer components in order to be found. The set of
	standard ligatures will normally remain constant by script.</para>

	<para>UI suggestion: This feature should be active by
	default. It is recommended that this feature not be turned off
	to avoid breaking obligatory script shaping.</para>

	<para>Script/language sensitivity: Applies to Arabic and
	Syriac. May apply to some other scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. See also liga.</para>


	<para>Tag: 'rphf'</para>

	<para>Friendly name: Reph Form</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the Reph form for a consonant and
	halant sequence.</para>

	<para>Example: In the Devanagari (Indic) script, the consonant
	Ra possesses a reph form. When the Ra is a syllable initial
	consonant and is followed by the virama, it is repositioned
	after the post base vowel sign within the syllable, and also
	substituted with a mark that sits above the base glyph.</para>

	<para>Recommended implementation: The rphf table maps the
	sequence of default form of Ra and virama to the Reph (GSUB
	lookup type 4).</para>

	<para>Application interface: The application gets back the GID
	for the reph mark.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic
	scripts. eg: Devanagari, Kannada.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'rtbd'</para>

	<para>Friendly name: Right Bounds</para>

	<para>Registered by: Adobe</para>

	<para>Function: Aligns glyphs by their apparent right extents
	at the right ends of horizontal lines of text, replacing the
	default behavior of aligning glyphs by their origins. This
	feature is called by the Optical Bounds (opbd) feature above.</para>

	<para>Example: Succeeding lines ending with r, h and y would
	shift to the right by differing degrees when the text is
	right-justified and this feature is applied.</para>

	<para>Recommended implementation: Values for affected glyphs
	describe the amount by which the placement and advance width
	should be altered (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the rtbd
	coverage table, the application passes a GID to the table and
	gets back a new XPlacement and XAdvance value.</para>

	<para>UI suggestion: This feature is called by an application
	when the user invokes the opbd feature.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: Should not be applied to glyphs
	which use fixed-width features (e.g. fwid, halt, hwid, qwid
	and twid) or vertical features (e.g. vert, vrt2, vpal, valt
	and vhal). Is called by opbd feature.</para>


	<para>Tag: 'rtla'</para>

	<para>Friendly name: Right-to-left alternates</para>

	<para>Registered by: Adobe</para>

	<para>Function: A number of Unicode characters are rendered by
	different shapes depending on the directional context in which
	they appear. For example, the character U+0028 LEFT
	PARENTHESIS is interpreted by the Unicode standard as an
	opening parenthesis and it appears as "(" in left-to-right
	contexts, and as ")" in right-to-left contexts (this is
	described on page 66 of the Unicode Standard, version
	3.0). The 'rtla' feature is used to access the shape
	appropriate for a right-to-left context.</para>

	<para>Example: The 'rtla' feature replaces the glyph "(" by
	the glyph ")".</para>

	<para>Recommended implementation: These are one-to-one
	substitutions (GSUB lookup type 1). Since this feature is a
	glyph selection feature, it should probably be performed early
	in the shaping process. At least all the glyphs mapped from
	characters with the mirrored property should have a
	replacement.</para>

	<para>Application interface: The layout application applies
	the Unicode bidi algorithm to the character string to display,
	and maps the resulting character string to glyphs via the
	cmap. It activates the 'rtla' feature on glyphs that
	correspond to characters with an odd (right-to-left) resolved
	level. It is important to note that this feature can be
	applied to more glyphs than those that correspond to
	characters with the mirrored property. The motivation is that
	the font designer may want additional characters to assume
	different shapes.</para>

	<para>If the 'rtla' feature is implemented, it must be
	implemented for all glyphs in the font that represent Unicode
	characters with the mirrored property. If the 'rtla' feature
	is not implemented, it is assumed that the application will
	take care of bidirectional mirroring through an algorithm.</para>

	<para>UI suggestion: None.</para>

	<para>Script/language sensitivity: Scripts that are
	right-to-left.</para>

	<para>Feature interaction: This feature may be used in
	combination with other features.</para>


	<para>Tag: 'ruby'</para>

	<para>Friendly name: Ruby Notation Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Japanese typesetting often uses smaller kana
	glyphs, generally in superscripted form, to clarify the
	meaning of kanji which may be unfamiliar to the reader. These
	are called ruby, from the old typesetting term for
	four-point-sized type. This feature identifies glyphs in the
	font which have been designed for this use, substituting them
	for the default designs.</para>

	<para>Example: The user applies this feature to the kana
	character U+3042, to get the ruby form for annotation.</para>

	<para>Recommended implementation: The font contains alternate
	glyphs for all kana characters which are enabled for ruby
	notation. The ruby table maps GIDs for default forms to GIDs
	for corresponding ruby alternates. These are one-to-one
	substitutions (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the ruby
	coverage table, the application passes the GIDs for default
	forms to the table and gets back new GIDs for ruby forms. The
	application then scales and positions these forms according to
	its defaults, which may take user parameters.</para>

	<para>UI suggestion: This feature should be inactive by
	default. Applications may offer the user an opportunity to
	specify the degree of scaling and baseline shift.</para>

	<para>Script/language sensitivity: Applies only to Japanese.</para>

	<para>Feature interaction: This feature overrides the results
	of any other feature for the affected characters.</para>



	<para>Tag: 'salt'</para>

	<para>Friendly name: Stylistic Alternates</para>

	<para>Registered by: Adobe</para>

	<para>Function: Many fonts contain alternate glyph designs for
	a purely esthetic effect; these do not always fit into a clear
	category like swash or historical. As in the case of swash
	glyphs, there may be more than one alternate form. This
	feature replaces the default forms with the stylistic
	alternates.</para>

	<para>Example: The user applies this feature to Industria to
	get the alternate form of g.</para>

	<para>Recommended implementation: The salt table maps GIDs for
	default forms to one or more GIDs for corresponding stylistic
	alternatives. While many of these substitutions are one-to-one
	(GSUB lookup type 1), others require a selection from a set
	(GSUB lookup type 3). The manufacturer may choose to build two
	tables (one for each lookup type) or only one which uses
	lookup type 3 for all substitutions. As in any one-from-many
	substitution, alternates present in more than one face should
	be ordered consistently across a family, so that those
	alternates can work correctly when switching between family
	members.</para>

	<para>Application interface: For GIDs found in the salt
	coverage table, the application passes the GIDs to the salt
	table and gets back one or more new GIDs. If more than one GID
	is returned, the application must provide a means for the user
	to select the one desired.</para>

	<para>UI suggestion: This feature should be inactive by
	default. When more than one GID is returned, an application
	could display the forms sequentially in context, or present a
	palette showing all the forms at once, or give the user a
	choice between these approaches. The application may assume
	that the first glyph in a set is the preferred form, so the
	font developer should order them accordingly.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'sinf'</para>

	<para>Friendly name: Scientific Inferiors</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces lining or oldstyle figures with
	inferior figures (smaller glyphs which sit lower than the
	standard baseline, primarily for chemical or mathematical
	notation). May also replace lowercase characters with
	alphabetic inferiors.</para>

	<para>Example: The application can use this feature to
	automatically access the inferior figures (more legible than
	scaled figures).</para>

	<para>Recommended implementation: The sinf table maps figures
	to the corresponding inferior forms (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the sinf
	coverage table, the application passes a GID to the feature
	and gets back a new GID.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Can apply to nearly any
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'size'</para>

	<para>Friendly name: Optical size</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature stores two kinds of information
	about the optical size of the font: design size (the point
	size for which the font is optimized) and size range (the
	range of point sizes which the font can serve well), as well
	as other information which helps applications use the size
	range. The design size is useful for determining proper
	tracking behavior. The size range is useful in families which
	have fonts covering several ranges. Additional values serve to
	identify the set of fonts which share related size ranges, and
	to identify their shared name. Note that sizes refer to
	nominal final output size, and are independent of viewing
	magnification or resolution.</para>

	<para>Required implementation:</para>

	<para>The Feature table of this GPOS feature contains no
	lookups; its Feature Parameters field records an offset from
	the beginning of the Feature table to an array of five 16-bit
	unsigned integer values. The size feature must be implemented
	in all fonts in any family which uses the feature. In this
	usage, a family is a set of fonts which share a Preferred
	Family name (name ID 16), or Font Family name (name ID 1) if
	the Preferred Family name is absent.</para>

	<itemizedlist>
	  <listitem>
	    <para>The first value represents the design size in
	      720/inch units (decipoints). The design size entry must
	      be non-zero. When there is a design size but no
	      recommended size range, the rest of the array will
	      consist of zeros.</para>
	  </listitem>
	  <listitem>
	    <para>The second value has no independent meaning, but
	    serves as an identifier that associates fonts in a
	    subfamily. All fonts which share a Preferred or Font
	    Family name and which differ only by size range shall have
	    the same subfamily value, and no fonts which differ in
	    weight or style shall have the same subfamily value. If
	    this value is zero, the remaining fields in the array will
	    be ignored.</para>
	  </listitem>
	  <listitem>
	    <para>The third value enables applications to use a single
	      name for the subfamily identified by the second
	      value. If the preceding value is non-zero, this value
	      must be set in the range 256 - 32767 (inclusive). It
	      records the value of a field in the name table, which
	      must contain English-language strings encoded in Windows
	      Unicode and Macintosh Roman, and may contain additional
	      strings localized to other scripts and languages. Each
	      of these strings is the name an application should use,
	      in combination with the family name, to represent the
	      subfamily in a menu. Applications will choose the
	      appropriate version based on their selection criteria.</para>
	  </listitem>
	  <listitem>
	    <para>The fourth and fifth values represent the small end
	    of the recommended usage range (exclusive) and the large
	    end of the recommended usage range (inclusive), stored in
	    720/inch units (decipoints). Ranges must not overlap, and
	    should generally be contiguous.</para>
	  </listitem>
	</itemizedlist>

	<para>Example: The size information in Bell Centennial is [60
	0 0 0 0]. This tells an application that the font's design
	size is six points, so larger sizes may need proportionate
	reduction in default inter-glyph spacing. The size information
	in Minion Pro Semibold Condensed Subhead is [180 3 257 139
	240]. These values tell an application that:</para>

	<itemizedlist>
	  <listitem>
	    <para>The font&#x2019;s design size is 18 points;</para>
	  </listitem>
	  <listitem>
	    <para>This font is part of a subfamily of fonts that
	    differ only by the size range which each covers, and which
	    share the arbitrary identifier number 3;</para>
	  </listitem>
	  <listitem>
	    <para>ID 257 in the name table is the suggested menu name
	    for this subfamily. In this case, the string at name ID
	    257 is Semibold Condensed;</para>
	  </listitem>
	  <listitem>
	    <para>This font is the recommended choice from sizes
	    greater than 13.9-point up through 24-points.</para>
	  </listitem>
	</itemizedlist>

	<para>Application interface: When the user specifies a size,
	the application checks for a size feature in the active
	font. If none is found, the application follows its default
	behavior. If one is found, the application follows the
	specified offset to retrieve the five values.</para>

	<itemizedlist>
	  <listitem>
	    <para>Design size: Applications which offer size-based
	    tracking have a pre-defined curve which they can apply. By
	    default, this curve should be set to produce no adjustment
	    at the font's design size (first value in the array, in
	    decipoints).</para>
	  </listitem>
	  <listitem>
	    <para>Size ranges: If the second value in the size array
	    is non-zero, the font has a recommended size range. When
	    any such font is selected by the user, the application
	    builds a list of all fonts with this subfamily value and
	    the same Preferred Family name, and notes the size range
	    in the current font. Applications may want to cache the
	    subfamily list at this point. If the specified size falls
	    in the current font's range, the application uses the
	    current font. If not, the application checks the other
	    ranges in the subfamily, and if the specified size falls
	    in one of them, uses that font. If the specified size is
	    not in any range present, the font with the range closest
	    to the specified value is used. If the specified size
	    falls exactly between two ranges, the range with the
	    larger values is used. Since adding or removing fonts from
	    a subfamily may cause reflow, applications should note
	    which fonts are used for which text.</para>
	  </listitem>
	</itemizedlist>

	<para>UI suggestion: This feature should be active by
	default. Applications may want to present the tracking curve
	to the user for adjustments via a GUI. At start-up, and when
	fonts are added or removed, applications may want to build a
	list of fonts with such ranges, and display the filtered
	subfamily names in their font selection UI, with each filtered
	name representing the full set of related sizes. Applications
	may also present a setting which allows the user to select
	non-default sizes (for example, in the case where final output
	is intended for on-screen viewing, a smaller optical size will
	produce better results). In such a case, the font-selection UI
	should present the unfiltered names. Applications should
	notify the user if fonts are removed or added from a subfamily
	with size ranges, and query about desired behavior.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: None.</para>


	<para>Tag: 'smcp'</para>

	<para>Friendly name: Small Capitals</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: This feature turns lowercase characters into
	small capitals. This corresponds to the common SC font
	layout. It is generally used for display lines set in Large and
	small caps, such as titles. Forms related to small capitals,
	such as oldstyle figures, may be included.</para>

	<para>Example: The user enters text as mixed capitals and
	lowercase, and gets Large and small cap text.</para>

	<para>Recommended implementation: The smcp table maps
	lowercase glyphs to the corresponding small-cap forms (GSUB
	lookup type 1).</para>

	<para>Application interface: For GIDs found in the smcp
	coverage table, the application passes GIDs to the smcp table,
	and gets back new GIDs. Note that applications should treat &#x00df;
	(U+00DF) as a pair of s characters, and that the Turkish
	dotless i maps to the normal small cap I.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to European
	scripts (Cyrillic, Greek and Latin), which have capital forms.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. Also see c2sc.</para>


	<para>Tag: 'smpl'</para>

	<para>Friendly name: Simplified Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces 'traditional' Chinese or Japanese
	forms with the corresponding 'simplified' forms.</para>

	<para>Example: The user gets U+53F0 when U+6AAF, U+81FA, or
	U+98B1 is entered.</para>

	<para>Recommended implementation: The smpl table maps each
	traditional form in a font to a corresponding simplified form
	(GSUB lookup type 1). Note that more than one traditional form
	may map to a single simplified form.</para>

	<para>Application interface: For GIDs found in the smpl
	coverage table, the application passes the GIDs to the table
	and gets back one new GID for each. Note: This is a change of
	character code. Besides the original character code, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature would be off by default, but
	could be made the default by a preference setting.</para>

	<para>Script/language sensitivity: Applies only to Chinese and
	Japanese.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other features, which should be turned off when
	it is applied, except the palt, vert and vrt2 features,
	which may be used in addition; trad and tnam are mutally
	exclusive, and override the results of smpl.</para>


	<para>Tag: 'ss01' - 'ss20'</para>

	<para>Friendly name: Stylistic Set 1 - Stylistic Set 20</para>

	<para>Registered by: Tiro Typeworks</para>

	<para>Function: In addition to, or instead of, stylistic
	alternatives of individual glyphs (see 'salt' feature), some
	fonts may contain sets of stylistic variant glyphs
	corresponding to portions of the character set, e.g. multiple
	variants for lowercase letters in a Latin font. Glyphs in
	stylistic sets may be designed to harmonise visually,
	interract in particular ways, or otherwise work
	together. Examples of fonts including stylistic sets are
	Zapfino Linotype and Adobe's Poetica. Individual features
	numbered sequentially with the tag name convention 'ss01'
	'ss02' 'ss03' . 'ss20' provide a mechanism for glyphs in these
	sets to be associated via GSUB lookup indexes to default forms
	and to each other, and for users to select from available
	stylistic sets.</para>

	<para>Recommended implementation: An ssXX table maps GIDs for
	default forms to one GIDs for corresponding stylistic
	alternatives in each set. Each ssXX feature uses one-to-one
	(GSUB lookup type 1) substitutions. Font developers may choose
	to map only from default forms to variants for each stylistic
	set, or may choose to map between all stylistic sets in each
	feature, depending on intended user experience. For example,
	feature 'ss03' might contain lookups mapping variant glyphs
	from 'ss01' and 'sso2' to corresponding variants in 'ss03', in
	addition to mapping from default forms.</para>

	<para>Application interface: Note that the application is
	responsible for counting and enumerating the number of
	features in the font with tag names of the format 'ss01' to
	'ss20', and for presenting the user with an appropriate
	selection mechanism. For GIDs found in the ssXX coverage
	table, the application passes the GIDs to the ssXX table and
	gets back one or more new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override. Note that after an ssXX feature has
	been applied, the user may wish to apply glyph-specific
	features, e.g. 'salt', to individual glyphs in the resulting
	layout; font developers are responsible for ordering
	substitution lookups to obtain desired user experience.</para>


	<para>Tag: 'subs'</para>

	<para>Friendly name: Subscript</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: The "subs" feature may replace a default glyph
	with a subscript glyph, or it may combine a glyph substitution
	with positioning adjustments for proper placement.</para>

	<para>Recommended implementation: First, a single or
	contextual substitution lookup implements the subscript glyph
	(GSUB lookup type 1). Then, if the glyph needs repositioning,
	an application may apply a single adjustment, pair adjustment,
	or contextual adjustment positioning lookup to modify its
	position.</para>

	<para>Application interface: For GIDs found in the subs
	coverage table, the application passes a GID to the feature
	and gets back a new GID. Note: This is a change of semantic
	value. Besides the original character codes, the application
	should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Can apply to nearly any
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'sups'</para>

	<para>Friendly name: Superscript</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces lining or oldstyle figures with
	superior figures (primarily for footnote indication), and
	replaces lowercase letters with superior letters (primarily
	for abbreviated French titles).</para>

	<para>Example: The application can use this feature to
	automatically access the superior figures (more legible than
	scaled figures) for footnotes, or the user can apply it to
	Mssr to get the classic form.</para>

	<para>Recommended implementation: The sups table maps figures
	and lowercase letters to the corresponding superior forms
	(GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the sups
	coverage table, the application passes a GID to the feature
	and gets back a new GID. Note: This can include a change of
	semantic value. Besides the original character codes, the
	application should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Can apply to nearly any
	script.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'swsh'</para>

	<para>Friendly name: Swash</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: This feature replaces default character glyphs
	with corresponding swash glyphs. Note that there may be more
	than one swash alternate for a given character.</para>

	<para>Example: The user inputs the ampersand character when
	setting text with Poetica with this feature active, and is
	presented with a choice of the 63 ampersand forms in that
	face.</para>

	<para>Recommended implementation: The swsh table maps GIDs for
	default forms to those for one or more corresponding swash
	forms. While many of these substitutions are one-to-one (GSUB
	lookup type 1), others require a selection from a set (GSUB
	lookup type 3). The manufacturer may choose to build two
	tables (one for each lookup type) or only one which uses
	lookup type 3 for all substitutions. If several styles of
	swash are present across the font, the set of forms for each
	character should be ordered consistently.</para>

	<para>Application interface: For GIDs found in the swsh
	coverage table, the application passes the GIDs to the swsh
	table and gets back one or more new GIDs. If more than one GID
	is returned, the application must provide a means for the user
	to select the one desired.</para>

	<para>UI suggestion: This feature should be inactive by
	default. When more than one GID is returned, an application
	could display the forms sequentially in context, or present a
	palette showing all the forms at once, or give the user a
	choice between these approaches. The application may assume
	that the first glyph in a set is the preferred form, so the
	font developer should order them accordingly.</para>

	<para>Script/language sensitivity: Does not apply to
	ideographic scripts.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'titl'</para>

	<para>Friendly name: Titling</para>

	<para>Registered by: Adobe</para>

	<para>Function: This feature replaces the default glyphs with
	corresponding forms designed specifically for titling. These
	may be all-capital and/or larger on the body, and adjusted for
	viewing at larger sizes.</para>

	<para>Example: The user applies this feature in Adobe Garamond
	to get the titling caps.</para>

	<para>Recommended implementation: The titl table maps default
	forms to corresponding titling forms (GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the titl
	coverage table, the application passes the GIDs to the titl
	table and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'tjmo'</para>

	<para>Friendly name: Trailing Jamo Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the trailing jamo form of a
	cluster.</para>

	<para>Example: In Hangul script, the jamo cluster is composed
	of three parts (leading consonant, vowel, and trailing
	consonant). When a sequence of trailing class jamos are found,
	their combined trailing jamo form is substituted.</para>

	<para>Recommended implementation: The tjmo table maps the
	sequence required to convert a series of jamos into its
	trailing jamo form (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	tjmo table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the trailing jamo form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required for Hangul script
	when Ancient Hangul writing system is supported.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'tnam'</para>

	<para>Friendly name: Traditional Name Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces 'simplified' Japanese kanji forms
	with the corresponding 'traditional' forms. This is equivalent
	to the Traditional Forms feature, but explicitly limited to
	the traditional forms considered proper for use in personal
	names (as many as 205 glyphs in some fonts).</para>

	<para>Example: The user inputs U+4E9C and gets U+4E9E.</para>

	<para>Recommended implementation: The tnam table maps
	simplified forms in a font to corresponding traditional forms
	which can be used in personal names (GSUB lookup type 1). The
	application stores a record of any simplified forms which
	resulted from substitutions (the smpl feature); for such
	forms, applying the tnam feature undoes the previous
	substitution.</para>

	<para>Application interface: For GIDs found in the tnam
	coverage table, the application passes the GIDs to the table
	and gets back new GIDs. Note: This is a change of character
	code. Besides the original character code, the application
	should store the code for the new character.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to Japanese.</para>

	<para>Feature interaction: May include some characters
	affected by the Proportional Alternate Widths feature (palt);
	trad and tnam are mutually exclusive, and override the results
	of smpl.</para>


	<para>Tag: 'tnum'</para>

	<para>Friendly name: Tabular Figures</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces figure glyphs set on proportional
	widths with corresponding glyphs set on uniform (tabular)
	widths. Tabular widths will generally be the default, but this
	cannot be safely assumed. Of course this feature would not be
	present in monospaced designs.</para>

	<para>Example: The user may apply this feature to get oldstyle
	figures to align vertically in a column.</para>

	<para>Recommended implementation: In order to simplify
	associated kerning and get the best glyph design for a given
	width, this feature should use new glyphs for the figures,
	rather than only adjusting the fit of the proportional glyphs
	(although some may be simple copies); i.e. not a GPOS
	feature. The tnum table maps proportional versions of lining
	and/or oldstyle figures to corresponding tabular glyphs (GSUB
	lookup type 1).</para>

	<para>Application interface: For GIDs found in the tnum
	coverage table, the application passes GIDs to the tnum table
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by
	default. The application may want to query the user about this
	feature when the user changes figure style (onum or lnum).</para>

	<para>Script/language sensitivity: None.</para>

	<para>Feature interaction: This feature overrides the results
	of the Proportional Figures feature ( pnum).</para>


	<para>Tag: 'trad'</para>

	<para>Friendly name: Traditional Forms</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces 'simplified' Chinese hanzi or
	Japanese kanji forms with the corresponding 'traditional'
	forms.</para>

	<para>Example: The user inputs U+53F0 and is offered a choice
	of U+6AAF, U+81FA, or U+98B1.</para>

	<para>Recommended implementation: The trad table maps each
	simplified form in a font to one or more traditional
	forms. While many of these substitutions are one-to-one (GSUB
	lookup type 1), others require a selection from a set (GSUB
	lookup type 3). The manufacturer may choose to build two
	tables (one for each lookup type) or only one which uses
	lookup type 3 for all substitutions. As in any one-from-many
	substitution, alternates present in more than one face should
	be ordered consistently across a family, so that those
	alternates can work correctly when switching between family
	members.</para>

	<para>Application interface: For GIDs found in the trad
	coverage table, the application passes the GIDs to the table
	and gets back one or more new GIDs. If more than one GID is
	returned, the application must provide a means for the user to
	select the one desired. The application stores a record of any
	simplified forms which resulted from substitutions (the smpl
	feature); for such forms, applying the trad feature undoes the
	previous substitution. Note: This is a change of character
	code. Besides the original character code, the application
	should store the code for the new character.</para>

	<para>UI suggestion: This feature should be inactive by
	default. If there's no record of a conversion from traditional
	to simplified, the user must be offered a set of possibilities
	from which to select. The application may note the user's
	choice, and offer it as a default the next time the source
	simplified character is encountered. In the absence of such
	prior information, the application may assume that the first
	glyph in a set is the preferred form, so the font developer
	should order them accordingly.</para>

	<para>Script/language sensitivity: Applies only to Chinese and
	Japanese.</para>

	<para>Feature interaction: May include some characters
	affected by the Proportional Alternate Widths feature (palt);
	trad and tnam are mutually exclusive, and override the results
	of smpl.</para>


	<para>Tag: 'twid'</para>

	<para>Friendly name: Third Widths</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces glyphs on other widths with glyphs
	set on widths of one third of an em. The characters involved
	are normally figures and some forms of punctuation.</para>

	<para>Example: The user may apply twid to place a three-digit
	figure in a single slot in a column of vertical text.</para>

	<para>Recommended implementation: The font may contain
	alternate glyphs designed to be set on third-em widths (GSUB
	lookup type 1), or it may specify alternate metrics for the
	original glyphs (GPOS lookup type 1) which adjust their
	spacing to fit in third-em widths.</para>

	<para>Application interface: For GIDs found in the twid
	coverage table, the application passes the GIDs to the table
	and gets back either new GIDs or positional adjustments
	(XPlacement and XAdvance).</para>

	<para>UI suggestion: This feature would normally be off by
	default.</para>

	<para>Script/language sensitivity: Generally used only in CJKV
	fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-width features (e.g. fwid, halt, hwid and
	qwid), which should be turned off when it's applied. It
	deactivates the kern feature.</para>


	<para>Tag: 'unic'</para>

	<para>Friendly name: Unicase</para>

	<para>Registered by: Tiro Typeworks / Emigre</para>

	<para>Function: This feature maps upper- and lowercase letters
	to a mixed set of lowercase and small capital forms, resulting
	in a single case alphabet (for an example of unicase, see the
	Emigre type family Filosofia). The letters substituted may
	vary from font to font, as appropriate to the design. If
	aligning to the x-height, smallcap glyphs may be substituted,
	or specially designed unicase forms might be
	used. Substitutions might also include specially designed
	figures.</para>

	<figure>
	  <title>unic illustration</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='unicprop.gif'/>
            </imageobject>
          </mediaobject>
	</figure>

	<para>Example: The user enters text as uppercase, lowercase or
	mixed case, and gets unicase text.</para>

	<para>Recommended implementation: The unic table maps some
	uppercase and lowercase glyphs to corresponding unicase forms
	(GSUB lookup type 1).</para>

	<para>Application interface: For GIDs found in the unic
	coverage table, the application passes GIDs to the unic table,
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be off by default.</para>

	<para>Script/language sensitivity: Applies only to scripts
	with both upper- and lowercase forms (e.g. Latin, Cyrillic,
	Greek).</para>

	<para>Feature interaction: This feature may be used in
	combination with other substitution (GSUB) features, whose
	results it may override.</para>


	<para>Tag: 'valt'</para>

	<para>Friendly name: Alternate Vertical Metrics</para>

	<para>Registered by: Adobe (Modified by Adobe, this is the
	newer description)</para>

	<para>Function: Repositions glyphs to visually center them
	within full-height metrics, for use in vertical
	setting. Typically applies to full-width Latin glyphs, which
	are aligned on a common horizontal baseline and not rotated
	when set vertically in CJKV fonts.</para>

	<para>Example: Applying this feature would shift a Roman h
	down, or y up, from their default full-width positions.</para>

	<para>Recommended implementation: The font specifies alternate
	metrics for the original glyphs (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the valt
	coverage table, the application passes the GIDs to the table
	and gets back positional adjustments (YPlacement).</para>

	<para>UI suggestion: This feature should be active by default
	in vertical-setting contexts.</para>

	<para>Script/language sensitivity: Applies only to scripts
	with vertical writing modes.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-height features (e.g. vhal and vpal),
	which should be turned off when it's applied. It deactivates
	the kern feature.</para>


	<para>Tag: "vatu"</para>

	<para>Friendly name: Vattu Variants</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes ligatures for conjuncts made up of
	base consonants with consonants that have vattu forms.</para>

	<para>Example: In the Devanagari (Indic) script, the consonant
	Ra takes a vattu form, when it is not the syllable initial
	consonant in a conjunct. This form ligates with the base
	consonant as well as half forms of consonants.</para>

	<para>Recommended implementation: The vatu table maps
	consonant and vattu form combinations to their respective
	ligatures (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	vatu table, the application passes the sequence of GIDs to the
	table, and gets back the GID for the vattu variant ligature.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required in Indic
	scripts. eg: Devanagari.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'vert'</para>

	<para>Friendly name: Vertical Alternates</para>

	<para>Registered by: Microsoft/Adobe</para>

	<para>Function: Replaces default forms with variants adjusted
	for vertical writing when in vertical writing mode. While most
	CJKV glyphs remain vertical when set in vertical writing mode,
	some take a different form (usually rotated and repositioned)
	for this purpose. Glyphs covered by this feature correspond to
	the set normally rotated in low-end DTP applications.</para>

	<para>Example: In vertical writing mode, the opening
	parenthesis (U+FF08) is replaced by the rotated form
	(U+FE35).</para>

	<para>Recommended implementation: The font includes rotated
	versions of the glyphs covered by this feature. The vert table
	maps the standard forms to the corresponding rotated forms
	(GSUB lookup type 1). This feature should be the last
	substitution in the font, and take input from other features.</para>

	<para>Application interface: For GIDs found in the vert
	coverage table, the application passes GIDs to the feature,
	and gets back new GIDs. See the vrt2 feature description for
	more details.</para>

	<para>UI suggestion: This feature should be active by default
	when vertical writing mode is on if the vrt2 feature is not
	present. See the vrt2 feature description for more details,
	and a discussion of vertical writing in OpenType.</para>

	<para>Script/language sensitivity: Applies only to scripts
	with vertical writing capability.</para>

	<para>Feature interaction: This is a subset of the vrt2
	feature; vrt2 is preferred. May be used in addition to any
	other feature.</para>


	<para>Tag: 'vhal'</para>

	<para>Friendly name: Alternate Vertical Half Metrics</para>

	<para>Registered by: Adobe</para>

	<para>Function: Respaces glyphs designed to be set on full-em
	heights, fitting them onto half-em heights. This differs from
	valt in that it does not substitute new glyphs.</para>

	<para>Example: The user may invoke this feature in a CJKV font
	to get better fit for punctuation or symbol glyphs without
	disrupting the monospaced alignment.</para>

	<para>Recommended implementation: The font specifies alternate
	metrics for the full-height glyphs (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the vhal
	coverage table, the application passes the GIDs to the table
	and gets back positional adjustments (XPlacement, XAdvance,
	YPlacement and YAdvance).</para>

	<para>UI suggestion: This feature would be off by default.</para>

	<para>Script/language sensitivity: Used only in CJKV fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-height features (e.g. valt and vpal),
	which should be turned off when it is applied. It
	deactivates the kern feature. See also halt.</para>


	<para>Tag: "vjmo"</para>

	<para>Friendly name: Vowel Jamo Forms</para>

	<para>Registered by: Microsoft</para>

	<para>Function: Substitutes the vowel jamo form of a cluster.</para>

	<para>Example: In Hangul script, the jamo cluster is composed
	of three parts (leading consonant, vowel, and trailing
	consonant). When a sequence of vowel class jamos are found,
	their combined vowel jamo form is substituted.</para>

	<para>Recommended implementation: The vjmo table maps the
	sequence required to convert a series of jamos into its vowel
	jamo form (GSUB lookup type 4).</para>

	<para>Application interface: For substitutions defined in the
	vjmo table, the application passes the sequence of GIDs to the
	feature, and gets back the GID for the vowel jamo form.</para>

	<para>UI suggestion: This feature should be on by default.</para>

	<para>Script/language sensitivity: Required for Hangul script
	when Ancient Hangul writing system is supported.</para>

	<para>Feature interaction: This feature overrides the results
	of all other features.</para>


	<para>Tag: 'vkna'</para>

	<para>Friendly name: Vertical Kana Alternates</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces standard kana with forms that have
	been specially designed for only vertical writing. This is a
	typographic optimization for improved fit and more even
	color. Also see hkna.</para>

	<para>Example: Standard full-width kana (hiragana and
	katakana) are replaced by forms that are designed for vertical
	use.</para>

	<para>Recommended implementation: The font includes a set of
	specially-designed glyphs, listed in the vkna coverage
	table. The vkna feature maps the standard full-width forms to
	the corresponding special vertical forms (GSUB lookup type
	1).</para>

	<para>Application interface: For GIDs found in the vkna
	coverage table, the application passes GIDs to the feature,
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature would be off by default.</para>

	<para>Script/language sensitivity: Applies only to fonts that
	support kana (hiragana and katakana).</para>

	<para>Feature interaction: Since this feature is only for
	vertical use, features applying to horizontal behaviors
	(e.g. kern) do not apply.</para>


	<para>Tag: 'vkrn'</para>

	<para>Friendly name: Vertical Kerning</para>

	<para>Registered by: Adobe</para>

	<para>Function: Adjusts amount of space between glyphs,
	generally to provide optically consistent spacing between
	glyphs. Although a well-designed typeface has consistent
	inter-glyph spacing overall, some glyph combinations require
	adjustment for improved legibility. Besides standard
	adjustment in the vertical direction, this feature can supply
	size-dependent kerning data via device tables, "cross-stream"
	kerning in the X text direction, and adjustment of glyph
	placement independent of the advance adjustment. Note that
	this feature may apply to runs of more than two glyphs, and
	would not be used in monospaced fonts. Also note that this
	feature applies only to text set vertically.</para>

	<para>Example: When the katakana character U+30B9 or U+30D8 is
	followed by U+30C8 in a vertical setting, U+30C8 is shifted up
	to fit more evenly.</para>

	<para>Recommended implementation: The font stores a set of
	adjustments for pairs of glyphs (GPOS lookup type 2 or
	8). These may be stored as one or more tables matching left
	and right classes, and/or as individual pairs. Additional
	adjustments may be provided for larger sets of glyphs
	(e.g. triplets, quadruplets, etc.) to overwrite the results of
	pair kerns in particular combinations.</para>

	<para>Application interface: The application passes a sequence
	of GIDs to the kern table, and gets back adjusted positions
	(XPlacement, XAdvance, YPlacement and YAdvance) for those
	GIDs. When using the type 2 lookup on a run of glyphs, it's
	critical to remember to not consume the last glyph, but to
	keep it available as the first glyph in a subsequent run (this
	is a departure from normal lookup behavior).</para>

	<para>UI suggestion: This feature should be active by default
	for vertical text setting. Applications may wish to allow
	users to add further manually-specified adjustments to suit
	specific needs and tastes.</para>

	<para>Script/language sensitivity: None</para>

	<para>Feature interaction: If 'vkrn' is activated, 'vpal' must
	also be activated if it exists. (If 'vpal' is activated, there
	is no requirement that 'vkrn' must also be activated.) May be
	used in addition to any other feature except those which
	result in fixed (uniform) advance heights.</para>


	<para>Tag: 'vpal'</para>

	<para>Friendly name: Proportional Alternate Vertical Metrics</para>

	<para>Registered by: Adobe</para>

	<para>Function: Respaces glyphs designed to be set on full-em
	heights, fitting them onto individual (more or less
	proportional) vertical heights. This differs from valt in that
	it does not substitute new glyphs (GPOS, not GSUB
	feature). The user may prefer the monospaced form, or may
	simply want to ensure that the glyph is well-fit.</para>

	<para>Example: The user may invoke this feature in a Japanese
	font to get Latin, Kanji, Kana or Symbol glyphs with the
	full-height design but individual metrics.</para>

	<para>Recommended implementation: The font specifies alternate
	heights for the full-height glyphs (GPOS lookup type 1).</para>

	<para>Application interface: For GIDs found in the vpal
	coverage table, the application passes the GIDs to the table
	and gets back positional adjustments (XPlacement, XAdvance,
	YPlacement and YAdvance).</para>

	<para>UI suggestion: This feature would be off by default.</para>

	<para>Script/language sensitivity: Used mostly in CJKV fonts.</para>

	<para>Feature interaction: This feature is mutually exclusive
	with all other glyph-height features (e.g. valt and vhal),
	which should be turned off when it's applied. Applying this
	feature should activate the kern feature. See also palt.</para>


	<para>Tag: 'vrt2'</para>

	<para>Friendly name: Vertical Alternates and Rotation</para>

	<para>Registered by: Adobe</para>

	<para>Function: Replaces some fixed-width (half-, third- or
	quarter-width) or proportional-width glyphs (mostly Latin or
	katakana) with forms suitable for vertical writing (that is,
	rotated 90 degrees clockwise). Note that these are a superset
	of the glyphs covered in the vert table.</para>

	<para>ATM/NT 4.1 and the Windows 2000 OTF driver impose the
	following requirements for an OpenType font with CFF outlines
	to be used for vertical writing: the vrt2 feature must be
	present in the GSUB table, it must comprises a single lookup
	of LookupType 1 and LookupFlag 0, and the lookup must have a
	single subtable. The predecessor feature, vert, is ignored.</para>

	<para>A rotated glyph must be designed such that its top side
	  bearing and vertical advance as recorded in the Vertical
	  Metrics (<ottable>vmtx</ottable>) table are identical to the
	  left side bearing and horizontal advance, respectively, of
	  the corresponding upright glyph as recorded in the
	  Horizontal Metrics (<ottable>hmtx</ottable>) table. (The
	  horizontal advance of the rotated glyph may be set to any
	  value, since the glyph is intended only for vertical writing
	  use. The vendor may however set it to head.unitsPerEm, to
	  prevent overlap during font proofing tests, for
	  example.)</para>

	<para>Thus, proportional-width glyphs with rotated forms in
	the vrt2 feature will appear identically spaced in both
	vertical and horizontal writing. In order for kerning to
	produce identical results as well, developers must ensure that
	the Vertical Kerning (vkrn) feature record kern values between
	the rotated glyphs that are the same as kern values between
	their corresponding upright glyphs in the Kerning (kern)
	feature.</para>

	<para>Example: Proportional- or half-width Latin and
	half-width katakana characters are rotated 90 degrees
	clockwise for vertical writing.</para>

	<para>Recommended implementation: The font includes rotated
	versions of the glyphs covered by this feature. The vrt2 table
	maps the standard (horizontal) forms to the corresponding
	vertical (rotated) forms (GSUB lookup type 1). This feature
	should be the last substitution in the font, and take input
	from other features.</para>

	<para>Application interface: For GIDs found in the vrt2
	coverage table, the application passes GIDs to the feature,
	and gets back new GIDs.</para>

	<para>UI suggestion: This feature should be active by default
	when vertical writing mode is on, although the user must be
	able to override it.</para>

	<para>Script/language sensitivity: Applies only to scripts
	with vertical writing capability.</para>

	<para>Feature interaction: Overrides the vert (Vertical
	Writing) feature, which is a subset of this one. May be used
	in addition to any other feature.</para>


	<para>Tag: 'zero'</para>

	<para>Friendly name: Slashed Zero</para>

	<para>Registered by: Adobe</para>

	<para>Function: Some fonts contain both a default form of
	zero, and an alternative form which uses a diagonal slash
	through the counter. Especially in condensed designs, it can
	be difficult to distinguish between 0 and O (zero and capital
	O) in any situation where capitals and lining figures may be
	arbitrarily mixed. This feature allows the user to change from
	the default 0 to a slashed form.</para>

	<para>Example: When setting labels, the user applies this
	feature to get the slashed 0.</para>

	<para>Recommended implementation: The zero table maps the GIDs
	for the lining forms of zero to corresponding slashed forms
	(GSUB lookup type 1).</para>

	<para>Application interface: For GIDs in the zero coverage
	table, the application passes a GID to the zero table and gets
	back a new GID.</para>

	<para>UI suggestion: Optimally, the application would store
	this as a preference setting, and the user could use the
	feature to toggle back and forth between the two forms. Most
	applications will want the default setting to disable this
	feature.</para>

	<para>Script/language sensitivity: Does not apply to scripts
	which use forms other than 0 for zero.</para>

	<para>Feature interaction: Applies only to lining figures, so
	  is inactivated by oldstyle figure features (e.g. onum).</para>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.proposed_features'>
    <title>Proposed OpenType features</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Proposals for new features are posted here for
	review. If you have questions, comments or concerns regarding
	any of the proposals listed please post them to the OpenType
	discussion mailing list.</para>
      </section>
    </section>


    <!--======================================================================-->
    <section role='fragment'>
      <title>Proposing new features</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para> Microsoft and Adobe welcome nominations for new
	  features and feature tags. To qualify for registration, a
	  feature must have a single function that is clearly
	  identified by its tag. The function of the feature should be
	  defined at the lowest useful level and must be distinctly
	  different from the functions of currently registered
	  features. When font developers register feature tags and
	  functions with Microsoft, they do not have to supply
	  implementation details.</para>

	<para>To submit a proposal please e-mail the following
	  information to ttwsite@microsoft.com. See the current
	  registered features for example wording.</para>

	<itemizedlist>
	  <listitem>
	    <para>Tag</para>
	  </listitem>
	  <listitem>
	    <para>Friendly name</para>
	  </listitem>
	  <listitem>
	    <para>Registered by</para>
	  </listitem>
	  <listitem>
	    <para>Status</para>
	  </listitem>
	  <listitem>
	    <para>Function</para>
	  </listitem>
	  <listitem>
	    <para>Example</para>
	  </listitem>
	  <listitem>
	    <para>Recommended implementation</para>
	  </listitem>
	  <listitem>
	    <para>Application interface</para>
	  </listitem>
	  <listitem>
	    <para>UI suggestion</para>
	  </listitem>
	  <listitem>
	    <para>Script/language sensitivity</para>
	  </listitem>
	  <listitem>
	    <para>Feature interaction</para>
	  </listitem>
	</itemizedlist>

	<para>Providing the proposal raises no serious concerns we will
	  post it here for review. After a further period of review the
	  status of the proposal will be updated to indicate if the
	  proposed feature has been accepted or rejected. Accepted
	  proposals will be added to the OpenType registered features
	  list when the OpenType specification is next updated.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.ttfundamentals'>
    <title>TrueType fundamentals</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>OpenType fonts are an extension of the TrueType Font
	File format.</para>


	<para>This chapter introduces the basic concepts needed to
	create and instruct a TrueType font, or an OpenType font that
	contains TrueType outline data. It begins with an overview of
	the steps involved in taking a design from paper to the
	creation of a bitmap that can be sent to an output device and
	follows with a closer look at each of the steps in the
	process.</para>
      </section>
    </section>


    <!--======================================================================-->
    <section role='fragment'>
      <title>From design to font file</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>A TrueType font can originate as a new design drawn on
	paper or created on a computer screen. TrueType fonts can also
	be obtained by converting fonts from other formats. Whatever
	the case, it is necessary to create a TrueType font file that,
	among other things, describes each glyph in the font as an
	outline in the TrueType format.</para>

        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00288.gif'/>
            </imageobject>
          </mediaobject>
	</informalfigure>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>From Font File to Paper</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This section describes the process that allows glyphs
	from a TrueType font file to be displayed on raster devices.</para>

	<para>First, the outline stored in the font file isscaled to
	the requested size. Once scaled, the points that make up the
	outline are no longer recorded in the FUnits used to describe
	the original outline, but have become device-specific pixel
	coordinates.</para>

	<para>Next, the instructions associated with this glyph are
	carried out by the interpreter. The result of carrying out the
	instructions is a grid-fitted outline for the requested
	glyph. This outline is then scan converted to produce a bitmap
	that can be rendered on the target device.</para>

        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref='ball.gif'/>
            </imageobject>
          </mediaobject>
	</informalfigure>

	<orderedlist>
	  <listitem>
	    <para>Digitize outline with FUnit coordinates in TrueType
	    font file</para>
	  </listitem>
	  <listitem>
	    <para>Scaler converts FUnits to pixel coordinates and
	    scales outline to size requested by application</para>
	  </listitem>
	  <listitem>
	    <para>Outline "sized" to new grid</para>
	  </listitem>
	  <listitem>
	    <para>Scaled outline with pixel coordinates</para>
	  </listitem>
	  <listitem>
	    <para>Interpreter executes instructions associated with
	    glyph "B" and gridfits</para>
	  </listitem>
	  <listitem>
	    <para>Grid-fitted outline</para>
	  </listitem>
	  <listitem>
	    <para>Grid fitted outline</para>
	  </listitem>
	  <listitem>
	    <para>Scan converter decides which pixels to turn on</para>
	  </listitem>
	  <listitem>
	    <para>Bitmap is rendered on raster device</para>
	  </listitem>
	</orderedlist>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Digitizing a Design</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>This section describes the coordinate system used to
	establish the locations of the points that define a glyph
	outline. It also documents the placement of glyphs with
	respect to the coordinate axes.</para>


	<bridgehead>Outlines</bridgehead>

	<para>In a TrueType font, glyph shapes are described by their
	outlines. A glyph outline consists of a series of contours. A
	simple glyph may have only one contour. More complex glyphs
	can have two or more contours. Composite glyphs can be
	constructed by combining two or more simpler glyphs. Certain
	control characters that have no visible manifestation will map
	to the glyph with no contours.</para>

        <figure>
          <title>Figure 1-1. Glyphs with one, two, three contours
	    respectively</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00290.gif'/>
            </imageobject>
          </mediaobject>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00291.gif'/>
            </imageobject>
          </mediaobject>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00292.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>Contours are composed of straight lines and
	curves. Curves are defined by a series of points that describe
	second order Bezier-splines. The TrueType Bezier-spline format
	uses two types of points to define curves, those that are on
	the curve and those that are off the curve. Any combination of
	off and on curve points is acceptable when defining a
	curve. Straight lines are defined by two consecutive on curve
	points.</para>

        <figure>
          <title>Figure 1-2 A glyph description consisting of a series
          of on and off curve points</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00293.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>The points that make up a curve must be numbered in
	consecutive order. It makes a difference whether the order is
	increasing or decreasing in determining the fill pattern of
	the shapes that make up the glyph. The direction of the curves
	has to be such that, if the curve is followed in the direction
	of increasing point numbers, the black space (the filled area)
	will always be to the right.</para>

	<bridgehead>FUnits and the em square</bridgehead>

	<para>In a TrueType font file point locations are described in
	font units, or FUnits. An FUnit is the smallest measurable
	unit in the em square, an imaginary square that is used to
	size and align glyphs. The dimensions of the em square
	typically are those of the full body height of a font plus
	some extra spacing to prevent lines of text from colliding
	when typeset without extra leading.</para>

        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00294.gif'/>
            </imageobject>
          </mediaobject>
	</informalfigure>

	<para>While in the days of metal type, glyphs could not extend
	beyond the em square, digital typefaces are not so
	constrained. The em square may be made large enough to
	completely contain all glyphs, including accented glyphs. Or,
	if it proves convenient, portions of glyphs may extend outside
	the em square. TrueType fonts can handle either approach so
	the choice is that of the font manufacturer. Figure 1-3 A
	character that extends outside of the em square</para>

        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00295.gif'/>
            </imageobject>
          </mediaobject>
        </informalfigure>

	<para>The em square defines a two-dimensional coordinate grid
	whose x-axis describes movement in a horizontal direction and
	whose y-axis describes movement in a vertical direction. This
	is discussed in more detail in the following section.</para>


	<bridgehead>FUnits and the grid</bridgehead>

	<para>A key decision in digitizing a font is determining the
	resolution at which the points that make up glyph outlines
	will be described. The points represent locations in a grid
	whose smallest addressable unit is known as an FUnit or font
	Unit. The grid is a two-dimensional coordinate system whose
	x-axis describes movement in a horizontal direction and whose
	y-axis describes movement in a vertical direction. The grid
	origin has the coordinates (0,0). The grid is not an infinite
	plane. Each point must be within the range -16384 and +16383
	FUnits. Depending upon the resolution chosen, the range of
	addressable grid locations will be smaller.</para>

	<para>The choice of the granularity of the coordinate
	grid-that is, number of units per em (upem)-is made by the
	font manufacturer. Outline scaling will be fastest if units
	per em is chosen to be a power of 2, such as 2048.</para>

        <figure>
          <title>Figure 1-4 The coordinate system</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00296.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>The origin of the em square need not have any consistent
	relationship to the glyph outlines. In practice, however,
	applications depend upon the existence of some convention for
	the placement of glyphs for a given font. For Roman fonts,
	which are intended to be laid out horizontally, a y-coordinate
	value of 0 typically is assumed to correspond to the baseline
	of the font. No particular meaning is assigned to an
	x-coordinate of 0 but manufacturers may improve the
	performance of applications by choosing a standard meaning for
	the x-origin.</para>

	<para>For example, you might place a glyph so that its
	aesthetic center is at the x-coordinate value of 0. That is, a
	set of glyphs so designed when placed in a column such that
	their x-coordinate values of 0 are coincident will appear to
	be nicely centered. This option would be used for Kanji or any
	fonts that are typeset vertically. Another alternative is to
	place each glyph so that its leftmost extreme outline point
	has an x-value equal to the left-side-bearing of the
	glyph. Fonts created in this way may allow some applications
	to print more quickly to PostScript printers.</para>


        <figure>
	  <title>Figure 1-5 Two possible choices for the glyph origin
	  in a Roman font. In the first case (left) the left side
	  bearing is x-zero. In the second (right), the aesthetic
	  center of the character is x-zero</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00297.gif'/>
            </imageobject>
          </mediaobject>
	</figure>

	<para>Non-Roman fonts may wish to use other conventions for
	the meaning of the x-origin and y-origin. For best results
	with high-lighting and carets, the body of the character
	should be roughly centered within the advance width. For
	example, a symmetrical character would have equal left and
	right side bearings.</para>


	<para>The granularity of the em square is determined by the
	number of FUnits per em, or more simply units per em . The em
	square as divided into FUnits defines a coordinate system with
	one unit equaling an FUnit. All points defined in this
	coordinate system must have integral locations. The greater
	the number of units per em, the greater the precision
	available in addressing locations within the em square.</para>


        <figure>
          <title>Figure 1-6 Two em squares, 8 units per em (left), 16
          units per em (right) </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00298.gif'/>
            </imageobject>
          </mediaobject>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00299.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>FUnits are relative units because they vary in size as
	the size of the em square changes. The number of units per em
	remains constant for a given font regardless of the point
	size. The number of points per em, however, will vary with the
	point size of a glyph. An em square is exactly 9 points high
	when a glyph is displayed at 9 points, exactly 10 points high
	when the font is displayed at 10 point, and so on. Since the
	number of units per em does not vary with the point size at
	which the font is displayed, the absolute size of an FUnit
	varies as the point size varies.</para>


        <figure>
          <title>Figure 1-7 72 point M and 127 point M and their em
	    squares. Upem equals 8 in both cases.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00300.gif'/>
            </imageobject>
          </mediaobject>
        </figure>


	<para>Because FUnits are relative to the em square, a given
	location on a glyph will have the same coordinate location in
	FUnits regardless of the point size at which the font is
	rendered. This is convenient because it makes it possible to
	instruct outline points once considering only the original
	outline and have the changes apply to the glyph at whatever
	size and resolution it is ultimately rendered.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Scaling a glyph</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>


	<para>This section describes how glyph outlines are scaled
	from the master size stored in the font file to the size
	requested by an application.</para>


	<bridgehead>Device space</bridgehead>

	<para>Whatever the resolution of the em square used to define
	a glyph outline, before that glyph can be displayed it must be
	scaled to reflect the size, transformation and the
	characteristics of the output device on which it is to be
	displayed. The scaled outline must describe the character
	outline in units that reflect an absolute rather than relative
	system of measurement. In this case the points that make up a
	glyph outline are described in terms of pixels.</para>


	<para>Intuitively, pixels are the actual output bits that will
	appear on screen or printer. To allow for greater precision in
	managing outlines, TrueType describes pixel coordinates to the
	nearest sixty-fourth of a pixel.</para>


	<bridgehead>Converting FUnits to pixels</bridgehead>

	<para>Values in the em square are converted to values in the
	pixel coordinate system by multiplying them by a scale. This
	scale is:</para>


	<para>pointSize * resolution / ( 72 points per inch *
	units_per_em )</para>


	<para>where pointSize is the size at which the glyph is to be
	displayed, and resolution is the resolution of the output
	device. The 72 in the denominator reflects the number of
	points per inch.</para>


	<para>For example, assume that a glyph feature is 550 FUnits
	in length on a 72 dpi screen at 18 point. There are 2048 units
	per em. The following calculation reveals that the feature is
	4.83 pixels long.</para>


	<para>550 * 18 * 72 / ( 72 * 2048 ) = 4.83</para>


	<bridgehead>Display device characteristics</bridgehead>

	<para>The resolution of any particular display device is
	specified by the number of dots or pixels per inch (dpi) that
	are displayed. For example, a VGA under Windows is treated as
	a 96 dpi device, and most laser printers have a resolution of
	300 dpi. Some devices, such as an EGA, have different
	resolution in the horizontal and vertical directions
	(i.e. non-square pixels); in the case of the EGA this
	resolution is 96 x 72. In such cases, horizontal dots per inch
	must be distinguished from vertical dots per inch.</para>

	<para>The number of pixels per em is dependent on the
	resolution of the output device. An 18 point character will
	have 18 pixels per em on a 72 dpi device. Change the
	resolution to 300 dpi and it has 75 pixels per em, or change
	to 1200 dpi and it has 300 pixels per em.</para>

        <figure>
          <title>Figure 1-8 18 point figure 8 at 72 dpi, 300 dpi and 1200 dpi.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00302b.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>Displaying type on a particular device at a specific
	point size yields an effective resolution measured in pixels
	per em (ppem). The formula for calculating pixels per em
	is:</para>


	<para>ppem = pointSize * dpi / 72</para>

	<para>= (pixels per inch) * (inches per pica point) * (pica
	points per em)</para>


	<para>= dpi * 1 / 72 * pointSize</para>

	<para>On a 300 dpi laser printer, a 12 point glyph would have
	12*300/72 or 50 ppem. On a typesetter with 2400 dpi, it would
	have 12*2400/72 or 400 ppem. On a VGA, a 12 point glyph would
	have 12*96/72 or 16 ppem. Similarly, the ppem for a 12 point
	character on a 72 dpi device would be 12*72/72, or 12. This
	last calculation points to a useful rule of thumb: on any 72
	dpi device, points and pixels per em are equal. Note, however,
	that in traditional typography an inch contains 72.2752 points
	(rather than 72); that is, one point equals .013836
	inches.</para>


	<para>If you know the ppem, the formula to convert between
	FUnits and pixel space coordinates is:</para>

	<para>pixel_coordinate = em_coordinate * ppem /upem</para>

	<para>An em_coordinate position of (1024, 0) would yield a
	device_pixels coordinate of (6, 0), given 2048 units per em
	and 12 pixels per em.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Grid-fitting a glyph outline</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The fundamental task of instructing a glyph is one of
	identifying the critical characteristics of the original
	design and using instructions to ensure that those
	characteristics will be preserved when the glyph is rendered
	at different sizes on different devices. Consistent stem
	weights, consistent color, even spacing, and the elimination
	of pixel dropouts are common goals.</para>

	<para>To accomplish these goals, it is necessary to ensure
	that the correct pixels are turned on when a glyph is
	rasterized. It is the pixels that are turned on that create
	the bitmap image of the glyph. Since it is the shape of the
	glyph outline that determines which pixels will make up the
	bitmap image of that character at a given size, it is
	sometimes necessary to change or distort the original outline
	description to produce a high quality image. This distortion
	of the outline is known as grid-fitting.</para>

	<para>The figure below illustrates how grid-fitting a
	character distorts the outline found in the original design.</para>


        <figure>
          <title>Figure 1-9 12 point outlines ungrid-fitted (left) and
          grid-fitted (right) </title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00304.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>As the illustration above suggests, the grid-fitting
	employed in TrueType goes well beyond aligning a glyph's left
	side bearing to the pixel grid. This sophisticated
	grid-fitting is guided by instructions. The beneficial effects
	of grid-fitting are illustrated in the next figure.</para>



        <figure>
          <title>Figure 1-10 12 point outlines and bitmap
	    ungrid-fitted (left) and grid-fitted (right)</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00305.gif'/>
            </imageobject>
          </mediaobject>
        </figure>

	<para>Grid-fitting is the process of stretching the outline of
	a glyph according to the instructions associated with it. Once
	a glyph is grid-fitted, the point numbers will be unchanged
	but the actual location of that point in the coordinate grid
	may have shifted. That is, the coordinates for a given point
	number will, very likely, have changed after a glyph is
	grid-fitted.</para>


	<bridgehead>What are instructions?</bridgehead>

	<para>The TrueType instruction set provides a large number of
	commands designed to allow designers to specify how character
	features should be rendered. Instructions are the mechanism by
	which the design of a character is preserved when it is
	scaled. In other words, instructions control the way in which
	a glyph outline will be grid-fitted for a particular size or
	device.</para>

	<para>Instructing a font will reshape the outline for a given
	glyph at a specific size on a given target device in such a
	way that the correct pixels are included within its
	outline. Reshaping the outline means moving outline
	points. Points that have been acted upon by an instruction are
	said to have been touched. Note that a point need not actually
	be moved to be touched. It must simply be acted upon by an
	instruction. (See MDAP, chapter 3.)</para>

	<para>TrueType fonts can be used with or without
	instructions. Uninstructed fonts will generally produce good
	quality results at sufficiently high resolutions and point
	sizes. The range of sizes over which an uninstructed font will
	produce good quality results depends not only on the output
	device resolution and point size of the character but also on
	the particular font design. The intended use of the font can
	also be a factor in determining whether or not a particular
	font should be instructed. For most fonts, if legibility of
	small point sizes on low resolution devices is important,
	adding instructions will be critical.</para>

	<para>Instructing a font is a process that involves analyzing
	the key elements of a glyph's design and using the TrueType
	instruction set to ensure that they are preserved. The
	instructions are flexible enough to allow characteristics that
	are roughly the same to be "homogenized" at small sizes while
	allowing the full flavor of the original design to emerge at
	sizes where there are sufficiently many pixels.</para>

	<para>How does the TrueType interpreter know the manner in
	which an outline should be distorted to produce a desirable
	result? This information is contained in instructions attached
	to each character in the font. Instructions specify aspects of
	a character's design that are to be preserved as it is
	scaled. For example, using instructions it is possible to
	control the height of an individual character or of all the
	characters in a font. You can also preserve the relationship
	between design elements within a character thereby ensuring,
	for example, that the widths of the three vertical stems in
	the lower case m will not differ dramatically at small sizes.</para>

	<para>The following figure illustrates how changing a glyph's
	outline at a specific size will yield a superior result. They
	show that an uninstructed 9 point Arial lowercase m suffers
	the loss of a stem due to chance effects in the relationship
	of stems to pixel centers. In the second glyph, instructions
	have aligned the stems to the grid so that the glyph suffers
	no similar loss.</para>


        <figure>
          <title>Figure 1-11 9 point Arial m-uninstructed (left),
	    instructed (right)</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00306.gif'/>
            </imageobject>
          </mediaobject>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00307.gif'/>
            </imageobject>
          </mediaobject>
        </figure>


	<bridgehead>The TrueType interpreter</bridgehead>

	<para>This section describes the actions of the TrueType
	interpreter. It is the interpreter, as the name suggests, that
	"interprets" or carries out the instructions.</para>

	<para>More concretely, the interpreter processes a stream or
	sequence of instructions. Typically these instructions take
	their arguments from the interpreter stack and place their
	results on that stack. The only exceptions are a small number
	of instructions that are used to push data onto the
	interpreter stack. These instructions take their arguments
	from the instruction stream.</para>

	<para>All of the interpreter's actions are carried on in the
	context of the Graphics State, a set of variables whose values
	guide the actions of the interpreter and determine the exact
	effect of a particular instruction.</para>

	<para>The interpreter's actions can be summarized as follows:</para>

	<orderedlist>
	  <listitem>
	    <para>The interpreter fetches an instruction from the
	    instruction stream, an ordered sequence of instruction
	    opcodes and data. Opcodes are 1-byte in size. Data can
	    consist of a single byte or two bytes (a word). If an
	    instruction takes words from the instruction stream it
	    will create those words by putting together two bytes. The
	    high byte appears first in the instruction stream and the
	    low byte appears second.</para>

	    <para>The following instruction stream is depicted as it
	    will be shown in the examples that follow. Note that the
	    pointer indicates the next instruction to be executed.</para>

	    <informalfigure>
	      <mediaobject>
		<imageobject>
		  <imagedata fileref='img00308.gif'/>
		</imageobject>
	      </mediaobject>
	    </informalfigure>
	  </listitem>

	  <listitem>
	    <para>The instruction is executed</para>

	    <itemizedlist>
	      <listitem>
		<para>If it is a push instruction it will take its
		arguments from the instruction stream.</para>
	      </listitem>
	      <listitem>
		<para>Any other instruction will pop any data it needs
		from the stack. A pop is illustrated below.</para>

		<informalfigure>
		  <mediaobject>
		    <imageobject>
		      <imagedata fileref='img00309.gif'/>
		    </imageobject>
		  </mediaobject>
		</informalfigure>
	      </listitem>

	      <listitem>
		<para>Any data the instruction produces is pushed onto
		the interpreter stack. A push is illustrated
		below.</para>

		<informalfigure>
		  <mediaobject>
		    <imageobject>
		      <imagedata fileref='img00310.gif'/>
		    </imageobject>
		  </mediaobject>
		</informalfigure>

		<para>As the previous discussion indicates, the
		interpreter stack is a LIFO or last in first out data
		structure. An instruction takes any data it needs from
		the last item placed on the stack. The action of
		removing the top item from the stack is commonly
		termed a pop. When an instruction produces some result
		it pushes that result to the top of the stack where it
		is potential input to the next instruction.</para>

		<para>The instruction set includes a full range of
		operators for manipulating the stack including
		operators for pushing items onto the stack, popping
		items from the stack, clearing the stack, duplicating
		stack elements and so forth.</para>
	      </listitem>

	      <listitem>
		<para>The effect of execution depends on the values of
		the variables that make up the Graphics State.</para>
	      </listitem>
	      <listitem>
		<para>The instruction may modify one or more Graphics
		State variables. In the illustration shown, the
		Graphics State variable rp0 is updated using a value
		taken from the interpreter stack.</para>

		<informalfigure>
		  <mediaobject>
		    <imageobject>
		      <imagedata fileref='img00311.gif'/>
		    </imageobject>
		  </mediaobject>
		</informalfigure>
	      </listitem>
	    </itemizedlist>
	  </listitem>

	  <listitem>
	    <para>The process is repeated until there are no further
	    instructions to be executed. </para>
	  </listitem>
	</orderedlist>


	<bridgehead>Using instructions</bridgehead>

	<para>Instructions can appear in a number of places in the
	font file tables that make up a TrueType font. They can appear
	as part of the Font Program, the CVT Program, or as glyph
	data. Instructions appearing in the first two apply to the
	font as a whole. Those found in glyph data
	(<ottable>glyf</ottable>) apply to individual glyphs within a
	font.</para>


	<bridgehead>The Font Program</bridgehead>

	<para>The Font Program consists of a set of instructions that
	is executed once, the first time a font is accessed by an
	application. It is used to create function definitions (FDEFs)
	and instruction definitions (IDEFs). Functions and
	instructions defined in the Font Program can be used elsewhere
	in the font file.</para>

	<bridgehead>The CVT Program</bridgehead>

	<para>The CVT Program is a sequence of TrueType instructions
	executed every time the point size or transformation
	change. It is used to make font wide changes rather than to
	manage individual glyphs. The CVT Program is used to establish
	the values in the Control Value Table.</para>

	<para>The purpose of the Control Value Table or CVT is to
	simplify the task of maintaining consistency when instructing
	a font. It is a numbered list of values that can be referenced
	by either of two indirect instructions (MIRP and MIAP). CVT
	entries can be used to store values that need to be the same
	across a number of glyphs in a font. For example an
	instruction might refer to a CVT entry whose purpose is to
	regularize stem weights across a font.</para>


	<table>
	  <title>Figure 1-12 Some sample CVT entries</title>

	  <tgroup cols='3'>
	    <thead>
	      <row>
		<entry>Entry #</entry>
		<entry>Value</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>0</entry>
		<entry>0</entry>
		<entry>upper and lower case flat base(base line)</entry>
	      </row>
	      <row>
		<entry>1</entry>
		<entry>-39</entry>
		<entry>upper case round base</entry>
	      </row>
	      <row>
		<entry>2</entry>
		<entry>-35</entry>
		<entry>lower case round base</entry>
	      </row>
	      <row>
		<entry>3</entry>
		<entry>-33</entry>
		<entry>figure round base</entry>
	      </row>
	      <row>
		<entry>4</entry>
		<entry>1082</entry>
		<entry>x-height flat</entry>
	      </row>
	      <row>
		<entry>5</entry>
		<entry>1114</entry>
		<entry>x-height round overlap</entry>
	      </row>
	      <row>
		<entry>6</entry>
		<entry>1493</entry>
		<entry>flat cap</entry>
	      </row>
	      <row>
		<entry>7</entry>
		<entry>1522</entry>
		<entry>round cap</entry>
	      </row>
	      <row>
		<entry>8</entry>
		<entry>1463</entry>
		<entry>numbers flat</entry>
	      </row>
	      <row>
		<entry>9</entry>
		<entry>1491</entry>
		<entry>numbers round top</entry>
	      </row>
	      <row>
		<entry>10</entry>
		<entry>1493</entry>
		<entry>flat ascender</entry>
	      </row>
	      <row>
		<entry>11</entry>
		<entry>1514</entry>
		<entry>round ascender</entry>
	      </row>
	      <row>
		<entry>12</entry>
		<entry>157</entry>
		<entry>x stem weight</entry>
	      </row>
	      <row>
		<entry>13</entry>
		<entry>127</entry>
		<entry>y stem weight</entry>
	      </row>
	      <row>
		<entry>14</entry>
		<entry>57</entry>
		<entry>serif</entry>
	      </row>
	      <row>
		<entry>15</entry>
		<entry>83</entry>
		<entry>space between the dot and the I</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Instructions that refer to values in the CVT are called
	indirect instructions as opposed to the direct instructions
	which take their values from the glyph outline.</para>

	<para>As part of the TrueType font file, the values in the CVT
	are expressed in FUnits. When the outlines are converted from
	FUnits to pixel units, values in the CVT are also converted.</para>

	<para>When writing to the CVT you may use a value that is in
	the glyph coordinate system (using WCVTP) or you can use a
	value that is in the original FUnits (using WCVTF). The
	interpreter will scale all values appropriately. Values read
	from the CVT are always in pixels (F26Dot6).</para>


	<bridgehead>The Storage Area</bridgehead>

	<para>The interpreter also maintains a Storage Area consisting
	of a portion of memory that can be used for temporary storage
	of data from the interpreter stack. Instructions exist that
	make it possible to read the values of stored data and to
	write new values to storage. Storage locations range from 0 to
	n-1 where n is the value established in the maxStorage entry
	in the maxProfile table of the font file. Values are 32 bit
	numbers</para>


	<table>
	  <title>Figure 1-13 Some storage area entries</title>
	  <tgroup cols='2'>
	    <thead>
	      <row>
		<entry>Address</entry>
		<entry>Value</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>0</entry>
		<entry>343</entry>
	      </row>
	      <row>
		<entry>1</entry>
		<entry>241</entry>
	      </row>
	      <row>
		<entry>2</entry>
		<entry>-27</entry>
	      </row>
	      <row>
		<entry>3</entry>
		<entry>4654</entry>
	      </row>
	      <row>
		<entry>4</entry>
		<entry>125</entry>
	      </row>
	      <row>
		<entry>5</entry>
		<entry>11</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>


	<bridgehead>The Graphics State</bridgehead>

	<para>The Graphics State consists of a table of variables and
	their values. All instructions act within the context of the
	Graphics State. Graphics State variables have default values
	as specified in Appendix B, "Graphics State Summary". Their
	values can be determined or changed using instructions.</para>

	<para>The Graphics State establishes the context within which
	all glyphs are interpreted. All Graphics State variables have
	a default value. Some of these values can be changed in the
	CVT Program if desired. Whatever the default value, it will be
	reestablished at the start of interpretation of any glyph. In
	other words, the Graphics State has no inter-glyph
	memory. Changing the value of a Graphics State variable while
	processing an individual glyph will result in a change that
	remains in effect only for that glyph.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>The scan converter</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>The TrueType scan converter takes an outline description
	of a glyph and produces a bitmap image for that glyph.</para>

	<para>The TrueType scan converter offers two modes. In the
	first mode, the scan converter uses a simple algorithm for
	determining which pixels are part of that glyph. The rules can
	be stated as follows:</para>

	<para>Rule 1: If a pixel's center falls within the glyph
	outline, that pixel is turned on and becomes part of that
	glyph.</para>

	<para>Rule 2: If a contour falls exactly on a pixel's center,
	that pixel is turned on.</para>

	<para>A point is considered to be an interior point of a glyph
	if it has a non-zero winding number. The winding number is
	itself determined by drawing a ray from the point in question
	toward infinity. (The direction in which the ray points in
	unimportant.) Starting with a count of zero, we subtract one
	each time a glyph contour crosses the ray from right to left
	or bottom to top. Such a crossing is termed an on
	transition. We add one each time a contour of the glyph
	crossed the ray from left to right or top to bottom. Such a
	crossing is termed an off transition. If the final count is
	non-zero, the point is an interior point.</para>

	<para>The direction of a contour can be determined by looking
	at the point numbers. The direction is always from lower point
	number toward higher point number.</para>

	<para>The illustration that follows demonstrates the use of
	winding numbers in determining whether a point is inside a
	glyph. The point p1 undergoes a sequence of four transitions
	(on transition, off transition, on transition, off
	transition). Since the sequence is even, the winding number is
	zero and the point is not inside the glyph. The second point,
	p2, undergoes an off transition followed by an on transition
	followed by an off transition yielding a winding number of
	+1. The point is in the interior of the glyph.</para>

        <figure>
          <title>Figure 1-14 Determining the winding number of a point.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00312.gif'/>
            </imageobject>
          </mediaobject>
        </figure>


	<bridgehead>What is a dropout?</bridgehead>

	<para>A dropout occurs whenever there is a connected region of
	a glyph interior that contains two black pixels that cannot be
	connected by a straight line that only passes through black
	pixels.</para>


        <figure>
          <title>Figure 1-15 The letter m with two dropouts.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref='img00313.gif'/>
            </imageobject>
          </mediaobject>
        </figure>


	<bridgehead>Preventing dropouts</bridgehead>

	<para>The TrueType instructions are designed to allow you to
	gridfit a glyph so that the desired pixels will be turned on
	by the simple scan converter regardless of the point size or
	the transformation used. It may prove difficult to foresee all
	possible transformations that a glyph might undergo. It is
	therefore difficult to instruct a glyph to ensure that the
	proper grid-fitting distortion of the outline will take place
	for every desired transformation. This problem is especially
	difficult for very small numbers of pixels per em and for
	complex typefaces. In these situations, some renditions of a
	glyph may contain dropouts.</para>

	<para>It is possible to test for potential dropouts by looking
	at an imaginary line segment connecting two adjacent pixel
	centers. If this line segment is intersected by both an
	on-Transition contour and an off-Transition contour, a
	potential dropout condition exists. The potential dropout only
	becomes an actual dropout if the two contour lines continue on
	in both directions to cut other line segments between adjacent
	pixel centers. If the two contours join together immediately
	after crossing a scan line (forming a stub), a dropout does
	not occur, although a stem of the glyph may become shorter
	than desired.</para>

	<para>To prevent dropouts, type manufacturers can choose to
	have the scan converter use two additional rules:</para>

	<para>Rule 3: If a scan line between two adjacent pixel centers (either
	vertical or horizontal) is intersected by both an
	on-Transition contour and an off-Transition contour and
	neither of the pixels was already turned on by rules 1 and 2,
	turn on the left-most pixel (horizontal scan line) or the
	bottom-most pixel (vertical scan line) </para>

	<para>Rule 4: Apply Rule 3 only if the two contours continue
	to intersect other scan lines in both directions. That is do
	not turn on pixels for 'stubs'. The scanline segments that
	form a square with the intersected scan line segment are
	examined to verify that they are intersected by two
	contours. It is possible that these could be different
	contours than the ones intersecting the dropout scan line
	segment. This is very unlikely but may have to be controlled
	with grid-fitting in some exotic glyphs.</para>

	<para>The type manufacturer can choose to use the simple scan
	converter employing rules 1 and 2 only or may optionally
	invoke either rule 3 or rule 4. The decision about which scan
	converter to use can be made on a font wide basis or a
	different choice can be specified for each glyph. The
	selection made in the preProgram will be the default for the
	entire font. A change made to the default in the instructions
	for an individual glyph will apply only to that glyph. </para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.ttinst'>
    <title>The TrueType instruction set</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>When TrueType glyph outlines are rasterized, they are
	hinted using instructions contained in the font file. The
	TrueType instruction set provides a powerful means of
	controlling glyph outlines at all or specific sizes and
	resolutions. Instructions are crucial for legible fonts at
	screen resolutions. The following Word documents discuss
	hinting and the TrueType instruction set in detail. These
	documents are currently being converted to HTML format.</para>

	<itemizedlist>
	  <listitem>
	    <para>Instructing TrueType Glyphs [Microsoft Word format]</para>
	  </listitem>
	  <listitem>
	    <para>The TrueType Instruction Set, Part 1 [Microsoft Word
	    format]</para>
	  </listitem>
	  <listitem>
	    <para>The TrueType Instruction Set, Part 2 [Microsoft Word
	    format]</para>
	  </listitem>
	  <listitem>
	    <para>Graphics State Summary [Microsoft Word format]</para>
	  </listitem>
	</itemizedlist>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.wgl4'>
    <title>WGL4.0 Character Set</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Characters</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<informaltable>
	  <tgroup cols='5'>
	    <thead>
	      <row>
		<entry>Unicode</entry>
		<entry>Postscript Name</entry>
		<entry>Descriptive Name</entry>
		<entry>MacChar</entry>
		<entry>MacIndex</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry/>
		<entry>.notdef</entry>
		<entry/>
		<entry/>
		<entry>0</entry>
	      </row>

	      <row>
		<entry/>
		<entry/>
		<entry/>
		<entry>0x0</entry>
		<entry>1</entry>
	      </row>

	      <row>
		<entry/>
		<entry/>
		<entry/>
		<entry>0xd</entry>
		<entry>2</entry>
	      </row>

	      <row>
		<entry>U+0020</entry>
		<entry>space</entry>
		<entry>space</entry>
		<entry>0x20</entry>
		<entry>3</entry>
	      </row>

	      <row>
		<entry>U+0021</entry>
		<entry>exclam</entry>
		<entry>exclamation mark</entry>
		<entry>0x21</entry>
		<entry>4</entry>
	      </row>

	      <row>
		<entry>U+0022</entry>
		<entry>quotedbl</entry>
		<entry>quotation mark</entry>
		<entry>0x22</entry>
		<entry>5</entry>
	      </row>

	      <row>
		<entry>U+0023</entry>
		<entry>numbersign</entry>
		<entry>number sign</entry>
		<entry>0x23</entry>
		<entry>6</entry>
	      </row>

	      <row>
		<entry>U+0024</entry>
		<entry>dollar</entry>
		<entry>dollar sign</entry>
		<entry>0x24</entry>
		<entry>7</entry>
	      </row>

	      <row>
		<entry>U+0025</entry>
		<entry>percent</entry>
		<entry>percent sign</entry>
		<entry>0x25</entry>
		<entry>8</entry>
	      </row>

	      <row>
		<entry>U+0026</entry>
		<entry>ampersand</entry>
		<entry>ampersand</entry>
		<entry>0x26</entry>
		<entry>9</entry>
	      </row>

	      <row>
		<entry>U+0027</entry>
		<entry>quotesingle</entry>
		<entry>apostrophe</entry>
		<entry>0x27</entry>
		<entry>10</entry>
	      </row>

	      <row>
		<entry>U+0028</entry>
		<entry>parenleft</entry>
		<entry>left parenthesis </entry>
		<entry>0x28</entry>
		<entry>11</entry>
	      </row>

	      <row>
		<entry>U+0029</entry>
		<entry>parenright</entry>
		<entry>right parenthesis</entry>
		<entry>0x29</entry>
		<entry>12</entry>
	      </row>

	      <row>
		<entry>U+002a</entry>
		<entry>asterisk</entry>
		<entry>asterisk</entry>
		<entry>0x2a</entry>
		<entry>13</entry>
	      </row>

	      <row>
		<entry>U+002b</entry>
		<entry>plus</entry>
		<entry>plus sign</entry>
		<entry>0x2b</entry>
		<entry>14</entry>
	      </row>

	      <row>
		<entry>U+002c</entry>
		<entry>comma</entry>
		<entry>comma</entry>
		<entry>0x2c</entry>
		<entry>15</entry>
	      </row>

	      <row>
		<entry>U+002d</entry>
		<entry>hyphen</entry>
		<entry>hyphen-minus</entry>
		<entry>0x2d</entry>
		<entry>16</entry>
	      </row>

	      <row>
		<entry>U+002e</entry>
		<entry>period</entry>
		<entry>period</entry>
		<entry>0x2e</entry>
		<entry>17</entry>
	      </row>

	      <row>
		<entry>U+002f</entry>
		<entry>slash</entry>
		<entry>slash</entry>
		<entry>0x2f</entry>
		<entry>18</entry>
	      </row>

	      <row>
		<entry>U+0030</entry>
		<entry>zero</entry>
		<entry>digit zero</entry>
		<entry>0x30</entry>
		<entry>19</entry>
	      </row>

	      <row>
		<entry>U+0031</entry>
		<entry>one</entry>
		<entry>digit one</entry>
		<entry>0x31</entry>
		<entry>20</entry>
	      </row>

	      <row>
		<entry>U+0032</entry>
		<entry>two</entry>
		<entry>digit two</entry>
		<entry>0x32</entry>
		<entry>21</entry>
	      </row>

	      <row>
		<entry>U+0033</entry>
		<entry>three</entry>
		<entry>digit three</entry>
		<entry>0x33</entry>
		<entry>22</entry>
	      </row>

	      <row>
		<entry>U+0034</entry>
		<entry>four</entry>
		<entry>digit four</entry>
		<entry>0x34</entry>
		<entry>23</entry>
	      </row>

	      <row>
		<entry>U+0035</entry>
		<entry>five</entry>
		<entry>digit five</entry>
		<entry>0x35</entry>
		<entry>24</entry>
	      </row>

	      <row>
		<entry>U+0036</entry>
		<entry>six</entry>
		<entry>digit six</entry>
		<entry>0x36</entry>
		<entry>25</entry>
	      </row>

	      <row>
		<entry>U+0037</entry>
		<entry>seven</entry>
		<entry>digit seven</entry>
		<entry>0x37</entry>
		<entry>26</entry>
	      </row>

	      <row>
		<entry>U+0038</entry>
		<entry>eight</entry>
		<entry>digit eight</entry>
		<entry>0x38</entry>
		<entry>27</entry>
	      </row>

	      <row>
		<entry>U+0039</entry>
		<entry>nine</entry>
		<entry>digit nine</entry>
		<entry>0x39</entry>
		<entry>28</entry>
	      </row>

	      <row>
		<entry>U+003a</entry>
		<entry>colon</entry>
		<entry>colon</entry>
		<entry>0x3a</entry>
		<entry>29</entry>
	      </row>

	      <row>
		<entry>U+003b</entry>
		<entry>semicolon</entry>
		<entry>semicolon</entry>
		<entry>0x3b</entry>
		<entry>30</entry>
	      </row>

	      <row>
		<entry>U+003c</entry>
		<entry>less</entry>
		<entry>less-than sign</entry>
		<entry>0x3c</entry>
		<entry>31</entry>
	      </row>

	      <row>
		<entry>U+003d</entry>
		<entry>equal</entry>
		<entry>equals sign</entry>
		<entry>0x3d</entry>
		<entry>32</entry>
	      </row>

	      <row>
		<entry>U+003e</entry>
		<entry>greater</entry>
		<entry>greater-than sign</entry>
		<entry>0x3e</entry>
		<entry>33</entry>
	      </row>

	      <row>
		<entry>U+003f</entry>
		<entry>question</entry>
		<entry>question mark</entry>
		<entry>0x3f</entry>
		<entry>34</entry>
	      </row>

	      <row>
		<entry>U+0040</entry>
		<entry>at</entry>
		<entry>commercial at</entry>
		<entry>0x40</entry>
		<entry>35</entry>
	      </row>

	      <row>
		<entry>U+0041</entry>
		<entry>A</entry>
		<entry>latin capital letter a</entry>
		<entry>0x41</entry>
		<entry>36</entry>
	      </row>

	      <row>
		<entry>U+0042</entry>
		<entry>B</entry>
		<entry>latin capital letter b</entry>
		<entry>0x42</entry>
		<entry>37</entry>
	      </row>

	      <row>
		<entry>U+0043</entry>
		<entry>C</entry>
		<entry>latin capital letter c</entry>
		<entry>0x43</entry>
		<entry>38</entry>
	      </row>

	      <row>
		<entry>U+0044</entry>
		<entry>D</entry>
		<entry>latin capital letter d</entry>
		<entry>0x44</entry>
		<entry>39</entry>
	      </row>

	      <row>
		<entry>U+0045</entry>
		<entry>E</entry>
		<entry>latin capital letter e</entry>
		<entry>0x45</entry>
		<entry>40</entry>
	      </row>

	      <row>
		<entry>U+0046</entry>
		<entry>F</entry>
		<entry>latin capital letter f</entry>
		<entry>0x46</entry>
		<entry>41</entry>
	      </row>

	      <row>
		<entry>U+0047</entry>
		<entry>G</entry>
		<entry>latin capital letter g</entry>
		<entry>0x47</entry>
		<entry>42</entry>
	      </row>

	      <row>
		<entry>U+0048</entry>
		<entry>H</entry>
		<entry>latin capital letter h</entry>
		<entry>0x48</entry>
		<entry>43</entry>
	      </row>

	      <row>
		<entry>U+0049</entry>
		<entry>I</entry>
		<entry>latin capital letter i</entry>
		<entry>0x49</entry>
		<entry>44</entry>
	      </row>

	      <row>
		<entry>U+004a</entry>
		<entry>J</entry>
		<entry>latin capital letter j</entry>
		<entry>0x4a</entry>
		<entry>45</entry>
	      </row>

	      <row>
		<entry>U+004b</entry>
		<entry>K</entry>
		<entry>latin capital letter k</entry>
		<entry>0x4b</entry>
		<entry>46</entry>
	      </row>

	      <row>
		<entry>U+004c</entry>
		<entry>L</entry>
		<entry>latin capital letter l</entry>
		<entry>0x4c</entry>
		<entry>47</entry>
	      </row>

	      <row>
		<entry>U+004d </entry>
		<entry></entry>
		<entry>latin capital letter m</entry>
		<entry>0x4d </entry>
		<entry>48</entry>
	      </row>

	      <row>
		<entry>U+004e</entry>
		<entry>N</entry>
		<entry>latin capital letter n</entry>
		<entry>0x4e</entry>
		<entry>49</entry>
	      </row>

	      <row>
		<entry>U+004f</entry>
		<entry>O</entry>
		<entry>latin capital letter o</entry>
		<entry>0x4f</entry>
		<entry>50</entry>
	      </row>

	      <row>
		<entry>U+0050</entry>
		<entry>P</entry>
		<entry>latin capital letter p</entry>
		<entry>0x50</entry>
		<entry>51</entry>
	      </row>

	      <row>
		<entry>U+0051</entry>
		<entry>Q</entry>
		<entry>latin capital letter q</entry>
		<entry>0x51</entry>
		<entry>52</entry>
	      </row>

	      <row>
		<entry>U+0052</entry>
		<entry>R</entry>
		<entry>latin capital letter r</entry>
		<entry>0x52</entry>
		<entry>53</entry>
	      </row>

	      <row>
		<entry>U+0053</entry>
		<entry>S</entry>
		<entry>latin capital letter s</entry>
		<entry>0x53</entry>
		<entry>54</entry>
	      </row>

	      <row>
		<entry>U+0054</entry>
		<entry>T</entry>
		<entry>latin capital letter t</entry>
		<entry>0x54</entry>
		<entry>55</entry>
	      </row>

	      <row>
		<entry>U+0055</entry>
		<entry>U</entry>
		<entry>latin capital letter u</entry>
		<entry>0x55</entry>
		<entry>56</entry>
	      </row>

	      <row>
		<entry>U+0056</entry>
		<entry>V</entry>
		<entry>latin capital letter v</entry>
		<entry>0x56</entry>
		<entry>57</entry>
	      </row>

	      <row>
		<entry>U+0057</entry>
		<entry>W</entry>
		<entry>latin capital letter w</entry>
		<entry>0x57</entry>
		<entry>58</entry>
	      </row>

	      <row>
		<entry>U+0058</entry>
		<entry>X</entry>
		<entry>latin capital letter x</entry>
		<entry>0x58</entry>
		<entry>59</entry>
	      </row>

	      <row>
		<entry>U+0059</entry>
		<entry>Y</entry>
		<entry>latin capital letter y</entry>
		<entry>0x59</entry>
		<entry>60</entry>
	      </row>

	      <row>
		<entry>U+005a</entry>
		<entry>Z</entry>
		<entry>latin capital letter z</entry>
		<entry>0x5a</entry>
		<entry>61</entry>
	      </row>

	      <row>
		<entry>U+005b</entry>
		<entry>bracketleft</entry>
		<entry>left square bracket</entry>
		<entry>0x5b</entry>
		<entry>62</entry>
	      </row>

	      <row>
		<entry>U+005c</entry>
		<entry>backslash</entry>
		<entry>backslash</entry>
		<entry>0x5c</entry>
		<entry>63</entry>
	      </row>

	      <row>
		<entry>U+005d</entry>
		<entry>bracketright</entry>
		<entry>right square bracket</entry>
		<entry>0x5d</entry>
		<entry>64</entry>
	      </row>

	      <row>
		<entry>U+005e</entry>
		<entry>asciicircum</entry>
		<entry>circumflex accent</entry>
		<entry>0x5e</entry>
		<entry>65</entry>
	      </row>

	      <row>
		<entry>U+005f</entry>
		<entry>underscore</entry>
		<entry>underline</entry>
		<entry>0x5f</entry>
		<entry>66</entry>
	      </row>

	      <row>
		<entry>U+0060</entry>
		<entry>grave</entry>
		<entry>grave accent</entry>
		<entry>0x60</entry>
		<entry>67</entry>
	      </row>

	      <row>
		<entry>U+0061</entry>
		<entry>a</entry>
		<entry>latin small letter a</entry>
		<entry>0x61</entry>
		<entry>68</entry>
	      </row>

	      <row>
		<entry>U+0062</entry>
		<entry>b</entry>
		<entry>latin small letter b</entry>
		<entry>0x62</entry>
		<entry>69</entry>
	      </row>

	      <row>
		<entry>U+0063</entry>
		<entry>c</entry>
		<entry>latin small letter c</entry>
		<entry>0x63</entry>
		<entry>70</entry>
	      </row>

	      <row>
		<entry>U+0064</entry>
		<entry>d</entry>
		<entry>latin small letter d</entry>
		<entry>0x64</entry>
		<entry>71</entry>
	      </row>

	      <row>
		<entry>U+0065</entry>
		<entry>e</entry>
		<entry>latin small letter e</entry>
		<entry>0x65</entry>
		<entry>72</entry>
	      </row>

	      <row>
		<entry>U+0066</entry>
		<entry>f</entry>
		<entry>latin small letter f</entry>
		<entry>0x66</entry>
		<entry>73</entry>
	      </row>

	      <row>
		<entry>U+0067</entry>
		<entry>g</entry>
		<entry>latin small letter g</entry>
		<entry>0x67</entry>
		<entry>74</entry>
	      </row>

	      <row>
		<entry>U+0068</entry>
		<entry>h</entry>
		<entry>latin small letter h</entry>
		<entry>0x68</entry>
		<entry>75</entry>
	      </row>

	      <row>
		<entry>U+0069</entry>
		<entry>i</entry>
		<entry>latin small letter i</entry>
		<entry>0x69</entry>
		<entry>76</entry>
	      </row>

	      <row>
		<entry>U+006a</entry>
		<entry>j</entry>
		<entry>latin small letter j</entry>
		<entry>0x6a</entry>
		<entry>77</entry>
	      </row>

	      <row>
		<entry>U+006b</entry>
		<entry>k</entry>
		<entry>latin small letter k</entry>
		<entry>0x6b</entry>
		<entry>78</entry>
	      </row>

	      <row>
		<entry>U+006c</entry>
		<entry>l</entry>
		<entry>latin small letter l</entry>
		<entry>0x6c</entry>
		<entry>79</entry>
	      </row>

	      <row>
		<entry>U+006d </entry>
		<entry></entry>
		<entry>latin small letter m</entry>
		<entry>0x6d </entry>
		<entry>80</entry>
	      </row>

	      <row>
		<entry>U+006e</entry>
		<entry>n</entry>
		<entry>latin small letter n</entry>
		<entry>0x6e</entry>
		<entry>81</entry>
	      </row>

	      <row>
		<entry>U+006f</entry>
		<entry>o</entry>
		<entry>latin small letter o</entry>
		<entry>0x6f</entry>
		<entry>82</entry>
	      </row>

	      <row>
		<entry>U+0070</entry>
		<entry>p</entry>
		<entry>latin small letter p</entry>
		<entry>0x70</entry>
		<entry>83</entry>
	      </row>

	      <row>
		<entry>U+0071</entry>
		<entry>q</entry>
		<entry>latin small letter q</entry>
		<entry>0x71</entry>
		<entry>84</entry>
	      </row>

	      <row>
		<entry>U+0072</entry>
		<entry>r</entry>
		<entry>latin small letter r</entry>
		<entry>0x72</entry>
		<entry>85</entry>
	      </row>

	      <row>
		<entry>U+0073</entry>
		<entry>s</entry>
		<entry>latin small letter s</entry>
		<entry>0x73</entry>
		<entry>86</entry>
	      </row>

	      <row>
		<entry>U+0074</entry>
		<entry>t</entry>
		<entry>latin small letter t</entry>
		<entry>0x74</entry>
		<entry>87</entry>
	      </row>

	      <row>
		<entry>U+0075</entry>
		<entry>u</entry>
		<entry>latin small letter u</entry>
		<entry>0x75</entry>
		<entry>88</entry>
	      </row>

	      <row>
		<entry>U+0076</entry>
		<entry>v</entry>
		<entry>latin small letter v</entry>
		<entry>0x76</entry>
		<entry>89</entry>
	      </row>

	      <row>
		<entry>U+0077</entry>
		<entry>w</entry>
		<entry>latin small letter w</entry>
		<entry>0x77</entry>
		<entry>90</entry>
	      </row>

	      <row>
		<entry>U+0078</entry>
		<entry>x</entry>
		<entry>latin small letter x</entry>
		<entry>0x78</entry>
		<entry>91</entry>
	      </row>

	      <row>
		<entry>U+0079</entry>
		<entry>y</entry>
		<entry>latin small letter y</entry>
		<entry>0x79</entry>
		<entry>92</entry>
	      </row>

	      <row>
		<entry>U+007a</entry>
		<entry>z</entry>
		<entry>latin small letter z</entry>
		<entry>0x7a</entry>
		<entry>93</entry>
	      </row>

	      <row>
		<entry>U+007b</entry>
		<entry>braceleft</entry>
		<entry>left curly bracket</entry>
		<entry>0x7b</entry>
		<entry>94</entry>
	      </row>

	      <row>
		<entry>U+007c</entry>
		<entry>bar</entry>
		<entry>vertical line</entry>
		<entry>0x7c</entry>
		<entry>95</entry>
	      </row>

	      <row>
		<entry>U+007d</entry>
		<entry>braceright</entry>
		<entry>right curly bracket</entry>
		<entry>0x7d</entry>
		<entry>96</entry>
	      </row>

	      <row>
		<entry>U+007e</entry>
		<entry>asciitilde</entry>
		<entry>tilde</entry>
		<entry>0x7e</entry>
		<entry>97</entry>
	      </row>

	      <row>
		<entry>U+00a0</entry>
		<entry>space
		  <footnote id='f1'>
		    <para>This glyph name is also used for another
		      Unicode value listed in this document. If a
		      separate design for this glyph is desired, it
		      may be given a uni&lt;CODE> glyph name, where
		      &lt;CODE> is a 4-digit uppercase hexadecimal
		      number that indicates the Unicode value.</para>

		    <para>For example, if different designs are
		      desired for MICRO SIGN (U+00B5) and GREEK SMALL
		      LETTER MU (U+03BC), then glyph "mu" should be
		      designed as MICRO SIGN and glyph "uni03BC" should
		      be designed as GREEK SMALL LETTER MU.</para>

		    <para>Refer to the Adobe document 'Unicode and Glyph Names'
		      for more details.</para>
		  </footnote></entry>
		<entry>no-break space</entry>
		<entry>0xca</entry>
		<entry>172</entry>
	      </row>

	      <row>
		<entry>U+00a1</entry>
		<entry>exclamdown </entry>
		<entry>inverted exclamation mark</entry>
		<entry>0xc1</entry>
		<entry>163</entry>
	      </row>

	      <row>
		<entry>U+00a2</entry>
		<entry>cent</entry>
		<entry>cent sign</entry>
		<entry>xa2</entry>
		<entry>132</entry>
	      </row>

	      <row>
		<entry>U+00a3</entry>
		<entry>sterling</entry>
		<entry>pound sign</entry>
		<entry>xa3</entry>
		<entry>133</entry>
	      </row>

	      <row>
		<entry>U+00a4</entry>
		<entry>currency</entry>
		<entry>currency sign</entry>
		<entry>xdb</entry>
		<entry>189</entry>
	      </row>

	      <row>
		<entry>U+00a5</entry>
		<entry>yen</entry>
		<entry>yen sign</entry>
		<entry>xb4</entry>
		<entry>150</entry>
	      </row>

	      <row>
		<entry>U+00a6</entry>
		<entry>brokenbar</entry>
		<entry>broken bar</entry>
		<entry/>
		<entry>232</entry>
	      </row>

	      <row>
		<entry>U+00a7</entry>
		<entry>section</entry>
		<entry>section sign</entry>
		<entry>0xa4</entry>
		<entry>134</entry>
	      </row>

	      <row>
		<entry>U+00a8</entry>
		<entry>diaeresis</entry>
		<entry>diaeresis</entry>
		<entry>0xac</entry>
		<entry>142</entry>
	      </row>

	      <row>
		<entry>U+00a9</entry>
		<entry>copyright</entry>
		<entry>copyright sign</entry>
		<entry>0xa9</entry>
		<entry>139</entry>
	      </row>

	      <row>
		<entry>U+00aa</entry>
		<entry>ordfeminine</entry>
		<entry>feminine ordinal indicator</entry>
		<entry>0xbb</entry>
		<entry>157</entry>
	      </row>

	      <row>
		<entry>U+00ab</entry>
		<entry>guillemotleft</entry>
		<entry>left guillemet</entry>
		<entry>0xc7</entry>
		<entry>169</entry>
	      </row>

	      <row>
		<entry>U+00ac</entry>
		<entry>logicalnot</entry>
		<entry>not sign</entry>
		<entry>0xc2</entry>
		<entry>164</entry>
	      </row>

	      <row>
		<entry>U+00ad</entry>
		<entry>hyphen<footnoteref linkend='f1'/></entry>
		<entry>soft hyphen</entry>
		<entry/>
		<entry/>
	      </row>

	      <row>
		<entry>U+00ae</entry>
		<entry>registered</entry>
		<entry>registered trade mark sign</entry>
		<entry>0xa8</entry>
		<entry>138</entry>
	      </row>

	      <row>
		<entry>U+00af</entry>
		<entry>macro</entry>
		<entry>macron, overline</entry>
		<entry>0xf8</entry>
		<entry>218</entry>
	      </row>

	      <row>
		<entry>U+00b0</entry>
		<entry>degree</entry>
		<entry>degree sign</entry>
		<entry>0xa1</entry>
		<entry>131</entry>
	      </row>

	      <row>
		<entry>U+00b1</entry>
		<entry>plusminus</entry>
		<entry>plus-minus sign</entry>
		<entry>0xb1</entry>
		<entry>147</entry>
	      </row>

	      <row>
		<entry>U+00b2</entry>
		<entry>twosuperior</entry>
		<entry>superscript two</entry>
		<entry/>
		<entry>242</entry>
	      </row>

	      <row>
		<entry>U+00b3</entry>
		<entry>threesuperior</entry>
		<entry>superscript three</entry>
		<entry/>
		<entry>243</entry>
	      </row>

	      <row>
		<entry>U+00b4</entry>
		<entry>acute</entry>
		<entry>acute accent</entry>
		<entry>0xab</entry>
		<entry>141</entry>
	      </row>

	      <row>
		<entry>U+00b5</entry>
		<entry>mu</entry>
		<entry>micro sign</entry>
		<entry>0xb5</entry>
		<entry>151</entry>
	      </row>

	      <row>
		<entry>U+00b6</entry>
		<entry>paragraph</entry>
		<entry>paragraph sign</entry>
		<entry>0xa6</entry>
		<entry>136</entry>
	      </row>

	      <row>
		<entry>U+00b7</entry>
		<entry>periodcentered</entry>
		<entry>middle dot, kana conjonctive</entry>
		<entry/>
		<entry/>
	      </row>

	      <row>
		<entry>U+00b8</entry>
		<entry>cedilla</entry>
		<entry>cedilla</entry>
		<entry>0xfc</entry>
		<entry>222</entry>
	      </row>

	      <row>
		<entry>U+00b9</entry>
		<entry>onesuperior</entry>
		<entry>superscript one</entry>
		<entry></entry>
		<entry>241</entry>
	      </row>

	      <row>
		<entry>U+00ba</entry>
		<entry>ordmasculine</entry>
		<entry>masculine ordinal indicator</entry>
		<entry>0xbc</entry>
		<entry>158</entry>
	      </row>

	      <row>
		<entry>U+00bb</entry>
		<entry>guillemotright</entry>
		<entry>right guillemet</entry>
		<entry>0xc8</entry>
		<entry>170</entry>
	      </row>

	      <row>
		<entry>U+00bc</entry>
		<entry>onequarter</entry>
		<entry>vulgar fraction one quarter</entry>
		<entry></entry>
		<entry>245</entry>
	      </row>

	      <row>
		<entry>U+00bd</entry>
		<entry>onehalf</entry>
		<entry>vulgar fraction one half</entry>
		<entry></entry>
		<entry>244</entry>
	      </row>

	      <row>
		<entry>U+00be</entry>
		<entry>threequarters</entry>
		<entry>vulgar fraction three quarters</entry>
		<entry></entry>
		<entry>246</entry>
	      </row>

	      <row>
		<entry>U+00bf</entry>
		<entry>questiondown</entry>
		<entry>inverted question mark</entry>
		<entry>0xc0</entry>
		<entry>162</entry>
	      </row>

	      <row>
		<entry>U+00c0</entry>
		<entry>Agrave</entry>
		<entry>latin capital letter a with grave accent</entry>
		<entry>0xcb</entry>
		<entry>173</entry>
	      </row>

	      <row>
		<entry>U+00c1</entry>
		<entry>Aacute</entry>
		<entry>latin capital letter a with acute accent</entry>
		<entry>0xe7</entry>
		<entry>201</entry>
	      </row>

	      <row>
		<entry>U+00c2</entry>
		<entry>Acircumflex</entry>
		<entry>latin capital letter a with circumflex accent</entry>
		<entry>0xe5</entry>
		<entry>199</entry>
	      </row>

	      <row>
		<entry>U+00c3</entry>
		<entry>Atilde</entry>
		<entry>latin capital letter a with tilde</entry>
		<entry>0xcc</entry>
		<entry>174</entry>
	      </row>

	      <row>
		<entry>U+00c4</entry>
		<entry>Adieresis</entry>
		<entry>latin capital letter a with diaeresis</entry>
		<entry>0x80</entry>
		<entry>98</entry>
	      </row>

	      <row>
		<entry>U+00c5</entry>
		<entry>Aring</entry>
		<entry>latin capital letter a with ring above</entry>
		<entry>0x81</entry>
		<entry>99</entry>
	      </row>

	      <row>
		<entry>U+00c6</entry>
		<entry>AE</entry>
		<entry>latin capital letter a with e</entry>
		<entry>0xae</entry>
		<entry>144</entry>
	      </row>

	      <row>
		<entry>U+00c7</entry>
		<entry>Ccedilla</entry>
		<entry>latin capital letter c with cedilla</entry>
		<entry>0x82</entry>
		<entry>100</entry>
	      </row>

	      <row>
		<entry>U+00c8</entry>
		<entry>Egrave</entry>
		<entry>latin capital letter e with grave accent</entry>
		<entry>0xe9</entry>
		<entry>203</entry>
	      </row>

	      <row>
		<entry>U+00c9</entry>
		<entry>Eacute</entry>
		<entry>latin capital letter e with acute accent</entry>
		<entry>0x83</entry>
		<entry>101</entry>
	      </row>

	      <row>
		<entry>U+00ca</entry>
		<entry>Ecircumflex</entry>
		<entry>latin capital letter e with circumflex accent</entry>
		<entry>0xe6</entry>
		<entry>200</entry>
	      </row>

	      <row>
		<entry>U+00cb</entry>
		<entry>Edieresis</entry>
		<entry>latin capital letter e with diaeresis</entry>
		<entry>0xe8</entry>
		<entry>202</entry>
	      </row>

	      <row>
		<entry>U+00cc</entry>
		<entry>Igrave</entry>
		<entry>latin capital letter i with grave accent</entry>
		<entry>0xed</entry>
		<entry>207</entry>
	      </row>

	      <row>
		<entry>U+00cd</entry>
		<entry>Iacute</entry>
		<entry>latin capital letter i with acute accent</entry>
		<entry>0xea</entry>
		<entry>204</entry>
	      </row>

	      <row>
		<entry>U+00ce</entry>
		<entry>Icircumflex</entry>
		<entry>latin capital letter i with circumflex accent</entry>
		<entry>0xeb</entry>
		<entry>205</entry>
	      </row>

	      <row>
		<entry>U+00cf</entry>
		<entry>Idieresis</entry>
		<entry>latin capital letter i with diaeresis</entry>
		<entry>0xec</entry>
		<entry>206</entry>
	      </row>

	      <row>
		<entry>U+00d0</entry>
		<entry>Eth</entry>
		<entry>latin capital letter eth</entry>
		<entry></entry>
		<entry>233</entry>
	      </row>

	      <row>
		<entry>U+00d1</entry>
		<entry>Ntilde</entry>
		<entry>latin capital letter n with tilde</entry>
		<entry>0x84</entry>
		<entry>102</entry>
	      </row>

	      <row>
		<entry>U+00d2</entry>
		<entry>Ograve</entry>
		<entry>latin capital letter o with grave accent</entry>
		<entry>0xf1</entry>
		<entry>211</entry>
	      </row>

	      <row>
		<entry>U+00d3</entry>
		<entry>Oacute</entry>
		<entry>latin capital letter o with acute accent</entry>
		<entry>0eex</entry>
		<entry>208</entry>
	      </row>

	      <row>
		<entry>U+00d4</entry>
		<entry>Ocircumflex</entry>
		<entry>latin capital letter o with circumflex accent</entry>
		<entry>0xef</entry>
		<entry>209</entry>
	      </row>

	      <row>
		<entry>U+00d5</entry>
		<entry>Otilde</entry>
		<entry>latin capital letter o with tilde</entry>
		<entry>0xcd</entry>
		<entry>175</entry>
	      </row>

	      <row>
		<entry>U+00d6</entry>
		<entry>Odieresis</entry>
		<entry>latin capital letter o with diaeresis</entry>
		<entry>0x85</entry>
		<entry>103</entry>
	      </row>

	      <row>
		<entry>U+00d7</entry>
		<entry>multiply </entry>
		<entry>multiplication sign</entry>
		<entry></entry>
		<entry>240</entry>
	      </row>

	      <row>
		<entry>U+00d8</entry>
		<entry>Oslash</entry>
		<entry>latin capital letter o with oblique stroke</entry>
		<entry>0xaf</entry>
		<entry>145</entry>
	      </row>

	      <row>
		<entry>U+00d9</entry>
		<entry>Ugrave</entry>
		<entry>latin capital letter u with grave accent</entry>
		<entry>0xf4</entry>
		<entry>214</entry>
	      </row>

	      <row>
		<entry>U+00da</entry>
		<entry>Uacute</entry>
		<entry>latin capital letter u with acute accent</entry>
		<entry>0xf2</entry>
		<entry>212</entry>
	      </row>

	      <row>
		<entry>U+00db</entry>
		<entry>Ucircumflex </entry>
		<entry>latin capital letter u with circumflex accent</entry>
		<entry>0xf3</entry>
		<entry>213</entry>
	      </row>

	      <row>
		<entry>U+00dc</entry>
		<entry>Udieresis </entry>
		<entry>latin capital letter u with diaeresis</entry>
		<entry>0x86</entry>
		<entry>104</entry>
	      </row>

	      <row>
		<entry>U+00dd</entry>
		<entry>Yacute </entry>
		<entry>latin capital letter y with acute accent</entry>
		<entry/>
		<entry>235</entry>
	      </row>

	      <row>
		<entry>U+00de</entry>
		<entry>Thorn </entry>
		<entry>latin capital letter thorn</entry>
		<entry></entry>
		<entry>237</entry>
	      </row>

	      <row>
		<entry>U+00df</entry>
		<entry>germandbls </entry>
		<entry>latin small letter sharp s</entry>
		<entry>0xa7</entry>
		<entry>137</entry>
	      </row>

	      <row>
		<entry>U+00e0</entry>
		<entry>agrave </entry>
		<entry>latin small letter a with grave accent</entry>
		<entry>0x88</entry>
		<entry>106</entry>
	      </row>

	      <row>
		<entry>U+00e1</entry>
		<entry>aacute </entry>
		<entry>latin small letter a with acute accent</entry>
		<entry>0x87</entry>
		<entry>105</entry>
	      </row>

	      <row>
		<entry>U+00e2</entry>
		<entry>acircumflex </entry>
		<entry>latin small letter a with circumflex accent</entry>
		<entry>0x89</entry>
		<entry>107</entry>
	      </row>

	      <row>
		<entry>U+00e3</entry>
		<entry>atilde </entry>
		<entry>latin small letter a with tilde</entry>
		<entry>0x8b</entry>
		<entry>109</entry>
	      </row>

	      <row>
		<entry>U+00e4</entry>
		<entry>adieresis </entry>
		<entry>latin small letter a with diaeresis</entry>
		<entry>0x8a</entry>
		<entry>108</entry>
	      </row>

	      <row>
		<entry>U+00e5</entry>
		<entry>aring </entry>
		<entry>latin small letter a with ring above</entry>
		<entry>0x8c</entry>
		<entry>110</entry>
	      </row>

	      <row>
		<entry>U+00e6</entry>
		<entry>ae </entry>
		<entry>latin small letter a with e</entry>
		<entry>0xbe</entry>
		<entry>160</entry>
	      </row>

	      <row>
		<entry>U+00e7</entry>
		<entry>ccedilla </entry>
		<entry>latin small letter c with cedilla</entry>
		<entry>0x8d</entry>
		<entry>111</entry>
	      </row>

	      <row>
		<entry>U+00e8</entry>
		<entry>egrave </entry>
		<entry>latin small letter e with grave accent</entry>
		<entry>0x8f</entry>
		<entry>113</entry>
	      </row>

	      <row>
		<entry>U+00e9</entry>
		<entry>eacute </entry>
		<entry>latin small letter e with acute accent</entry>
		<entry>0x8e</entry>
		<entry>112</entry>
	      </row>

	      <row>
		<entry>U+00ea</entry>
		<entry>ecircumflex </entry>
		<entry>latin small letter e with circumflex accent</entry>
		<entry>0x90</entry>
		<entry>114</entry>
	      </row>

	      <row>
		<entry>U+00eb</entry>
		<entry>edieresis </entry>
		<entry>latin small letter e with diaeresis</entry>
		<entry>0x91</entry>
		<entry>115</entry>
	      </row>

	      <row>
		<entry>U+00ec</entry>
		<entry>igrave </entry>
		<entry>latin small letter i with grave accent</entry>
		<entry>0x93</entry>
		<entry>117</entry>
	      </row>

	      <row>
		<entry>U+00ed</entry>
		<entry>iacute </entry>
		<entry>latin small letter i with acute accent</entry>
		<entry>0x92</entry>
		<entry>116</entry>
	      </row>

	      <row>
		<entry>U+00ee</entry>
		<entry>icircumflex </entry>
		<entry>latin small letter i with circumflex accent</entry>
		<entry>0x94</entry>
		<entry>118</entry>
	      </row>

	      <row>
		<entry>U+00ef</entry>
		<entry>idieresis </entry>
		<entry>latin small letter i with diaeresis</entry>
		<entry>0x95</entry>
		<entry>119</entry>
	      </row>

	      <row>
		<entry>U+00f0</entry>
		<entry>eth </entry>
		<entry>latin small letter eth</entry>
		<entry></entry>
		<entry>234</entry>
	      </row>

	      <row>
		<entry>U+00f1</entry>
		<entry>ntilde </entry>
		<entry>latin small letter n with tilde</entry>
		<entry>0x96</entry>
		<entry>120</entry>
	      </row>

	      <row>
		<entry>U+00f2</entry>
		<entry>ograve </entry>
		<entry>latin small letter o with grave accent</entry>
		<entry>0x98</entry>
		<entry>122</entry>
	      </row>

	      <row>
		<entry>U+00f3</entry>
		<entry>oacute </entry>
		<entry>latin small letter o with acute accent</entry>
		<entry>0x97</entry>
		<entry>121</entry>
	      </row>

	      <row>
		<entry>U+00f4</entry>
		<entry>ocircumflex </entry>
		<entry>latin small letter o with circumflex accent</entry>
		<entry>0x99</entry>
		<entry>123</entry>
	      </row>

	      <row>
		<entry>U+00f5</entry>
		<entry>otilde </entry>
		<entry>latin small letter o with tilde</entry>
		<entry>0x9b</entry>
		<entry>125</entry>
	      </row>

	      <row>
		<entry>U+00f6</entry>
		<entry>odieresis </entry>
		<entry>latin small letter o with diaeresis</entry>
		<entry>0x9a</entry>
		<entry>124</entry>
	      </row>

	      <row>
		<entry>U+00f7</entry>
		<entry>divide </entry>
		<entry>division sign</entry>
		<entry>0xd6</entry>
		<entry>184</entry>
	      </row>

	      <row>
		<entry>U+00f8</entry>
		<entry>oslash </entry>
		<entry>latin small letter o with oblique stroke</entry>
		<entry>0xbf</entry>
		<entry>161</entry>
	      </row>

	      <row>
		<entry>U+00f9</entry>
		<entry>ugrave </entry>
		<entry>latin small letter u with grave accent</entry>
		<entry>0x9d</entry>
		<entry>127</entry>
	      </row>

	      <row>
		<entry>U+00fa</entry>
		<entry>uacute </entry>
		<entry>latin small letter u with acute accent</entry>
		<entry>0x9c</entry>
		<entry>126</entry>
	      </row>

	      <row>
		<entry>U+00fb</entry>
		<entry>ucircumflex </entry>
		<entry>latin small letter u with circumflex accent</entry>
		<entry>0x9e</entry>
		<entry>128</entry>
	      </row>

	      <row>
		<entry>U+00fc</entry>
		<entry>udieresis </entry>
		<entry>latin small letter u with diaeresis</entry>
		<entry>0x9f</entry>
		<entry>129</entry>
	      </row>

	      <row>
		<entry>U+00fd</entry>
		<entry>yacute </entry>
		<entry>latin small letter y with acute accent</entry>
		<entry></entry>
		<entry>236</entry>
	      </row>

	      <row>
		<entry>U+00fe</entry>
		<entry>thorn </entry>
		<entry>latin small letter thorn</entry>
		<entry></entry>
		<entry>238</entry>
	      </row>

	      <row>
		<entry>U+00ff</entry>
		<entry>ydieresis </entry>
		<entry>latin small letter y with diaeresis</entry>
		<entry>0xd8</entry>
		<entry>186</entry>
	      </row>

	      <row>
		<entry>U+0100</entry>
		<entry>Amacron </entry>
		<entry>latin capital letter a with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0101</entry>
		<entry>amacron </entry>
		<entry>latin small letter a with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0102</entry>
		<entry>Abreve </entry>
		<entry>latin capital letter a with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0103</entry>
		<entry>abreve </entry>
		<entry>latin small letter a with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0104</entry>
		<entry>Aogonek </entry>
		<entry>latin capital letter a with ogonek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0105</entry>
		<entry>aogonek </entry>
		<entry>latin small letter a with ogonek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0106</entry>
		<entry>Cacute </entry>
		<entry>latin capital letter c with acute accent</entry>
		<entry></entry>
		<entry>253</entry>
	      </row>

	      <row>
		<entry>U+0107</entry>
		<entry>cacute </entry>
		<entry>latin small letter c with acute accent</entry>
		<entry></entry>
		<entry>254</entry>
	      </row>

	      <row>
		<entry>U+0108</entry>
		<entry>Ccircumflex </entry>
		<entry>latin capital letter c with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0109</entry>
		<entry>ccircumflex </entry>
		<entry>latin small letter c with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+010a</entry>
		<entry>Cdotaccent </entry>
		<entry>latin capital letter c with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+010b</entry>
		<entry>cdotaccent </entry>
		<entry>latin small letter c with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+010c</entry>
		<entry>Ccaron </entry>
		<entry>latin capital letter c with caron</entry>
		<entry></entry>
		<entry>255</entry>
	      </row>

	      <row>
		<entry>U+010d</entry>
		<entry>ccaron </entry>
		<entry>latin small letter c with caron</entry>
		<entry></entry>
		<entry>256</entry>
	      </row>

	      <row>
		<entry>U+010e</entry>
		<entry>Dcaron </entry>
		<entry>latin capital letter d with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+010f</entry>
		<entry>dcaron </entry>
		<entry>latin small letter d with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0110</entry>
		<entry>Dcroat </entry>
		<entry>latin capital letter d with stroke</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0111</entry>
		<entry>dcroat </entry>
		<entry>latin small letter d with stroke</entry>
		<entry></entry>
		<entry>257</entry>
	      </row>

	      <row>
		<entry>U+0112</entry>
		<entry>Emacron </entry>
		<entry>latin capital letter e with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0113</entry>
		<entry>emacron </entry>
		<entry>latin small letter e with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0114</entry>
		<entry>Ebreve </entry>
		<entry>latin capital letter e with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0115</entry>
		<entry>ebreve </entry>
		<entry>latin small letter e with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0116</entry>
		<entry>Edotaccent</entry>
		<entry>latin capital letter e with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0117</entry>
		<entry>edotaccent</entry>
		<entry>latin small letter e with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0118</entry>
		<entry>Eogonek </entry>
		<entry>latin capital letter e with ogenek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0119</entry>
		<entry>eogonek </entry>
		<entry>latin small letter e with ogenek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+011a</entry>
		<entry>Ecaron </entry>
		<entry>latin capital letter e with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+011b</entry>
		<entry>ecaron </entry>
		<entry>latin small letter e with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+011c</entry>
		<entry>Gcircumflex </entry>
		<entry>latin capital letter g with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+011d</entry>
		<entry>gcircumflex </entry>
		<entry>latin small letter g with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+011e</entry>
		<entry>Gbreve </entry>
		<entry>latin capital letter g with breve</entry>
		<entry></entry>
		<entry>248</entry>
	      </row>

	      <row>
		<entry>U+011f</entry>
		<entry>gbreve </entry>
		<entry>latin small letter g with breve</entry>
		<entry></entry>
		<entry>249</entry>
	      </row>

	      <row>
		<entry>U+0120</entry>
		<entry>Gdotaccent</entry>
		<entry>latin capital letter g with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0121</entry>
		<entry>gdotaccent</entry>
		<entry>latin small letter g with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0122</entry>
		<entry>Gcommaaccent</entry>
		<entry>latin capital letter g with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0123</entry>
		<entry>gcommaaccent</entry>
		<entry>latin small letter g with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0124</entry>
		<entry>Hcircumflex </entry>
		<entry>latin capital letter h with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0125</entry>
		<entry>hcircumflex </entry>
		<entry>latin small letter h with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0126</entry>
		<entry>Hbar </entry>
		<entry>latin capital letter h with stroke</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0127</entry>
		<entry>hbar </entry>
		<entry>latin small letter h with stroke</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0128</entry>
		<entry>Itilde </entry>
		<entry>latin capital letter i with tilde</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0129</entry>
		<entry>itilde </entry>
		<entry>latin small letter i with tilde</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+012a</entry>
		<entry>Imacron </entry>
		<entry>latin capital letter i with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+012b</entry>
		<entry>imacron </entry>
		<entry>latin small letter i with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+012c</entry>
		<entry>Ibreve </entry>
		<entry>latin capital letter i with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+012d</entry>
		<entry>ibreve </entry>
		<entry>latin small letter i with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+012e</entry>
		<entry>Iogonek </entry>
		<entry>latin capital letter i with ogonek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+012f</entry>
		<entry>iogonek </entry>
		<entry>latin small letter i with ogonek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0130</entry>
		<entry>Idotaccent</entry>
		<entry>latin capital letter i with dot above</entry>
		<entry></entry>
		<entry>250</entry>
	      </row>

	      <row>
		<entry>U+0131</entry>
		<entry>dotlessi </entry>
		<entry>latin small letter i without dot above</entry>
		<entry>0xf5</entry>
		<entry>215</entry>
	      </row>

	      <row>
		<entry>U+0132</entry>
		<entry>IJ </entry>
		<entry>latin capital ligature ij</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0133</entry>
		<entry>ij </entry>
		<entry>latin small ligature ij</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0134</entry>
		<entry>Jcircumflex </entry>
		<entry>latin capital letter j with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0135</entry>
		<entry>jcircumflex </entry>
		<entry>latin small letter j with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0136</entry>
		<entry>Kcommaaccent</entry>
		<entry>latin capital letter k with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0137</entry>
		<entry>kcommaaccent</entry>
		<entry>latin small letter k with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0138</entry>
		<entry>kgreenlandic </entry>
		<entry>latin small letter kra</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0139</entry>
		<entry>Lacute </entry>
		<entry>latin capital letter l with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+013a</entry>
		<entry>lacute </entry>
		<entry>latin small letter l with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+013b</entry>
		<entry>Lcommaaccent</entry>
		<entry>latin capital letter l with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+013c</entry>
		<entry>lcommaaccent </entry>
		<entry>latin small letter l with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+013d</entry>
		<entry>Lcaron </entry>
		<entry>latin capital letter l with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+013e</entry>
		<entry>lcaron </entry>
		<entry>latin small letter l with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+013f</entry>
		<entry>Ldot </entry>
		<entry>latin capital letter l with middle dot</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0140</entry>
		<entry>ldot </entry>
		<entry>latin small letter l with middle dot</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0141</entry>
		<entry>Lslash </entry>
		<entry>latin capital letter l with stroke</entry>
		<entry></entry>
		<entry>226</entry>
	      </row>

	      <row>
		<entry>U+0142</entry>
		<entry>lslash </entry>
		<entry>latin small letter l with stroke</entry>
		<entry></entry>
		<entry>227</entry>
	      </row>

	      <row>
		<entry>U+0143</entry>
		<entry>Nacute </entry>
		<entry>latin capital letter n with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0144</entry>
		<entry>nacute </entry>
		<entry>latin small letter n with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0145</entry>
		<entry>Ncommaaccent</entry>
		<entry>latin capital letter n with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0146</entry>
		<entry>ncommaaccent </entry>
		<entry>latin small letter n with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0147</entry>
		<entry>Ncaron </entry>
		<entry>latin capital letter n with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0148</entry>
		<entry>ncaron </entry>
		<entry>latin small letter n with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0149</entry>
		<entry>napostrophe </entry>
		<entry>latin small letter n preceded by apostrophe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+014a</entry>
		<entry>Eng </entry>
		<entry>latin capital letter eng</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+014b</entry>
		<entry>eng </entry>
		<entry>latin small letter eng</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+014c</entry>
		<entry>Omacron </entry>
		<entry>latin capital letter o with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+014d</entry>
		<entry>omacron </entry>
		<entry>latin small letter o with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+014e</entry>
		<entry>Obreve </entry>
		<entry>latin capital letter o with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+014f</entry>
		<entry>obreve </entry>
		<entry>latin small letter o with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0150</entry>
		<entry>Ohungarumlaut</entry>
		<entry>latin capital letter o with double acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0151</entry>
		<entry>ohungarumlaut </entry>
		<entry>latin small letter o with double acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0152</entry>
		<entry>OE </entry>
		<entry>latin capital ligature o with e</entry>
		<entry>0xce</entry>
		<entry>176</entry>
	      </row>

	      <row>
		<entry>U+0153</entry>
		<entry>oe </entry>
		<entry>latin small ligature o with e</entry>
		<entry>0xcf</entry>
		<entry>177</entry>
	      </row>

	      <row>
		<entry>U+0154</entry>
		<entry>Racute </entry>
		<entry>latin capital letter r with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0155</entry>
		<entry>racute </entry>
		<entry>latin small letter r with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0156</entry>
		<entry>Rcommaaccent </entry>
		<entry>latin capital letter r with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0157</entry>
		<entry>rcommaaccent </entry>
		<entry>latin small letter r with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0158</entry>
		<entry>Rcaron </entry>
		<entry>latin capital letter r with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0159</entry>
		<entry>rcaron </entry>
		<entry>latin small letter r with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+015a</entry>
		<entry>Sacute </entry>
		<entry>latin capital letter s with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+015b</entry>
		<entry>sacute </entry>
		<entry>latin small letter s with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+015c</entry>
		<entry>Scircumflex </entry>
		<entry>latin capital letter s with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+015d</entry>
		<entry>scircumflex </entry>
		<entry>latin small letter s with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+015e</entry>
		<entry>Scedilla </entry>
		<entry>latin capital letter s with cedilla</entry>
		<entry></entry>
		<entry>251</entry>
	      </row>

	      <row>
		<entry>U+015f</entry>
		<entry>scedilla </entry>
		<entry>latin small letter s with cedilla</entry>
		<entry></entry>
		<entry>252</entry>
	      </row>

	      <row>
		<entry>U+0160</entry>
		<entry>Scaron </entry>
		<entry>latin capital letter s with hacek</entry>
		<entry></entry>
		<entry>228</entry>
	      </row>

	      <row>
		<entry>U+0161</entry>
		<entry>scaron </entry>
		<entry>latin small letter s with hacek</entry>
		<entry></entry>
		<entry>229</entry>
	      </row>

	      <row>
		<entry>U+0162</entry>
		<entry>Tcommaaccent<footnoteref linkend='f1'/></entry>
		<entry>latin capital letter t with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0163</entry>
		<entry>tcommaaccent<footnoteref linkend='f1'/> </entry>
		<entry>latin small letter t with cedilla</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0164</entry>
		<entry>Tcaron </entry>
		<entry>latin capital letter t with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0165</entry>
		<entry>tcaron </entry>
		<entry>latin small letter t with hacek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0166</entry>
		<entry>Tbar </entry>
		<entry>latin capital letter t with stroke</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0167</entry>
		<entry>tbar </entry>
		<entry>latin small letter t with stroke</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0168</entry>
		<entry>Utilde </entry>
		<entry>latin capital letter u with tilde</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0169</entry>
		<entry>utilde </entry>
		<entry>latin small letter u with tilde</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+016a</entry>
		<entry>Umacron </entry>
		<entry>latin capital letter u with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+016b</entry>
		<entry>umacron </entry>
		<entry>latin small letter u with macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+016c</entry>
		<entry>Ubreve </entry>
		<entry>latin capital letter u with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+016d</entry>
		<entry>ubreve </entry>
		<entry>latin small letter u with breve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+016e</entry>
		<entry>Uring </entry>
		<entry>latin capital letter u with ring above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+016f</entry>
		<entry>uring </entry>
		<entry>latin small letter u with ring above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0170</entry>
		<entry>Uhungarumlaut </entry>
		<entry>latin capital letter u with double acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0171</entry>
		<entry>uhungarumlaut </entry>
		<entry>latin small letter u with double acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0172</entry>
		<entry>Uogonek </entry>
		<entry>latin capital letter u with ogonek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0173</entry>
		<entry>uogonek </entry>
		<entry>latin small letter u with ogonek</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0174</entry>
		<entry>Wcircumflex </entry>
		<entry>latin capital letter w with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0175</entry>
		<entry>wcircumflex </entry>
		<entry>latin cmall letter w with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0176</entry>
		<entry>Ycircumflex </entry>
		<entry>latin capital letter y with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0177</entry>
		<entry>ycircumflex </entry>
		<entry>latin small letter y with circumflex</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0178</entry>
		<entry>Ydieresis </entry>
		<entry>latin capital letter y with diaeresis</entry>
		<entry>0xd9</entry>
		<entry>187</entry>
	      </row>

	      <row>
		<entry>U+0179</entry>
		<entry>Zacute </entry>
		<entry>latin capital letter z with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+017a</entry>
		<entry>zacute </entry>
		<entry>latin small letter z with acute accent</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+017b</entry>
		<entry>Zdotaccent</entry>
		<entry>latin capital letter z with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+017c</entry>
		<entry>zdotaccent</entry>
		<entry>latin small letter z with dot above</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+017d</entry>
		<entry>Zcaron </entry>
		<entry>latin capital letter z with hacek</entry>
		<entry></entry>
		<entry>230</entry>
	      </row>

	      <row>
		<entry>U+017e</entry>
		<entry>zcaron </entry>
		<entry>latin small letter z with hacek</entry>
		<entry></entry>
		<entry>231</entry>
	      </row>

	      <row>
		<entry>U+017f</entry>
		<entry>longs </entry>
		<entry>latin small letter long s</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0192</entry>
		<entry>florin </entry>
		<entry>latin small letter script f,florin sign</entry>
		<entry>0xc4</entry>
		<entry>166</entry>
	      </row>

	      <row>
		<entry>U+01fa</entry>
		<entry>Aringacute </entry>
		<entry>latin capital letter a with ring above and acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+01fb</entry>
		<entry>aringacute </entry>
		<entry>latin small letter a with ring above and acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+01fc</entry>
		<entry>AEacute </entry>
		<entry>latin capital ligature ae with acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+01fd</entry>
		<entry>aeacute </entry>
		<entry>latin small ligature ae with acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+01fe</entry>
		<entry>Oslashacute </entry>
		<entry>latin capital letter o with stroke and acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+01ff</entry>
		<entry>oslashacute </entry>
		<entry>latin small letter o with stroke and acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+02c6</entry>
		<entry>circumflex </entry>
		<entry>nonspacing circumflex accent</entry>
		<entry>0xf6</entry>
		<entry>216</entry>
	      </row>

	      <row>
		<entry>U+02c7</entry>
		<entry>caron </entry>
		<entry>modifier letter hacek</entry>
		<entry>0xff</entry>
		<entry>225</entry>
	      </row>

	      <row>
		<entry>U+02c9</entry>
		<entry>macron<footnoteref linkend='f1'/> </entry>
		<entry>modifier letter macron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+02d8</entry>
		<entry>breve </entry>
		<entry>breve</entry>
		<entry>0xf9</entry>
		<entry>219</entry>
	      </row>

	      <row>
		<entry>U+02d9</entry>
		<entry>dotaccent </entry>
		<entry>dot above</entry>
		<entry>0xfa</entry>
		<entry>220</entry>
	      </row>

	      <row>
		<entry>U+02da</entry>
		<entry>ring </entry>
		<entry>ring above</entry>
		<entry>0xfb</entry>
		<entry>221</entry>
	      </row>

	      <row>
		<entry>U+02db</entry>
		<entry>ogonek </entry>
		<entry>ogonek</entry>
		<entry>0xfe</entry>
		<entry>224</entry>
	      </row>

	      <row>
		<entry>U+02dc</entry>
		<entry>tilde</entry>
		<entry>nonspacing tilde </entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+02dd</entry>
		<entry>hungarumlaut </entry>
		<entry>modifier letter double prime</entry>
		<entry>0xfd</entry>
		<entry>223</entry>
	      </row>

	      <row>
		<entry>U+0384</entry>
		<entry>tonos </entry>
		<entry>greek tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0385</entry>
		<entry>dieresistonos </entry>
		<entry>greek dialytika tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0386</entry>
		<entry>Alphatonos </entry>
		<entry>greek capital letter alpha with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0387</entry>
		<entry>anoteleia </entry>
		<entry>greek ano teleia</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0388</entry>
		<entry>Epsilontonos </entry>
		<entry>greek capital letter epsilon with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0389</entry>
		<entry>Etatonos </entry>
		<entry>greek capital letter eta with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+038a</entry>
		<entry>Iotatonos </entry>
		<entry>greek capital letter iota with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+038c</entry>
		<entry>Omicrontonos </entry>
		<entry>greek capital letter omicron with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+038e</entry>
		<entry>Upsilontonos </entry>
		<entry>greek capital letter upsilon with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+038f</entry>
		<entry>Omegatonos </entry>
		<entry>greek capital letter omega with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0390</entry>
		<entry>iotadieresistonos </entry>
		<entry>greek small letter iota with dialytika and tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0391</entry>
		<entry>Alpha </entry>
		<entry>greek capital letter alpha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0392</entry>
		<entry>Beta </entry>
		<entry>greek capital letter beta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0393</entry>
		<entry>Gamma </entry>
		<entry>greek capital letter gamma</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0394</entry>
		<entry>Delta<footnoteref linkend='f1'/> </entry>
		<entry>greek capital letter delta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0395</entry>
		<entry>Epsilon </entry>
		<entry>greek capital letter epsilon</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0396</entry>
		<entry>Zeta </entry>
		<entry>greek capital letter zeta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0397</entry>
		<entry>Eta </entry>
		<entry>greek capital letter eta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0398</entry>
		<entry>Theta </entry>
		<entry>greek capital letter theta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0399</entry>
		<entry>Iota </entry>
		<entry>greek capital letter iota</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+039a</entry>
		<entry>Kappa </entry>
		<entry>greek capital letter kappa</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+039b</entry>
		<entry>Lambda </entry>
		<entry>greek capital letter lamda</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+039c</entry>
		<entry>Mu </entry>
		<entry>greek capital letter mu</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+039d</entry>
		<entry>Nu </entry>
		<entry>greek capital letter nu</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+039e</entry>
		<entry>Xi </entry>
		<entry>greek capital letter xi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+039f</entry>
		<entry>Omicron </entry>
		<entry>greek capital letter omicron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a0</entry>
		<entry>Pi </entry>
		<entry>greek capital letter pi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a1</entry>
		<entry>Rho </entry>
		<entry>greek capital letter rho</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a3</entry>
		<entry>Sigma </entry>
		<entry>greek capital letter sigma</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a4</entry>
		<entry>Tau </entry>
		<entry>greek capital letter tau</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a5</entry>
		<entry>Upsilon </entry>
		<entry>greek capital letter upsilon</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a6</entry>
		<entry>Phi </entry>
		<entry>greek capital letter phi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a7</entry>
		<entry>Chi </entry>
		<entry>greek capital letter chi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a8</entry>
		<entry>Psi </entry>
		<entry>greek capital letter psi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03a9</entry>
		<entry>Omega<footnoteref linkend='f1'/></entry>
		<entry>greek capital letter omega</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03aa</entry>
		<entry>Iotadieresis </entry>
		<entry>greek capital letter iota with dialytika</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ab</entry>
		<entry>Upsilondieresis </entry>
		<entry>greek capital letter upsilon with dialytika</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ac</entry>
		<entry>alphatonos </entry>
		<entry>greek small letter alpha with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ad</entry>
		<entry>epsilontonos </entry>
		<entry>greek small letter epsilon with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ae</entry>
		<entry>etatonos </entry>
		<entry>greek small letter eta with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03af</entry>
		<entry>iotatonos </entry>
		<entry>greek small letter iota with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b0</entry>
		<entry>upsilondieresistonos </entry>
		<entry>greek small letter upsilon with dialytika and tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b1</entry>
		<entry>alpha </entry>
		<entry>greek small letter alpha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b2</entry>
		<entry>beta </entry>
		<entry>greek small letter beta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b3</entry>
		<entry>gamma </entry>
		<entry>greek small letter gamma</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b4</entry>
		<entry>delta </entry>
		<entry>greek small letter delta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b5</entry>
		<entry>epsilon </entry>
		<entry>greek small letter epsilon</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b6</entry>
		<entry>zeta </entry>
		<entry>greek small letter zeta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b7</entry>
		<entry>eta </entry>
		<entry>greek small letter eta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b8</entry>
		<entry>theta </entry>
		<entry>greek small letter theta</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03b9</entry>
		<entry>iota </entry>
		<entry>greek small letter iota</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ba</entry>
		<entry>kappa </entry>
		<entry>greek small letter kappa</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03bb</entry>
		<entry>lambda </entry>
		<entry>greek small letter lamda</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03bc</entry>
		<entry>mu<footnoteref linkend='f1'/> </entry>
		<entry>greek small letter mu</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03bd</entry>
		<entry>nu </entry>
		<entry>greek small letter nu</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03be</entry>
		<entry>xi </entry>
		<entry>greek small letter xi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03bf</entry>
		<entry>omicron </entry>
		<entry>greek small letter omicron</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c0</entry>
		<entry>pi </entry>
		<entry>greek small letter pi</entry>
		<entry>0xb9</entry>
		<entry>155</entry>
	      </row>

	      <row>
		<entry>U+03c1</entry>
		<entry>rho </entry>
		<entry>greek small letter rho</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c2</entry>
		<entry>sigma1 </entry>
		<entry>greek small letter final sigma</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c3</entry>
		<entry>sigma </entry>
		<entry>greek small letter sigma</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c4</entry>
		<entry>tau </entry>
		<entry>greek small letter tau</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c5</entry>
		<entry>upsilon </entry>
		<entry>greek small letter upsilon</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c6</entry>
		<entry>phi </entry>
		<entry>greek small letter phi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c7</entry>
		<entry>chi </entry>
		<entry>greek small letter chi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c8</entry>
		<entry>psi </entry>
		<entry>greek small letter psi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03c9</entry>
		<entry>omega </entry>
		<entry>greek small letter omega</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ca</entry>
		<entry>iotadieresis </entry>
		<entry>greek small letter iota with dialytika</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03cb</entry>
		<entry>upsilondieresis </entry>
		<entry>greek small letter upsilon with dialytika</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03cc</entry>
		<entry>omicrontonos </entry>
		<entry>greek small letter omicron with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03cd</entry>
		<entry>upsilontonos </entry>
		<entry>greek small letter upsilon with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+03ce</entry>
		<entry>omegatonos </entry>
		<entry>greek small letter omega with tonos</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0401</entry>
		<entry>afii10023 </entry>
		<entry>cyrillic capital letter io</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0402</entry>
		<entry>afii10051 </entry>
		<entry>cyrillic capital letter dje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0403</entry>
		<entry>afii10052 </entry>
		<entry>cyrillic capital letter gje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0404</entry>
		<entry>afii10053 </entry>
		<entry>cyrillic capital letter ukrainian ie</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0405</entry>
		<entry>afii10054 </entry>
		<entry>cyrillic capital letter dze</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0406</entry>
		<entry>afii10055 </entry>
		<entry>cyrillic capital letter byelorussian-ukrainian i</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0407</entry>
		<entry>afii10056 </entry>
		<entry>cyrillic capital letter yi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0408</entry>
		<entry>afii10057 </entry>
		<entry>cyrillic capital letter je</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0409</entry>
		<entry>afii10058 </entry>
		<entry>cyrillic capital letter lje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+040a</entry>
		<entry>afii10059 </entry>
		<entry>cyrillic capital letter nje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+040b</entry>
		<entry>afii10060 </entry>
		<entry>cyrillic capital letter tshe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+040c</entry>
		<entry>afii10061 </entry>
		<entry>cyrillic capital letter kje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+040e</entry>
		<entry>afii10062 </entry>
		<entry>cyrillic capital letter short u</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+040f</entry>
		<entry>afii10145 </entry>
		<entry>cyrillic capital letter dzhe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0410</entry>
		<entry>afii10017 </entry>
		<entry>cyrillic capital letter a</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0411</entry>
		<entry>afii10018 </entry>
		<entry>cyrillic capital letter be</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0412</entry>
		<entry>afii10019 </entry>
		<entry>cyrillic capital letter ve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0413</entry>
		<entry>afii10020 </entry>
		<entry>cyrillic capital letter ghe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0414</entry>
		<entry>afii10021 </entry>
		<entry>cyrillic capital letter de</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0415</entry>
		<entry>afii10022 </entry>
		<entry>cyrillic capital letter ie</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0416</entry>
		<entry>afii10024 </entry>
		<entry>cyrillic capital letter zhe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0417</entry>
		<entry>afii10025 </entry>
		<entry>cyrillic capital letter ze</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0418</entry>
		<entry>afii10026 </entry>
		<entry>cyrillic capital letter i</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0419</entry>
		<entry>afii10027 </entry>
		<entry>cyrillic capital letter short i</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+041a</entry>
		<entry>afii10028 </entry>
		<entry>cyrillic capital letter ka</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+041b</entry>
		<entry>afii10029 </entry>
		<entry>cyrillic capital letter el</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+041c</entry>
		<entry>afii10030 </entry>
		<entry>cyrillic capital letter em</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+041d</entry>
		<entry>afii10031 </entry>
		<entry>cyrillic capital letter en</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+041e</entry>
		<entry>afii10032 </entry>
		<entry>cyrillic capital letter o</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+041f</entry>
		<entry>afii10033 </entry>
		<entry>cyrillic capital letter pe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0420</entry>
		<entry>afii10034 </entry>
		<entry>cyrillic capital letter er</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0421</entry>
		<entry>afii10035 </entry>
		<entry>cyrillic capital letter es</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0422</entry>
		<entry>afii10036 </entry>
		<entry>cyrillic capital letter te</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0423</entry>
		<entry>afii10037 </entry>
		<entry>cyrillic capital letter u</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0424</entry>
		<entry>afii10038 </entry>
		<entry>cyrillic capital letter ef</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0425</entry>
		<entry>afii10039 </entry>
		<entry>cyrillic capital letter ha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0426</entry>
		<entry>afii10040 </entry>
		<entry>cyrillic capital letter tse</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0427</entry>
		<entry>afii10041 </entry>
		<entry>cyrillic capital letter che</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0428</entry>
		<entry>afii10042 </entry>
		<entry>cyrillic capital letter sha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0429</entry>
		<entry>afii10043 </entry>
		<entry>cyrillic capital letter shcha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+042a</entry>
		<entry>afii10044 </entry>
		<entry>cyrillic capital letter hard sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+042b</entry>
		<entry>afii10045 </entry>
		<entry>cyrillic capital letter yeru</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+042c</entry>
		<entry>afii10046 </entry>
		<entry>cyrillic capital letter soft sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+042d</entry>
		<entry>afii10047 </entry>
		<entry>cyrillic capital letter e</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+042e</entry>
		<entry>afii10048 </entry>
		<entry>cyrillic capital letter yu</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+042f</entry>
		<entry>afii10049 </entry>
		<entry>cyrillic capital letter ya</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0430</entry>
		<entry>afii10065 </entry>
		<entry>cyrillic small letter a</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0431</entry>
		<entry>afii10066 </entry>
		<entry>cyrillic small letter be</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0432</entry>
		<entry>afii10067 </entry>
		<entry>cyrillic small letter ve</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0433</entry>
		<entry>afii10068 </entry>
		<entry>cyrillic small letter ghe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0434</entry>
		<entry>afii10069 </entry>
		<entry>cyrillic small letter de</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0435</entry>
		<entry>afii10070 </entry>
		<entry>cyrillic small letter ie</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0436</entry>
		<entry>afii10072 </entry>
		<entry>cyrillic small letter zhe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0437</entry>
		<entry>afii10073 </entry>
		<entry>cyrillic small letter ze</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0438</entry>
		<entry>afii10074 </entry>
		<entry>cyrillic small letter i</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0439</entry>
		<entry>afii10075 </entry>
		<entry>cyrillic small letter short i</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+043a</entry>
		<entry>afii10076 </entry>
		<entry>cyrillic small letter ka</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+043b</entry>
		<entry>afii10077 </entry>
		<entry>cyrillic small letter el</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+043c</entry>
		<entry>afii10078 </entry>
		<entry>cyrillic small letter em</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+043d</entry>
		<entry>afii10079 </entry>
		<entry>cyrillic small letter en</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+043e</entry>
		<entry>afii10080 </entry>
		<entry>cyrillic small letter o</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+043f</entry>
		<entry>afii10081 </entry>
		<entry>cyrillic small letter pe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0440</entry>
		<entry>afii10082 </entry>
		<entry>cyrillic small letter er</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0441</entry>
		<entry>afii10083 </entry>
		<entry>cyrillic small letter es</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0442</entry>
		<entry>afii10084 </entry>
		<entry>cyrillic small letter te</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0443</entry>
		<entry>afii10085 </entry>
		<entry>cyrillic small letter u</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0444</entry>
		<entry>afii10086 </entry>
		<entry>cyrillic small letter ef</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0445</entry>
		<entry>afii10087 </entry>
		<entry>cyrillic small letter ha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0446</entry>
		<entry>afii10088 </entry>
		<entry>cyrillic small letter tse</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0447</entry>
		<entry>afii10089 </entry>
		<entry>cyrillic small letter che</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0448</entry>
		<entry>afii10090 </entry>
		<entry>cyrillic small letter sha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0449</entry>
		<entry>afii10091 </entry>
		<entry>cyrillic small letter shcha</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+044a</entry>
		<entry>afii10092 </entry>
		<entry>cyrillic small letter hard sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+044b</entry>
		<entry>afii10093 </entry>
		<entry>cyrillic small letter yeru</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+044c</entry>
		<entry>afii10094 </entry>
		<entry>cyrillic small letter soft sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+044d</entry>
		<entry>afii10095 </entry>
		<entry>cyrillic small letter e</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+044e</entry>
		<entry>afii10096 </entry>
		<entry>cyrillic small letter yu</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+044f</entry>
		<entry>afii10097 </entry>
		<entry>cyrillic small letter ya</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0451</entry>
		<entry>afii10071 </entry>
		<entry>cyrillic small letter io</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0452</entry>
		<entry>afii10099 </entry>
		<entry>cyrillic small letter dje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0453</entry>
		<entry>afii10100 </entry>
		<entry>cyrillic small letter gje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0454</entry>
		<entry>afii10101 </entry>
		<entry>cyrillic small letter ukrainian ie</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0455</entry>
		<entry>afii10102 </entry>
		<entry>cyrillic small letter dze</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0456</entry>
		<entry>afii10103 </entry>
		<entry>cyrillic small letter byelorussian-ukrainian i</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0457</entry>
		<entry>afii10104 </entry>
		<entry>cyrillic small letter yi</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0458</entry>
		<entry>afii10105 </entry>
		<entry>cyrillic small letter je</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0459</entry>
		<entry>afii10106 </entry>
		<entry>cyrillic small letter lje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+045a</entry>
		<entry>afii10107 </entry>
		<entry>cyrillic small letter nje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+045b</entry>
		<entry>afii10108 </entry>
		<entry>cyrillic small letter tshe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+045c</entry>
		<entry>afii10109 </entry>
		<entry>cyrillic small letter kje</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+045e</entry>
		<entry>afii10110 </entry>
		<entry>cyrillic small letter short u</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+045f</entry>
		<entry>afii10193 </entry>
		<entry>cyrillic small letter dzhe</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0490</entry>
		<entry>afii10050 </entry>
		<entry>cyrillic capital letter ghe with upturn</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+0491</entry>
		<entry>afii10098 </entry>
		<entry>cyrillic small letter ghe with upturn</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1e80</entry>
		<entry>Wgrave </entry>
		<entry>latin capital letter w with grave</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1e81</entry>
		<entry>wgrave </entry>
		<entry>latin small letter w with grave</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1e82</entry>
		<entry>Wacute </entry>
		<entry>latin capital letter w with acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1e83</entry>
		<entry>wacute </entry>
		<entry>latin small letter w with acute</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1e84</entry>
		<entry>Wdieresis </entry>
		<entry>latin capital letter w with diaeresis</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1e85</entry>
		<entry>wdieresis </entry>
		<entry>latin small letter w with diaeresis</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1ef2</entry>
		<entry>Ygrave </entry>
		<entry>latin capital letter y with grave</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+1ef3</entry>
		<entry>ygrave </entry>
		<entry>latin small letter y with grave</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2013</entry>
		<entry>endash </entry>
		<entry>en dash</entry>
		<entry>0xd0</entry>
		<entry>178</entry>
	      </row>

	      <row>
		<entry>U+2014</entry>
		<entry>emdash </entry>
		<entry>em dash</entry>
		<entry>0xd1</entry>
		<entry>179</entry>
	      </row>

	      <row>
		<entry>U+2015</entry>
		<entry>afii00208 </entry>
		<entry>horizontal bar</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2017</entry>
		<entry>underscoredbl </entry>
		<entry>double low line</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2018</entry>
		<entry>quoteleft </entry>
		<entry>left single quotation mark</entry>
		<entry>0xd4</entry>
		<entry>182</entry>
	      </row>

	      <row>
		<entry>U+2019</entry>
		<entry>quoteright </entry>
		<entry>right single quotation mark</entry>
		<entry>0xd5</entry>
		<entry>183</entry>
	      </row>

	      <row>
		<entry>U+201a</entry>
		<entry>quotesinglbase </entry>
		<entry>single low-9 quotation mark</entry>
		<entry>0xe2</entry>
		<entry>196</entry>
	      </row>

	      <row>
		<entry>U+201b</entry>
		<entry>quotereversed </entry>
		<entry>single high-reversed-9 quotation mark</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+201c</entry>
		<entry>quotedblleft </entry>
		<entry>left double quotation mark</entry>
		<entry>0xd2</entry>
		<entry>180</entry>
	      </row>

	      <row>
		<entry>U+201d</entry>
		<entry>quotedblright </entry>
		<entry>right double quotation mark</entry>
		<entry>0xd3</entry>
		<entry>181</entry>
	      </row>

	      <row>
		<entry>U+201e</entry>
		<entry>quotedblbase </entry>
		<entry>double low-9 quotation mark</entry>
		<entry>0xe3</entry>
		<entry>197</entry>
	      </row>

	      <row>
		<entry>U+2020</entry>
		<entry>dagger </entry>
		<entry>dagger</entry>
		<entry>0xa0</entry>
		<entry>130</entry>
	      </row>

	      <row>
		<entry>U+2021</entry>
		<entry>daggerdbl </entry>
		<entry>double dagger</entry>
		<entry>0xe0</entry>
		<entry>194</entry>
	      </row>

	      <row>
		<entry>U+2022</entry>
		<entry>bullet </entry>
		<entry>bullet</entry>
		<entry>0xa5</entry>
		<entry>135</entry>
	      </row>

	      <row>
		<entry>U+2026</entry>
		<entry>ellipsis </entry>
		<entry>horizontal ellipsis</entry>
		<entry>0xc9</entry>
		<entry>171</entry>
	      </row>

	      <row>
		<entry>U+2030</entry>
		<entry>perthousand </entry>
		<entry>per mille sign</entry>
		<entry>0xe4</entry>
		<entry>198</entry>
	      </row>

	      <row>
		<entry>U+2032</entry>
		<entry>minute </entry>
		<entry>prime</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2033</entry>
		<entry>second </entry>
		<entry>double prime</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2039</entry>
		<entry>guilsinglleft </entry>
		<entry>single left-pointing angle quotation mark</entry>
		<entry>0xdc</entry>
		<entry>190</entry>
	      </row>

	      <row>
		<entry>U+203a</entry>
		<entry>guilsinglright </entry>
		<entry>single right-pointing angle quotation mark</entry>
		<entry>0xdd</entry>
		<entry>191</entry>
	      </row>

	      <row>
		<entry>U+203c</entry>
		<entry>exclamdbl </entry>
		<entry>double exclamation mark</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+203e</entry>
		<entry>uni203E</entry>
		<entry>overline</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2044</entry>
		<entry>fraction </entry>
		<entry>fraction slash</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+207f</entry>
		<entry>nsuperior </entry>
		<entry>superscript latin small letter n</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+20a3</entry>
		<entry>franc </entry>
		<entry>french franc sign</entry>
		<entry></entry>
		<entry>247</entry>
	      </row>

	      <row>
		<entry>U+20a4</entry>
		<entry>lira</entry>
		<entry>l</entry>
		<entry>ira sign</entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+20a7</entry>
		<entry>peseta </entry>
		<entry>peseta sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+20ac</entry>
		<entry>Euro </entry>
		<entry>euro currency symbol</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2105</entry>
		<entry>afii61248 </entry>
		<entry>care of</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2113</entry>
		<entry>afii61289 </entry>
		<entry>script small l</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2116</entry>
		<entry>afii61352 </entry>
		<entry>numero sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2122</entry>
		<entry>trademark </entry>
		<entry>trademark sign</entry>
		<entry>0xaa</entry>
		<entry>140</entry>
	      </row>

	      <row>
		<entry>U+2126</entry>
		<entry>Omega</entry>
		<entry>ohm sign</entry>
		<entry>0xbd</entry>
		<entry>159</entry>
	      </row>

	      <row>
		<entry>U+212e</entry>
		<entry>estimated </entry>
		<entry>estimated symbol</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+215b</entry>
		<entry>oneeighth </entry>
		<entry>vulgar fraction one eighth</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+215c</entry>
		<entry>threeeighths </entry>
		<entry>vulgar fraction three eighths</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+215d</entry>
		<entry>fiveeighths </entry>
		<entry>vulgar fraction five eighths</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+215e</entry>
		<entry>seveneighths </entry>
		<entry>vulgar fraction seven eighths</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2190</entry>
		<entry>arrowleft </entry>
		<entry>leftwards arrow</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2191</entry>
		<entry>arrowup </entry>
		<entry>upwards arrow</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2192</entry>
		<entry>arrowright </entry>
		<entry>rightwards arrow</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2193</entry>
		<entry>arrowdown</entry>
		<entry>downwards arrow</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2194</entry>
		<entry>arrowboth </entry>
		<entry>left right arrow</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2195</entry>
		<entry>arrowupdn </entry>
		<entry>up down arrow</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+21a8</entry>
		<entry>arrowupdnbse<footnote id='f2'>
		    <para>This is an optional glyph</para>
		  </footnote></entry>
		<entry>up down arrow with base</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2202</entry>
		<entry>partialdiff </entry>
		<entry>partial differential</entry>
		<entry>0xb6</entry>
		<entry>152</entry>
	      </row>

	      <row>
		<entry>U+2206</entry>
		<entry>Delta </entry>
		<entry>increment</entry>
		<entry>0xc6</entry>
		<entry>168</entry>
	      </row>

	      <row>
		<entry>U+220f</entry>
		<entry>product </entry>
		<entry>n-ary product</entry>
		<entry>0xb8</entry>
		<entry>154</entry>
	      </row>

	      <row>
		<entry>U+2211</entry>
		<entry>summation </entry>
		<entry>n-ary summation</entry>
		<entry>0xb7</entry>
		<entry>153</entry>
	      </row>

	      <row>
		<entry>U+2212</entry>
		<entry>minus </entry>
		<entry>minus sign</entry>
		<entry></entry>
		<entry>239</entry>
	      </row>

	      <row>
		<entry>U+2215</entry>
		<entry>fraction<footnoteref linkend='f1'/></entry>
		<entry>division slash</entry>
		<entry>0xda</entry>
		<entry>188</entry>
	      </row>

	      <row>
		<entry>U+2219</entry>
		<entry>periodcentered<footnoteref linkend='f1'/></entry>
		<entry>bullet operator</entry>
		<entry>0xe1</entry>
		<entry>195</entry>
	      </row>

	      <row>
		<entry>U+221a</entry>
		<entry>radical </entry>
		<entry>square root</entry>
		<entry>0xc3</entry>
		<entry>165</entry>
	      </row>

	      <row>
		<entry>U+221e</entry>
		<entry>infinity </entry>
		<entry>infinity</entry>
		<entry>0xb0</entry>
		<entry>146</entry>
	      </row>

	      <row>
		<entry>U+221f</entry>
		<entry>orthogonal </entry>
		<entry>right angle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2229</entry>
		<entry>intersection </entry>
		<entry>intersection</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+222b</entry>
		<entry>integral </entry>
		<entry>integral</entry>
		<entry>0xba</entry>
		<entry>156</entry>
	      </row>

	      <row>
		<entry>U+2248</entry>
		<entry>approxequal </entry>
		<entry>almost equal to</entry>
		<entry>0xc5</entry>
		<entry>167</entry>
	      </row>

	      <row>
		<entry>U+2260</entry>
		<entry>notequal </entry>
		<entry>not equal to</entry>
		<entry>0xad</entry>
		<entry>143</entry>
	      </row>

	      <row>
		<entry>U+2261</entry>
		<entry>equivalence </entry>
		<entry>identical to</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2264</entry>
		<entry>lessequal </entry>
		<entry>less-than or equal to</entry>
		<entry>0xb2</entry>
		<entry>148</entry>
	      </row>

	      <row>
		<entry>U+2265</entry>
		<entry>greaterequal </entry>
		<entry>greater-than or equal to</entry>
		<entry>0xb3</entry>
		<entry>149</entry>
	      </row>

	      <row>
		<entry>U+2302</entry>
		<entry>house<footnoteref linkend='f2'/></entry>
		<entry>house</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2310</entry>
		<entry>revlogicalnot<footnoteref linkend='f2'/> </entry>
		<entry>reversed not sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2320</entry>
		<entry>integraltp<footnoteref linkend='f2'/></entry>
		<entry>top half integral</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2321</entry>
		<entry>integralbt<footnoteref linkend='f2'/></entry>
		<entry>bottom half integral</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2500</entry>
		<entry>SF100000 </entry>
		<entry>box drawings light horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2502</entry>
		<entry>SF110000 </entry>
		<entry>box drawings light vertical</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+250c</entry>
		<entry>SF010000 </entry>
		<entry>box drawings light down and right</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2510</entry>
		<entry>SF030000 </entry>
		<entry>box drawings light down and left</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2514</entry>
		<entry>SF020000 </entry>
		<entry>box drawings light up and right</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2518</entry>
		<entry>SF040000 </entry>
		<entry>box drawings light up and left</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+251c</entry>
		<entry>SF080000 </entry>
		<entry>box drawings light vertical and right</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2524</entry>
		<entry>SF090000 </entry>
		<entry>box drawings light vertical and left</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+252c</entry>
		<entry>SF060000 </entry>
		<entry>box drawings light down and horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2534</entry>
		<entry>SF070000 </entry>
		<entry>box drawings light up and horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+253c</entry>
		<entry>SF050000 </entry>
		<entry>box drawings light vertical and horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2550</entry>
		<entry>SF430000 </entry>
		<entry>box drawings double horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2551</entry>
		<entry>SF240000 </entry>
		<entry>box drawings double vertical</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2552</entry>
		<entry>SF510000 </entry>
		<entry>box drawings down single and right double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2553</entry>
		<entry>SF520000 </entry>
		<entry>box drawings down double and right single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2554</entry>
		<entry>SF390000 </entry>
		<entry>box drawings double down and right</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2555</entry>
		<entry>SF220000 </entry>
		<entry>box drawings down single and left double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2556</entry>
		<entry>SF210000 </entry>
		<entry>box drawings down double and left single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2557</entry>
		<entry>SF250000 </entry>
		<entry>box drawings double down and left</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2558</entry>
		<entry>SF500000 </entry>
		<entry>box drawings up single and right double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2559</entry>
		<entry>SF490000 </entry>
		<entry>box drawings up double and right single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+255a</entry>
		<entry>SF380000 </entry>
		<entry>box drawings double up and right</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+255b</entry>
		<entry>SF280000 </entry>
		<entry>box drawings up single and left double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+255c</entry>
		<entry>SF270000 </entry>
		<entry>box drawings up double and left single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+255d</entry>
		<entry>SF260000 </entry>
		<entry>box drawings double up and left</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+255e</entry>
		<entry>SF360000 </entry>
		<entry>box drawings vertical single and right double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+255f</entry>
		<entry>SF370000 </entry>
		<entry>box drawings vertical double and right single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2560</entry>
		<entry>SF420000 </entry>
		<entry>box drawings double vertical and right</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2561</entry>
		<entry>SF190000 </entry>
		<entry>box drawings vertical single and left double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2562</entry>
		<entry>SF200000 </entry>
		<entry>box drawings vertical double and left single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2563</entry>
		<entry>SF230000 </entry>
		<entry>box drawings double vertical and left</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2564</entry>
		<entry>SF470000 </entry>
		<entry>box drawings down single and horizontal double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2565</entry>
		<entry>SF480000 </entry>
		<entry>box drawings down double and horizontal single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2566</entry>
		<entry>SF410000 </entry>
		<entry>box drawings double down and horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2567</entry>
		<entry>SF450000 </entry>
		<entry>box drawings up single and horizontal double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2568</entry>
		<entry>SF460000 </entry>
		<entry>box drawings up double and horizontal single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2569</entry>
		<entry>SF400000 </entry>
		<entry>box drawings double up and horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+256a</entry>
		<entry>SF540000 </entry>
		<entry>box drawings vertical single and horizontal double</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+256b</entry>
		<entry>SF530000 </entry>
		<entry>box drawings vertical double and horizontal single</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+256c</entry>
		<entry>SF440000 </entry>
		<entry>box drawings double vertical and horizontal</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2580</entry>
		<entry>upblock<footnoteref linkend='f2'/></entry>
		<entry>upper half block</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2584</entry>
		<entry>dnblock </entry>
		<entry>lower half block</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2588</entry>
		<entry>block </entry>
		<entry>full block</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+258c</entry>
		<entry>lfblock </entry>
		<entry>left half block</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2590</entry>
		<entry>rtblock<footnoteref linkend='f2'/></entry>
		<entry>right half block</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2591</entry>
		<entry>ltshade<footnoteref linkend='f2'/></entry>
		<entry>light shade</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2592</entry>
		<entry>shade </entry>
		<entry>medium shade</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2593</entry>
		<entry>dkshade </entry>
		<entry>dark shade</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25a0</entry>
		<entry>filledbox </entry>
		<entry>black square</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25a1</entry>
		<entry>H22073 </entry>
		<entry>white square</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25aa</entry>
		<entry>H18543 </entry>
		<entry>black small square</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25ab</entry>
		<entry>H18551 </entry>
		<entry>white small square</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25ac</entry>
		<entry>filledrect<footnoteref linkend='f2'/></entry>
		<entry>black rectangle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25b2</entry>
		<entry>triagup </entry>
		<entry>black up-pointing triangle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25ba</entry>
		<entry>triagrt<footnoteref linkend='f2'/></entry>
		<entry>black right-pointing pointer</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25bc</entry>
		<entry>triagdn </entry>
		<entry>black down-pointing triangle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25c4</entry>
		<entry>triaglf<footnoteref linkend='f2'/></entry>
		<entry>black left-pointing pointer</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25ca</entry>
		<entry>lozenge </entry>
		<entry>lozenge</entry>
		<entry>0xd7</entry>
		<entry>185</entry>
	      </row>

	      <row>
		<entry>U+25cb</entry>
		<entry>circle </entry>
		<entry>white circle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25cf</entry>
		<entry>H18533 </entry>
		<entry>black circle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25d8</entry>
		<entry>invbullet<footnoteref linkend='f2'/></entry>
		<entry>inverse bullet</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25d9</entry>
		<entry>invcircle<footnoteref linkend='f2'/></entry>
		<entry>inverse white circle</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+25e6</entry>
		<entry>openbullet </entry>
		<entry>white bullet</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+263a</entry>
		<entry>smileface<footnoteref linkend='f2'/></entry>
		<entry>white smiling face</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+263b</entry>
		<entry>invsmileface<footnoteref linkend='f2'/></entry>
		<entry>black smiling face</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+263c</entry>
		<entry>sun<footnoteref linkend='f2'/></entry>
		<entry>white sun with rays</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2640</entry>
		<entry>female </entry>
		<entry>female sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2642</entry>
		<entry>male </entry>
		<entry>male sign</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2660</entry>
		<entry>spade </entry>
		<entry>black spade suit</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2663</entry>
		<entry>club </entry>
		<entry>black club suit</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2665</entry>
		<entry>heart </entry>
		<entry>black heart suit</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+2666</entry>
		<entry>diamond<footnoteref linkend='f2'/></entry>
		<entry>black diamond suit</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+266a</entry>
		<entry>musicalnote </entry>
		<entry>eighth note</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+266b</entry>
		<entry>musicalnotedbl<footnoteref linkend='f2'/></entry>
		<entry>beamed eighth notes</entry>
		<entry></entry>
		<entry></entry>
	      </row>

	      <row>
		<entry>U+f001</entry>
		<entry>fi </entry>
		<entry>fi ligature</entry>
		<entry>0xde</entry>
		<entry>192</entry>
	      </row>

	      <row>
		<entry>U+f002</entry>
		<entry>fl </entry>
		<entry>fl ligature</entry>
		<entry>0xdf</entry>
		<entry>193</entry>
	      </row>

	      <row>
		<entry>U+fb01</entry>
		<entry>fi </entry>
		<entry>fi ligature</entry>
		<entry>0xde</entry>
		<entry>192</entry>
	      </row>

	      <row>
		<entry>U+fb02</entry>
		<entry>fl </entry>
		<entry>fl ligature</entry>
		<entry>0xdf</entry>
		<entry>193</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Note about the Euro Currency Symbol</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para> The euro is the name given to the proposed single
	currency of the European Union. According to the European
	Commission the euro will exist as a currency from 1 January
	1999 but will only gradually move into general use, with the
	introduction of coins and notes in 2002.</para>

	<para>According to the information posted on the official euro
	Web site, about thirty draft designs were drawn up internally
	by the European Commission. Of these members of the general
	public assessed ten, narrowing the shortlist to two
	designs. Jacques Santer, president of the European Commission,
	and Yves-Thibault de Silguy, the European commissioner in
	charge of the euro chose the final design.</para>

	<para>The euro symbol as it appears in Courier New, Times New
	Roman and Arial. Microsoft and other vendors have chosen to
	make instances of the euro symbol font and style specific - so
	the design of the symbol takes on the characteristics of the
	font in which it resides.</para>

	<para>Traditionally numerals and currency symbols are the same
	width for any given font. This helps values line up properly
	in tabular applications like spreadsheets. To make the euro
	symbol the correct width for Arial and Times New Roman it had
	to be condensed.</para>

	<para>To access the symbol in Microsoft Word 97, a user
	selects 'Symbol..' from the 'Insert' menu. Word also lets
	users set up a keyboard shortcut to access any available
	symbol.</para>

	<para>The Unicode assignment of the euro symbol is 20AC. The
	symbol will be added to the following codepages at position
	'0x80'; 1250 Eastern European, 1252 Western, 1253 Greek, 1254
	Turkish and 1257 Baltic. In 1251 Cyrillic the symbol will be
	added at position '0x88'.</para>

	<para>For detailed information about the euro, links to what
	other people are are doing with it, please see our
	comprehensive frequently asked questions page.</para>


        <informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata fileref='neweuro.gif'/>
            </imageobject>
          </mediaobject>
        </informalfigure>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.changes'>
    <title>Changes log</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.4</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released October 11, 2002</para>

	<para>baselinetags.htm
	  <itemizedlist>
	    <listitem>
	      <para>Corrected typographic error.</para>
	    </listitem>
	    <listitem>
	      <para>Changed hanging baseline references from Hindi to
	      Tibetan.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>chapter2.htm
	  <itemizedlist>
	    <listitem>
	      <para>Corrected link to GDEF table.</para>
	    </listitem>
	    <listitem>
	      <para>Add documentation on new script tag 'DFLT'.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>cmap.htm
	  <itemizedlist>
	    <listitem>
	      <para>Add Name column to tabular data to make consistent with
		other parts of spec.</para>
	    </listitem>
	    <listitem>
	      <para>Correct description of Encoding Record.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>cvt.htm
	  <itemizedlist>
	    <listitem>
	      <para>Indicate that length must be integral value of FWORD
		units.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>default.htm
	  <itemizedlist>
	    <listitem>
	      <para>Update the version number to 1.4.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>dsig.htm
	  <itemizedlist>
	    <listitem>
	      <para>Provide information for ulVersion to be
		0x00000001.</para>
	    </listitem>
	    <listitem>
	      <para>Update to show usFlag bits that are assigned.</para>
	    </listitem>
	    <listitem>
	      <para>Add section on signatures for TrueType Collections.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>ebdt.htm
	  <itemizedlist>
	    <listitem>
	      <para>Change wording to indicate 'EBDT' is superset of
		'bdat'. These are not the same.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>featurelist.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added new features: abvf, c2pc, ljmo, nlck, pcap, pref,
		rtla, tjmo, unic, and vjmo.</para>
	    </listitem>
	    <listitem>
	      <para>Change friendly name of 'calt' from Connection Forms to
		Contextual Alternates.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>fpgm.htm
	  <itemizedlist>
	    <listitem>
	      <para>Add comment that array size n is the number of bytes in
		the table.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>gdef.htm
	  <itemizedlist>
	    <listitem>
	      <para>Example 6, typos in the comments column for increasing
		15 and 16ppem corrected.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>gpos.htm
	  <itemizedlist>
	    <listitem>
	      <para>Clarify origin of Cartesian coordinate system at
		baseline of the left side.</para>
	    </listitem>
	    <listitem>
	      <para>Specify all values are done in font unit
		measurements.</para>
	    </listitem>
	    <listitem>
	      <para>Update images for better presentation.</para>
	    </listitem>
	    <listitem>
	      <para>PairPosFormat1 subtable ValueRecord changed to
		Offset, PairSetOffset[PairSetCount].</para>
	    </listitem>
	    <listitem>
	      <para>Update wording on MarkToMark attachment.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>gsub.htm
	  <itemizedlist>
	    <listitem>
	      <para>Add Lookup Type 8, Reverse Chaining contextual single
		substitution.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>hdmx.htm
	  <itemizedlist>
	    <listitem>
	      <para>Remove references to EGA.</para>
	    </listitem>
	    <listitem>
	      <para>Add statement that bit 2 of head.flag must be set to
		1.</para>
	    </listitem>
	    <listitem>
	      <para>Add Name columns to tabular data for consistency with
		spec.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>head.htm
	  <itemizedlist>
	    <listitem>
	      <para>Updated macStyle bit descriptions for bits 2 to
		15.</para>
	    </listitem>
	    <listitem>
	      <para>unitsPerEm annotated that it should be a power of
		2.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>hhea.htm
	  <itemizedlist>
	    <listitem>
	      <para>Change FWord to FWORD for correct data type
		spelling.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>ibmfc.htm
	  <itemizedlist>
	    <listitem>
	      <para>Fix formatting to indent subclasses for better
		readability.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>name.htm
	  <itemizedlist>
	    <listitem>
	      <para>Add Name column to tabular data for consistency with
		spec.</para>
	    </listitem>
	    <listitem>
	      <para>Correct descriptions in Naming Table for count and
		nameRecord[count].</para>
	    </listitem>
	    <listitem>
	      <para>Clarified description of encoding ID 0/3. Added encoding
		ID 0/4. Changed description of encoding ID 3/10 to UTF-32.</para>
	    </listitem>
	    <listitem>
	      <para>Added description and example, for use of name ID 4 in
		CFF fonts.</para>
	    </listitem>
	    <listitem>
	      <para>Clarified working for use of name ID 5 (Version
		string).</para>
	    </listitem>
	    <listitem>
	      <para>Changed wording for name ID 16 (Preferred Family) and
		name ID 17 (Preferred Subfamily).</para>
	    </listitem>
	    <listitem>
	      <para>Suggest that style strings (name ID 2 or 17) match with
		OS/2.usWeightClass and OS/2.usWidthClass.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>os2.htm
	  <itemizedlist>
	    <listitem>
	      <para>Updated version number to 0x0003</para>
	    </listitem>
	    <listitem>
	      <para>Updated Unicode sub-range bits to be aligned with
		Unicode 3.2.</para>
	    </listitem>
	    <listitem>
	      <para>Remove weighted calculation of xAvgCharWidth.</para>
	    </listitem>
	    <listitem>
	      <para>Make fsType bits 0-3 to be mutually exclusive. In other
		words, only one of those bits may be set to "1" at a
		time. This is to avoid problems of ambiguity in what the font
		designer intends.</para>
	    </listitem>
	    <listitem>
	      <para>Change link to PANOSE specification.</para>
	    </listitem>
	    <listitem>
	      <para>Updated description of usFirstCharIndex,
		usLastCharIndex, usDefaultChar, usBreakChar; in context of
		fonts that provide surrogate character support.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>otff.htm
	  <itemizedlist>
	    <listitem>
	      <para>Update filename information for TrueType outline
		fonts.</para>
	    </listitem>
	    <listitem>
	      <para>Add data types for FWORD and UFWORD.</para>
	    </listitem>
	    <listitem>
	      <para>Corrected content and description of TTC header v1 and
		v2.</para>
	    </listitem>
	    <listitem>
	      <para>Moved VORG table to PostScript Outlines
		group.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>pclt.htm
	  <itemizedlist>
	    <listitem>
	      <para>Change to discourage use of this table.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>proposals.htm
	  <itemizedlist>
	    <listitem>
	      <para>Remove proposed feature tags that were incorporated into
		this version.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>recom.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added recommendation for first four glyphs in font.</para>
	    </listitem>
	    <listitem>
	      <para>Added recommendation for shape of .notdef
		glyph.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>scripttags.htm
	  <itemizedlist>
	    <listitem>
	      <para>Add script tags for Byzantine Music and Default.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>ttinst2.doc
	  <itemizedlist>
	    <listitem>
	      <para>Corrected description in
		Logical_Functions.Greater_Than.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>ttoreg.htm
	  <itemizedlist>
	    <listitem>
	      <para>Reworded and reorganized for better readability.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>vdmx.htm
	  <itemizedlist>
	    <listitem>
	      <para>Change ratio record and vTable record to tabular
		format.</para>
	    </listitem>
	    <listitem>
	      <para>Recommend use of version 1 vdmx.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>wgl4e.htm
	  <itemizedlist>
	    <listitem>
	      <para>Optional glyphs identified and marked. Added a
		footnote.</para>
	    </listitem>
	  </itemizedlist></para>
      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.3</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released April, 2001.</para>

	<para>Multiple Master support in OpenType, discontinued. The
	  following tables pertaining to it have been removed from this
	  version of the OpenType specification: 'fvar', 'MMSD',
	  'MMFX'.</para>

	<para>base.htm
	  <itemizedlist>
	    <listitem>
	      <para>BaseTagList Table: Added a sentence with a link to the
		baseline tags in the tags registry.</para>
	    </listitem>
	    <listitem>
	      <para>BaseCoord Format 4: removed</para>
	    </listitem>
	  </itemizedlist></para>

	<para>cff.htm
	  <itemizedlist>
	    <listitem>
	      <para>Removed references to MM fonts in the CFF and Type 2
		Charstring Format specifications. See the change log in each
		specification for additional changes made.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>chapter2.htm
	  <itemizedlist>
	    <listitem>
	      <para>Table Organisation: In paragraph 3, changed the number
		of types of GSUB and GPOS lookups. Phrase added to Paragraph 4
		to exclude the Extension lookup.</para>
	    </listitem>
	    <listitem>
	      <para>LookupFlag bit enumeration: Name of the first bit
		reverted back to RightToLeft. Provided newer description of
		its use.</para>
	    </listitem>
	    <listitem>
	      <para>Coverage Table: added to exclude the Extension
		lookup.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>cmap.htm
	  <itemizedlist>
	    <listitem>
	      <para>Merged paragraph 3 and 4 in the introduction section.</para>
	    </listitem>
	    <listitem>
	      <para>Added notes that fonts for Windows that support UCS-4
		characters (surrogates), need to use an encoding ID 10 and
		format 12.</para>
	    </listitem>
	    <listitem>
	      <para>The version field has been renamed as 'language', to
		align it with Apple's TT spec. Added a note to clarify the use
		of this field.</para>
	    </listitem>
	    <listitem>
	      <para>Added information that platform ID 3, encoding ID 7,8
		and 9 are reserved.</para>
	    </listitem>
	    <listitem>
	      <para>Added platform ID 3, encoding ID 10.</para>
	    </listitem>
	    <listitem>
	      <para>Swapped the description of encoding ID 3 and 4. They
		were incorrectly mapped to Big5 and PRC respectively, in
		earlier versions of the specification.</para>
	    </listitem>
	    <listitem>
	      <para>Added a note on OTF Windows compatibility mapping.</para>
	    </listitem>
	    <listitem>
	      <para>Formats 2, 4, 6. Made the description of the 'length'
		field in these formats consistent with the rest of the
		formats.</para>
	    </listitem>
	    <listitem>
	      <para>Format 2: Removed the duplicate entry for subHeaders[
		].</para>
	    </listitem>
	    <listitem>
	      <para>Format 4: Corrected 'endCode' and 'startCode' values in
		the example for this format.</para>
	    </listitem>
	    <listitem>
	      <para>Supporting 4-byte character codes (Formats 8, 10, 12):
		Added these new formats.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>ebdt.htm
	  <itemizedlist>
	    <listitem>
	      <para>minor typo in the name of ebdtComponent corrected.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>feattags.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added features 'ccmp', 'fin2', 'fin3', med2' and
		'rlig'.</para>
	    </listitem>
	    <listitem>
	      <para>Clarified the Feature Interaction sections for 'kern',
		'vkrn'.</para>
	    </listitem>
	    <listitem>
	      <para>UB lookup type to be used, in the Recommended
		implementation section of 'ordn'.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>fvar.htm: This table removed.</para>

	<para>gdef.htm
	  <itemizedlist>
	    <listitem>
	      <para>Introduction: Added information on the
		MarkAttachClassDef field.</para>
	    </listitem>
	    <listitem>
	      <para>Overview: Updated image to contain MarkAttachClassDef.</para>
	    </listitem>
	    <listitem>
	      <para>GDEF Header: Added missing information on the
		MarkAttachClassDef field.</para>
	    </listitem>
	    <listitem>
	      <para>GDEF Header Table: Added the note that offsets might be
		null for the GlyphClassDef, AttachList, LigCaretList,
		MarkAttachClassDef</para>
	    </listitem>
	    <listitem>
	      <para>GlyphClassDef Enumeration List: An explanatory note
		added for definition of ligatures and component glyphs.</para>
	    </listitem>
	    <listitem>
	      <para>Mark Attachment Class Definition Table: An explanatory
		section and example 7 added.</para>
	    </listitem>
	    <listitem>
	      <para>CaretValue: Format 4: This format used by MM fonts
		removed.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>gpos.htm
	  <itemizedlist>
	    <listitem>
	      <para>Corrected the link "Common Table Formats" to read
		"OpenType Common Table Formats"; throughout table.</para>
	    </listitem>
	    <listitem>
	      <para>Table Organization: Updated the image. Added links for
		all lookup types. Added Extension positioning as LookupType 9,
		types 10+ are now Reserved.</para>
	    </listitem>
	    <listitem>
	      <para>PairPosFormat1 subtable: PairSet field corrected to
		specify it as an array of Offsets.</para>
	    </listitem>
	    <listitem>
	      <para>Lookup Type 6: Sentence added to clarify input context
		for MarkToBase, MarkToLigature and MarkToMark positioning
		tables.</para>
	    </listitem>
	    <listitem>
	      <para>LookupType 9: Extension Positioning: This new lookup
		type added.</para>
	    </listitem>
	    <listitem>
	      <para>ValueRecord table: Removed XIdPlacement, YIdPlacement,
		XIdAdvance, YIdAdvance and the sentence following the
		table.</para>
	    </listitem>
	    <listitem>
	      <para>ValueFormat bit enumeration: Removed XIdPlacement,
		YIdPlacement, XIdAdvance, YIdAdvance and the sentence
		following the table.</para>
	    </listitem>
	    <listitem>
	      <para>Anchor Table: Format 4: This format used by MM
		fonts removed</para>
	    </listitem>
	  </itemizedlist></para>

	<para>gsub.htm
	  <itemizedlist>
	    <listitem>
	      <para>Corrected the link "Common Table Formats" to read
		"OpenType Common Table Formats"; throughout table.</para>
	    </listitem>
	    <listitem>
	      <para>Substituting Glyphs with OpenType: Types of lookups
		corrected to six. Added an explanation to the ligature
		substitution section, to clarify the location occupied by a
		ligature glyph when it replaces a sequence of glyphs. Missing
		paragraph on Chaining contextual substitution added.</para>
	    </listitem>
	    <listitem>
	      <para>Table Organization: Updated image.</para>
	    </listitem>
	    <listitem>
	      <para>LookupType Enumeration table for glyph substitution:
		Added links for all lookup types. Added Extension Substitution
		as the 7th lookup type. This hence classifies types 8+ as
		Reserved.</para>
	    </listitem>
	    <listitem>
	      <para>LookupType 2:: Prohibited the deletion of an input
		glyph, and added that GlyphCount should always be greater than
		0.</para>
	    </listitem>
	    <listitem>
	      <para>Chaining Context Substitution Format 1: Simple Chaining
		Context Glyph Substitution: Added that the match for the
		string 'backtrack sequence + input sequence + lookahead
		sequence' takes place in the simplest of cases; and that
		lookup flag values affect backtrack/lookahead sequences. Since
		the input sequence includes the covered glyph, removed
		"covered glyph" from the above string.</para>
	    </listitem>
	    <listitem>
	      <para>LookupType 7: Extension Substitution: This new lookup
		type added.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>head.htm
	  <itemizedlist>
	    <listitem>
	      <para>table: Clarified description for bit 1, 5-10. Added
		specification for bit 13.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>hhea.htm
	  <itemizedlist>
	    <listitem>
	      <para>table: Added a footnote for the fields Ascender,
		Descender and LineGap.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>hmtx.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added a note that the advanceWidth for each glyph in CFF
		OpenType fonts must match its x width in the CFF table.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>loca.htm
	  <itemizedlist>
	    <listitem>
	      <para>Corrected minor typo.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>maxp.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added a note to indicate the difference in representing the
		fractional part of a version number when it is non-zero.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>mmfx.htm: This table removed.</para>

	<para>mmsd.htm: This table removed.</para>

	<para>name.htm
	  <itemizedlist>
	    <listitem>
	      <para>Minor rewording of text done in the introduction section
		related to fonts for the Macintosh.</para>
	    </listitem>
	    <listitem>
	      <para>Platform ID, specific encoding ID and languageId
		information combined into one table.</para>
	    </listitem>
	    <listitem>
	      <para>Unicode platform-specific encoding IDs (platform ID =
		0): This new table added.</para>
	    </listitem>
	    <listitem>
	      <para>Microsoft platform-specific encoding IDs: This table
		replaced with a more comprehensive table from the
		cmap.htm.</para>
	    </listitem>
	    <listitem>
	      <para>Mac platform-specific encoding IDs: Clarified IDs 2 and
		25. Corrected typo in ID 32.</para>
	    </listitem>
	    <listitem>
	      <para>Mac language IDs: Newer IDs added 23-150.</para>
	    </listitem>
	    <listitem>
	      <para>ISO specific encodings (platform ID=2): Marked as
		deprecated. Minor typo in the sentence below the table
		corrected.</para>
	    </listitem>
	    <listitem>
	      <para>Custom platform-specific encoding IDs (platform ID = 4):
		Newer platform ID added.</para>
	    </listitem>
	    <listitem>
	      <para>Name IDs: Added newer description for nameID 5. Added
		nameID 19 and 20.</para>
	    </listitem>
	    <listitem>
	      <para>Examples: Added example for nameID 19.</para>
	    </listitem>
	    <listitem>
	      <para>LCID-CP list: Updated this list.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>os2.htm
	  <itemizedlist>
	    <listitem>
	      <para>xAvgCharWidth.description: Comments for this field
		updated.</para>
	    </listitem>
	    <listitem>
	      <para>fsType.table: Added Bit Mask and description details for
		the case when no bit is set; added Bit Mask value
		0x0001.</para>
	    </listitem>
	    <listitem>
	      <para>fsType.comments: Information on setting Bit Masks
		consolidated into the description column of the table. Removed
		the redundant section below the table.</para>
	    </listitem>
	    <listitem>
	      <para>yStrikeoutPosition.description: Added that this is the
		distance of the top of the strikeout stroke.</para>
	    </listitem>
	    <listitem>
	      <para>panose.description: Removed dead url for the PANOSE
		evaluation document, added that the "greybook" reference could
		be used instead.</para>
	    </listitem>
	    <listitem>
	      <para>ulUnicodeRange.table: Updated the Unicode standard
		version number to 3.0 in the description for these
		fields. Added bits 70- 127. Added a footnote for setting bit
		57 (Surrogates).</para>
	    </listitem>
	    <listitem>
	      <para>usFirstCharIndex.description: Minor correction-- added
		the word platform specific.</para>
	    </listitem>
	    <listitem>
	      <para>sTypoAscender and sTypodescender: Minor corrections
		done; "design space" now referred to as "ideo em box" in the
		descriptions; added a links to recom.htm for these fields.</para>
	    </listitem>
	    <listitem>
	      <para>usWinAscent: Explanatory note added to explain the
		circumstances in which clipping will take place.</para>
	    </listitem>
	    <listitem>
	      <para>usWinDescent: Explanatory note added to explain the
		circumstances in which clipping will take place.</para>
	    </listitem>
	    <listitem>
	      <para>sxHeight: Added a note that this metric can be used in
		font substitution.</para>
	    </listitem>
	    <listitem>
	      <para>usDefaultChar: that for a given font, missing glyphs
		will be displayed using the content of glyph 0 in the selected
		font.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>otff.htm
	  <itemizedlist>
	    <listitem>
	      <para>Version Numbers: Added explanation that representation
		of a non-zero fractional part in version numbers, differs from
		the representation of the matissa.</para>
	    </listitem>
	    <listitem>
	      <para>Tables Related to PostScript Outlines:
		Removed links and description details for the fvar, MMSD and
		MMFX tables.</para>
	    </listitem>
	    <listitem>
	      <para>Advanced Typographic Tables: Added a link to OpenType
		Layout Common Table Formats.</para>
	    </listitem>
	    <listitem>
	      <para>Other OpenType Tables: the VORG table name to the
	      list.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>otover.htm: Related documentation: Removed sections in the
	  description related to MM fonts.</para>

	<para>post.htm
	  <itemizedlist>
	    <listitem>
	      <para>table.version.description: Added versions 2.5 and 3.0</para>
	    </listitem>
	    <listitem>
	      <para>table.underlinePosition.description: PostScript
		information added.</para>
	    </listitem>
	    <listitem>
	      <para>version2.0: Updated name and description details in the
		table contents</para>
	    </listitem>
	    <listitem>
	      <para>version2.5: Updated table contents, added that this
		version has been deprecated.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>recom.htm
	  <itemizedlist>
	    <listitem>
	      <para><ottable>BASE</ottable> Table: This section added.</para>
	    </listitem>
	    <listitem>
	      <para><ottable>cmap</ottable> table: Added details on
		requirements that need to be satisfied by surrogate
		fonts on Windows.</para>
	    </listitem>
	    <listitem>
	      <para><ottable>head</ottable> Table: Added details
		regarding usage of the fontRevision value.</para>
	    </listitem>
	    <listitem>
	      <para><ottable>hhead</ottable> Table: Removed sentence
		which incorrectly stated that OpenType fonts that
		include CFF data must set numberOfHMetrics equal to
		the number of glyphs in the font.</para>
	    </listitem>
	    <listitem>
	      <para><ottable>post</ottable> Table: Updated content
		related to glyph names in the post table.</para>
	    </listitem>
	    <listitem>
	      <para>'os/2' Table: Added section on sTypoAscender,
		sTypoDescender, sTypoLineGap.</para>
	    </listitem>
	    <listitem>
	      <para>General Recommendations: Updated the table
		ordering list for OpenType fonts containing CFF data
		by adding the <ottable>maxp</ottable> table; and,
		removing the 'fvar' and 'MMSD' tables.</para>
	    </listitem>
	    <listitem>
	      <para>Baseline to Baseline Distances: Added a paragraph on the
		recommended use of sTypoAscender, sTypoDescender, and
		sTypoLineGap.</para>
	    </listitem>
	    <listitem>
	      <para>OpenType CJK Font Guidelines: This new section
		added.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>ttochap1.htm
	  <itemizedlist>
	    <listitem>
	      <para>Introduction: Removed 'MMSD' reference. Expanded the
		brief description of the content of Registered OpenType Layout
		Tags to reflect all OpenType tags: scripts, languages,
		baselines, features.</para>
	    </listitem>
	    <listitem>
	      <para>How Multiple Master OpenType Fonts Use OpenType Layout
		Tables: This section removed.</para>
	    </listitem>
	  </itemizedlist></para>


	<para>ttoreg.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added links in the introduction section, to help jump to
		the script, language, baseline and feature tag sections.</para>
	    </listitem>
	    <listitem>
	      <para>Script tags: Corrected script tag length
		description. Added newer script tags.</para>
	    </listitem>
	    <listitem>
	      <para>Language system tags: Added newer language tags.</para>
	    </listitem>
	    <listitem>
	      <para>Baseline tags: Added newer baseline tags: "icfb", "icft"
		and "idtp". Expanded the description of existing tags into two
		categories:"Baseline for HorizAxis" and "Baseline for
		VertAxis".</para>
	    </listitem>
	    <listitem>
	      <para>Ideographic Em-Box: This new section added.</para>
	    </listitem>
	    <listitem>
	      <para>Ideographic Character Face: This new section added.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>vhea.htm
	  <itemizedlist>
	    <listitem>
	      <para>Introduction: Added a link each for the vmtx table and
		the CJK guidelines section.</para>
	    </listitem>
	    <listitem>
	      <para>table.version.description: Version number increased to
		1.1. Added a note to indicate the difference in representing
		the fractional part of a version number when it is
		non-zero.</para>
	    </listitem>
	    <listitem>
	      <para>table.ascent: Replaced by vertTypoAscender.</para>
	    </listitem>
	    <listitem>
	      <para>table.descent: Replaced by vertTypoDescender.</para>
	    </listitem>
	    <listitem>
	      <para>table.lineGap: Replaced by vertTypoLineGap.</para>
	    </listitem>
	    <listitem>
	      <para>Vertical Header Table Example: Changed version value to
		1.1. Corrected the name for vertTypoLineGap</para>
	    </listitem>
	  </itemizedlist></para>

	<para>vmtx.htm
	  <itemizedlist>
	    <listitem>
	      <para>Introduction: Added a link for accessing the CJK
		guidelines section.</para>
	    </listitem>
	    <listitem>
	      <para>Vertical Origin and Advance Height: This new section
		added.</para>
	    </listitem>
	    <listitem>
	      <para>Vertical Metrics Table Format: Added a note on the
		calculating the top side bearing.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>vorg.htm
	  <itemizedlist>
	    <listitem>
	      <para>This new table added. This is needed by CFF OpenType
		fonts to locate the origin of vertical glyphs.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>wgl4d.htm
	  <itemizedlist>
	    <listitem>
	      <para>Added a missing asterisk for PostScriptName.macron</para>
	    </listitem>
	    <listitem>
	      <para>Added the U+02dc (tilde)-- was missing from the list.</para>
	    </listitem>
	  </itemizedlist></para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.25</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released July, 2000</para>

	<para>feattags.htm (Feature Tags)
	  <itemizedlist>
	    <listitem>
	      <para>Features added: abvm (Above-base Mark Positioning); abvs
		(Above-base Substitutions); akhn (Akhand); blwf (Below-base
		Forms); blws (Below-base Substitutions); clig (Contextual
		Ligatures); cswh (Contextual Swash); curs (Cursive
		Positioning); dist (Distances); falt (Final Glyph on Line
		Alternates); half (Half Forms); haln (Halant Forms); hkna
		(Horizontal Kana Alternates); isol (Isolated Forms); jalt
		(Justification Alternates); locl (Localized Forms) (replaces
		jajp, kokr, vivn, zhch, and zhtw); mkmk (Mark to Mark
		Positioning); nukt (Nukta Forms); pres (Pre-base
		substitutions); pstf (Post-base Forms); psts (Post-base
		Substitutions); rphf (Reph Forms); ruby (Ruby Notation Forms);
		size (Optical Size); vatu (Vattu Variants); vhal (Alternate
		Vertical Half Metrics); vkna (Vertical Kana Alternates); vkrn
		(Vertical Kerning) vpal (Proportional Alternate Vertical
		Metrics).</para>
	    </listitem>
	    <listitem>
	      <para>Features removed: crcy (Currency), dpng (Diphthongs), jajp
		(Japanese Forms), kokr (Korean Forms), vivn (Vietnamese
		Forms), zhcn (Simplified Chinese Forms), zhtw (Traditional
		Chinese Forms).</para>
	    </listitem>
	    <listitem>
	      <para>Features modified: aalt: Added ordering suggestion, reworked
		user interface suggestions, clarified implementation
		recommendation, feature interaction and function. altv:
		changed tag to valt. c2sc, dlig: Clarified function, example
		and feature interaction. calt, case, dnom, expt, halt, hist,
		hwid, jp78, jp83, jp90, kern, lfbd, liga, lnum, numr, onum,
		pwid, qwid, rtbd, smpl, sups, titl, twid, valt: Clarified
		feature interaction. fina, init, medi, rand, salt, swsh:
		Clarified user interface suggestion and feature
		interaction. frac: Added numr and dnom extensions, clarified
		feature interaction. fwid, palt: Clarified feature
		interaction and function. hngl: Clarified feature
		interaction and implementation recommendation. ital:
		Clarified function and feature interaction. mark: Added
		example, application interface, user interface suggestion,
		script sensitivity, feature interaction. Modified
		recommended implementation. mset: Added example. nalt:
		Clarified user interface suggestion, implementation
		recommendation and feature interaction. opbd: Added lfbd and
		rtbd extensions; clarified user interface suggestion and
		feature interaction. ordn: Clarified script sensitivity,
		corrected lookup type, clarified implementation
		recommendation and feature interaction. ornm: Clarified user
		interface suggestion, implementation recommendation, feature
		interaction and function description. smcp: Added note about
		dotlessi; clarified function and feature interaction. trad:
		corrected terminology (hanzi, not hanja), clarified user
		interface suggestion and implementation
		recommendation. vert: Clarified feature interaction and
		added ordering recommendation; extended application
		interface notes. vrt2: Changed 'friendly' name, clarified
		feature interaction and added ordering recommendation; added
		ATM/OTF driver information and descriptions of how to
		construct the rotated glyphs in the Function section. zero:
		Clarified user interface suggestion.</para>
	    </listitem>
	    <listitem>
	      <para>Features relocated: mark and mset have been moved from
		the Metric Behaviors category, to the Other Substitutions
		category for consistency in classification.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>chapter2.htm
	  <itemizedlist>
	    <listitem>
	      <para>modified description of FeatureParams field for a
		non-null offset (the size feature uses it).</para>
	    </listitem>
	  </itemizedlist></para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.2</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released November, 1998</para>

	<para>Data type notation and spelling corrected
	throughout</para>

	<para>base.htm - added BaseCoord Table Format 4</para>

	<para>chapter2.htm - corrected example 3; refined description
	of next glyph; reserved RightToLeft lookup flag; corrected
	descriptions of LookupFlag bits</para>

	<para>cmap.htm - removed legacy encodings</para>

	<para>dsig.htm - updated field names and format of signature
	  record; added step to creation of content digest</para>

	<para>feattags.htm - registered new features crcy, dnom, jajp,
	  kokr, lfbd, numr, rtbd, vivn, vrt2, zhcn, zhtw; removed
	  features trak, vrot; edited and clarified descriptions of
	  features afrc, altv, c2sc, calt, case, cpsp, dlig, dpng,
	  expt, fina, frac, fwid, halt, hlig, lngl, hwid, init, ital,
	  jp78, jp90, kern, lnum, medi, mgrk, onum, opbd, ordn, ornm,
	  palt, pnum, pwid, qwid, smcp, smpl, sups, tnam, tnum, trad,
	  twid, vert</para>

	<para>gdef.htm - added MarkAttachClassDef to header, and
	  MarkAttachmentType bit setting to LookupFlag bits; added
	  CaretValue Table Format 4</para>

	<para>glyf.htm - added table detailing component record
	  structure</para>

	<para>gsub.htm - added format 6, for chaining contextual
	  substitution; general editing</para>

	<para>gpos.htm - added format 8, for chaining contextual
	  positioning; clarified pair positioning operations;
	  corrected Example 10; clarified coordinate system
	  description; refined description of when a lookup is
	  finished; added AnchorTable Format 4; general editing</para>

	<para>head.htm - added note about fontRevision field;
	  clarified description of compression flag</para>

	<para>hhea.htm - corrected description of
	numberOfHMetrics</para>

	<para>mmfx.htm - corrections throughout; added
	MMFXIdZero</para>

	<para>name.htm - general editing</para>

	<para>os2.htm - renamed usMaxLookup to usMaxContext; edited
	  descriptions of defaultChar and breakChar; updated
	  registered vendors</para>

	<para>otff.htm - general editing; added ulDsigTag and related
	  fields to TTC header; added datatypes LONGDATETIME;
	  clarified checksum calculations; added tag name
	  restrictions; clarified use of version numbers</para>

	<para>post.htm - renamed FormatType to Version</para>

	<para>vhea.htm - replaced mention of centerline with vertical
	  baseline; corrected description of
	  numOfLongVerMetrics</para>

	<para>CFF.pdf and Type2.pdf updated (December 1998)</para>

	<para>Several PostScript glyph names corrected in the WGL
	  tables (18 December 1998)</para>

	<para>name.htm - Descriptions of name ID 13 and 14 corrected
	  (29 January 1999)</para>

	<para>mmsd.htm - Attribute flags corrected (29 January
	  1999)</para>

	<para>head.htm - Data type of xMin corrected (29 January
	  1999)</para>


      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.1</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released April, 1999</para>

	<para>CFF and Type2 specs updated</para>

	<para>chapter2.htm - corrected typo in figure 2d
	(fig2d.gif)</para>

	<para>dsig.htm - added info about location of DSIG table;
	  added list of sfnt structural requirements</para>

	<para>feattags.htm - created more comprehensive list and
	  description of layout feature tags</para>

	<para>gpos.htm - corrected illustration 4f (fig4f.gif)</para>

	<para>head.htm - added bit 12 (converted) to flags
	field</para>

	<para>hhea.htm - removed CFF restriction listed in
	  numberOfHMetrics field; added caretOffset field.</para>

	<para>maxp.htm - added version 0.5 table (numGlyphs field);
	  general editing</para>

	<para>name.htm - added name id's 16, 17, and 18; corrected
	  name id example</para>

	<para>os2.htm - added new version (2), adding new fields
	  sxHeight, sCapHeight, usDefaultChar, usBreakChar,
	  usMaxLookup; clarified sTypoAscender and sTypoDescender
	  fields; changed some Unicode range values to reflect Unicode
	  2; updated registered vendors</para>

	<para>otff.htm - general editing; added description of two
	  types of TTC headers, and DSIG table location</para>

	<para>recom.htm - general editing</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.01</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released October, 1997</para>

	<para>mmfx.htm, fvar.htm, mmsd.htm, otover.htm, recom.htm -
	  edits throughout</para>

	<para>loca.htm - changed long-aligned to word-aligned for
	  local offsets</para>

	<para>wgl4.htm - added reference to Euro symbol</para>

	<para>dsig.htm - added note about system use of dsig table to
	  distinguish OT from TT fonts</para>

	<para>ttoreg.htm - added VIT, TRK, and ROM lang sys
	  tags</para>

	<para>otff.htm - rearranged table list</para>

	<para>base.htm - change to basecoordformat3 data type</para>

	<para>gpos.htm - pairposformat1 subtable valuerecord becomes
	  offset</para>

	<para>kern.htm - gpos clarification</para>

	<para>name.htm - added name id's 13 and 14</para>

	<para>ltsh.htm - clarified option for fixed-pitch fonts</para>

	<para>dmx.htm - version 1 added to vdmx table</para>

	<para>os2.htm - added codepage range 8 for Vietnamese; added
	  new vendor id's, including UNKN</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Version 1.0</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>Released April, 1997</para>

      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.discussion_forum'>
    <title>OpenType discussion forum</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role='specification'>
        <title>Specification</title>

	<para>An e-mail based discussion forum has been set up
	  specifically to help people working on the development of
	  OpenType fonts and associated technologies.</para>

	<itemizedlist>
	  <listitem>
	    <para>To subscribe to the OpenType Mailing List, send
	      e-mail to: opentype-subscribe@topica.com</para>
	  </listitem>
	  <listitem>
	    <para>To post a message to the list, send e-mail to:
	    opentype@topica.com</para>
	  </listitem>
	  <listitem>
	    <para>To remove yourself from this mailing list, send
	    e-mail to: opentype-unsubscribe@topica.com</para>
	  </listitem>
	  <listitem>
	    <para>To get a list of archives available, browse to:
	    http://topica.com/lists/opentype/read</para>
	  </listitem>
	  <listitem>
	    <para>For more help with mailing list commands, browse to:
	    http://topica.com/lists/opentype/</para>
	  </listitem>
	</itemizedlist>

	<para>Please note that if you join the forum your e-mail
	  address will be accessible to the other subscribers.</para>
      </section>
    </section>
  </section>

  <!--************************************************************************-->
  <section id='chapter.misc'>
    <title>Misc</title>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Code to sort out</title>

      <!--____________________________________________________________________-->
      <section role='implementation'>
        <title>Implementation</title>


      <para>The SAX2 <varname>ContentHandler</varname> class provides
        a minimal interface  between SAX players. This makes it
        possible to connect minimal implementations. The downside is
        that applications that generate events out of the blue (by
        opposition to parsers) have a fair amount of work.</para>

      <para>The <varname>ContentHandlerPlus</varname> class makes
        this situation more tolerable by extending the
        <varname>ContentHandler</varname> interface. For example, the
        <varname>element</varname> method is a shorthand for the
        combination of <varname>startElement</varname> and
        <varname>endElement</varname>.</para>

      <para>Since this class is fairly straightforward, we are just
        going to give it in bulk:</para>

<code-fragment package='com.adobe.aots.util' class='ContentHandlerPlus' >
  <code-title>StyleSheet</code-title>
package com.adobe.aots.util;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;

import org.xml.sax.SAXException;
import org.xml.sax.Attributes;


public class ContentHandlerPlus implements org.xml.sax.ContentHandler {

  protected ContentHandler base;

  protected Attributes nullAtts = new org.xml.sax.helpers.AttributesImpl ();

  public ContentHandlerPlus (ContentHandler base) {
    this.base = base;
  }

  public void setDocumentLocator (Locator locator) {
    base.setDocumentLocator (locator);
  }

  public void startDocument ()
      throws SAXException {
    base.startDocument ();
  }

  public void endDocument()
      throws SAXException {
    base.endDocument ();
  }

  public void startPrefixMapping (String prefix, String uri)
      throws SAXException {
    base.startPrefixMapping (prefix, uri);
  }

  public void endPrefixMapping (String prefix)
      throws SAXException {
    base.endPrefixMapping (prefix);
  }

  public void startElement (String namespaceURI, String localName,
                            String qName, Attributes atts)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, atts);
  }

  public void startElement (String namespaceURI, String localName,
                            String qName)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, nullAtts);
  }

  public void startElement (String localName, Attributes atts)
      throws SAXException {
    base.startElement ("", localName, localName, atts);
  }

  public void startElement (String localName)
      throws SAXException {
    base.startElement ("", localName, localName, nullAtts);
  }

  public void endElement (String namespaceURI, String localName,
                          String qName)
      throws SAXException {
    base.endElement (namespaceURI, localName, qName);
  }

  public void endElement (String localName)
      throws SAXException {
    base.endElement ("", localName, localName);
  }

  public void element (String namespaceURI, String localName,
                       String qName, Attributes atts)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, atts);
    base.endElement (namespaceURI, localName, qName);
  }

  public void element (String namespaceURI, String localName,
                       String qName)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, nullAtts);
    base.endElement (namespaceURI, localName, qName);
  }

  public void element (String localName, Attributes atts)
      throws SAXException {
    startElement (localName, atts);
    endElement (localName);
  }

  public void element (String localName)
      throws SAXException {
    startElement (localName);
    endElement (localName);
  }

  public void element (String localName, String content)
      throws SAXException {
    startElement (localName);
    characters (content);
    endElement (localName);
  }

  public void characters (char ch[], int start, int length)
      throws SAXException {
    base.characters (ch, start, length);
  }

  public void characters (String s)
      throws SAXException {
    char[] ch = s.toCharArray ();
    base.characters (ch, 0, ch.length);
  }

  public void ignorableWhitespace (char ch[], int start, int length)
      throws SAXException {
    base.ignorableWhitespace (ch, start, length);
  }

  public void processingInstruction (String target, String data)
      throws SAXException {
    base.processingInstruction (target, data);
  }

  public void skippedEntity (String name)
      throws SAXException {
    base.skippedEntity (name);
  }
}
</code-fragment>



<code-fragment id='test_imports'>
  <code-title>Imports for test methods</code-title>

  import java.io.File;
  import java.net.URL;
  import java.text.BreakIterator;
</code-fragment>

<code-fragment id='test_methods'>
  <code-title>Methods for testing</code-title>
  static int[] parseIntList (String s) {
    int i;
    int len = s.length ();
    int count = 0;

    i = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; (s.charAt (i) == ' ' || s.charAt (i) == ',')) {
        i++; }
      if (i == len) {
        break; }
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ' &amp;&amp; s.charAt (i) != ',') {
        i++; }
      count++; }

    int[] list = new int [count];

    i = 0;
    count = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; (s.charAt (i) == ' ' || s.charAt (i) == ',')) {
        i++; }
      if (i == len) {
        break; }
      int start = i;
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ' &amp;&amp; s.charAt (i) != ',') {
        i++; }
      int radix = 10;
      if (   i - start >= 2
          &amp;&amp; s.charAt (start) == '0'
          &amp;&amp; s.charAt (start+1) == 'x') {
        start += 2;
        radix = 16; }
      list [count] = Integer.parseInt (s.substring (start, i), radix);
      count++; }

    return list;
  }

  static void printIntList (int [] ints) {
    for (int i = 0; i &lt; ints.length; i++) {
      System.out.print (" " + ints [i]); }
    System.out.println ("");
  }

  static boolean compareIntLists (int[] expected, int[] outputs) {
    return compareIntLists (expected, outputs, outputs.length);
  }

  static boolean compareIntLists (int[] expected, int[] outputs,
                                  int outputLength ) {
    boolean pass = true;

    if (outputLength != expected.length) {
      pass = false; }
    else {
      for (int i = 0; i &lt; expected.length; i++) {
        if (outputs [i] != expected [i]) {
          pass = false;
          break; }}}

    return pass;
  }

  static void reportStatus (String test, boolean pass) {
    if (pass) {
      System.out.println ("----- TEST " + test + " PASS"); }
    else {
      System.out.println ("***** TEST " + test + " FAIL"); }
  }
</code-fragment>


<code-fragment package='com.adobe.aots.opentype' class='InvalidFontException'>
  <code-title>Invalid Font Exception</code-title>
  package com.adobe.aots.opentype;

  public class InvalidFontException extends Exception {

    static final long serialVersionUID = 44839L;

    public InvalidFontException () {
      super ();
    }

    public InvalidFontException (String s) {
      super (s);
    }
  }
</code-fragment>

<code-fragment package='com.adobe.aots.opentype' class='UnsupportedFontException'>
  <code-title>Unsupported Font Exception</code-title>
  package com.adobe.aots.opentype;

  public class UnsupportedFontException extends Exception {

    static final long serialVersionUID = 44888L;

    public UnsupportedFontException () {
      super ();
    }

    public UnsupportedFontException (String s) {
      super (s);
    }
  }
</code-fragment>


<code-fragment package='com.adobe.aots.opentype' class='Font'>
  <code-title>Font class</code-title>
package com.adobe.aots.opentype;

import java.util.Iterator;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;


import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Element;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Font {
  public Header header = null;
  public Head head = null;
  public Name name = null;
  public Cmap cmap = null;
  public Hhea hhea = null;
  public Hdmx hdmx = null;
  public Hmtx hmtx = null;
  public Vhea vhea = null;
  public Vmtx vmtx = null;
  public Base base = null;
  public Gdef gdef = null;
  public Gsub gsub = null;
  public Gpos gpos = null;
  public OS2  os2  = null;
  public Post post = null;
  public Maxp maxp = null;
  public CFF  cff  = null;
  public Dsig dsig = null;
  public Glyf glyf = null;
  public Loca loca = null;
  public Table cvt = null;
  public Table prep = null;
  public Table fpgm = null;
  public Vorg vorg = null;
  public Vdmx vdmx = null;

  public java.util.SortedMap&lt;Long, Table> tables
  = new java.util.TreeMap&lt;Long, Table> ();

  <code-include linkend='font.methods'/>

  public void fromBinary (URL src)
    throws IOException, InvalidFontException {

    fromBinary (src.openStream ());
  }

  public void fromBinary (URL src, int ttcIndex)
    throws IOException, InvalidFontException {

    fromBinary (src.openStream (), ttcIndex);
  }

  public void fromBinary (InputStream in)
      throws IOException, InvalidFontException {

    fromBinary (in, -1);
  }

  public void fromBinary (InputStream in, int ttcIndex)
      throws IOException, InvalidFontException {

    try {
      int curOffset = 0;

      Header header = new Header (this);

      if (ttcIndex == -1) {
        curOffset += header.fromBinary (in); }
      else {
        curOffset += header.fromTTCBinary (in, ttcIndex); }

      for (Iterator it = header.tablesByOffset (); it.hasNext ();) {
        Header.TableDesc td = (Header.TableDesc) it.next ();

        while (curOffset != td.offset) {
          curOffset += in.skip (td.offset - curOffset); }

        Table t = null;

             if (td.tag == Tag.name) { t = name = new Name (this); }
        else if (td.tag == Tag.cmap) { t = cmap = new Cmap (this); }
        else if (td.tag == Tag.head) { t = head = new Head (this); }
        else if (td.tag == Tag.hhea) { t = hhea = new Hhea (this); }
        else if (td.tag == Tag.hdmx) { t = hdmx = new Hdmx (this); }
        else if (td.tag == Tag.hmtx) { t = hmtx = new Hmtx (this); }
        else if (td.tag == Tag.vhea) { t = vhea = new Vhea (this); }
        else if (td.tag == Tag.vmtx) { t = vmtx = new Vmtx (this); }
        else if (td.tag == Tag.os2 ) { t = os2  = new OS2  (this); }
        else if (td.tag == Tag.post) { t = post = new Post (this); }
        else if (td.tag == Tag.maxp) { t = maxp = new Maxp (this); }
        else if (td.tag == Tag.loca) { t = loca = new Loca (this); }
        else if (td.tag == Tag.glyf) { t = glyf = new Glyf (this); }
        else if (td.tag == Tag.CFF ) { t = cff  = new CFF  (this); }
        else if (td.tag == Tag.BASE) { t = base = new Base (this); }
        else if (td.tag == Tag.GPOS) { t = gpos = new Gpos (this); }
        else if (td.tag == Tag.GSUB) { t = gsub = new Gsub (this); }
        else if (td.tag == Tag.GDEF) { t = gdef = new Gdef (this); }
        else if (td.tag == Tag.DSIG) { t = dsig = new Dsig (this); }
        else if (td.tag == Tag.VORG) { t = vorg = new Vorg (this); }
        else if (td.tag == Tag.VDMX) { t = vdmx = new Vdmx (this); }
        else if (td.tag == Tag.cvt)  { t = cvt  = new UnknownTable (td.tag, this); }
        else if (td.tag == Tag.prep) { t = prep = new UnknownTable (td.tag, this); }
        else if (td.tag == Tag.fpgm) { t = fpgm = new UnknownTable (td.tag, this); }
        else                         { t = new UnknownTable (td.tag, this); }

        tables.put (td.tag, t);
        curOffset += t.fromBinary (in, td.length); }}

    finally {
      in.close (); }
  }

  public void fromXML (URL context, Element font)
      throws IOException, InvalidFontException, UnsupportedFontException {
    NodeList tableNodes = font.getChildNodes ();

    for (int i = 0; i &lt; tableNodes.getLength (); i++) {
      Element tableElem = (Element) tableNodes.item (i);

      if ("base-font".equals (tableElem.getTagName ())) {
        fromBinary (new URL (context, tableElem.getAttribute ("name"))); }

      else {
        String tags = tableElem.getTagName ();
        if ("OS2".equals (tags)) {
          tags = "OS/2"; }
        long tag = Tag.string2tag (tags);
        Table t = null;

             if (tag == Tag.name) { t = name = new Name (this); }
        else if (tag == Tag.cmap) { t = cmap = new Cmap (this); }
        else if (tag == Tag.head) { t = head = new Head (this); }
        else if (tag == Tag.hhea) { t = hhea = new Hhea (this); }
        else if (tag == Tag.hdmx) { t = hdmx = new Hdmx (this); }
        else if (tag == Tag.hmtx) { t = hmtx = new Hmtx (this); }
        else if (tag == Tag.vhea) { t = vhea = new Vhea (this); }
        else if (tag == Tag.vmtx) { t = vmtx = new Vmtx (this); }
        else if (tag == Tag.os2 ) { t = os2  = new OS2  (this); }
        else if (tag == Tag.post) { t = post = new Post (this); }
        else if (tag == Tag.maxp) { t = maxp = new Maxp (this); }
        else if (tag == Tag.glyf) { t = glyf = new Glyf (this); }
        else if (tag == Tag.CFF ) { t = cff  = new CFF  (this); }
        else if (tag == Tag.BASE) { t = base = new Base (this); }
        else if (tag == Tag.GPOS) { t = gpos = new Gpos (this); }
        else if (tag == Tag.GSUB) { t = gsub = new Gsub (this); }
        else if (tag == Tag.GDEF) { t = gdef = new Gdef (this); }
        else if (tag == Tag.DSIG) { t = dsig = new Dsig (this); }
        else if (tag == Tag.VORG) { t = vorg = new Vorg (this); }
        else if (tag == Tag.VDMX) { t = vdmx = new Vdmx (this); }
        else if (tag == Tag.cvt)  { t = cvt  = new UnknownTable (tag, this); }
        else if (tag == Tag.prep) { t = prep = new UnknownTable (tag, this); }
        else if (tag == Tag.fpgm) { t = fpgm = new UnknownTable (tag, this); }
        else                      { t = new UnknownTable (tag, this); }

        t.fromXML (tableElem);
        tables.put (tag, t); }}
  }

  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException,
             InvalidFontException,
             UnsupportedFontException {
    toXML (conf, null, null);
  }

  public void toXML (DecompilerConfig conf, long[] tags, URL base)
      throws org.xml.sax.SAXException,
             InvalidFontException,
             UnsupportedFontException {
    conf.ch.startElement ("font"); {
      if (base != null) {
        AttributesImpl at = new AttributesImpl ();
	at.addAttribute ("", "name", "name", "CDATA", base.toString ());
	conf.ch.element ("base-font", at); }

      if (conf.gid == DecompilerConfig.Gid.byName) {
        conf.glyphNames = getGlyphNames ();
        conf.incorporateUserGlyphNames (maxp.getNumGlyphs ());
	if (conf.glyphNames == null) {
	  conf.gid = DecompilerConfig.Gid.byNumber; }}

      for (Table t : tables.values ()) {
	boolean dumpIt = false;
	if (tags == null) {
          dumpIt = true; }
        else {
          for (int i = 0; i &lt; tags.length; i++) {
            if (tags [i] == Tag.size &amp;&amp; t instanceof Gpos) {
              ((Gpos)t).opticalSizeToXML (conf); }
            if (tags [i] == t.tag) {
              dumpIt = true; }}}
	if (dumpIt) {
          t.toXML (conf); }}
      conf.ch.endElement ("font"); }
  }

  public String[] getGlyphNames () {
    if (cff != null) {
      return cff.getGlyphNames (); }
    else {
      return post.getGlyphNames (); }
  }

  public void toBinary (String outfile)
      throws java.io.IOException, java.io.FileNotFoundException {

    toBinary (new java.io.FileOutputStream (outfile));
  }


  public void toBinary (java.io.OutputStream out)
      throws java.io.IOException {

    int headerSize = 12 + 16 * tables.size ();
    int searchRange = 1;
    int entrySelector = 0;
    while (searchRange &lt;= tables.size ()) {
      searchRange *= 2;
      entrySelector++; }
    searchRange *= 8;
    entrySelector--;
    int rangeShift = tables.size () * 16 - searchRange;

    Block header = new Block (headerSize, 0);

    if (tables.get (new Long (Tag.CFF)) != null) {
      header.setTag (0, "OTTO"); }
    else {
      header.setFixed (0, 1, 0); }
    header.setuint16 (4, tables.size ());
    header.setuint16 (6, searchRange);
    header.setuint16 (8, entrySelector);
    header.setuint16 (10, rangeShift);

    long offset = headerSize;
    int headerOffset = 12;
    long fileChecksum = 0;

    head.clearChecksumAdjust ();

    java.util.Map&lt;Long, byte[]> tablesData
         = new java.util.TreeMap&lt;Long, byte[]> ();
    for (Table t : tables.values ()) {
      byte[] data = t.toBinary ();
      tablesData.put (t.getTag (), data);
      long tableChecksum = checksum (data);

      fileChecksum = (fileChecksum + tableChecksum) &amp; 0xffffffffL;

      header.setuint32 (headerOffset,      (int)t.getTag ());
      header.setuint32 (headerOffset + 4,  (int)tableChecksum);
      header.setuint32 (headerOffset + 8,  (int)offset);
      header.setuint32 (headerOffset + 12, data.length);
      headerOffset += 16;

      offset += data.length;
      if (data.length % 4 != 0) {
        offset += 4 - (data.length % 4); }}

    fileChecksum = (fileChecksum + checksum (header.content)) &amp; 0xffffffffL;

    long checksumAdjust = (0xb1b0afbaL - fileChecksum) &amp; 0xffffffffL;
    head.setChecksumAdjust (checksumAdjust);
    tablesData.put (Tag.head, head.toBinary ());

    out.write (header.content);

    for (Iterator it = tables.keySet ().iterator (); it.hasNext ();) {
      byte[] data = tablesData.get (it.next ());
      out.write (data);

      if (data.length % 4 != 0) {
        int pad = ((data.length / 4) + 1) * 4 - data.length;
        for (int k = 0; k &lt; pad; k++) {
          out.write (0); }}}

    out.close ();
  }

  public void applyGsubFeatures (long scriptTag, long langSysTag,
                                 long[] featureTags, GlyphRun gr)
      throws InvalidFontException {

    if (gsub != null) {
      gsub.applyFeatures (scriptTag, langSysTag, featureTags, gr); }
  }

  public void applyGposFeatures (long scriptTag, long langSysTag,
                                 long[] featureTags, GlyphRun gr)
      throws InvalidFontException {

    if (gpos != null) {
      gpos.applyFeatures (scriptTag, langSysTag, featureTags, gr); }
  }

  public BoundingBox getGlyphBoundingBox (int gid) {
    if (cff != null) {
      return cff.getGlyphBoundingBox (gid); }
    else {
      return glyf.getGlyphBoundingBox (gid); }
  }
}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role='fragment'>
      <title>Test Font Fragments</title>

      <!--____________________________________________________________________-->
      <section role='test-suite'>
        <title>Test Suite</title>

	<para>Here are some useful font fragments to build test
	fonts.</para>

	<para>The first fragment is a piece of layout table. It declares
	the 'latn' script, a default language for it, and a feature list
	for it which references the lookup with id 'lookup.test'.</para>

<code-fragment id='testfonts.gsub.scripts_features'>
  <code-title>ScriptList latn/default; Feature list: 'test'->lookup.test</code-title>
  <scriptList>
    <script tag='latn'>
      <defaultLangSys >
        <featureIndex name='feature.test'/>
      </defaultLangSys>
    </script>
  </scriptList>

  <featureList>
   <feature id='feature.test' tag='test'>
     <lookupIndex name="lookup.test"/>
   </feature>
  </featureList>
</code-fragment>

<code-fragment id='testfonts.gpos.scripts_features'>
  <code-title>ScriptList latn/default; Feature list: 'test'->lookup.test</code-title>
  <scriptList>
    <script tag='latn'>
      <defaultLangSys >
        <featureIndex name='feature.test'/>
      </defaultLangSys>
    </script>
  </scriptList>

  <featureList>
   <feature id='feature.test' tag='test'>
     <lookupIndex name="lookup.test"/>
   </feature>
  </featureList>
</code-fragment>


         <para>For contextual and chaining contextual lookups, we have a
	 bit more infrastructure. Here are GSUB lookups that are going
	 to be invoked from contextual lookups:</para>

<code-fragment id='testfonts.context.gsub.lookups'>
  <lookup id='lookup.single' type='1'>
    <singleSubst format='1'>
      <coverage format='1' glyphs='20 21 22 23 24 25 26 27 28 29'/>
      <delta v='40'/>
    </singleSubst>
  </lookup>

  <lookup id='lookup.double' type='4'>
    <ligatureSubst format='1'>
      <subst in="21 22" out="61"/>
    </ligatureSubst>
  </lookup>

  <lookup id='lookup.double.nomarks' type='4' ignoreMarks='yes'>
    <ligatureSubst format='1'>
      <subst in="21 22" out="61"/>
    </ligatureSubst>
  </lookup>

  <lookup id='lookup.multiple' type='2'>
    <multipleSubst format='1'>
      <subst in='21' out='61 62 63'/>
    </multipleSubst>
  </lookup>
</code-fragment>

         <para>Here is the similar set of GPOS lookups:</para>

<code-fragment id='testfonts.context.gpos.lookups'>
  <lookup id='lookup.single' type='1'>
    <singlePos format='1'>
      <coverage format='any' glyphs="20 21 22 23 24 25 26 27 28 29"/>
      <value xPlacement='20'/>
    </singlePos>
  </lookup>

  <lookup id='lookup.double' type='2'>
    <pairPos format='1'>
      <pairSet in='21'>
	<pos2 in="22">
	  <value1 xPlacement='20'/>
	</pos2>
      </pairSet>
    </pairPos>
  </lookup>

  <lookup id='lookup.double.nomarks' type='2' ignoreMarks='yes'>
    <pairPos format='1'>
      <pairSet in='21'>
	<pos2 in="22">
	  <value1 xPlacement='20'/>
	</pos2>
      </pairSet>
    </pairPos>
  </lookup>

  <lookup id='lookup.multiple' type='1'/>
     <!-- there is nothing equivalent to multiple in GPOS-->
</code-fragment>

          <para>The GDEF table that goes with them:</para>

<code-fragment id='testfonts.context.gdef'>
  <GDEF major='1' minor='0'>
    <glyphClassDef format='any'>
      <class classID='1' glyphs='80 81 82 83 84'/> <!-- base -->
      <class classID='2' glyphs='85 86 87 88 89'/> <!-- ligature -->
      <class classID='3' glyphs='90 91 92 93 94'/> <!-- mark -->
      <class classID='4' glyphs='95 96 97 98 99'/> <!-- component -->
    </glyphClassDef>
  </GDEF>
</code-fragment>
      </section>
    </section>
  </section>
</article>
